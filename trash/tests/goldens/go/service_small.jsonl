{"chunk_id": "PLACEHOLDER", "repo": "test-repo", "path": "tests/fixtures/go/service_small/service.go", "language": "go", "start_line": 17, "end_line": 19, "ast_path": "go:type:providerClient (interface)", "text": "package foreca\nimport \"context\"\ntype providerClient interface {\n\tGetForecastForLocation(ctx context.Context, location string) (*Forecast, error)\n}", "header_context": "package foreca\nimport \"context\"", "core": "type providerClient interface {\n\tGetForecastForLocation(ctx context.Context, location string) (*Forecast, error)\n}", "footer_context": "", "symbols_defined": ["providerClient"], "symbols_referenced": ["GetForecastForLocation", "error", "Forecast", "context.Context"], "imports_used": ["context"], "neighbors": {"prev": null, "next": "PLACEHOLDER"}, "summary_1l": "Go interface providerClient", "qa_terms": "providerClient, interface, context", "token_counts": {"header": 0, "core": 0, "footer": 0, "total": 0}, "file_sha": "PLACEHOLDER", "created_at": "PLACEHOLDER", "v": 3}
{"chunk_id": "PLACEHOLDER", "repo": "test-repo", "path": "tests/fixtures/go/service_small/service.go", "language": "go", "start_line": 22, "end_line": 24, "ast_path": "go:type:mappingsRepository (interface)", "text": "package foreca\nimport \"context\"\ntype mappingsRepository interface {\n\tGetMappingByID(ctx context.Context, id string) (*Mapping, error)\n}", "header_context": "package foreca\nimport \"context\"", "core": "type mappingsRepository interface {\n\tGetMappingByID(ctx context.Context, id string) (*Mapping, error)\n}", "footer_context": "", "symbols_defined": ["mappingsRepository"], "symbols_referenced": ["GetMappingByID", "error", "context.Context", "Mapping"], "imports_used": ["context"], "neighbors": {"prev": "PLACEHOLDER", "next": "PLACEHOLDER"}, "summary_1l": "Go interface mappingsRepository", "qa_terms": "mappingsRepository, interface, context", "token_counts": {"header": 0, "core": 0, "footer": 0, "total": 0}, "file_sha": "PLACEHOLDER", "created_at": "PLACEHOLDER", "v": 3}
{"chunk_id": "PLACEHOLDER", "repo": "test-repo", "path": "tests/fixtures/go/service_small/service.go", "language": "go", "start_line": 27, "end_line": 30, "ast_path": "go:type:cacheClient (interface)", "text": "package foreca\nimport (\n\t\"context\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"time\"\n)\ntype cacheClient interface {\n\tGet(ctx context.Context, key string) (*cache.Item, error)\n\tSet(ctx context.Context, key string, value interface{}, ttl time.Duration) error\n}", "header_context": "package foreca\nimport (\n\t\"context\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"time\"\n)\n\t\"context\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"time\"\n)", "core": "type cacheClient interface {\n\tGet(ctx context.Context, key string) (*cache.Item, error)\n\tSet(ctx context.Context, key string, value interface{}, ttl time.Duration) error\n}", "footer_context": "", "symbols_defined": ["cacheClient"], "symbols_referenced": ["value", "Get", "time.Duration", "Set", "error", "context.Context", "cache.Item"], "imports_used": ["context", "go.impalastudios.com/weather/foreca_proxy/internal/cache", "time"], "neighbors": {"prev": "PLACEHOLDER", "next": "PLACEHOLDER"}, "summary_1l": "Go interface cacheClient", "qa_terms": "cacheClient, interface, cache, time, context", "token_counts": {"header": 0, "core": 0, "footer": 0, "total": 0}, "file_sha": "PLACEHOLDER", "created_at": "PLACEHOLDER", "v": 3}
{"chunk_id": "PLACEHOLDER", "repo": "test-repo", "path": "tests/fixtures/go/service_small/service.go", "language": "go", "start_line": 33, "end_line": 41, "ast_path": "go:type:Service (struct)", "text": "package foreca\nimport (\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/singleflight\"\n\t\"time\"\n)\ntype Service struct {\n\tprovider  providerClient\n\tmappings  mappingsRepository\n\tcache     cacheClient\n\tsf        *singleflight.Group\n\tlogger    *zap.Logger\n\ttracer    trace.Tracer\n\tttl       time.Duration\n}", "header_context": "package foreca\nimport (\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/singleflight\"\n\t\"time\"\n)\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/singleflight\"\n\t\"time\"\n)", "core": "type Service struct {\n\tprovider  providerClient\n\tmappings  mappingsRepository\n\tcache     cacheClient\n\tsf        *singleflight.Group\n\tlogger    *zap.Logger\n\ttracer    trace.Tracer\n\tttl       time.Duration\n}", "footer_context": "", "symbols_defined": ["Service"], "symbols_referenced": ["trace.Tracer", "providerClient", "mappingsRepository", "time.Duration", "singleflight.Group", "cacheClient", "zap.Logger"], "imports_used": ["go.impalastudios.com/weather/foreca_proxy/internal/cache", "go.opentelemetry.io/otel/trace", "go.uber.org/zap", "golang.org/x/sync/singleflight", "time"], "neighbors": {"prev": "PLACEHOLDER", "next": "PLACEHOLDER"}, "summary_1l": "Go struct Service", "qa_terms": "Service, struct, time, cache", "token_counts": {"header": 0, "core": 0, "footer": 0, "total": 0}, "file_sha": "PLACEHOLDER", "created_at": "PLACEHOLDER", "v": 3}
{"chunk_id": "PLACEHOLDER", "repo": "test-repo", "path": "tests/fixtures/go/service_small/service.go", "language": "go", "start_line": 44, "end_line": 60, "ast_path": "go:function:", "text": "package foreca\nimport (\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/singleflight\"\n\t\"time\"\n)\nfunc NewService(\n\tprovider providerClient,\n\tmappings mappingsRepository,\n\tcache cacheClient,\n\tlogger *zap.Logger,\n\tttl time.Duration,\n) *Service {\n\treturn &Service{\n\t\tprovider: provider,\n\t\tmappings: mappings,\n\t\tcache:    cache,\n\t\tsf:       &singleflight.Group{},\n\t\tlogger:   logger,\n\t\ttracer:   otel.Tracer(\"foreca-service\"),\n\t\tttl:      ttl,\n\t}\n}", "header_context": "package foreca\nimport (\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/singleflight\"\n\t\"time\"\n)\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/singleflight\"\n\t\"time\"\n)", "core": "func NewService(\n\tprovider providerClient,\n\tmappings mappingsRepository,\n\tcache cacheClient,\n\tlogger *zap.Logger,\n\tttl time.Duration,\n) *Service {\n\treturn &Service{\n\t\tprovider: provider,\n\t\tmappings: mappings,\n\t\tcache:    cache,\n\t\tsf:       &singleflight.Group{},\n\t\tlogger:   logger,\n\t\ttracer:   otel.Tracer(\"foreca-service\"),\n\t\tttl:      ttl,\n\t}\n}", "footer_context": "", "symbols_defined": [], "symbols_referenced": ["Service", "time.Duration", "singleflight.Group", "NewService", "otel.Tracer", "zap.Logger"], "imports_used": ["go.impalastudios.com/weather/foreca_proxy/internal/cache", "go.opentelemetry.io/otel", "go.uber.org/zap", "golang.org/x/sync/singleflight", "time"], "neighbors": {"prev": "PLACEHOLDER", "next": "PLACEHOLDER"}, "summary_1l": "Go function ", "qa_terms": "cache, otel, singleflight, zap", "token_counts": {"header": 0, "core": 0, "footer": 0, "total": 0}, "file_sha": "PLACEHOLDER", "created_at": "PLACEHOLDER", "v": 3}
{"chunk_id": "PLACEHOLDER", "repo": "test-repo", "path": "tests/fixtures/go/service_small/service.go", "language": "go", "start_line": 63, "end_line": 119, "ast_path": "go:method:(s *Service).GetForecastForLocation", "text": "package foreca\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/singleflight\"\n)\n// receiver: s *Service\nfunc (s *Service) GetForecastForLocation(ctx context.Context, locationID string) (*Forecast, error) {\n\tctx, span := s.tracer.Start(ctx, \"GetForecastForLocation\")\n\tdefer span.End()\n\n\t// Check cache first\n\tcacheKey := \"forecast:\" + locationID\n\tcachedItem, err := s.cache.Get(ctx, cacheKey)\n\tif err == nil && cachedItem != nil {\n\t\tspan.SetAttributes(attribute.Bool(\"cache_hit\", true))\n\t\ts.logger.Info(\"Cache hit for location\", zap.String(\"location_id\", locationID))\n\t\t\n\t\tvar forecast Forecast\n\t\tif err := json.Unmarshal(cachedItem.Data, &forecast); err != nil {\n\t\t\ts.logger.Error(\"Failed to unmarshal cached forecast\", zap.Error(err))\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &forecast, nil\n\t}\n\n\tspan.SetAttributes(attribute.Bool(\"cache_hit\", false))\n\n\t// Use singleflight to deduplicate concurrent requests\n\tresult, err, _ := s.sf.Do(locationID, func() (interface{}, error) {\n\t\t// Load timezone for the location\n\t\tlocation, err := s.mappings.GetMappingByID(ctx, locationID)\n\t\tif err != nil {\n\t\t\tspan.SetAttributes(attribute.Bool(\"mapping_error\", true))\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Get forecast from provider\n\t\tforecast, err := s.provider.GetForecastForLocation(ctx, location.Name)\n\t\tif err != nil {\n\t\t\tspan.SetAttributes(attribute.Bool(\"provider_error\", true))\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Cache the result\n\t\tforecastData, err := json.Marshal(forecast)\n\t\tif err != nil {\n\t\t\ts.logger.Error(\"Failed to marshal forecast for caching\", zap.Error(err))\n\t\t} else {\n\t\t\tif err := s.cache.Set(ctx, cacheKey, forecastData, s.ttl); err != nil {\n\t\t\t\ts.logger.Error(\"Failed to cache forecast\", zap.Error(err))\n\t\t\t}\n\t\t}\n\n\t\treturn forecast, nil\n\t})\n\n\tif err != nil {\n\t\tspan.SetAttributes(attribute.Bool(\"error\", true))\n\t\treturn nil, err\n\t}\n\n\treturn result.(*Forecast), nil\n}", "header_context": "package foreca\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/singleflight\"\n)\n\t\"context\"\n\t\"encoding/json\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/cache\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/singleflight\"\n)\n// receiver: s *Service", "core": "func (s *Service) GetForecastForLocation(ctx context.Context, locationID string) (*Forecast, error) {\n\tctx, span := s.tracer.Start(ctx, \"GetForecastForLocation\")\n\tdefer span.End()\n\n\t// Check cache first\n\tcacheKey := \"forecast:\" + locationID\n\tcachedItem, err := s.cache.Get(ctx, cacheKey)\n\tif err == nil && cachedItem != nil {\n\t\tspan.SetAttributes(attribute.Bool(\"cache_hit\", true))\n\t\ts.logger.Info(\"Cache hit for location\", zap.String(\"location_id\", locationID))\n\t\t\n\t\tvar forecast Forecast\n\t\tif err := json.Unmarshal(cachedItem.Data, &forecast); err != nil {\n\t\t\ts.logger.Error(\"Failed to unmarshal cached forecast\", zap.Error(err))\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &forecast, nil\n\t}\n\n\tspan.SetAttributes(attribute.Bool(\"cache_hit\", false))\n\n\t// Use singleflight to deduplicate concurrent requests\n\tresult, err, _ := s.sf.Do(locationID, func() (interface{}, error) {\n\t\t// Load timezone for the location\n\t\tlocation, err := s.mappings.GetMappingByID(ctx, locationID)\n\t\tif err != nil {\n\t\t\tspan.SetAttributes(attribute.Bool(\"mapping_error\", true))\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Get forecast from provider\n\t\tforecast, err := s.provider.GetForecastForLocation(ctx, location.Name)\n\t\tif err != nil {\n\t\t\tspan.SetAttributes(attribute.Bool(\"provider_error\", true))\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Cache the result\n\t\tforecastData, err := json.Marshal(forecast)\n\t\tif err != nil {\n\t\t\ts.logger.Error(\"Failed to marshal forecast for caching\", zap.Error(err))\n\t\t} else {\n\t\t\tif err := s.cache.Set(ctx, cacheKey, forecastData, s.ttl); err != nil {\n\t\t\t\ts.logger.Error(\"Failed to cache forecast\", zap.Error(err))\n\t\t\t}\n\t\t}\n\n\t\treturn forecast, nil\n\t})\n\n\tif err != nil {\n\t\tspan.SetAttributes(attribute.Bool(\"error\", true))\n\t\treturn nil, err\n\t}\n\n\treturn result.(*Forecast), nil\n}", "footer_context": "", "symbols_defined": ["GetForecastForLocation"], "symbols_referenced": ["zap.Error", "Data", "err", "End", "Get", "result", "forecast", "locationID", "Start", "Name", "first", "Service", "json.Unmarshal", "cacheKey", "Do", "Set", "Forecast", "zap.String", "requests", "GetMappingByID", "attribute.Bool", "provider", "Info", "error", "SetAttributes", "context.Context", "location", "json.Marshal", "ttl"], "imports_used": ["context", "encoding/json", "go.impalastudios.com/weather/foreca_proxy/internal/cache", "go.opentelemetry.io/otel/attribute", "go.uber.org/zap", "golang.org/x/sync/singleflight"], "neighbors": {"prev": "PLACEHOLDER", "next": "PLACEHOLDER"}, "summary_1l": "Go method GetForecastForLocation on s *Service", "qa_terms": "GetForecastForLocation, attribute, cache, json.Unmarshal, otel, s Service, singleflight, zap", "token_counts": {"header": 0, "core": 0, "footer": 0, "total": 0}, "file_sha": "PLACEHOLDER", "created_at": "PLACEHOLDER", "v": 3}
{"chunk_id": "PLACEHOLDER", "repo": "test-repo", "path": "tests/fixtures/go/service_small/service.go", "language": "go", "start_line": 122, "end_line": 127, "ast_path": "go:type:Forecast (struct)", "text": "package foreca\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\ntype Forecast struct {\n\tLocation    string    `json:\"location\"`\n\tTemperature float64   `json:\"temperature\"`\n\tHumidity    int       `json:\"humidity\"`\n\tTimestamp   time.Time `json:\"timestamp\"`\n}", "header_context": "package foreca\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\n\t\"encoding/json\"\n\t\"time\"\n)", "core": "type Forecast struct {\n\tLocation    string    `json:\"location\"`\n\tTemperature float64   `json:\"temperature\"`\n\tHumidity    int       `json:\"humidity\"`\n\tTimestamp   time.Time `json:\"timestamp\"`\n}", "footer_context": "", "symbols_defined": ["Forecast"], "symbols_referenced": ["time.Time"], "imports_used": ["encoding/json", "time"], "neighbors": {"prev": "PLACEHOLDER", "next": "PLACEHOLDER"}, "summary_1l": "Go struct Forecast", "qa_terms": "Forecast, struct, time", "token_counts": {"header": 0, "core": 0, "footer": 0, "total": 0}, "file_sha": "PLACEHOLDER", "created_at": "PLACEHOLDER", "v": 3}
{"chunk_id": "PLACEHOLDER", "repo": "test-repo", "path": "tests/fixtures/go/service_small/service.go", "language": "go", "start_line": 130, "end_line": 133, "ast_path": "go:type:Mapping (struct)", "text": "package foreca\nimport \"encoding/json\"\ntype Mapping struct {\n\tID   string `json:\"id\"`\n\tName string `json:\"name\"`\n}", "header_context": "package foreca\nimport \"encoding/json\"", "core": "type Mapping struct {\n\tID   string `json:\"id\"`\n\tName string `json:\"name\"`\n}", "footer_context": "", "symbols_defined": ["Mapping"], "symbols_referenced": [], "imports_used": ["encoding/json"], "neighbors": {"prev": "PLACEHOLDER", "next": null}, "summary_1l": "Go struct Mapping", "qa_terms": "Mapping, struct", "token_counts": {"header": 0, "core": 0, "footer": 0, "total": 0}, "file_sha": "PLACEHOLDER", "created_at": "PLACEHOLDER", "v": 3}
