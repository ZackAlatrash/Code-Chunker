{"id": "/Users/zack.alatrash/Downloads/beszel-main/beszel.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/beszel.go", "rel_path": "beszel.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 11, "text": "package beszel\n\nimport \"github.com/blang/semver\"\n\nconst (\n\tVersion = \"0.12.7\"\n\tAppName = \"beszel\"\n)\n\nvar MinVersionCbor = semver.MustParse(\"0.12.0\")\n", "n_tokens": 50, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 11], "def_symbols": [], "symbols": ["package", "beszel", "import", "github", "com", "blang", "semver", "const", "Version", "AppName", "var", "MinVersionCbor", "MustParse"], "doc_head": "package beszel\nimport \"github.com/blang/semver\"\nconst (\n\tVersion = \"0.12.7\"\n\tAppName = \"beszel\"\n)\nvar MinVersionCbor = semver.MustParse(\"0.12.0\")"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go", "rel_path": "agent/sensors.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 27, "text": "package agent\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"path\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf8\"\n\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/shirou/gopsutil/v4/common\"\n\t\"github.com/shirou/gopsutil/v4/sensors\"\n)\n\ntype SensorConfig struct {\n\tcontext        context.Context\n\tsensors        map[string]struct{}\n\tprimarySensor  string\n\tisBlacklist    bool\n\thasWildcards   bool\n\tskipCollection bool\n}\n", "n_tokens": 120, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 27], "def_symbols": [], "symbols": ["package", "agent", "import", "context", "fmt", "log", "slog", "path", "runtime", "strconv", "strings", "unicode", "utf8", "github", "com", "henrygd", "beszel", "src", "entities", "system", "shirou", "gopsutil", "common", "sensors", "type", "SensorConfig", "struct", "Context", "map", "string", "primarySensor", "isBlacklist", "bool", "hasWildcards", "skipCollection"], "doc_head": "package agent\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"path\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf8\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/shirou/gopsutil/v4/common\"\n\t\"github.com/shirou/gopsutil/v4/sensors\"\n)\ntype SensorConfig struct {\n\tcontext        context.Context\n\tsensors        map[string]struct{}\n\tprimarySensor  string\n\tisBlacklist    bool\n\thasWildcards   bool\n\tskipCollection bool\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go", "rel_path": "agent/sensors.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 28, "end_line": 39, "text": "func (a *Agent) newSensorConfig() *SensorConfig {\n\tprimarySensor, _ := GetEnv(\"PRIMARY_SENSOR\")\n\tsysSensors, _ := GetEnv(\"SYS_SENSORS\")\n\tsensorsEnvVal, sensorsSet := GetEnv(\"SENSORS\")\n\tskipCollection := sensorsSet && sensorsEnvVal == \"\"\n\n\treturn a.newSensorConfigWithEnv(primarySensor, sysSensors, sensorsEnvVal, skipCollection)\n}\n\n// Matches sensors.TemperaturesWithContext to allow for panic recovery (gopsutil/issues/1832)\ntype getTempsFn func(ctx context.Context) ([]sensors.TemperatureStat, error)\n", "n_tokens": 128, "primary_symbol": "newSensorConfig", "primary_kind": "function", "primary_span": [28, 39], "def_symbols": ["newSensorConfig"], "symbols": ["newSensorConfig", "func", "Agent", "SensorConfig", "primarySensor", "GetEnv", "PRIMARY_SENSOR", "sysSensors", "SYS_SENSORS", "sensorsEnvVal", "sensorsSet", "SENSORS", "skipCollection", "return", "newSensorConfigWithEnv", "Matches", "sensors", "TemperaturesWithContext", "allow", "for", "panic", "recovery", "gopsutil", "issues", "type", "getTempsFn", "ctx", "context", "Context", "TemperatureStat", "error"], "doc_head": "func (a *Agent) newSensorConfig() *SensorConfig {\n\tprimarySensor, _ := GetEnv(\"PRIMARY_SENSOR\")\n\tsysSensors, _ := GetEnv(\"SYS_SENSORS\")\n\tsensorsEnvVal, sensorsSet := GetEnv(\"SENSORS\")\n\tskipCollection := sensorsSet && sensorsEnvVal == \"\"\n\treturn a.newSensorConfigWithEnv(primarySensor, sysSensors, sensorsEnvVal, skipCollection)\n}\n// Matches sensors.TemperaturesWithContext to allow for panic recovery (gopsutil/issues/1832)\ntype getTempsFn func(ctx context.Context) ([]sensors.TemperatureStat, error)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go", "rel_path": "agent/sensors.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 40, "end_line": 46, "text": "// newSensorConfigWithEnv creates a SensorConfig with the provided environment variables\n// sensorsSet indicates if the SENSORS environment variable was explicitly set (even to empty string)\nfunc (a *Agent) newSensorConfigWithEnv(primarySensor, sysSensors, sensorsEnvVal string, skipCollection bool) *SensorConfig {\n\tconfig := &SensorConfig{\n\t\tcontext:        context.Background(),\n\t\tprimarySensor:  primarySensor,\n\t\tskipCollection: skipCollection,", "n_tokens": 97, "primary_symbol": "newSensorConfigWithEnv", "primary_kind": "function", "primary_span": [42, 46], "def_symbols": ["newSensorConfigWithEnv"], "symbols": ["newSensorConfigWithEnv", "creates", "SensorConfig", "with", "the", "provided", "environment", "variables", "sensorsSet", "indicates", "SENSORS", "variable", "was", "explicitly", "set", "even", "empty", "string", "func", "Agent", "primarySensor", "sysSensors", "sensorsEnvVal", "skipCollection", "bool", "config", "context", "Background"], "doc_head": "// newSensorConfigWithEnv creates a SensorConfig with the provided environment variables\n// sensorsSet indicates if the SENSORS environment variable was explicitly set (even to empty string)\nfunc (a *Agent) newSensorConfigWithEnv(primarySensor, sysSensors, sensorsEnvVal string, skipCollection bool) *SensorConfig {\n\tconfig := &SensorConfig{\n\t\tcontext:        context.Background(),\n\t\tprimarySensor:  primarySensor,\n\t\tskipCollection: skipCollection,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go", "rel_path": "agent/sensors.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 47, "end_line": 76, "text": "\t\tsensors:        make(map[string]struct{}),\n\t}\n\n\t// Set sensors context (allows overriding sys location for sensors)\n\tif sysSensors != \"\" {\n\t\tslog.Info(\"SYS_SENSORS\", \"path\", sysSensors)\n\t\tconfig.context = context.WithValue(config.context,\n\t\t\tcommon.EnvKey, common.EnvMap{common.HostSysEnvKey: sysSensors},\n\t\t)\n\t}\n\n\t// handle blacklist\n\tif strings.HasPrefix(sensorsEnvVal, \"-\") {\n\t\tconfig.isBlacklist = true\n\t\tsensorsEnvVal = sensorsEnvVal[1:]\n\t}\n\n\tfor sensor := range strings.SplitSeq(sensorsEnvVal, \",\") {\n\t\tsensor = strings.TrimSpace(sensor)\n\t\tif sensor != \"\" {\n\t\t\tconfig.sensors[sensor] = struct{}{}\n\t\t\tif strings.Contains(sensor, \"*\") {\n\t\t\t\tconfig.hasWildcards = true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn config\n}\n", "n_tokens": 191, "primary_symbol": "", "primary_kind": "", "primary_span": [47, 76], "def_symbols": [], "symbols": ["sensors", "make", "map", "string", "struct", "Set", "context", "allows", "overriding", "sys", "location", "for", "sysSensors", "slog", "Info", "SYS_SENSORS", "path", "config", "WithValue", "common", "EnvKey", "EnvMap", "HostSysEnvKey", "handle", "blacklist", "strings", "HasPrefix", "sensorsEnvVal", "isBlacklist", "true", "sensor", "range", "SplitSeq", "TrimSpace", "Contains", "hasWildcards", "return"], "doc_head": "\t\tsensors:        make(map[string]struct{}),\n\t}\n\t// Set sensors context (allows overriding sys location for sensors)\n\tif sysSensors != \"\" {\n\t\tslog.Info(\"SYS_SENSORS\", \"path\", sysSensors)\n\t\tconfig.context = context.WithValue(config.context,\n\t\t\tcommon.EnvKey, common.EnvMap{common.HostSysEnvKey: sysSensors},\n\t\t)\n\t}\n\t// handle blacklist\n\tif strings.HasPrefix(sensorsEnvVal, \"-\") {\n\t\tconfig.isBlacklist = true\n\t\tsensorsEnvVal = sensorsEnvVal[1:]\n\t}\n\tfor sensor := range strings.SplitSeq(sensorsEnvVal, \",\") {\n\t\tsensor = strings.TrimSpace(sensor)\n\t\tif sensor != \"\" {\n\t\t\tconfig.sensors[sensor] = struct{}{}\n\t\t\tif strings.Contains(sensor, \"*\") {\n\t\t\t\tconfig.hasWildcards = true\n\t\t\t}\n\t\t}\n\t}\n\treturn config\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go", "rel_path": "agent/sensors.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 77, "end_line": 141, "text": "// updateTemperatures updates the agent with the latest sensor temperatures\nfunc (a *Agent) updateTemperatures(systemStats *system.Stats) {\n\t// skip if sensors whitelist is set to empty string\n\tif a.sensorConfig.skipCollection {\n\t\tslog.Debug(\"Skipping temperature collection\")\n\t\treturn\n\t}\n\n\t// reset high temp\n\ta.systemInfo.DashboardTemp = 0\n\n\ttemps, err := a.getTempsWithPanicRecovery(getSensorTemps)\n\tif err != nil {\n\t\t// retry once on panic (gopsutil/issues/1832)\n\t\ttemps, err = a.getTempsWithPanicRecovery(getSensorTemps)\n\t\tif err != nil {\n\t\t\tslog.Warn(\"Error updating temperatures\", \"err\", err)\n\t\t\tif len(systemStats.Temperatures) > 0 {\n\t\t\t\tsystemStats.Temperatures = make(map[string]float64)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tslog.Debug(\"Temperature\", \"sensors\", temps)\n\n\t// return if no sensors\n\tif len(temps) == 0 {\n\t\treturn\n\t}\n\n\tsystemStats.Temperatures = make(map[string]float64, len(temps))\n\tfor i, sensor := range temps {\n\t\t// check for malformed strings on darwin (gopsutil/issues/1832)\n\t\tif runtime.GOOS == \"darwin\" && !utf8.ValidString(sensor.SensorKey) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// scale temperature\n\t\tif sensor.Temperature != 0 && sensor.Temperature < 1 {\n\t\t\tsensor.Temperature = scaleTemperature(sensor.Temperature)\n\t\t}\n\t\t// skip if temperature is unreasonable\n\t\tif sensor.Temperature <= 0 || sensor.Temperature >= 200 {\n\t\t\tcontinue\n\t\t}\n\t\tsensorName := sensor.SensorKey\n\t\tif _, ok := systemStats.Temperatures[sensorName]; ok {\n\t\t\t// if key already exists, append int to key\n\t\t\tsensorName = sensorName + \"_\" + strconv.Itoa(i)\n\t\t}\n\t\t// skip if not in whitelist or blacklist\n\t\tif !isValidSensor(sensorName, a.sensorConfig) {\n\t\t\tcontinue\n\t\t}\n\t\t// set dashboard temperature\n\t\tswitch a.sensorConfig.primarySensor {\n\t\tcase \"\":\n\t\t\ta.systemInfo.DashboardTemp = max(a.systemInfo.DashboardTemp, sensor.Temperature)\n\t\tcase sensorName:\n\t\t\ta.systemInfo.DashboardTemp = sensor.Temperature\n\t\t}\n\t\tsystemStats.Temperatures[sensorName] = twoDecimals(sensor.Temperature)\n\t}\n}\n", "n_tokens": 541, "primary_symbol": "updateTemperatures", "primary_kind": "function", "primary_span": [78, 141], "def_symbols": ["updateTemperatures"], "symbols": ["updateTemperatures", "updates", "the", "agent", "with", "latest", "sensor", "temperatures", "func", "Agent", "systemStats", "system", "Stats", "skip", "sensors", "whitelist", "set", "empty", "string", "sensorConfig", "skipCollection", "slog", "Debug", "Skipping", "temperature", "collection", "return", "reset", "high", "temp", "systemInfo", "DashboardTemp", "temps", "err", "getTempsWithPanicRecovery", "getSensorTemps", "nil", "retry", "once", "panic", "gopsutil", "issues", "Warn", "Error", "updating", "len", "Temperatures", "make", "map", "float64", "Temperature", "for", "range", "check", "malformed", "strings", "darwin", "runtime", "GOOS", "utf8", "ValidString", "SensorKey", "continue", "scale", "scaleTemperature", "unreasonable", "sensorName", "key", "already", "exists", "append", "int", "strconv", "Itoa", "not", "blacklist", "isValidSensor", "dashboard", "switch", "primarySensor", "case", "max", "twoDecimals"], "doc_head": "// updateTemperatures updates the agent with the latest sensor temperatures\nfunc (a *Agent) updateTemperatures(systemStats *system.Stats) {\n\t// skip if sensors whitelist is set to empty string\n\tif a.sensorConfig.skipCollection {\n\t\tslog.Debug(\"Skipping temperature collection\")\n\t\treturn\n\t}\n\t// reset high temp\n\ta.systemInfo.DashboardTemp = 0\n\ttemps, err := a.getTempsWithPanicRecovery(getSensorTemps)\n\tif err != nil {\n\t\t// retry once on panic (gopsutil/issues/1832)\n\t\ttemps, err = a.getTempsWithPanicRecovery(getSensorTemps)\n\t\tif err != nil {\n\t\t\tslog.Warn(\"Error updating temperatures\", \"err\", err)\n\t\t\tif len(systemStats.Temperatures) > 0 {\n\t\t\t\tsystemStats.Temperatures = make(map[string]float64)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tslog.Debug(\"Temperature\", \"sensors\", temps)\n\t// return if no sensors\n\tif len(temps) == 0 {\n\t\treturn\n\t}\n\tsystemStats.Temperatures = make(map[string]float64, len(temps))\n\tfor i, sensor := range temps {\n\t\t// check for malformed strings on darwin (gopsutil/issues/1832)\n\t\tif runtime.GOOS == \"darwin\" && !utf8.ValidString(sensor.SensorKey) {\n\t\t\tcontinue\n\t\t}\n\t\t// scale temperature\n\t\tif sensor.Temperature != 0 && sensor.Temperature < 1 {\n\t\t\tsensor.Temperature = scaleTemperature(sensor."}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go", "rel_path": "agent/sensors.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 142, "end_line": 153, "text": "// getTempsWithPanicRecovery wraps sensors.TemperaturesWithContext to recover from panics (gopsutil/issues/1832)\nfunc (a *Agent) getTempsWithPanicRecovery(getTemps getTempsFn) (temps []sensors.TemperatureStat, err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = fmt.Errorf(\"panic: %v\", r)\n\t\t}\n\t}()\n\t// get sensor data (error ignored intentionally as it may be only with one sensor)\n\ttemps, _ = getTemps(a.sensorConfig.context)\n\treturn\n}\n", "n_tokens": 131, "primary_symbol": "getTempsWithPanicRecovery", "primary_kind": "function", "primary_span": [143, 153], "def_symbols": ["getTempsWithPanicRecovery"], "symbols": ["getTempsWithPanicRecovery", "wraps", "sensors", "TemperaturesWithContext", "recover", "from", "panics", "gopsutil", "issues", "func", "Agent", "getTemps", "getTempsFn", "temps", "TemperatureStat", "err", "error", "defer", "nil", "fmt", "Errorf", "panic", "get", "sensor", "data", "ignored", "intentionally", "may", "only", "with", "one", "sensorConfig", "context", "return"], "doc_head": "// getTempsWithPanicRecovery wraps sensors.TemperaturesWithContext to recover from panics (gopsutil/issues/1832)\nfunc (a *Agent) getTempsWithPanicRecovery(getTemps getTempsFn) (temps []sensors.TemperatureStat, err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = fmt.Errorf(\"panic: %v\", r)\n\t\t}\n\t}()\n\t// get sensor data (error ignored intentionally as it may be only with one sensor)\n\ttemps, _ = getTemps(a.sensorConfig.context)\n\treturn\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go", "rel_path": "agent/sensors.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 154, "end_line": 183, "text": "// isValidSensor checks if a sensor is valid based on the sensor name and the sensor config\nfunc isValidSensor(sensorName string, config *SensorConfig) bool {\n\t// if no sensors configured, everything is valid\n\tif len(config.sensors) == 0 {\n\t\treturn true\n\t}\n\n\t// Exact match - return true if whitelist, false if blacklist\n\tif _, exactMatch := config.sensors[sensorName]; exactMatch {\n\t\treturn !config.isBlacklist\n\t}\n\n\t// If no wildcards, return true if blacklist, false if whitelist\n\tif !config.hasWildcards {\n\t\treturn config.isBlacklist\n\t}\n\n\t// Check for wildcard patterns\n\tfor pattern := range config.sensors {\n\t\tif !strings.Contains(pattern, \"*\") {\n\t\t\tcontinue\n\t\t}\n\t\tif match, _ := path.Match(pattern, sensorName); match {\n\t\t\treturn !config.isBlacklist\n\t\t}\n\t}\n\n\treturn config.isBlacklist\n}\n", "n_tokens": 197, "primary_symbol": "isValidSensor", "primary_kind": "function", "primary_span": [155, 183], "def_symbols": ["isValidSensor"], "symbols": ["isValidSensor", "checks", "sensor", "valid", "based", "the", "name", "and", "config", "func", "sensorName", "string", "SensorConfig", "bool", "sensors", "configured", "everything", "len", "return", "true", "Exact", "match", "whitelist", "false", "blacklist", "exactMatch", "isBlacklist", "wildcards", "hasWildcards", "Check", "for", "wildcard", "patterns", "pattern", "range", "strings", "Contains", "continue", "path", "Match"], "doc_head": "// isValidSensor checks if a sensor is valid based on the sensor name and the sensor config\nfunc isValidSensor(sensorName string, config *SensorConfig) bool {\n\t// if no sensors configured, everything is valid\n\tif len(config.sensors) == 0 {\n\t\treturn true\n\t}\n\t// Exact match - return true if whitelist, false if blacklist\n\tif _, exactMatch := config.sensors[sensorName]; exactMatch {\n\t\treturn !config.isBlacklist\n\t}\n\t// If no wildcards, return true if blacklist, false if whitelist\n\tif !config.hasWildcards {\n\t\treturn config.isBlacklist\n\t}\n\t// Check for wildcard patterns\n\tfor pattern := range config.sensors {\n\t\tif !strings.Contains(pattern, \"*\") {\n\t\t\tcontinue\n\t\t}\n\t\tif match, _ := path.Match(pattern, sensorName); match {\n\t\t\treturn !config.isBlacklist\n\t\t}\n\t}\n\treturn config.isBlacklist\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors.go", "rel_path": "agent/sensors.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 184, "end_line": 199, "text": "// scaleTemperature scales temperatures in fractional values to reasonable Celsius values\nfunc scaleTemperature(temp float64) float64 {\n\tif temp > 1 {\n\t\treturn temp\n\t}\n\tscaled100 := temp * 100\n\tscaled1000 := temp * 1000\n\n\tif scaled100 >= 15 && scaled100 <= 95 {\n\t\treturn scaled100\n\t} else if scaled1000 >= 15 && scaled1000 <= 95 {\n\t\treturn scaled1000\n\t}\n\treturn scaled100\n}\n", "n_tokens": 104, "primary_symbol": "scaleTemperature", "primary_kind": "function", "primary_span": [185, 199], "def_symbols": ["scaleTemperature"], "symbols": ["scaleTemperature", "scales", "temperatures", "fractional", "values", "reasonable", "Celsius", "func", "temp", "float64", "return", "scaled100", "scaled1000", "else"], "doc_head": "// scaleTemperature scales temperatures in fractional values to reasonable Celsius values\nfunc scaleTemperature(temp float64) float64 {\n\tif temp > 1 {\n\t\treturn temp\n\t}\n\tscaled100 := temp * 100\n\tscaled1000 := temp * 1000\n\tif scaled100 >= 15 && scaled100 <= 95 {\n\t\treturn scaled100\n\t} else if scaled1000 >= 15 && scaled1000 <= 95 {\n\t\treturn scaled1000\n\t}\n\treturn scaled100\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/system.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/system.go", "rel_path": "agent/system.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 23, "text": "package agent\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/agent/battery\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/shirou/gopsutil/v4/cpu\"\n\t\"github.com/shirou/gopsutil/v4/disk\"\n\t\"github.com/shirou/gopsutil/v4/host\"\n\t\"github.com/shirou/gopsutil/v4/load\"\n\t\"github.com/shirou/gopsutil/v4/mem\"\n\tpsutilNet \"github.com/shirou/gopsutil/v4/net\"\n)\n", "n_tokens": 153, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 23], "def_symbols": [], "symbols": ["package", "agent", "import", "bufio", "fmt", "log", "slog", "strconv", "strings", "time", "github", "com", "henrygd", "beszel", "battery", "src", "entities", "system", "shirou", "gopsutil", "cpu", "disk", "host", "load", "mem", "psutilNet", "net"], "doc_head": "package agent\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/agent/battery\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/shirou/gopsutil/v4/cpu\"\n\t\"github.com/shirou/gopsutil/v4/disk\"\n\t\"github.com/shirou/gopsutil/v4/host\"\n\t\"github.com/shirou/gopsutil/v4/load\"\n\t\"github.com/shirou/gopsutil/v4/mem\"\n\tpsutilNet \"github.com/shirou/gopsutil/v4/net\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/system.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/system.go", "rel_path": "agent/system.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 24, "end_line": 70, "text": "// Sets initial / non-changing values about the host system\nfunc (a *Agent) initializeSystemInfo() {\n\ta.systemInfo.AgentVersion = beszel.Version\n\ta.systemInfo.Hostname, _ = os.Hostname()\n\n\tplatform, _, version, _ := host.PlatformInformation()\n\n\tif platform == \"darwin\" {\n\t\ta.systemInfo.KernelVersion = version\n\t\ta.systemInfo.Os = system.Darwin\n\t} else if strings.Contains(platform, \"indows\") {\n\t\ta.systemInfo.KernelVersion = strings.Replace(platform, \"Microsoft \", \"\", 1) + \" \" + version\n\t\ta.systemInfo.Os = system.Windows\n\t} else if platform == \"freebsd\" {\n\t\ta.systemInfo.Os = system.Freebsd\n\t\ta.systemInfo.KernelVersion = version\n\t} else {\n\t\ta.systemInfo.Os = system.Linux\n\t}\n\n\tif a.systemInfo.KernelVersion == \"\" {\n\t\ta.systemInfo.KernelVersion, _ = host.KernelVersion()\n\t}\n\n\t// cpu model\n\tif info, err := cpu.Info(); err == nil && len(info) > 0 {\n\t\ta.systemInfo.CpuModel = info[0].ModelName\n\t}\n\t// cores / threads\n\ta.systemInfo.Cores, _ = cpu.Counts(false)\n\tif threads, err := cpu.Counts(true); err == nil {\n\t\tif threads > 0 && threads < a.systemInfo.Cores {\n\t\t\t// in lxc logical cores reflects container limits, so use that as cores if lower\n\t\t\ta.systemInfo.Cores = threads\n\t\t} else {\n\t\t\ta.systemInfo.Threads = threads\n\t\t}\n\t}\n\n\t// zfs\n\tif _, err := getARCSize(); err != nil {\n\t\tslog.Debug(\"Not monitoring ZFS ARC\", \"err\", err)\n\t} else {\n\t\ta.zfs = true\n\t}\n}\n", "n_tokens": 393, "primary_symbol": "initializeSystemInfo", "primary_kind": "function", "primary_span": [25, 70], "def_symbols": ["initializeSystemInfo"], "symbols": ["initializeSystemInfo", "Sets", "initial", "non", "changing", "values", "about", "the", "host", "system", "func", "Agent", "systemInfo", "AgentVersion", "beszel", "Version", "Hostname", "platform", "version", "PlatformInformation", "darwin", "KernelVersion", "Darwin", "else", "strings", "Contains", "indows", "Replace", "Microsoft", "Windows", "freebsd", "Freebsd", "Linux", "cpu", "model", "info", "err", "Info", "nil", "len", "CpuModel", "ModelName", "cores", "threads", "Cores", "Counts", "false", "true", "lxc", "logical", "reflects", "container", "limits", "use", "that", "lower", "Threads", "zfs", "getARCSize", "slog", "Debug", "Not", "monitoring", "ZFS", "ARC"], "doc_head": "// Sets initial / non-changing values about the host system\nfunc (a *Agent) initializeSystemInfo() {\n\ta.systemInfo.AgentVersion = beszel.Version\n\ta.systemInfo.Hostname, _ = os.Hostname()\n\tplatform, _, version, _ := host.PlatformInformation()\n\tif platform == \"darwin\" {\n\t\ta.systemInfo.KernelVersion = version\n\t\ta.systemInfo.Os = system.Darwin\n\t} else if strings.Contains(platform, \"indows\") {\n\t\ta.systemInfo.KernelVersion = strings.Replace(platform, \"Microsoft \", \"\", 1) + \" \" + version\n\t\ta.systemInfo.Os = system.Windows\n\t} else if platform == \"freebsd\" {\n\t\ta.systemInfo.Os = system.Freebsd\n\t\ta.systemInfo.KernelVersion = version\n\t} else {\n\t\ta.systemInfo.Os = system.Linux\n\t}\n\tif a.systemInfo.KernelVersion == \"\" {\n\t\ta.systemInfo.KernelVersion, _ = host.KernelVersion()\n\t}\n\t// cpu model\n\tif info, err := cpu.Info(); err == nil && len(info) > 0 {\n\t\ta.systemInfo.CpuModel = info[0].ModelName\n\t}\n\t// cores / threads\n\ta.systemInfo.Cores, _ = cpu.Counts(false)\n\tif threads, err := cpu.Counts(true); err == nil {\n\t\tif threads > 0 && threads < a.systemInfo.Cores {\n\t\t\t// in lxc logical cores reflects container limits, so use that as cores if lower\n\t\t\ta.systemInfo.Cores = threads\n\t\t} else {\n\t\t\ta.systemInfo"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/system.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/system.go", "rel_path": "agent/system.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 71, "end_line": 280, "text": "// Returns current info, stats about the host system\nfunc (a *Agent) getSystemStats() system.Stats {\n\tsystemStats := system.Stats{}\n\n\t// battery\n\tif battery.HasReadableBattery() {\n\t\tsystemStats.Battery[0], systemStats.Battery[1], _ = battery.GetBatteryStats()\n\t}\n\n\t// cpu percent\n\tcpuPct, err := cpu.Percent(0, false)\n\tif err != nil {\n\t\tslog.Error(\"Error getting cpu percent\", \"err\", err)\n\t} else if len(cpuPct) > 0 {\n\t\tsystemStats.Cpu = twoDecimals(cpuPct[0])\n\t}\n\n\t// load average\n\tif avgstat, err := load.Avg(); err == nil {\n\t\tsystemStats.LoadAvg[0] = avgstat.Load1\n\t\tsystemStats.LoadAvg[1] = avgstat.Load5\n\t\tsystemStats.LoadAvg[2] = avgstat.Load15\n\t\tslog.Debug(\"Load average\", \"5m\", avgstat.Load5, \"15m\", avgstat.Load15)\n\t} else {\n\t\tslog.Error(\"Error getting load average\", \"err\", err)\n\t}\n\n\t// memory\n\tif v, err := mem.VirtualMemory(); err == nil {\n\t\t// swap\n\t\tsystemStats.Swap = bytesToGigabytes(v.SwapTotal)\n\t\tsystemStats.SwapUsed = bytesToGigabytes(v.SwapTotal - v.SwapFree - v.SwapCached)\n\t\t// cache + buffers value for default mem calculation\n\t\tcacheBuff := v.Total - v.Free - v.Used\n\t\t// htop memory calculation overrides\n\t\tif a.memCalc == \"htop\" {\n\t\t\t// note: gopsutil automatically adds SReclaimable to v.Cached\n\t\t\tcacheBuff = v.Cached + v.Buffers - v.Shared\n\t\t\tv.Used = v.Total - (v.Free + cacheBuff)\n\t\t\tv.UsedPercent = float64(v.Used) / float64(v.Total) * 100.0\n\t\t}\n\t\t// subtract ZFS ARC size from used memory and add as its own category\n\t\tif a.zfs {\n\t\t\tif arcSize, _ := getARCSize(); arcSize > 0 && arcSize < v.Used {\n\t\t\t\tv.Used = v.Used - arcSize\n\t\t\t\tv.UsedPercent = float64(v.Used) / float64(v.Total) * 100.0\n\t\t\t\tsystemStats.MemZfsArc = bytesToGigabytes(arcSize)\n\t\t\t}\n\t\t}\n\t\tsystemStats.Mem = bytesToGigabytes(v.Total)\n\t\tsystemStats.MemBuffCache = bytesToGigabytes(cacheBuff)\n\t\tsystemStats.MemUsed = bytesToGigabytes(v.Used)\n\t\tsystemStats.MemPct = twoDecimals(v.UsedPercent)\n\t}\n\n\t// disk usage\n\tfor _, stats := range a.fsStats {\n\t\tif d, err := disk.Usage(stats.Mountpoint); err == nil {\n\t\t\tstats.DiskTotal = bytesToGigabytes(d.Total)\n\t\t\tstats.DiskUsed = bytesToGigabytes(d.Used)\n\t\t\tif stats.Root {\n\t\t\t\tsystemStats.DiskTotal = bytesToGigabytes(d.Total)\n\t\t\t\tsystemStats.DiskUsed = bytesToGigabytes(d.Used)\n\t\t\t\tsystemStats.DiskPct = twoDecimals(d.UsedPercent)\n\t\t\t}\n\t\t} else {\n\t\t\t// reset stats if error (likely unmounted)\n\t\t\tslog.Error(\"Error getting disk stats\", \"name\", stats.Mountpoint, \"err\", err)\n\t\t\tstats.DiskTotal = 0\n\t\t\tstats.DiskUsed = 0\n\t\t\tstats.TotalRead = 0\n\t\t\tstats.TotalWrite = 0\n\t\t}\n\t}\n\n\t// disk i/o\n\tif ioCounters, err := disk.IOCounters(a.fsNames...); err == nil {\n\t\tfor _, d := range ioCounters {\n\t\t\tstats := a.fsStats[d.Name]\n\t\t\tif stats == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsecondsElapsed := time.Since(stats.Time).Seconds()\n\t\t\treadPerSecond := bytesToMegabytes(float64(d.ReadBytes-stats.TotalRead) / secondsElapsed)\n\t\t\twritePerSecond := bytesToMegabytes(float64(d.WriteBytes-stats.TotalWrite) / secondsElapsed)\n\t\t\t// check for invalid values and reset stats if so\n\t\t\tif readPerSecond < 0 || writePerSecond < 0 || readPerSecond > 50_000 || writePerSecond > 50_000 {\n\t\t\t\tslog.Warn(\"Invalid disk I/O. Resetting.\", \"name\", d.Name, \"read\", readPerSecond, \"write\", writePerSecond)\n\t\t\t\ta.initializeDiskIoStats(ioCounters)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tstats.Time = time.Now()\n\t\t\tstats.DiskReadPs = readPerSecond\n\t\t\tstats.DiskWritePs = writePerSecond\n\t\t\tstats.TotalRead = d.ReadBytes\n\t\t\tstats.TotalWrite = d.WriteBytes\n\t\t\t// if root filesystem, update system stats\n\t\t\tif stats.Root {\n\t\t\t\tsystemStats.DiskReadPs = stats.DiskReadPs\n\t\t\t\tsystemStats.DiskWritePs = stats.DiskWritePs\n\t\t\t}\n\t\t}\n\t}\n\n\t// network stats\n\tif len(a.netInterfaces) == 0 {\n\t\t// if no network interfaces, initialize again\n\t\t// this is a fix if agent started before network is online (#466)\n\t\t// maybe refactor this in the future to not cache interface names at all so we\n\t\t// don't miss an interface that's been added after agent started in any circumstance\n\t\ta.initializeNetIoStats()\n\t}\n\tif netIO, err := psutilNet.IOCounters(true); err == nil {\n\t\tmsElapsed := uint64(time.Since(a.netIoStats.Time).Milliseconds())\n\t\ta.netIoStats.Time = time.Now()\n\t\ttotalBytesSent := uint64(0)\n\t\ttotalBytesRecv := uint64(0)\n\t\t// sum all bytes sent and received\n\t\tfor _, v := range netIO {\n\t\t\t// skip if not in valid network interfaces list\n\t\t\tif _, exists := a.netInterfaces[v.Name]; !exists {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttotalBytesSent += v.BytesSent\n\t\t\ttotalBytesRecv += v.BytesRecv\n\t\t}\n\t\t// add to systemStats\n\t\tvar bytesSentPerSecond, bytesRecvPerSecond uint64\n\t\tif msElapsed > 0 {\n\t\t\tbytesSentPerSecond = (totalBytesSent - a.netIoStats.BytesSent) * 1000 / msElapsed\n\t\t\tbytesRecvPerSecond = (totalBytesRecv - a.netIoStats.BytesRecv) * 1000 / msElapsed\n\t\t}\n\t\tnetworkSentPs := bytesToMegabytes(float64(bytesSentPerSecond))\n\t\tnetworkRecvPs := bytesToMegabytes(float64(bytesRecvPerSecond))\n\t\t// add check for issue (#150) where sent is a massive number\n\t\tif networkSentPs > 10_000 || networkRecvPs > 10_000 {\n\t\t\tslog.Warn(\"Invalid net stats. Resetting.\", \"sent\", networkSentPs, \"recv\", networkRecvPs)\n\t\t\tfor _, v := range netIO {\n\t\t\t\tif _, exists := a.netInterfaces[v.Name]; !exists {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tslog.Info(v.Name, \"recv\", v.BytesRecv, \"sent\", v.BytesSent)\n\t\t\t}\n\t\t\t// reset network I/O stats\n\t\t\ta.initializeNetIoStats()\n\t\t} else {\n\t\t\tsystemStats.NetworkSent = networkSentPs\n\t\t\tsystemStats.NetworkRecv = networkRecvPs\n\t\t\tsystemStats.Bandwidth[0], systemStats.Bandwidth[1] = bytesSentPerSecond, bytesRecvPerSecond\n\t\t\t// update netIoStats\n\t\t\ta.netIoStats.BytesSent = totalBytesSent\n\t\t\ta.netIoStats.BytesRecv = totalBytesRecv\n\t\t}\n\t}\n\n\t// temperatures\n\t// TODO: maybe refactor to methods on systemStats\n\ta.updateTemperatures(&systemStats)\n\n\t// GPU data\n\tif a.gpuManager != nil {\n\t\t// reset high gpu percent\n\t\ta.systemInfo.GpuPct = 0\n\t\t// get current GPU data\n\t\tif gpuData := a.gpuManager.GetCurrentData(); len(gpuData) > 0 {\n\t\t\tsystemStats.GPUData = gpuData\n\n\t\t\t// add temperatures\n\t\t\tif systemStats.Temperatures == nil {\n\t\t\t\tsystemStats.Temperatures = make(map[string]float64, len(gpuData))\n\t\t\t}\n\t\t\thighestTemp := 0.0\n\t\t\tfor _, gpu := range gpuData {\n\t\t\t\tif gpu.Temperature > 0 {\n\t\t\t\t\tsystemStats.Temperatures[gpu.Name] = gpu.Temperature\n\t\t\t\t\tif a.sensorConfig.primarySensor == gpu.Name {\n\t\t\t\t\t\ta.systemInfo.DashboardTemp = gpu.Temperature\n\t\t\t\t\t}\n\t\t\t\t\tif gpu.Temperature > highestTemp {\n\t\t\t\t\t\thighestTemp = gpu.Temperature\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// update high gpu percent for dashboard\n\t\t\t\ta.systemInfo.GpuPct = max(a.systemInfo.GpuPct, gpu.Usage)\n\t\t\t}\n\t\t\t// use highest temp for dashboard temp if dashboard temp is unset\n\t\t\tif a.systemInfo.DashboardTemp == 0 {\n\t\t\t\ta.systemInfo.DashboardTemp = highestTemp\n\t\t\t}\n\t\t}\n\t}\n\n\t// update base system info\n\ta.systemInfo.Cpu = systemStats.Cpu\n\ta.systemInfo.LoadAvg = systemStats.LoadAvg\n\t// TODO: remove these in future release in favor of load avg array\n\ta.systemInfo.LoadAvg1 = systemStats.LoadAvg[0]\n\ta.systemInfo.LoadAvg5 = systemStats.LoadAvg[1]\n\ta.systemInfo.LoadAvg15 = systemStats.LoadAvg[2]\n\ta.systemInfo.MemPct = systemStats.MemPct\n\ta.systemInfo.DiskPct = systemStats.DiskPct\n\ta.systemInfo.Uptime, _ = host.Uptime()\n\t// TODO: in future release, remove MB bandwidth values in favor of bytes\n\ta.systemInfo.Bandwidth = twoDecimals(systemStats.NetworkSent + systemStats.NetworkRecv)\n\ta.systemInfo.BandwidthBytes = systemStats.Bandwidth[0] + systemStats.Bandwidth[1]\n\tslog.Debug(\"sysinfo\", \"data\", a.systemInfo)\n\n\treturn systemStats\n}\n", "n_tokens": 2189, "primary_symbol": "getSystemStats", "primary_kind": "function", "primary_span": [72, 280], "def_symbols": ["getSystemStats"], "symbols": ["getSystemStats", "Returns", "current", "info", "stats", "about", "the", "host", "system", "func", "Agent", "Stats", "systemStats", "battery", "HasReadableBattery", "Battery", "GetBatteryStats", "cpu", "percent", "cpuPct", "err", "Percent", "false", "nil", "slog", "Error", "getting", "else", "len", "Cpu", "twoDecimals", "load", "average", "avgstat", "Avg", "LoadAvg", "Load1", "Load5", "Load15", "Debug", "Load", "memory", "mem", "VirtualMemory", "swap", "Swap", "bytesToGigabytes", "SwapTotal", "SwapUsed", "SwapFree", "SwapCached", "cache", "buffers", "value", "for", "default", "calculation", "cacheBuff", "Total", "Free", "Used", "htop", "overrides", "memCalc", "note", "gopsutil", "automatically", "adds", "SReclaimable", "Cached", "Buffers", "Shared", "UsedPercent", "float64", "subtract", "ZFS", "ARC", "size", "from", "used", "and", "add", "its", "own", "category", "zfs", "arcSize", "getARCSize", "MemZfsArc", "Mem", "MemBuffCache", "MemUsed", "MemPct", "disk", "usage", "range", "fsStats", "Usage", "Mountpoint", "DiskTotal", "DiskUsed", "Root", "DiskPct", "reset", "error", "likely", "unmounted", "name", "TotalRead", "TotalWrite", "ioCounters", "IOCounters", "fsNames", "Name", "continue", "secondsElapsed", "time", "Since", "Time", "Seconds", "readPerSecond", "bytesToMegabytes", "ReadBytes", "writePerSecond", "WriteBytes", "check", "invalid", "values", "Warn", "Invalid", "Resetting", "read", "write", "initializeDiskIoStats", "break", "Now", "DiskReadPs", "DiskWritePs", "root", "filesystem", "update", "network", "netInterfaces", "interfaces", "initialize", "again", "this", "fix", "agent", "started", "before", "online", "maybe", "refactor", "future", "not", "interface", "names", "all", "don", "miss", "that", "been", "added", "after", "any", "circumstance", "initializeNetIoStats", "netIO", "psutilNet", "true", "msElapsed", "uint64", "netIoStats", "Milliseconds", "totalBytesSent", "totalBytesRecv", "sum", "bytes", "sent", "received", "skip", "valid", "list", "exists", "BytesSent", "BytesRecv", "var", "bytesSentPerSecond", "bytesRecvPerSecond", "networkSentPs", "networkRecvPs", "issue", "where", "massive", "number", "net", "recv", "Info", "NetworkSent", "NetworkRecv", "Bandwidth", "temperatures", "TODO", "methods", "updateTemperatures", "GPU", "data", "gpuManager", "high", "gpu", "systemInfo", "GpuPct", "get", "gpuData", "GetCurrentData", "GPUData", "Temperatures", "make", "map", "string", "highestTemp", "Temperature", "sensorConfig", "primarySensor", "DashboardTemp", "dashboard", "max", "use", "highest", "temp", "unset", "base", "remove", "these", "release", "favor", "avg", "array", "LoadAvg1", "LoadAvg5", "LoadAvg15", "Uptime", "bandwidth", "BandwidthBytes", "sysinfo", "return"], "doc_head": "// Returns current info, stats about the host system\nfunc (a *Agent) getSystemStats() system.Stats {\n\tsystemStats := system.Stats{}\n\t// battery\n\tif battery.HasReadableBattery() {\n\t\tsystemStats.Battery[0], systemStats.Battery[1], _ = battery.GetBatteryStats()\n\t}\n\t// cpu percent\n\tcpuPct, err := cpu.Percent(0, false)\n\tif err != nil {\n\t\tslog.Error(\"Error getting cpu percent\", \"err\", err)\n\t} else if len(cpuPct) > 0 {\n\t\tsystemStats.Cpu = twoDecimals(cpuPct[0])\n\t}\n\t// load average\n\tif avgstat, err := load.Avg(); err == nil {\n\t\tsystemStats.LoadAvg[0] = avgstat.Load1\n\t\tsystemStats.LoadAvg[1] = avgstat.Load5\n\t\tsystemStats.LoadAvg[2] = avgstat.Load15\n\t\tslog.Debug(\"Load average\", \"5m\", avgstat.Load5, \"15m\", avgstat.Load15)\n\t} else {\n\t\tslog.Error(\"Error getting load average\", \"err\", err)\n\t}\n\t// memory\n\tif v, err := mem.VirtualMemory(); err == nil {\n\t\t// swap\n\t\tsystemStats.Swap = bytesToGigabytes(v.SwapTotal)\n\t\tsystemStats.SwapUsed = bytesToGigabytes(v.SwapTotal - v.SwapFree - v.SwapCached)\n\t\t// cache + buffers value for default mem calculation\n\t\tcacheBuff := v.Total - v.Free - v.Used\n\t\t// htop memory calculation overrides\n\t\tif a.memCalc == \"htop\" {\n\t\t\t// note: gopsutil automatically adds SRecla"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/system.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/system.go", "rel_path": "agent/system.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 281, "end_line": 306, "text": "// Returns the size of the ZFS ARC memory cache in bytes\nfunc getARCSize() (uint64, error) {\n\tfile, err := os.Open(\"/proc/spl/kstat/zfs/arcstats\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer file.Close()\n\n\t// Scan the lines\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tif strings.HasPrefix(line, \"size\") {\n\t\t\t// Example line: size 4 15032385536\n\t\t\tfields := strings.Fields(line)\n\t\t\tif len(fields) < 3 {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\t// Return the size as uint64\n\t\t\treturn strconv.ParseUint(fields[2], 10, 64)\n\t\t}\n\t}\n\n\treturn 0, fmt.Errorf(\"failed to parse size field\")\n}\n", "n_tokens": 182, "primary_symbol": "getARCSize", "primary_kind": "function", "primary_span": [282, 306], "def_symbols": ["getARCSize"], "symbols": ["getARCSize", "Returns", "the", "size", "ZFS", "ARC", "memory", "cache", "bytes", "func", "uint64", "error", "file", "err", "Open", "proc", "spl", "kstat", "zfs", "arcstats", "nil", "return", "defer", "Close", "Scan", "lines", "scanner", "bufio", "NewScanner", "for", "line", "Text", "strings", "HasPrefix", "Example", "fields", "Fields", "len", "Return", "strconv", "ParseUint", "fmt", "Errorf", "failed", "parse", "field"], "doc_head": "// Returns the size of the ZFS ARC memory cache in bytes\nfunc getARCSize() (uint64, error) {\n\tfile, err := os.Open(\"/proc/spl/kstat/zfs/arcstats\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer file.Close()\n\t// Scan the lines\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tif strings.HasPrefix(line, \"size\") {\n\t\t\t// Example line: size 4 15032385536\n\t\t\tfields := strings.Fields(line)\n\t\t\tif len(fields) < 3 {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\t// Return the size as uint64\n\t\t\treturn strconv.ParseUint(fields[2], 10, 64)\n\t\t}\n\t}\n\treturn 0, fmt.Errorf(\"failed to parse size field\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go", "rel_path": "agent/server.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 23, "text": "package agent\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/common\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/blang/semver\"\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/gliderlabs/ssh\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n", "n_tokens": 116, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 23], "def_symbols": [], "symbols": ["package", "agent", "import", "encoding", "json", "errors", "fmt", "log", "slog", "net", "strings", "time", "github", "com", "henrygd", "beszel", "src", "common", "entities", "system", "blang", "semver", "fxamacker", "cbor", "gliderlabs", "ssh", "gossh", "golang", "org", "crypto"], "doc_head": "package agent\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/common\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/blang/semver\"\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/gliderlabs/ssh\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go", "rel_path": "agent/server.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 24, "end_line": 33, "text": "// ServerOptions contains configuration options for starting the SSH server.\ntype ServerOptions struct {\n\tAddr    string            // Network address to listen on (e.g., \":45876\" or \"/path/to/socket\")\n\tNetwork string            // Network type (\"tcp\" or \"unix\")\n\tKeys    []gossh.PublicKey // SSH public keys for authentication\n}\n\n// hubVersions caches hub versions by session ID to avoid repeated parsing.\nvar hubVersions map[string]semver.Version\n", "n_tokens": 96, "primary_symbol": "", "primary_kind": "", "primary_span": [24, 33], "def_symbols": [], "symbols": ["ServerOptions", "contains", "configuration", "options", "for", "starting", "the", "SSH", "server", "type", "struct", "Addr", "string", "Network", "address", "listen", "path", "socket", "tcp", "unix", "Keys", "gossh", "PublicKey", "public", "keys", "authentication", "hubVersions", "caches", "hub", "versions", "session", "avoid", "repeated", "parsing", "var", "map", "semver", "Version"], "doc_head": "// ServerOptions contains configuration options for starting the SSH server.\ntype ServerOptions struct {\n\tAddr    string            // Network address to listen on (e.g., \":45876\" or \"/path/to/socket\")\n\tNetwork string            // Network type (\"tcp\" or \"unix\")\n\tKeys    []gossh.PublicKey // SSH public keys for authentication\n}\n// hubVersions caches hub versions by session ID to avoid repeated parsing.\nvar hubVersions map[string]semver.Version"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go", "rel_path": "agent/server.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 34, "end_line": 97, "text": "// StartServer starts the SSH server with the provided options.\n// It configures the server with secure defaults, sets up authentication,\n// and begins listening for connections. Returns an error if the server\n// is already running or if there's an issue starting the server.\nfunc (a *Agent) StartServer(opts ServerOptions) error {\n\tif a.server != nil {\n\t\treturn errors.New(\"server already started\")\n\t}\n\n\tslog.Info(\"Starting SSH server\", \"addr\", opts.Addr, \"network\", opts.Network)\n\n\tif opts.Network == \"unix\" {\n\t\t// remove existing socket file if it exists\n\t\tif err := os.Remove(opts.Addr); err != nil && !os.IsNotExist(err) {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// start listening on the address\n\tln, err := net.Listen(opts.Network, opts.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ln.Close()\n\n\t// base config (limit to allowed algorithms)\n\tconfig := &gossh.ServerConfig{\n\t\tServerVersion: fmt.Sprintf(\"SSH-2.0-%s_%s\", beszel.AppName, beszel.Version),\n\t}\n\tconfig.KeyExchanges = common.DefaultKeyExchanges\n\tconfig.MACs = common.DefaultMACs\n\tconfig.Ciphers = common.DefaultCiphers\n\n\t// set default handler\n\tssh.Handle(a.handleSession)\n\n\ta.server = &ssh.Server{\n\t\tServerConfigCallback: func(ctx ssh.Context) *gossh.ServerConfig {\n\t\t\treturn config\n\t\t},\n\t\t// check public key(s)\n\t\tPublicKeyHandler: func(ctx ssh.Context, key ssh.PublicKey) bool {\n\t\t\tremoteAddr := ctx.RemoteAddr()\n\t\t\tfor _, pubKey := range opts.Keys {\n\t\t\t\tif ssh.KeysEqual(key, pubKey) {\n\t\t\t\t\tslog.Info(\"SSH connected\", \"addr\", remoteAddr)\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t\tslog.Warn(\"Invalid SSH key\", \"addr\", remoteAddr)\n\t\t\treturn false\n\t\t},\n\t\t// disable pty\n\t\tPtyCallback: func(ctx ssh.Context, pty ssh.Pty) bool {\n\t\t\treturn false\n\t\t},\n\t\t// close idle connections after 70 seconds\n\t\tIdleTimeout: 70 * time.Second,\n\t}\n\n\t// Start SSH server on the listener\n\treturn a.server.Serve(ln)\n}\n", "n_tokens": 481, "primary_symbol": "StartServer", "primary_kind": "function", "primary_span": [38, 97], "def_symbols": ["StartServer"], "symbols": ["StartServer", "starts", "the", "SSH", "server", "with", "provided", "options", "configures", "secure", "defaults", "sets", "authentication", "and", "begins", "listening", "for", "connections", "Returns", "error", "already", "running", "there", "issue", "starting", "func", "Agent", "opts", "ServerOptions", "nil", "return", "errors", "New", "started", "slog", "Info", "Starting", "addr", "Addr", "network", "Network", "unix", "remove", "existing", "socket", "file", "exists", "err", "Remove", "IsNotExist", "start", "address", "net", "Listen", "defer", "Close", "base", "config", "limit", "allowed", "algorithms", "gossh", "ServerConfig", "ServerVersion", "fmt", "Sprintf", "beszel", "AppName", "Version", "KeyExchanges", "common", "DefaultKeyExchanges", "MACs", "DefaultMACs", "Ciphers", "DefaultCiphers", "set", "default", "handler", "ssh", "Handle", "handleSession", "Server", "ServerConfigCallback", "ctx", "Context", "check", "public", "key", "PublicKeyHandler", "PublicKey", "bool", "remoteAddr", "RemoteAddr", "pubKey", "range", "Keys", "KeysEqual", "connected", "true", "Warn", "Invalid", "false", "disable", "pty", "PtyCallback", "Pty", "close", "idle", "after", "seconds", "IdleTimeout", "time", "Second", "Start", "listener", "Serve"], "doc_head": "// StartServer starts the SSH server with the provided options.\n// It configures the server with secure defaults, sets up authentication,\n// and begins listening for connections. Returns an error if the server\n// is already running or if there's an issue starting the server.\nfunc (a *Agent) StartServer(opts ServerOptions) error {\n\tif a.server != nil {\n\t\treturn errors.New(\"server already started\")\n\t}\n\tslog.Info(\"Starting SSH server\", \"addr\", opts.Addr, \"network\", opts.Network)\n\tif opts.Network == \"unix\" {\n\t\t// remove existing socket file if it exists\n\t\tif err := os.Remove(opts.Addr); err != nil && !os.IsNotExist(err) {\n\t\t\treturn err\n\t\t}\n\t}\n\t// start listening on the address\n\tln, err := net.Listen(opts.Network, opts.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ln.Close()\n\t// base config (limit to allowed algorithms)\n\tconfig := &gossh.ServerConfig{\n\t\tServerVersion: fmt.Sprintf(\"SSH-2.0-%s_%s\", beszel.AppName, beszel.Version),\n\t}\n\tconfig.KeyExchanges = common.DefaultKeyExchanges\n\tconfig.MACs = common.DefaultMACs\n\tconfig.Ciphers = common.DefaultCiphers\n\t// set default handler\n\tssh.Handle(a.handleSession)\n\ta.server = &ssh.Server{\n\t\tServerConfigCallback: func(ctx ssh.Context) *gossh.Serv"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go", "rel_path": "agent/server.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 98, "end_line": 117, "text": "// getHubVersion retrieves and caches the hub version for a given session.\n// It extracts the version from the SSH client version string and caches\n// it to avoid repeated parsing. Returns a zero version if parsing fails.\nfunc (a *Agent) getHubVersion(sessionId string, sessionCtx ssh.Context) semver.Version {\n\tif hubVersions == nil {\n\t\thubVersions = make(map[string]semver.Version, 1)\n\t}\n\thubVersion, ok := hubVersions[sessionId]\n\tif ok {\n\t\treturn hubVersion\n\t}\n\t// Extract hub version from SSH client version\n\tclientVersion := sessionCtx.Value(ssh.ContextKeyClientVersion)\n\tif versionStr, ok := clientVersion.(string); ok {\n\t\thubVersion, _ = extractHubVersion(versionStr)\n\t}\n\thubVersions[sessionId] = hubVersion\n\treturn hubVersion\n}\n", "n_tokens": 177, "primary_symbol": "getHubVersion", "primary_kind": "function", "primary_span": [101, 117], "def_symbols": ["getHubVersion"], "symbols": ["getHubVersion", "retrieves", "and", "caches", "the", "hub", "version", "for", "given", "session", "extracts", "from", "SSH", "client", "string", "avoid", "repeated", "parsing", "Returns", "zero", "fails", "func", "Agent", "sessionId", "sessionCtx", "ssh", "Context", "semver", "Version", "hubVersions", "nil", "make", "map", "hubVersion", "return", "Extract", "clientVersion", "Value", "ContextKeyClientVersion", "versionStr", "extractHubVersion"], "doc_head": "// getHubVersion retrieves and caches the hub version for a given session.\n// It extracts the version from the SSH client version string and caches\n// it to avoid repeated parsing. Returns a zero version if parsing fails.\nfunc (a *Agent) getHubVersion(sessionId string, sessionCtx ssh.Context) semver.Version {\n\tif hubVersions == nil {\n\t\thubVersions = make(map[string]semver.Version, 1)\n\t}\n\thubVersion, ok := hubVersions[sessionId]\n\tif ok {\n\t\treturn hubVersion\n\t}\n\t// Extract hub version from SSH client version\n\tclientVersion := sessionCtx.Value(ssh.ContextKeyClientVersion)\n\tif versionStr, ok := clientVersion.(string); ok {\n\t\thubVersion, _ = extractHubVersion(versionStr)\n\t}\n\thubVersions[sessionId] = hubVersion\n\treturn hubVersion\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go", "rel_path": "agent/server.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 118, "end_line": 140, "text": "// handleSession handles an incoming SSH session by gathering system statistics\n// and sending them to the hub. It signals connection events, determines the\n// appropriate encoding format based on hub version, and exits with appropriate\n// status codes.\nfunc (a *Agent) handleSession(s ssh.Session) {\n\ta.connectionManager.eventChan <- SSHConnect\n\n\tsessionCtx := s.Context()\n\tsessionID := sessionCtx.SessionID()\n\n\thubVersion := a.getHubVersion(sessionID, sessionCtx)\n\n\tstats := a.gatherStats(sessionID)\n\n\terr := a.writeToSession(s, stats, hubVersion)\n\tif err != nil {\n\t\tslog.Error(\"Error encoding stats\", \"err\", err, \"stats\", stats)\n\t\ts.Exit(1)\n\t} else {\n\t\ts.Exit(0)\n\t}\n}\n", "n_tokens": 162, "primary_symbol": "handleSession", "primary_kind": "function", "primary_span": [122, 140], "def_symbols": ["handleSession"], "symbols": ["handleSession", "handles", "incoming", "SSH", "session", "gathering", "system", "statistics", "and", "sending", "them", "the", "hub", "signals", "connection", "events", "determines", "appropriate", "encoding", "format", "based", "version", "exits", "with", "status", "codes", "func", "Agent", "ssh", "Session", "connectionManager", "eventChan", "SSHConnect", "sessionCtx", "Context", "sessionID", "SessionID", "hubVersion", "getHubVersion", "stats", "gatherStats", "err", "writeToSession", "nil", "slog", "Error", "Exit", "else"], "doc_head": "// handleSession handles an incoming SSH session by gathering system statistics\n// and sending them to the hub. It signals connection events, determines the\n// appropriate encoding format based on hub version, and exits with appropriate\n// status codes.\nfunc (a *Agent) handleSession(s ssh.Session) {\n\ta.connectionManager.eventChan <- SSHConnect\n\tsessionCtx := s.Context()\n\tsessionID := sessionCtx.SessionID()\n\thubVersion := a.getHubVersion(sessionID, sessionCtx)\n\tstats := a.gatherStats(sessionID)\n\terr := a.writeToSession(s, stats, hubVersion)\n\tif err != nil {\n\t\tslog.Error(\"Error encoding stats\", \"err\", err, \"stats\", stats)\n\t\ts.Exit(1)\n\t} else {\n\t\ts.Exit(0)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go", "rel_path": "agent/server.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 141, "end_line": 157, "text": "// writeToSession encodes and writes system statistics to the session.\n// It chooses between CBOR and JSON encoding based on the hub version,\n// using CBOR for newer versions and JSON for legacy compatibility.\nfunc (a *Agent) writeToSession(w io.Writer, stats *system.CombinedData, hubVersion semver.Version) error {\n\tif hubVersion.GTE(beszel.MinVersionCbor) {\n\t\treturn cbor.NewEncoder(w).Encode(stats)\n\t}\n\treturn json.NewEncoder(w).Encode(stats)\n}\n\n// extractHubVersion extracts the beszel version from SSH client version string.\n// Expected format: \"SSH-2.0-beszel_X.Y.Z\" or \"beszel_X.Y.Z\"\nfunc extractHubVersion(versionString string) (semver.Version, error) {\n\t_, after, _ := strings.Cut(versionString, \"_\")\n\treturn semver.Parse(after)\n}\n", "n_tokens": 183, "primary_symbol": "writeToSession", "primary_kind": "function", "primary_span": [144, 157], "def_symbols": ["writeToSession", "extractHubVersion"], "symbols": ["writeToSession", "extractHubVersion", "encodes", "and", "writes", "system", "statistics", "the", "session", "chooses", "between", "CBOR", "JSON", "encoding", "based", "hub", "version", "using", "for", "newer", "versions", "legacy", "compatibility", "func", "Agent", "Writer", "stats", "CombinedData", "hubVersion", "semver", "Version", "error", "GTE", "beszel", "MinVersionCbor", "return", "cbor", "NewEncoder", "Encode", "json", "extracts", "from", "SSH", "client", "string", "Expected", "format", "beszel_X", "versionString", "after", "strings", "Cut", "Parse"], "doc_head": "// writeToSession encodes and writes system statistics to the session.\n// It chooses between CBOR and JSON encoding based on the hub version,\n// using CBOR for newer versions and JSON for legacy compatibility.\nfunc (a *Agent) writeToSession(w io.Writer, stats *system.CombinedData, hubVersion semver.Version) error {\n\tif hubVersion.GTE(beszel.MinVersionCbor) {\n\t\treturn cbor.NewEncoder(w).Encode(stats)\n\t}\n\treturn json.NewEncoder(w).Encode(stats)\n}\n// extractHubVersion extracts the beszel version from SSH client version string.\n// Expected format: \"SSH-2.0-beszel_X.Y.Z\" or \"beszel_X.Y.Z\"\nfunc extractHubVersion(versionString string) (semver.Version, error) {\n\t_, after, _ := strings.Cut(versionString, \"_\")\n\treturn semver.Parse(after)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go", "rel_path": "agent/server.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 158, "end_line": 177, "text": "// ParseKeys parses a string containing SSH public keys in authorized_keys format.\n// It returns a slice of ssh.PublicKey and an error if any key fails to parse.\nfunc ParseKeys(input string) ([]gossh.PublicKey, error) {\n\tvar parsedKeys []gossh.PublicKey\n\tfor line := range strings.Lines(input) {\n\t\tline = strings.TrimSpace(line)\n\t\t// Skip empty lines or comments\n\t\tif len(line) == 0 || strings.HasPrefix(line, \"#\") {\n\t\t\tcontinue\n\t\t}\n\t\t// Parse the key\n\t\tparsedKey, _, _, _, err := gossh.ParseAuthorizedKey([]byte(line))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse key: %s, error: %w\", line, err)\n\t\t}\n\t\tparsedKeys = append(parsedKeys, parsedKey)\n\t}\n\treturn parsedKeys, nil\n}\n", "n_tokens": 186, "primary_symbol": "ParseKeys", "primary_kind": "function", "primary_span": [160, 177], "def_symbols": ["ParseKeys"], "symbols": ["ParseKeys", "parses", "string", "containing", "SSH", "public", "keys", "authorized_keys", "format", "returns", "slice", "ssh", "PublicKey", "and", "error", "any", "key", "fails", "parse", "func", "input", "gossh", "var", "parsedKeys", "for", "line", "range", "strings", "Lines", "TrimSpace", "Skip", "empty", "lines", "comments", "len", "HasPrefix", "continue", "Parse", "the", "parsedKey", "err", "ParseAuthorizedKey", "byte", "nil", "return", "fmt", "Errorf", "failed", "append"], "doc_head": "// ParseKeys parses a string containing SSH public keys in authorized_keys format.\n// It returns a slice of ssh.PublicKey and an error if any key fails to parse.\nfunc ParseKeys(input string) ([]gossh.PublicKey, error) {\n\tvar parsedKeys []gossh.PublicKey\n\tfor line := range strings.Lines(input) {\n\t\tline = strings.TrimSpace(line)\n\t\t// Skip empty lines or comments\n\t\tif len(line) == 0 || strings.HasPrefix(line, \"#\") {\n\t\t\tcontinue\n\t\t}\n\t\t// Parse the key\n\t\tparsedKey, _, _, _, err := gossh.ParseAuthorizedKey([]byte(line))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse key: %s, error: %w\", line, err)\n\t\t}\n\t\tparsedKeys = append(parsedKeys, parsedKey)\n\t}\n\treturn parsedKeys, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go", "rel_path": "agent/server.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 178, "end_line": 198, "text": "// GetAddress determines the network address to listen on from various sources.\n// It checks the provided address, then environment variables (LISTEN, PORT),\n// and finally defaults to \":45876\".\nfunc GetAddress(addr string) string {\n\tif addr == \"\" {\n\t\taddr, _ = GetEnv(\"LISTEN\")\n\t}\n\tif addr == \"\" {\n\t\t// Legacy PORT environment variable support\n\t\taddr, _ = GetEnv(\"PORT\")\n\t}\n\tif addr == \"\" {\n\t\treturn \":45876\"\n\t}\n\t// prefix with : if only port was provided\n\tif GetNetwork(addr) != \"unix\" && !strings.Contains(addr, \":\") {\n\t\taddr = \":\" + addr\n\t}\n\treturn addr\n}\n", "n_tokens": 146, "primary_symbol": "GetAddress", "primary_kind": "function", "primary_span": [181, 198], "def_symbols": ["GetAddress"], "symbols": ["GetAddress", "determines", "the", "network", "address", "listen", "from", "various", "sources", "checks", "provided", "then", "environment", "variables", "LISTEN", "PORT", "and", "finally", "defaults", "func", "addr", "string", "GetEnv", "Legacy", "variable", "support", "return", "prefix", "with", "only", "port", "was", "GetNetwork", "unix", "strings", "Contains"], "doc_head": "// GetAddress determines the network address to listen on from various sources.\n// It checks the provided address, then environment variables (LISTEN, PORT),\n// and finally defaults to \":45876\".\nfunc GetAddress(addr string) string {\n\tif addr == \"\" {\n\t\taddr, _ = GetEnv(\"LISTEN\")\n\t}\n\tif addr == \"\" {\n\t\t// Legacy PORT environment variable support\n\t\taddr, _ = GetEnv(\"PORT\")\n\t}\n\tif addr == \"\" {\n\t\treturn \":45876\"\n\t}\n\t// prefix with : if only port was provided\n\tif GetNetwork(addr) != \"unix\" && !strings.Contains(addr, \":\") {\n\t\taddr = \":\" + addr\n\t}\n\treturn addr\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server.go", "rel_path": "agent/server.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 199, "end_line": 225, "text": "// GetNetwork determines the network type based on the address format.\n// It checks the NETWORK environment variable first, then infers from\n// the address format: addresses starting with \"/\" are \"unix\", others are \"tcp\".\nfunc GetNetwork(addr string) string {\n\tif network, ok := GetEnv(\"NETWORK\"); ok && network != \"\" {\n\t\treturn network\n\t}\n\tif strings.HasPrefix(addr, \"/\") {\n\t\treturn \"unix\"\n\t}\n\treturn \"tcp\"\n}\n\n// StopServer stops the SSH server if it's running.\n// It returns an error if the server is not running or if there's an error stopping it.\nfunc (a *Agent) StopServer() error {\n\tif a.server == nil {\n\t\treturn errors.New(\"SSH server not running\")\n\t}\n\n\tslog.Info(\"Stopping SSH server\")\n\t_ = a.server.Close()\n\ta.server = nil\n\ta.connectionManager.eventChan <- SSHDisconnect\n\treturn nil\n}\n", "n_tokens": 189, "primary_symbol": "GetNetwork", "primary_kind": "function", "primary_span": [202, 225], "def_symbols": ["GetNetwork", "StopServer"], "symbols": ["GetNetwork", "StopServer", "determines", "the", "network", "type", "based", "address", "format", "checks", "NETWORK", "environment", "variable", "first", "then", "infers", "from", "addresses", "starting", "with", "are", "unix", "others", "tcp", "func", "addr", "string", "GetEnv", "return", "strings", "HasPrefix", "stops", "SSH", "server", "running", "returns", "error", "not", "there", "stopping", "Agent", "nil", "errors", "New", "slog", "Info", "Stopping", "Close", "connectionManager", "eventChan", "SSHDisconnect"], "doc_head": "// GetNetwork determines the network type based on the address format.\n// It checks the NETWORK environment variable first, then infers from\n// the address format: addresses starting with \"/\" are \"unix\", others are \"tcp\".\nfunc GetNetwork(addr string) string {\n\tif network, ok := GetEnv(\"NETWORK\"); ok && network != \"\" {\n\t\treturn network\n\t}\n\tif strings.HasPrefix(addr, \"/\") {\n\t\treturn \"unix\"\n\t}\n\treturn \"tcp\"\n}\n// StopServer stops the SSH server if it's running.\n// It returns an error if the server is not running or if there's an error stopping it.\nfunc (a *Agent) StopServer() error {\n\tif a.server == nil {\n\t\treturn errors.New(\"SSH server not running\")\n\t}\n\tslog.Info(\"Stopping SSH server\")\n\t_ = a.server.Close()\n\ta.server = nil\n\ta.connectionManager.eventChan <- SSHDisconnect\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_cache_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_cache_test.go", "rel_path": "agent/agent_cache_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 16, "text": "//go:build testing\n// +build testing\n\npackage agent\n\nimport (\n\t\"testing\"\n\t\"testing/synctest\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n", "n_tokens": 58, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 16], "def_symbols": [], "symbols": ["build", "testing", "package", "agent", "import", "synctest", "time", "github", "com", "henrygd", "beszel", "src", "entities", "system", "stretchr", "testify", "assert", "require"], "doc_head": "//go:build testing\n// +build testing\npackage agent\nimport (\n\t\"testing\"\n\t\"testing/synctest\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_cache_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_cache_test.go", "rel_path": "agent/agent_cache_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 17, "end_line": 76, "text": "func TestSessionCache_GetSet(t *testing.T) {\n\tsynctest.Test(t, func(t *testing.T) {\n\t\tcache := NewSessionCache(69 * time.Second)\n\n\t\ttestData := &system.CombinedData{\n\t\t\tInfo: system.Info{\n\t\t\t\tHostname: \"test-host\",\n\t\t\t\tCores:    4,\n\t\t\t},\n\t\t\tStats: system.Stats{\n\t\t\t\tCpu:     50.0,\n\t\t\t\tMemPct:  30.0,\n\t\t\t\tDiskPct: 40.0,\n\t\t\t},\n\t\t}\n\n\t\t// Test initial state - should not be cached\n\t\tdata, isCached := cache.Get(\"session1\")\n\t\tassert.False(t, isCached, \"Expected no cached data initially\")\n\t\tassert.NotNil(t, data, \"Expected data to be initialized\")\n\t\t// Set data for session1\n\t\tcache.Set(\"session1\", testData)\n\n\t\ttime.Sleep(15 * time.Second)\n\n\t\t// Get data for a different session - should be cached\n\t\tdata, isCached = cache.Get(\"session2\")\n\t\tassert.True(t, isCached, \"Expected data to be cached for non-primary session\")\n\t\trequire.NotNil(t, data, \"Expected cached data to be returned\")\n\t\tassert.Equal(t, \"test-host\", data.Info.Hostname, \"Hostname should match test data\")\n\t\tassert.Equal(t, 4, data.Info.Cores, \"Cores should match test data\")\n\t\tassert.Equal(t, 50.0, data.Stats.Cpu, \"CPU should match test data\")\n\t\tassert.Equal(t, 30.0, data.Stats.MemPct, \"Memory percentage should match test data\")\n\t\tassert.Equal(t, 40.0, data.Stats.DiskPct, \"Disk percentage should match test data\")\n\n\t\ttime.Sleep(10 * time.Second)\n\n\t\t// Get data for the primary session - should not be cached\n\t\tdata, isCached = cache.Get(\"session1\")\n\t\tassert.False(t, isCached, \"Expected data not to be cached for primary session\")\n\t\trequire.NotNil(t, data, \"Expected data to be returned even if not cached\")\n\t\tassert.Equal(t, \"test-host\", data.Info.Hostname, \"Hostname should match test data\")\n\t\t// if not cached, agent will update the data\n\t\tcache.Set(\"session1\", testData)\n\n\t\ttime.Sleep(45 * time.Second)\n\n\t\t// Get data for a different session - should still be cached\n\t\t_, isCached = cache.Get(\"session2\")\n\t\tassert.True(t, isCached, \"Expected data to be cached for non-primary session\")\n\n\t\t// Wait for the lease to expire\n\t\ttime.Sleep(30 * time.Second)\n\n\t\t// Get data for session2 - should not be cached\n\t\t_, isCached = cache.Get(\"session2\")\n\t\tassert.False(t, isCached, \"Expected data not to be cached after lease expiration\")\n\t})\n}\n", "n_tokens": 616, "primary_symbol": "TestSessionCache_GetSet", "primary_kind": "function", "primary_span": [17, 76], "def_symbols": ["TestSessionCache_GetSet"], "symbols": ["TestSessionCache_GetSet", "func", "testing", "synctest", "Test", "cache", "NewSessionCache", "time", "Second", "testData", "system", "CombinedData", "Info", "Hostname", "test", "host", "Cores", "Stats", "Cpu", "MemPct", "DiskPct", "initial", "state", "should", "not", "cached", "data", "isCached", "Get", "session1", "assert", "False", "Expected", "initially", "NotNil", "initialized", "Set", "for", "Sleep", "different", "session", "session2", "True", "non", "primary", "require", "returned", "Equal", "match", "CPU", "Memory", "percentage", "Disk", "the", "even", "agent", "will", "update", "still", "Wait", "lease", "expire", "after", "expiration"], "doc_head": "func TestSessionCache_GetSet(t *testing.T) {\n\tsynctest.Test(t, func(t *testing.T) {\n\t\tcache := NewSessionCache(69 * time.Second)\n\t\ttestData := &system.CombinedData{\n\t\t\tInfo: system.Info{\n\t\t\t\tHostname: \"test-host\",\n\t\t\t\tCores:    4,\n\t\t\t},\n\t\t\tStats: system.Stats{\n\t\t\t\tCpu:     50.0,\n\t\t\t\tMemPct:  30.0,\n\t\t\t\tDiskPct: 40.0,\n\t\t\t},\n\t\t}\n\t\t// Test initial state - should not be cached\n\t\tdata, isCached := cache.Get(\"session1\")\n\t\tassert.False(t, isCached, \"Expected no cached data initially\")\n\t\tassert.NotNil(t, data, \"Expected data to be initialized\")\n\t\t// Set data for session1\n\t\tcache.Set(\"session1\", testData)\n\t\ttime.Sleep(15 * time.Second)\n\t\t// Get data for a different session - should be cached\n\t\tdata, isCached = cache.Get(\"session2\")\n\t\tassert.True(t, isCached, \"Expected data to be cached for non-primary session\")\n\t\trequire.NotNil(t, data, \"Expected cached data to be returned\")\n\t\tassert.Equal(t, \"test-host\", data.Info.Hostname, \"Hostname should match test data\")\n\t\tassert.Equal(t, 4, data.Info.Cores, \"Cores should match test data\")\n\t\tassert.Equal(t, 50.0, data.Stats.Cpu, \"CPU should match test data\")\n\t\tassert.Equal(t, 30.0, data.Stats.MemPct, \"Memory percentage should match test data\")\n\t\tassert."}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_cache_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_cache_test.go", "rel_path": "agent/agent_cache_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 77, "end_line": 90, "text": "func TestSessionCache_NilData(t *testing.T) {\n\t// Create a new SessionCache\n\tcache := NewSessionCache(30 * time.Second)\n\n\t// Test setting nil data (should not panic)\n\tassert.NotPanics(t, func() {\n\t\tcache.Set(\"session1\", nil)\n\t}, \"Setting nil data should not panic\")\n\n\t// Get data - should not be nil even though we set nil\n\tdata, _ := cache.Get(\"session2\")\n\tassert.NotNil(t, data, \"Expected data to not be nil after setting nil data\")\n}\n", "n_tokens": 115, "primary_symbol": "TestSessionCache_NilData", "primary_kind": "function", "primary_span": [77, 90], "def_symbols": ["TestSessionCache_NilData"], "symbols": ["TestSessionCache_NilData", "func", "testing", "Create", "new", "SessionCache", "cache", "NewSessionCache", "time", "Second", "Test", "setting", "nil", "data", "should", "not", "panic", "assert", "NotPanics", "Set", "session1", "Setting", "Get", "even", "though", "set", "session2", "NotNil", "Expected", "after"], "doc_head": "func TestSessionCache_NilData(t *testing.T) {\n\t// Create a new SessionCache\n\tcache := NewSessionCache(30 * time.Second)\n\t// Test setting nil data (should not panic)\n\tassert.NotPanics(t, func() {\n\t\tcache.Set(\"session1\", nil)\n\t}, \"Setting nil data should not panic\")\n\t// Get data - should not be nil even though we set nil\n\tdata, _ := cache.Get(\"session2\")\n\tassert.NotNil(t, data, \"Expected data to not be nil after setting nil data\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/disk.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/disk.go", "rel_path": "agent/disk.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 15, "text": "package agent\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/shirou/gopsutil/v4/disk\"\n)\n", "n_tokens": 56, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 15], "def_symbols": [], "symbols": ["package", "agent", "import", "log", "slog", "path", "filepath", "runtime", "strings", "time", "github", "com", "henrygd", "beszel", "src", "entities", "system", "shirou", "gopsutil", "disk"], "doc_head": "package agent\nimport (\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/shirou/gopsutil/v4/disk\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/disk.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/disk.go", "rel_path": "agent/disk.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 16, "end_line": 153, "text": "// Sets up the filesystems to monitor for disk usage and I/O.\nfunc (a *Agent) initializeDiskInfo() {\n\tfilesystem, _ := GetEnv(\"FILESYSTEM\")\n\tefPath := \"/extra-filesystems\"\n\thasRoot := false\n\n\tpartitions, err := disk.Partitions(false)\n\tif err != nil {\n\t\tslog.Error(\"Error getting disk partitions\", \"err\", err)\n\t}\n\tslog.Debug(\"Disk\", \"partitions\", partitions)\n\n\t// ioContext := context.WithValue(a.sensorsContext,\n\t// \tcommon.EnvKey, common.EnvMap{common.HostProcEnvKey: \"/tmp/testproc\"},\n\t// )\n\t// diskIoCounters, err := disk.IOCountersWithContext(ioContext)\n\n\tdiskIoCounters, err := disk.IOCounters()\n\tif err != nil {\n\t\tslog.Error(\"Error getting diskstats\", \"err\", err)\n\t}\n\tslog.Debug(\"Disk I/O\", \"diskstats\", diskIoCounters)\n\n\t// Helper function to add a filesystem to fsStats if it doesn't exist\n\taddFsStat := func(device, mountpoint string, root bool) {\n\t\tvar key string\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\tkey = device\n\t\t} else {\n\t\t\tkey = filepath.Base(device)\n\t\t}\n\t\tvar ioMatch bool\n\t\tif _, exists := a.fsStats[key]; !exists {\n\t\t\tif root {\n\t\t\t\tslog.Info(\"Detected root device\", \"name\", key)\n\t\t\t\t// Check if root device is in /proc/diskstats, use fallback if not\n\t\t\t\tif _, ioMatch = diskIoCounters[key]; !ioMatch {\n\t\t\t\t\tkey, ioMatch = findIoDevice(filesystem, diskIoCounters, a.fsStats)\n\t\t\t\t\tif !ioMatch {\n\t\t\t\t\t\tslog.Info(\"Using I/O fallback\", \"device\", device, \"mountpoint\", mountpoint, \"fallback\", key)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Check if non-root has diskstats and fall back to folder name if not\n\t\t\t\t// Scenario: device is encrypted and named luks-2bcb02be-999d-4417-8d18-5c61e660fb6e - not in /proc/diskstats.\n\t\t\t\t// However, the device can be specified by mounting folder from luks device at /extra-filesystems/sda1\n\t\t\t\tif _, ioMatch = diskIoCounters[key]; !ioMatch {\n\t\t\t\t\tefBase := filepath.Base(mountpoint)\n\t\t\t\t\tif _, ioMatch = diskIoCounters[efBase]; ioMatch {\n\t\t\t\t\t\tkey = efBase\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.fsStats[key] = &system.FsStats{Root: root, Mountpoint: mountpoint}\n\t\t}\n\t}\n\n\t// Use FILESYSTEM env var to find root filesystem\n\tif filesystem != \"\" {\n\t\tfor _, p := range partitions {\n\t\t\tif strings.HasSuffix(p.Device, filesystem) || p.Mountpoint == filesystem {\n\t\t\t\taddFsStat(p.Device, p.Mountpoint, true)\n\t\t\t\thasRoot = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !hasRoot {\n\t\t\tslog.Warn(\"Partition details not found\", \"filesystem\", filesystem)\n\t\t}\n\t}\n\n\t// Add EXTRA_FILESYSTEMS env var values to fsStats\n\tif extraFilesystems, exists := GetEnv(\"EXTRA_FILESYSTEMS\"); exists {\n\t\tfor _, fs := range strings.Split(extraFilesystems, \",\") {\n\t\t\tfound := false\n\t\t\tfor _, p := range partitions {\n\t\t\t\tif strings.HasSuffix(p.Device, fs) || p.Mountpoint == fs {\n\t\t\t\t\taddFsStat(p.Device, p.Mountpoint, false)\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if not in partitions, test if we can get disk usage\n\t\t\tif !found {\n\t\t\t\tif _, err := disk.Usage(fs); err == nil {\n\t\t\t\t\taddFsStat(filepath.Base(fs), fs, false)\n\t\t\t\t} else {\n\t\t\t\t\tslog.Error(\"Invalid filesystem\", \"name\", fs, \"err\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Process partitions for various mount points\n\tfor _, p := range partitions {\n\t\t// fmt.Println(p.Device, p.Mountpoint)\n\t\t// Binary root fallback or docker root fallback\n\t\tif !hasRoot && (p.Mountpoint == \"/\" || (p.Mountpoint == \"/etc/hosts\" && strings.HasPrefix(p.Device, \"/dev\"))) {\n\t\t\tfs, match := findIoDevice(filepath.Base(p.Device), diskIoCounters, a.fsStats)\n\t\t\tif match {\n\t\t\t\taddFsStat(fs, p.Mountpoint, true)\n\t\t\t\thasRoot = true\n\t\t\t}\n\t\t}\n\n\t\t// Check if device is in /extra-filesystems\n\t\tif strings.HasPrefix(p.Mountpoint, efPath) {\n\t\t\taddFsStat(p.Device, p.Mountpoint, false)\n\t\t}\n\t}\n\n\t// Check all folders in /extra-filesystems and add them if not already present\n\tif folders, err := os.ReadDir(efPath); err == nil {\n\t\texistingMountpoints := make(map[string]bool)\n\t\tfor _, stats := range a.fsStats {\n\t\t\texistingMountpoints[stats.Mountpoint] = true\n\t\t}\n\t\tfor _, folder := range folders {\n\t\t\tif folder.IsDir() {\n\t\t\t\tmountpoint := filepath.Join(efPath, folder.Name())\n\t\t\t\tslog.Debug(\"/extra-filesystems\", \"mountpoint\", mountpoint)\n\t\t\t\tif !existingMountpoints[mountpoint] {\n\t\t\t\t\taddFsStat(folder.Name(), mountpoint, false)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no root filesystem set, use fallback\n\tif !hasRoot {\n\t\trootDevice, _ := findIoDevice(filepath.Base(filesystem), diskIoCounters, a.fsStats)\n\t\tslog.Info(\"Root disk\", \"mountpoint\", \"/\", \"io\", rootDevice)\n\t\ta.fsStats[rootDevice] = &system.FsStats{Root: true, Mountpoint: \"/\"}\n\t}\n\n\ta.initializeDiskIoStats(diskIoCounters)\n}\n", "n_tokens": 1292, "primary_symbol": "initializeDiskInfo", "primary_kind": "function", "primary_span": [17, 153], "def_symbols": ["initializeDiskInfo"], "symbols": ["initializeDiskInfo", "Sets", "the", "filesystems", "monitor", "for", "disk", "usage", "and", "func", "Agent", "filesystem", "GetEnv", "FILESYSTEM", "efPath", "extra", "hasRoot", "false", "partitions", "err", "Partitions", "nil", "slog", "Error", "getting", "Debug", "Disk", "ioContext", "context", "WithValue", "sensorsContext", "common", "EnvKey", "EnvMap", "HostProcEnvKey", "tmp", "testproc", "diskIoCounters", "IOCountersWithContext", "IOCounters", "diskstats", "Helper", "function", "add", "fsStats", "doesn", "exist", "addFsStat", "device", "mountpoint", "string", "root", "bool", "var", "key", "runtime", "GOOS", "windows", "else", "filepath", "Base", "ioMatch", "exists", "Info", "Detected", "name", "Check", "proc", "use", "fallback", "not", "findIoDevice", "Using", "non", "has", "fall", "back", "folder", "Scenario", "encrypted", "named", "luks", "However", "can", "specified", "mounting", "from", "sda1", "efBase", "system", "FsStats", "Root", "Mountpoint", "Use", "env", "find", "range", "strings", "HasSuffix", "Device", "true", "break", "Warn", "Partition", "details", "found", "Add", "EXTRA_FILESYSTEMS", "values", "extraFilesystems", "Split", "test", "get", "Usage", "Invalid", "Process", "various", "mount", "points", "fmt", "Println", "Binary", "docker", "etc", "hosts", "HasPrefix", "dev", "match", "all", "folders", "them", "already", "present", "ReadDir", "existingMountpoints", "make", "map", "stats", "IsDir", "Join", "Name", "set", "rootDevice", "initializeDiskIoStats"], "doc_head": "// Sets up the filesystems to monitor for disk usage and I/O.\nfunc (a *Agent) initializeDiskInfo() {\n\tfilesystem, _ := GetEnv(\"FILESYSTEM\")\n\tefPath := \"/extra-filesystems\"\n\thasRoot := false\n\tpartitions, err := disk.Partitions(false)\n\tif err != nil {\n\t\tslog.Error(\"Error getting disk partitions\", \"err\", err)\n\t}\n\tslog.Debug(\"Disk\", \"partitions\", partitions)\n\t// ioContext := context.WithValue(a.sensorsContext,\n\t// \tcommon.EnvKey, common.EnvMap{common.HostProcEnvKey: \"/tmp/testproc\"},\n\t// )\n\t// diskIoCounters, err := disk.IOCountersWithContext(ioContext)\n\tdiskIoCounters, err := disk.IOCounters()\n\tif err != nil {\n\t\tslog.Error(\"Error getting diskstats\", \"err\", err)\n\t}\n\tslog.Debug(\"Disk I/O\", \"diskstats\", diskIoCounters)\n\t// Helper function to add a filesystem to fsStats if it doesn't exist\n\taddFsStat := func(device, mountpoint string, root bool) {\n\t\tvar key string\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\tkey = device\n\t\t} else {\n\t\t\tkey = filepath.Base(device)\n\t\t}\n\t\tvar ioMatch bool\n\t\tif _, exists := a.fsStats[key]; !exists {\n\t\t\tif root {\n\t\t\t\tslog.Info(\"Detected root device\", \"name\", key)\n\t\t\t\t// Check if root device is in /proc/diskstats, use fallback if not\n\t\t\t\tif _, ioMatch = diskIoCounters[ke"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/disk.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/disk.go", "rel_path": "agent/disk.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 154, "end_line": 174, "text": "// Returns matching device from /proc/diskstats,\n// or the device with the most reads if no match is found.\n// bool is true if a match was found.\nfunc findIoDevice(filesystem string, diskIoCounters map[string]disk.IOCountersStat, fsStats map[string]*system.FsStats) (string, bool) {\n\tvar maxReadBytes uint64\n\tmaxReadDevice := \"/\"\n\tfor _, d := range diskIoCounters {\n\t\tif d.Name == filesystem || (d.Label != \"\" && d.Label == filesystem) {\n\t\t\treturn d.Name, true\n\t\t}\n\t\tif d.ReadBytes > maxReadBytes {\n\t\t\t// don't use if device already exists in fsStats\n\t\t\tif _, exists := fsStats[d.Name]; !exists {\n\t\t\t\tmaxReadBytes = d.ReadBytes\n\t\t\t\tmaxReadDevice = d.Name\n\t\t\t}\n\t\t}\n\t}\n\treturn maxReadDevice, false\n}\n", "n_tokens": 193, "primary_symbol": "findIoDevice", "primary_kind": "function", "primary_span": [157, 174], "def_symbols": ["findIoDevice"], "symbols": ["findIoDevice", "Returns", "matching", "device", "from", "proc", "diskstats", "the", "with", "most", "reads", "match", "found", "bool", "true", "was", "func", "filesystem", "string", "diskIoCounters", "map", "disk", "IOCountersStat", "fsStats", "system", "FsStats", "var", "maxReadBytes", "uint64", "maxReadDevice", "for", "range", "Name", "Label", "return", "ReadBytes", "don", "use", "already", "exists", "false"], "doc_head": "// Returns matching device from /proc/diskstats,\n// or the device with the most reads if no match is found.\n// bool is true if a match was found.\nfunc findIoDevice(filesystem string, diskIoCounters map[string]disk.IOCountersStat, fsStats map[string]*system.FsStats) (string, bool) {\n\tvar maxReadBytes uint64\n\tmaxReadDevice := \"/\"\n\tfor _, d := range diskIoCounters {\n\t\tif d.Name == filesystem || (d.Label != \"\" && d.Label == filesystem) {\n\t\t\treturn d.Name, true\n\t\t}\n\t\tif d.ReadBytes > maxReadBytes {\n\t\t\t// don't use if device already exists in fsStats\n\t\t\tif _, exists := fsStats[d.Name]; !exists {\n\t\t\t\tmaxReadBytes = d.ReadBytes\n\t\t\t\tmaxReadDevice = d.Name\n\t\t\t}\n\t\t}\n\t}\n\treturn maxReadDevice, false\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/disk.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/disk.go", "rel_path": "agent/disk.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 175, "end_line": 192, "text": "// Sets start values for disk I/O stats.\nfunc (a *Agent) initializeDiskIoStats(diskIoCounters map[string]disk.IOCountersStat) {\n\tfor device, stats := range a.fsStats {\n\t\t// skip if not in diskIoCounters\n\t\td, exists := diskIoCounters[device]\n\t\tif !exists {\n\t\t\tslog.Warn(\"Device not found in diskstats\", \"name\", device)\n\t\t\tcontinue\n\t\t}\n\t\t// populate initial values\n\t\tstats.Time = time.Now()\n\t\tstats.TotalRead = d.ReadBytes\n\t\tstats.TotalWrite = d.WriteBytes\n\t\t// add to list of valid io device names\n\t\ta.fsNames = append(a.fsNames, device)\n\t}\n}\n", "n_tokens": 156, "primary_symbol": "initializeDiskIoStats", "primary_kind": "function", "primary_span": [176, 192], "def_symbols": ["initializeDiskIoStats"], "symbols": ["initializeDiskIoStats", "Sets", "start", "values", "for", "disk", "stats", "func", "Agent", "diskIoCounters", "map", "string", "IOCountersStat", "device", "range", "fsStats", "skip", "not", "exists", "slog", "Warn", "Device", "found", "diskstats", "name", "continue", "populate", "initial", "Time", "time", "Now", "TotalRead", "ReadBytes", "TotalWrite", "WriteBytes", "add", "list", "valid", "names", "fsNames", "append"], "doc_head": "// Sets start values for disk I/O stats.\nfunc (a *Agent) initializeDiskIoStats(diskIoCounters map[string]disk.IOCountersStat) {\n\tfor device, stats := range a.fsStats {\n\t\t// skip if not in diskIoCounters\n\t\td, exists := diskIoCounters[device]\n\t\tif !exists {\n\t\t\tslog.Warn(\"Device not found in diskstats\", \"name\", device)\n\t\t\tcontinue\n\t\t}\n\t\t// populate initial values\n\t\tstats.Time = time.Now()\n\t\tstats.TotalRead = d.ReadBytes\n\t\tstats.TotalWrite = d.WriteBytes\n\t\t// add to list of valid io device names\n\t\ta.fsNames = append(a.fsNames, device)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go", "rel_path": "agent/update.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 31, "text": "package agent\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/henrygd/beszel/src/ghupdate\"\n)\n\n// restarter knows how to restart the beszel-agent service.\ntype restarter interface {\n\tRestart() error\n}\n\ntype systemdRestarter struct{ cmd string }\n\nfunc (s *systemdRestarter) Restart() error {\n\t// Only restart if the service is active\n\tif err := exec.Command(s.cmd, \"is-active\", \"beszel-agent.service\").Run(); err != nil {\n\t\treturn nil\n\t}\n\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel-agent.service via systemd\")\n\treturn exec.Command(s.cmd, \"restart\", \"beszel-agent.service\").Run()\n}\n\ntype openRCRestarter struct{ cmd string }\n", "n_tokens": 178, "primary_symbol": "Restart", "primary_kind": "function", "primary_span": [21, 31], "def_symbols": ["Restart"], "symbols": ["Restart", "package", "agent", "import", "fmt", "log", "exec", "runtime", "strings", "github", "com", "henrygd", "beszel", "src", "ghupdate", "restarter", "knows", "how", "restart", "the", "service", "type", "interface", "error", "systemdRestarter", "struct", "cmd", "string", "func", "Only", "active", "err", "Command", "Run", "nil", "return", "ColorPrint", "ColorYellow", "Restarting", "via", "systemd", "openRCRestarter"], "doc_head": "package agent\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"strings\"\n\t\"github.com/henrygd/beszel/src/ghupdate\"\n)\n// restarter knows how to restart the beszel-agent service.\ntype restarter interface {\n\tRestart() error\n}\ntype systemdRestarter struct{ cmd string }\nfunc (s *systemdRestarter) Restart() error {\n\t// Only restart if the service is active\n\tif err := exec.Command(s.cmd, \"is-active\", \"beszel-agent.service\").Run(); err != nil {\n\t\treturn nil\n\t}\n\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel-agent.service via systemd\")\n\treturn exec.Command(s.cmd, \"restart\", \"beszel-agent.service\").Run()\n}\ntype openRCRestarter struct{ cmd string }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go", "rel_path": "agent/update.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 32, "end_line": 51, "text": "func (o *openRCRestarter) Restart() error {\n\tif err := exec.Command(o.cmd, \"status\", \"beszel-agent\").Run(); err != nil {\n\t\treturn nil\n\t}\n\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel-agent via OpenRC\")\n\treturn exec.Command(o.cmd, \"restart\", \"beszel-agent\").Run()\n}\n\ntype openWRTRestarter struct{ cmd string }\n\nfunc (w *openWRTRestarter) Restart() error {\n\tif err := exec.Command(w.cmd, \"running\", \"beszel-agent\").Run(); err != nil {\n\t\treturn nil\n\t}\n\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel-agent via procd\")\n\treturn exec.Command(w.cmd, \"restart\", \"beszel-agent\").Run()\n}\n\ntype freeBSDRestarter struct{ cmd string }\n", "n_tokens": 182, "primary_symbol": "Restart", "primary_kind": "function", "primary_span": [32, 51], "def_symbols": ["Restart"], "symbols": ["Restart", "func", "openRCRestarter", "error", "err", "exec", "Command", "cmd", "status", "beszel", "agent", "Run", "nil", "return", "ghupdate", "ColorPrint", "ColorYellow", "Restarting", "via", "OpenRC", "restart", "type", "openWRTRestarter", "struct", "string", "running", "procd", "freeBSDRestarter"], "doc_head": "func (o *openRCRestarter) Restart() error {\n\tif err := exec.Command(o.cmd, \"status\", \"beszel-agent\").Run(); err != nil {\n\t\treturn nil\n\t}\n\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel-agent via OpenRC\")\n\treturn exec.Command(o.cmd, \"restart\", \"beszel-agent\").Run()\n}\ntype openWRTRestarter struct{ cmd string }\nfunc (w *openWRTRestarter) Restart() error {\n\tif err := exec.Command(w.cmd, \"running\", \"beszel-agent\").Run(); err != nil {\n\t\treturn nil\n\t}\n\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel-agent via procd\")\n\treturn exec.Command(w.cmd, \"restart\", \"beszel-agent\").Run()\n}\ntype freeBSDRestarter struct{ cmd string }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go", "rel_path": "agent/update.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 52, "end_line": 59, "text": "func (f *freeBSDRestarter) Restart() error {\n\tif err := exec.Command(f.cmd, \"beszel-agent\", \"status\").Run(); err != nil {\n\t\treturn nil\n\t}\n\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel-agent via FreeBSD rc\")\n\treturn exec.Command(f.cmd, \"beszel-agent\", \"restart\").Run()\n}\n", "n_tokens": 80, "primary_symbol": "Restart", "primary_kind": "function", "primary_span": [52, 59], "def_symbols": ["Restart"], "symbols": ["Restart", "func", "freeBSDRestarter", "error", "err", "exec", "Command", "cmd", "beszel", "agent", "status", "Run", "nil", "return", "ghupdate", "ColorPrint", "ColorYellow", "Restarting", "via", "FreeBSD", "restart"], "doc_head": "func (f *freeBSDRestarter) Restart() error {\n\tif err := exec.Command(f.cmd, \"beszel-agent\", \"status\").Run(); err != nil {\n\t\treturn nil\n\t}\n\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel-agent via FreeBSD rc\")\n\treturn exec.Command(f.cmd, \"beszel-agent\", \"restart\").Run()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go", "rel_path": "agent/update.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 60, "end_line": 75, "text": "func detectRestarter() restarter {\n\tif path, err := exec.LookPath(\"systemctl\"); err == nil {\n\t\treturn &systemdRestarter{cmd: path}\n\t}\n\tif path, err := exec.LookPath(\"rc-service\"); err == nil {\n\t\treturn &openRCRestarter{cmd: path}\n\t}\n\tif path, err := exec.LookPath(\"service\"); err == nil {\n\t\tif runtime.GOOS == \"freebsd\" {\n\t\t\treturn &freeBSDRestarter{cmd: path}\n\t\t}\n\t\treturn &openWRTRestarter{cmd: path}\n\t}\n\treturn nil\n}\n", "n_tokens": 128, "primary_symbol": "detectRestarter", "primary_kind": "function", "primary_span": [60, 75], "def_symbols": ["detectRestarter"], "symbols": ["detectRestarter", "func", "restarter", "path", "err", "exec", "LookPath", "systemctl", "nil", "return", "systemdRestarter", "cmd", "service", "openRCRestarter", "runtime", "GOOS", "freebsd", "freeBSDRestarter", "openWRTRestarter"], "doc_head": "func detectRestarter() restarter {\n\tif path, err := exec.LookPath(\"systemctl\"); err == nil {\n\t\treturn &systemdRestarter{cmd: path}\n\t}\n\tif path, err := exec.LookPath(\"rc-service\"); err == nil {\n\t\treturn &openRCRestarter{cmd: path}\n\t}\n\tif path, err := exec.LookPath(\"service\"); err == nil {\n\t\tif runtime.GOOS == \"freebsd\" {\n\t\t\treturn &freeBSDRestarter{cmd: path}\n\t\t}\n\t\treturn &openWRTRestarter{cmd: path}\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go", "rel_path": "agent/update.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 76, "end_line": 127, "text": "// Update checks GitHub for a newer release of beszel-agent, applies it,\n// fixes SELinux context if needed, and restarts the service.\nfunc Update(useMirror bool) error {\n\texePath, _ := os.Executable()\n\n\tdataDir, err := getDataDir()\n\tif err != nil {\n\t\tdataDir = os.TempDir()\n\t}\n\tupdated, err := ghupdate.Update(ghupdate.Config{\n\t\tArchiveExecutable: \"beszel-agent\",\n\t\tDataDir:           dataDir,\n\t\tUseMirror:         useMirror,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif !updated {\n\t\treturn nil\n\t}\n\n\t// make sure the file is executable\n\tif err := os.Chmod(exePath, 0755); err != nil {\n\t\tghupdate.ColorPrintf(ghupdate.ColorYellow, \"Warning: failed to set executable permissions: %v\", err)\n\t}\n\t// set ownership to beszel:beszel if possible\n\tif chownPath, err := exec.LookPath(\"chown\"); err == nil {\n\t\tif err := exec.Command(chownPath, \"beszel:beszel\", exePath).Run(); err != nil {\n\t\t\tghupdate.ColorPrintf(ghupdate.ColorYellow, \"Warning: failed to set file ownership: %v\", err)\n\t\t}\n\t}\n\n\t// 6) Fix SELinux context if necessary\n\tif err := handleSELinuxContext(exePath); err != nil {\n\t\tghupdate.ColorPrintf(ghupdate.ColorYellow, \"Warning: SELinux context handling: %v\", err)\n\t}\n\n\t// 7) Restart service if running under a recognised init system\n\tif r := detectRestarter(); r != nil {\n\t\tif err := r.Restart(); err != nil {\n\t\t\tghupdate.ColorPrintf(ghupdate.ColorYellow, \"Warning: failed to restart service: %v\", err)\n\t\t\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Please restart the service manually.\")\n\t\t} else {\n\t\t\tghupdate.ColorPrint(ghupdate.ColorGreen, \"Service restarted successfully\")\n\t\t}\n\t} else {\n\t\tghupdate.ColorPrint(ghupdate.ColorYellow, \"No supported init system detected; please restart manually if needed.\")\n\t}\n\n\treturn nil\n}\n", "n_tokens": 473, "primary_symbol": "Update", "primary_kind": "function", "primary_span": [78, 127], "def_symbols": ["Update"], "symbols": ["Update", "checks", "GitHub", "for", "newer", "release", "beszel", "agent", "applies", "fixes", "SELinux", "context", "needed", "and", "restarts", "the", "service", "func", "useMirror", "bool", "error", "exePath", "Executable", "dataDir", "err", "getDataDir", "nil", "TempDir", "updated", "ghupdate", "Config", "ArchiveExecutable", "DataDir", "UseMirror", "log", "Fatal", "return", "make", "sure", "file", "executable", "Chmod", "ColorPrintf", "ColorYellow", "Warning", "failed", "set", "permissions", "ownership", "possible", "chownPath", "exec", "LookPath", "chown", "Command", "Run", "Fix", "necessary", "handleSELinuxContext", "handling", "Restart", "running", "under", "recognised", "init", "system", "detectRestarter", "restart", "ColorPrint", "Please", "manually", "else", "ColorGreen", "Service", "restarted", "successfully", "supported", "detected", "please"], "doc_head": "// Update checks GitHub for a newer release of beszel-agent, applies it,\n// fixes SELinux context if needed, and restarts the service.\nfunc Update(useMirror bool) error {\n\texePath, _ := os.Executable()\n\tdataDir, err := getDataDir()\n\tif err != nil {\n\t\tdataDir = os.TempDir()\n\t}\n\tupdated, err := ghupdate.Update(ghupdate.Config{\n\t\tArchiveExecutable: \"beszel-agent\",\n\t\tDataDir:           dataDir,\n\t\tUseMirror:         useMirror,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif !updated {\n\t\treturn nil\n\t}\n\t// make sure the file is executable\n\tif err := os.Chmod(exePath, 0755); err != nil {\n\t\tghupdate.ColorPrintf(ghupdate.ColorYellow, \"Warning: failed to set executable permissions: %v\", err)\n\t}\n\t// set ownership to beszel:beszel if possible\n\tif chownPath, err := exec.LookPath(\"chown\"); err == nil {\n\t\tif err := exec.Command(chownPath, \"beszel:beszel\", exePath).Run(); err != nil {\n\t\t\tghupdate.ColorPrintf(ghupdate.ColorYellow, \"Warning: failed to set file ownership: %v\", err)\n\t\t}\n\t}\n\t// 6) Fix SELinux context if necessary\n\tif err := handleSELinuxContext(exePath); err != nil {\n\t\tghupdate.ColorPrintf(ghupdate.ColorYellow, \"Warning: SELinux context handling: %v\", err)\n\t}\n\t// 7) Restart service if runn"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/update.go", "rel_path": "agent/update.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 128, "end_line": 166, "text": "// handleSELinuxContext restores or applies the correct SELinux label to the binary.\nfunc handleSELinuxContext(path string) error {\n\tout, err := exec.Command(\"getenforce\").Output()\n\tif err != nil {\n\t\t// SELinux not enabled or getenforce not available\n\t\treturn nil\n\t}\n\tstate := strings.TrimSpace(string(out))\n\tif state == \"Disabled\" {\n\t\treturn nil\n\t}\n\n\tghupdate.ColorPrint(ghupdate.ColorYellow, \"SELinux is enabled; applying context\")\n\tvar errs []string\n\n\t// Try persistent context via semanage+restorecon\n\tif semanagePath, err := exec.LookPath(\"semanage\"); err == nil {\n\t\tif err := exec.Command(semanagePath, \"fcontext\", \"-a\", \"-t\", \"bin_t\", path).Run(); err != nil {\n\t\t\terrs = append(errs, \"semanage fcontext failed: \"+err.Error())\n\t\t} else if restoreconPath, err := exec.LookPath(\"restorecon\"); err == nil {\n\t\t\tif err := exec.Command(restoreconPath, \"-v\", path).Run(); err != nil {\n\t\t\t\terrs = append(errs, \"restorecon failed: \"+err.Error())\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to temporary context via chcon\n\tif chconPath, err := exec.LookPath(\"chcon\"); err == nil {\n\t\tif err := exec.Command(chconPath, \"-t\", \"bin_t\", path).Run(); err != nil {\n\t\t\terrs = append(errs, \"chcon failed: \"+err.Error())\n\t\t}\n\t}\n\n\tif len(errs) > 0 {\n\t\treturn fmt.Errorf(\"SELinux context errors: %s\", strings.Join(errs, \"; \"))\n\t}\n\treturn nil\n}\n", "n_tokens": 374, "primary_symbol": "handleSELinuxContext", "primary_kind": "function", "primary_span": [129, 166], "def_symbols": ["handleSELinuxContext"], "symbols": ["handleSELinuxContext", "restores", "applies", "the", "correct", "SELinux", "label", "binary", "func", "path", "string", "error", "out", "err", "exec", "Command", "getenforce", "Output", "nil", "not", "enabled", "available", "return", "state", "strings", "TrimSpace", "Disabled", "ghupdate", "ColorPrint", "ColorYellow", "applying", "context", "var", "errs", "Try", "persistent", "via", "semanage", "restorecon", "semanagePath", "LookPath", "fcontext", "bin_t", "Run", "append", "failed", "Error", "else", "restoreconPath", "Fallback", "temporary", "chcon", "chconPath", "len", "fmt", "Errorf", "errors", "Join"], "doc_head": "// handleSELinuxContext restores or applies the correct SELinux label to the binary.\nfunc handleSELinuxContext(path string) error {\n\tout, err := exec.Command(\"getenforce\").Output()\n\tif err != nil {\n\t\t// SELinux not enabled or getenforce not available\n\t\treturn nil\n\t}\n\tstate := strings.TrimSpace(string(out))\n\tif state == \"Disabled\" {\n\t\treturn nil\n\t}\n\tghupdate.ColorPrint(ghupdate.ColorYellow, \"SELinux is enabled; applying context\")\n\tvar errs []string\n\t// Try persistent context via semanage+restorecon\n\tif semanagePath, err := exec.LookPath(\"semanage\"); err == nil {\n\t\tif err := exec.Command(semanagePath, \"fcontext\", \"-a\", \"-t\", \"bin_t\", path).Run(); err != nil {\n\t\t\terrs = append(errs, \"semanage fcontext failed: \"+err.Error())\n\t\t} else if restoreconPath, err := exec.LookPath(\"restorecon\"); err == nil {\n\t\t\tif err := exec.Command(restoreconPath, \"-v\", path).Run(); err != nil {\n\t\t\t\terrs = append(errs, \"restorecon failed: \"+err.Error())\n\t\t\t}\n\t\t}\n\t}\n\t// Fallback to temporary context via chcon\n\tif chconPath, err := exec.LookPath(\"chcon\"); err == nil {\n\t\tif err := exec.Command(chconPath, \"-t\", \"bin_t\", path).Run(); err != nil {\n\t\t\terrs = append(errs, \"chcon failed: \"+err.Error())\n\t\t}\n\t}\n\tif le"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "package agent\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/entities/container\"\n\n\t\"github.com/blang/semver\"\n)\n\ntype dockerManager struct {", "n_tokens": 75, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 22], "def_symbols": [], "symbols": ["package", "agent", "import", "bytes", "context", "encoding", "json", "fmt", "log", "slog", "net", "http", "url", "strings", "sync", "time", "github", "com", "henrygd", "beszel", "src", "entities", "container", "blang", "semver", "type", "dockerManager", "struct"], "doc_head": "package agent\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/entities/container\"\n\t\"github.com/blang/semver\"\n)\ntype dockerManager struct {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 23, "end_line": 36, "text": "\tclient              *http.Client                // Client to query Docker API\n\twg                  sync.WaitGroup              // WaitGroup to wait for all goroutines to finish\n\tsem                 chan struct{}               // Semaphore to limit concurrent container requests\n\tcontainerStatsMutex sync.RWMutex                // Mutex to prevent concurrent access to containerStatsMap\n\tapiContainerList    []*container.ApiInfo        // List of containers from Docker API (no pointer)\n\tcontainerStatsMap   map[string]*container.Stats // Keeps track of container stats\n\tvalidIds            map[string]struct{}         // Map of valid container ids, used to prune invalid containers from containerStatsMap\n\tgoodDockerVersion   bool                        // Whether docker version is at least 25.0.0 (one-shot works correctly)\n\tisWindows           bool                        // Whether the Docker Engine API is running on Windows\n\tbuf                 *bytes.Buffer               // Buffer to store and read response bodies\n\tdecoder             *json.Decoder               // Reusable JSON decoder that reads from buf\n\tapiStats            *container.ApiStats         // Reusable API stats object\n}\n", "n_tokens": 219, "primary_symbol": "", "primary_kind": "", "primary_span": [23, 36], "def_symbols": [], "symbols": ["client", "http", "Client", "query", "Docker", "API", "sync", "WaitGroup", "wait", "for", "all", "goroutines", "finish", "sem", "chan", "struct", "Semaphore", "limit", "concurrent", "container", "requests", "containerStatsMutex", "RWMutex", "Mutex", "prevent", "access", "containerStatsMap", "apiContainerList", "ApiInfo", "List", "containers", "from", "pointer", "map", "string", "Stats", "Keeps", "track", "stats", "validIds", "Map", "valid", "ids", "used", "prune", "invalid", "goodDockerVersion", "bool", "Whether", "docker", "version", "least", "one", "shot", "works", "correctly", "isWindows", "the", "Engine", "running", "Windows", "buf", "bytes", "Buffer", "store", "and", "read", "response", "bodies", "decoder", "json", "Decoder", "Reusable", "JSON", "that", "reads", "apiStats", "ApiStats", "object"], "doc_head": "\tclient              *http.Client                // Client to query Docker API\n\twg                  sync.WaitGroup              // WaitGroup to wait for all goroutines to finish\n\tsem                 chan struct{}               // Semaphore to limit concurrent container requests\n\tcontainerStatsMutex sync.RWMutex                // Mutex to prevent concurrent access to containerStatsMap\n\tapiContainerList    []*container.ApiInfo        // List of containers from Docker API (no pointer)\n\tcontainerStatsMap   map[string]*container.Stats // Keeps track of container stats\n\tvalidIds            map[string]struct{}         // Map of valid container ids, used to prune invalid containers from containerStatsMap\n\tgoodDockerVersion   bool                        // Whether docker version is at least 25.0.0 (one-shot works correctly)\n\tisWindows           bool                        // Whether the Docker Engine API is running on Windows\n\tbuf                 *bytes.Buffer               // Buffer to store and read response bodies\n\tdecoder             *json.Decoder               // Reusable JSON decoder that reads from buf\n\tapiStats            *container.ApiStats         // Reusable API stats object\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 37, "end_line": 64, "text": "// userAgentRoundTripper is a custom http.RoundTripper that adds a User-Agent header to all requests\ntype userAgentRoundTripper struct {\n\trt        http.RoundTripper\n\tuserAgent string\n}\n\n// RoundTrip implements the http.RoundTripper interface\nfunc (u *userAgentRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n\treq.Header.Set(\"User-Agent\", u.userAgent)\n\treturn u.rt.RoundTrip(req)\n}\n\n// Add goroutine to the queue\nfunc (d *dockerManager) queue() {\n\td.wg.Add(1)\n\tif d.goodDockerVersion {\n\t\td.sem <- struct{}{}\n\t}\n}\n\n// Remove goroutine from the queue\nfunc (d *dockerManager) dequeue() {\n\td.wg.Done()\n\tif d.goodDockerVersion {\n\t\t<-d.sem\n\t}\n}\n", "n_tokens": 175, "primary_symbol": "RoundTrip", "primary_kind": "function", "primary_span": [44, 64], "def_symbols": ["RoundTrip", "queue", "dequeue"], "symbols": ["RoundTrip", "queue", "dequeue", "userAgentRoundTripper", "custom", "http", "RoundTripper", "that", "adds", "User", "Agent", "header", "all", "requests", "type", "struct", "userAgent", "string", "implements", "the", "interface", "func", "req", "Request", "Response", "error", "Header", "Set", "return", "Add", "goroutine", "dockerManager", "goodDockerVersion", "sem", "Remove", "from", "Done"], "doc_head": "// userAgentRoundTripper is a custom http.RoundTripper that adds a User-Agent header to all requests\ntype userAgentRoundTripper struct {\n\trt        http.RoundTripper\n\tuserAgent string\n}\n// RoundTrip implements the http.RoundTripper interface\nfunc (u *userAgentRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n\treq.Header.Set(\"User-Agent\", u.userAgent)\n\treturn u.rt.RoundTrip(req)\n}\n// Add goroutine to the queue\nfunc (d *dockerManager) queue() {\n\td.wg.Add(1)\n\tif d.goodDockerVersion {\n\t\td.sem <- struct{}{}\n\t}\n}\n// Remove goroutine from the queue\nfunc (d *dockerManager) dequeue() {\n\td.wg.Done()\n\tif d.goodDockerVersion {\n\t\t<-d.sem\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 65, "end_line": 82, "text": "// Returns stats for all running containers\nfunc (dm *dockerManager) getDockerStats() ([]*container.Stats, error) {\n\tresp, err := dm.client.Get(\"http://localhost/containers/json\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdm.apiContainerList = dm.apiContainerList[:0]\n\tif err := dm.decode(resp, &dm.apiContainerList); err != nil {\n\t\treturn nil, err\n\t}\n\n\tdm.isWindows = strings.Contains(resp.Header.Get(\"Server\"), \"windows\")\n\n\tcontainersLength := len(dm.apiContainerList)\n\n\t// store valid ids to clean up old container ids from map\n\tif dm.validIds == nil {", "n_tokens": 142, "primary_symbol": "getDockerStats", "primary_kind": "function", "primary_span": [66, 82], "def_symbols": ["getDockerStats"], "symbols": ["getDockerStats", "Returns", "stats", "for", "all", "running", "containers", "func", "dockerManager", "container", "Stats", "error", "resp", "err", "client", "Get", "http", "localhost", "json", "nil", "return", "apiContainerList", "decode", "isWindows", "strings", "Contains", "Header", "Server", "windows", "containersLength", "len", "store", "valid", "ids", "clean", "old", "from", "map", "validIds"], "doc_head": "// Returns stats for all running containers\nfunc (dm *dockerManager) getDockerStats() ([]*container.Stats, error) {\n\tresp, err := dm.client.Get(\"http://localhost/containers/json\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdm.apiContainerList = dm.apiContainerList[:0]\n\tif err := dm.decode(resp, &dm.apiContainerList); err != nil {\n\t\treturn nil, err\n\t}\n\tdm.isWindows = strings.Contains(resp.Header.Get(\"Server\"), \"windows\")\n\tcontainersLength := len(dm.apiContainerList)\n\t// store valid ids to clean up old container ids from map\n\tif dm.validIds == nil {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 83, "end_line": 92, "text": "\t\tdm.validIds = make(map[string]struct{}, containersLength)\n\t} else {\n\t\tclear(dm.validIds)\n\t}\n\n\tvar failedContainers []*container.ApiInfo\n\n\tfor i := range dm.apiContainerList {\n\t\tctr := dm.apiContainerList[i]\n\t\tctr.IdShort = ctr.Id[:12]", "n_tokens": 65, "primary_symbol": "", "primary_kind": "", "primary_span": [83, 92], "def_symbols": [], "symbols": ["validIds", "make", "map", "string", "struct", "containersLength", "else", "clear", "var", "failedContainers", "container", "ApiInfo", "for", "range", "apiContainerList", "ctr", "IdShort"], "doc_head": "\t\tdm.validIds = make(map[string]struct{}, containersLength)\n\t} else {\n\t\tclear(dm.validIds)\n\t}\n\tvar failedContainers []*container.ApiInfo\n\tfor i := range dm.apiContainerList {\n\t\tctr := dm.apiContainerList[i]\n\t\tctr.IdShort = ctr.Id[:12]"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 93, "end_line": 145, "text": "\t\tdm.validIds[ctr.IdShort] = struct{}{}\n\t\t// check if container is less than 1 minute old (possible restart)\n\t\t// note: can't use Created field because it's not updated on restart\n\t\tif strings.Contains(ctr.Status, \"second\") {\n\t\t\t// if so, remove old container data\n\t\t\tdm.deleteContainerStatsSync(ctr.IdShort)\n\t\t}\n\t\tdm.queue()\n\t\tgo func() {\n\t\t\tdefer dm.dequeue()\n\t\t\terr := dm.updateContainerStats(ctr)\n\t\t\t// if error, delete from map and add to failed list to retry\n\t\t\tif err != nil {\n\t\t\t\tdm.containerStatsMutex.Lock()\n\t\t\t\tdelete(dm.containerStatsMap, ctr.IdShort)\n\t\t\t\tfailedContainers = append(failedContainers, ctr)\n\t\t\t\tdm.containerStatsMutex.Unlock()\n\t\t\t}\n\t\t}()\n\t}\n\n\tdm.wg.Wait()\n\n\t// retry failed containers separately so we can run them in parallel (docker 24 bug)\n\tif len(failedContainers) > 0 {\n\t\tslog.Debug(\"Retrying failed containers\", \"count\", len(failedContainers))\n\t\tfor i := range failedContainers {\n\t\t\tctr := failedContainers[i]\n\t\t\tdm.queue()\n\t\t\tgo func() {\n\t\t\t\tdefer dm.dequeue()\n\t\t\t\terr = dm.updateContainerStats(ctr)\n\t\t\t\tif err != nil {\n\t\t\t\t\tslog.Error(\"Error getting container stats\", \"err\", err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tdm.wg.Wait()\n\t}\n\n\t// populate final stats and remove old / invalid container stats\n\tstats := make([]*container.Stats, 0, containersLength)\n\tfor id, v := range dm.containerStatsMap {\n\t\tif _, exists := dm.validIds[id]; !exists {\n\t\t\tdelete(dm.containerStatsMap, id)\n\t\t} else {\n\t\t\tstats = append(stats, v)\n\t\t}\n\t}\n\n\treturn stats, nil\n}\n", "n_tokens": 399, "primary_symbol": "", "primary_kind": "", "primary_span": [93, 145], "def_symbols": [], "symbols": ["validIds", "ctr", "IdShort", "struct", "check", "container", "less", "than", "minute", "old", "possible", "restart", "note", "can", "use", "Created", "field", "because", "not", "updated", "strings", "Contains", "Status", "second", "remove", "data", "deleteContainerStatsSync", "queue", "func", "defer", "dequeue", "err", "updateContainerStats", "error", "delete", "from", "map", "and", "add", "failed", "list", "retry", "nil", "containerStatsMutex", "Lock", "containerStatsMap", "failedContainers", "append", "Unlock", "Wait", "containers", "separately", "run", "them", "parallel", "docker", "bug", "len", "slog", "Debug", "Retrying", "count", "for", "range", "Error", "getting", "stats", "populate", "final", "invalid", "make", "Stats", "containersLength", "exists", "else", "return"], "doc_head": "\t\tdm.validIds[ctr.IdShort] = struct{}{}\n\t\t// check if container is less than 1 minute old (possible restart)\n\t\t// note: can't use Created field because it's not updated on restart\n\t\tif strings.Contains(ctr.Status, \"second\") {\n\t\t\t// if so, remove old container data\n\t\t\tdm.deleteContainerStatsSync(ctr.IdShort)\n\t\t}\n\t\tdm.queue()\n\t\tgo func() {\n\t\t\tdefer dm.dequeue()\n\t\t\terr := dm.updateContainerStats(ctr)\n\t\t\t// if error, delete from map and add to failed list to retry\n\t\t\tif err != nil {\n\t\t\t\tdm.containerStatsMutex.Lock()\n\t\t\t\tdelete(dm.containerStatsMap, ctr.IdShort)\n\t\t\t\tfailedContainers = append(failedContainers, ctr)\n\t\t\t\tdm.containerStatsMutex.Unlock()\n\t\t\t}\n\t\t}()\n\t}\n\tdm.wg.Wait()\n\t// retry failed containers separately so we can run them in parallel (docker 24 bug)\n\tif len(failedContainers) > 0 {\n\t\tslog.Debug(\"Retrying failed containers\", \"count\", len(failedContainers))\n\t\tfor i := range failedContainers {\n\t\t\tctr := failedContainers[i]\n\t\t\tdm.queue()\n\t\t\tgo func() {\n\t\t\t\tdefer dm.dequeue()\n\t\t\t\terr = dm.updateContainerStats(ctr)\n\t\t\t\tif err != nil {\n\t\t\t\t\tslog.Error(\"Error getting container stats\", \"err\", err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tdm.wg.Wait()\n\t}\n\t// populate final stats and remove old / invalid con"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 146, "end_line": 241, "text": "// Updates stats for individual container\nfunc (dm *dockerManager) updateContainerStats(ctr *container.ApiInfo) error {\n\tname := ctr.Names[0][1:]\n\n\tresp, err := dm.client.Get(\"http://localhost/containers/\" + ctr.IdShort + \"/stats?stream=0&one-shot=1\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tdm.containerStatsMutex.Lock()\n\tdefer dm.containerStatsMutex.Unlock()\n\n\t// add empty values if they doesn't exist in map\n\tstats, initialized := dm.containerStatsMap[ctr.IdShort]\n\tif !initialized {\n\t\tstats = &container.Stats{Name: name}\n\t\tdm.containerStatsMap[ctr.IdShort] = stats\n\t}\n\n\t// reset current stats\n\tstats.Cpu = 0\n\tstats.Mem = 0\n\tstats.NetworkSent = 0\n\tstats.NetworkRecv = 0\n\n\t// docker host container stats response\n\t// res := dm.getApiStats()\n\t// defer dm.putApiStats(res)\n\t//\n\n\tres := dm.apiStats\n\tres.Networks = nil\n\tif err := dm.decode(resp, res); err != nil {\n\t\treturn err\n\t}\n\n\t// calculate cpu and memory stats\n\tvar usedMemory uint64\n\tvar cpuPct float64\n\n\t// store current cpu stats\n\tprevCpuContainer, prevCpuSystem := stats.CpuContainer, stats.CpuSystem\n\tstats.CpuContainer = res.CPUStats.CPUUsage.TotalUsage\n\tstats.CpuSystem = res.CPUStats.SystemUsage\n\n\tif dm.isWindows {\n\t\tusedMemory = res.MemoryStats.PrivateWorkingSet\n\t\tcpuPct = res.CalculateCpuPercentWindows(prevCpuContainer, stats.PrevReadTime)\n\t} else {\n\t\t// check if container has valid data, otherwise may be in restart loop (#103)\n\t\tif res.MemoryStats.Usage == 0 {\n\t\t\treturn fmt.Errorf(\"%s - no memory stats - see https://github.com/henrygd/beszel/issues/144\", name)\n\t\t}\n\t\tmemCache := res.MemoryStats.Stats.InactiveFile\n\t\tif memCache == 0 {\n\t\t\tmemCache = res.MemoryStats.Stats.Cache\n\t\t}\n\t\tusedMemory = res.MemoryStats.Usage - memCache\n\n\t\tcpuPct = res.CalculateCpuPercentLinux(prevCpuContainer, prevCpuSystem)\n\t}\n\n\tif cpuPct > 100 {\n\t\treturn fmt.Errorf(\"%s cpu pct greater than 100: %+v\", name, cpuPct)\n\t}\n\n\t// network\n\tvar total_sent, total_recv uint64\n\tfor _, v := range res.Networks {\n\t\ttotal_sent += v.TxBytes\n\t\ttotal_recv += v.RxBytes\n\t}\n\tvar sent_delta, recv_delta uint64\n\tmillisecondsElapsed := uint64(time.Since(stats.PrevReadTime).Milliseconds())\n\tif initialized && millisecondsElapsed > 0 {\n\t\t// get bytes per second\n\t\tsent_delta = (total_sent - stats.PrevNet.Sent) * 1000 / millisecondsElapsed\n\t\trecv_delta = (total_recv - stats.PrevNet.Recv) * 1000 / millisecondsElapsed\n\t\t// check for unrealistic network values (> 5GB/s)\n\t\tif sent_delta > 5e9 || recv_delta > 5e9 {\n\t\t\tslog.Warn(\"Bad network delta\", \"container\", name)\n\t\t\tsent_delta, recv_delta = 0, 0\n\t\t}\n\t}\n\tstats.PrevNet.Sent, stats.PrevNet.Recv = total_sent, total_recv\n\n\tstats.Cpu = twoDecimals(cpuPct)\n\tstats.Mem = bytesToMegabytes(float64(usedMemory))\n\tstats.NetworkSent = bytesToMegabytes(float64(sent_delta))\n\tstats.NetworkRecv = bytesToMegabytes(float64(recv_delta))\n\tstats.PrevReadTime = res.Read\n\n\treturn nil\n}\n", "n_tokens": 810, "primary_symbol": "updateContainerStats", "primary_kind": "function", "primary_span": [147, 241], "def_symbols": ["updateContainerStats"], "symbols": ["updateContainerStats", "Updates", "stats", "for", "individual", "container", "func", "dockerManager", "ctr", "ApiInfo", "error", "name", "Names", "resp", "err", "client", "Get", "http", "localhost", "containers", "IdShort", "stream", "one", "shot", "nil", "return", "defer", "Body", "Close", "containerStatsMutex", "Lock", "Unlock", "add", "empty", "values", "they", "doesn", "exist", "map", "initialized", "containerStatsMap", "Stats", "Name", "reset", "current", "Cpu", "Mem", "NetworkSent", "NetworkRecv", "docker", "host", "response", "res", "getApiStats", "putApiStats", "apiStats", "Networks", "decode", "calculate", "cpu", "and", "memory", "var", "usedMemory", "uint64", "cpuPct", "float64", "store", "prevCpuContainer", "prevCpuSystem", "CpuContainer", "CpuSystem", "CPUStats", "CPUUsage", "TotalUsage", "SystemUsage", "isWindows", "MemoryStats", "PrivateWorkingSet", "CalculateCpuPercentWindows", "PrevReadTime", "else", "check", "has", "valid", "data", "otherwise", "may", "restart", "loop", "Usage", "fmt", "Errorf", "see", "https", "github", "com", "henrygd", "beszel", "issues", "memCache", "InactiveFile", "Cache", "CalculateCpuPercentLinux", "pct", "greater", "than", "network", "total_sent", "total_recv", "range", "TxBytes", "RxBytes", "sent_delta", "recv_delta", "millisecondsElapsed", "time", "Since", "Milliseconds", "get", "bytes", "per", "second", "PrevNet", "Sent", "Recv", "unrealistic", "slog", "Warn", "Bad", "delta", "twoDecimals", "bytesToMegabytes", "Read"], "doc_head": "// Updates stats for individual container\nfunc (dm *dockerManager) updateContainerStats(ctr *container.ApiInfo) error {\n\tname := ctr.Names[0][1:]\n\tresp, err := dm.client.Get(\"http://localhost/containers/\" + ctr.IdShort + \"/stats?stream=0&one-shot=1\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tdm.containerStatsMutex.Lock()\n\tdefer dm.containerStatsMutex.Unlock()\n\t// add empty values if they doesn't exist in map\n\tstats, initialized := dm.containerStatsMap[ctr.IdShort]\n\tif !initialized {\n\t\tstats = &container.Stats{Name: name}\n\t\tdm.containerStatsMap[ctr.IdShort] = stats\n\t}\n\t// reset current stats\n\tstats.Cpu = 0\n\tstats.Mem = 0\n\tstats.NetworkSent = 0\n\tstats.NetworkRecv = 0\n\t// docker host container stats response\n\t// res := dm.getApiStats()\n\t// defer dm.putApiStats(res)\n\t//\n\tres := dm.apiStats\n\tres.Networks = nil\n\tif err := dm.decode(resp, res); err != nil {\n\t\treturn err\n\t}\n\t// calculate cpu and memory stats\n\tvar usedMemory uint64\n\tvar cpuPct float64\n\t// store current cpu stats\n\tprevCpuContainer, prevCpuSystem := stats.CpuContainer, stats.CpuSystem\n\tstats.CpuContainer = res.CPUStats.CPUUsage.TotalUsage\n\tstats.CpuSystem = res.CPUStats.SystemUsage\n\tif dm.isWindows {\n\t\tusedMe"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 242, "end_line": 248, "text": "// Delete container stats from map using mutex\nfunc (dm *dockerManager) deleteContainerStatsSync(id string) {\n\tdm.containerStatsMutex.Lock()\n\tdefer dm.containerStatsMutex.Unlock()\n\tdelete(dm.containerStatsMap, id)\n}\n", "n_tokens": 47, "primary_symbol": "deleteContainerStatsSync", "primary_kind": "function", "primary_span": [243, 248], "def_symbols": ["deleteContainerStatsSync"], "symbols": ["deleteContainerStatsSync", "Delete", "container", "stats", "from", "map", "using", "mutex", "func", "dockerManager", "string", "containerStatsMutex", "Lock", "defer", "Unlock", "delete", "containerStatsMap"], "doc_head": "// Delete container stats from map using mutex\nfunc (dm *dockerManager) deleteContainerStatsSync(id string) {\n\tdm.containerStatsMutex.Lock()\n\tdefer dm.containerStatsMutex.Unlock()\n\tdelete(dm.containerStatsMap, id)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 249, "end_line": 307, "text": "// Creates a new http client for Docker or Podman API\nfunc newDockerManager(a *Agent) *dockerManager {\n\tdockerHost, exists := GetEnv(\"DOCKER_HOST\")\n\tif exists {\n\t\t// return nil if set to empty string\n\t\tif dockerHost == \"\" {\n\t\t\treturn nil\n\t\t}\n\t} else {\n\t\tdockerHost = getDockerHost()\n\t}\n\n\tparsedURL, err := url.Parse(dockerHost)\n\tif err != nil {\n\t\tos.Exit(1)\n\t}\n\n\ttransport := &http.Transport{\n\t\tDisableCompression: true,\n\t\tMaxConnsPerHost:    0,\n\t}\n\n\tswitch parsedURL.Scheme {\n\tcase \"unix\":\n\t\ttransport.DialContext = func(ctx context.Context, proto, addr string) (net.Conn, error) {\n\t\t\treturn (&net.Dialer{}).DialContext(ctx, \"unix\", parsedURL.Path)\n\t\t}\n\tcase \"tcp\", \"http\", \"https\":\n\t\ttransport.DialContext = func(ctx context.Context, proto, addr string) (net.Conn, error) {\n\t\t\treturn (&net.Dialer{}).DialContext(ctx, \"tcp\", parsedURL.Host)\n\t\t}\n\tdefault:\n\t\tslog.Error(\"Invalid DOCKER_HOST\", \"scheme\", parsedURL.Scheme)\n\t\tos.Exit(1)\n\t}\n\n\t// configurable timeout\n\ttimeout := time.Millisecond * 2100\n\tif t, set := GetEnv(\"DOCKER_TIMEOUT\"); set {\n\t\ttimeout, err = time.ParseDuration(t)\n\t\tif err != nil {\n\t\t\tslog.Error(err.Error())\n\t\t\tos.Exit(1)\n\t\t}\n\t\tslog.Info(\"DOCKER_TIMEOUT\", \"timeout\", timeout)\n\t}\n\n\t// Custom user-agent to avoid docker bug: https://github.com/docker/for-mac/issues/7575\n\tuserAgentTransport := &userAgentRoundTripper{\n\t\trt:        transport,\n\t\tuserAgent: \"Docker-Client/\",\n\t}\n\n\tmanager := &dockerManager{\n\t\tclient: &http.Client{\n\t\t\tTimeout:   timeout,\n\t\t\tTransport: userAgentTransport,\n\t\t},\n\t\tcontainerStatsMap: make(map[string]*container.Stats),", "n_tokens": 443, "primary_symbol": "newDockerManager", "primary_kind": "function", "primary_span": [250, 307], "def_symbols": ["newDockerManager"], "symbols": ["newDockerManager", "Creates", "new", "http", "client", "for", "Docker", "Podman", "API", "func", "Agent", "dockerManager", "dockerHost", "exists", "GetEnv", "DOCKER_HOST", "return", "nil", "set", "empty", "string", "else", "getDockerHost", "parsedURL", "err", "url", "Parse", "Exit", "transport", "Transport", "DisableCompression", "true", "MaxConnsPerHost", "switch", "Scheme", "case", "unix", "DialContext", "ctx", "context", "Context", "proto", "addr", "net", "Conn", "error", "Dialer", "Path", "tcp", "https", "Host", "default", "slog", "Error", "Invalid", "scheme", "configurable", "timeout", "time", "Millisecond", "DOCKER_TIMEOUT", "ParseDuration", "Info", "Custom", "user", "agent", "avoid", "docker", "bug", "github", "com", "mac", "issues", "userAgentTransport", "userAgentRoundTripper", "userAgent", "Client", "manager", "Timeout", "containerStatsMap", "make", "map", "container", "Stats"], "doc_head": "// Creates a new http client for Docker or Podman API\nfunc newDockerManager(a *Agent) *dockerManager {\n\tdockerHost, exists := GetEnv(\"DOCKER_HOST\")\n\tif exists {\n\t\t// return nil if set to empty string\n\t\tif dockerHost == \"\" {\n\t\t\treturn nil\n\t\t}\n\t} else {\n\t\tdockerHost = getDockerHost()\n\t}\n\tparsedURL, err := url.Parse(dockerHost)\n\tif err != nil {\n\t\tos.Exit(1)\n\t}\n\ttransport := &http.Transport{\n\t\tDisableCompression: true,\n\t\tMaxConnsPerHost:    0,\n\t}\n\tswitch parsedURL.Scheme {\n\tcase \"unix\":\n\t\ttransport.DialContext = func(ctx context.Context, proto, addr string) (net.Conn, error) {\n\t\t\treturn (&net.Dialer{}).DialContext(ctx, \"unix\", parsedURL.Path)\n\t\t}\n\tcase \"tcp\", \"http\", \"https\":\n\t\ttransport.DialContext = func(ctx context.Context, proto, addr string) (net.Conn, error) {\n\t\t\treturn (&net.Dialer{}).DialContext(ctx, \"tcp\", parsedURL.Host)\n\t\t}\n\tdefault:\n\t\tslog.Error(\"Invalid DOCKER_HOST\", \"scheme\", parsedURL.Scheme)\n\t\tos.Exit(1)\n\t}\n\t// configurable timeout\n\ttimeout := time.Millisecond * 2100\n\tif t, set := GetEnv(\"DOCKER_TIMEOUT\"); set {\n\t\ttimeout, err = time.ParseDuration(t)\n\t\tif err != nil {\n\t\t\tslog.Error(err.Error())\n\t\t\tos.Exit(1)\n\t\t}\n\t\tslog.Info(\"DOCKER_TIMEOUT\", \"timeout\", timeout)\n\t}\n\t// C"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 308, "end_line": 319, "text": "\t\tsem:               make(chan struct{}, 5),\n\t\tapiContainerList:  []*container.ApiInfo{},\n\t\tapiStats:          &container.ApiStats{},\n\t}\n\n\t// If using podman, return client\n\tif strings.Contains(dockerHost, \"podman\") {\n\t\ta.systemInfo.Podman = true\n\t\tmanager.goodDockerVersion = true\n\t\treturn manager\n\t}\n", "n_tokens": 80, "primary_symbol": "", "primary_kind": "", "primary_span": [308, 319], "def_symbols": [], "symbols": ["sem", "make", "chan", "struct", "apiContainerList", "container", "ApiInfo", "apiStats", "ApiStats", "using", "podman", "return", "client", "strings", "Contains", "dockerHost", "systemInfo", "Podman", "true", "manager", "goodDockerVersion"], "doc_head": "\t\tsem:               make(chan struct{}, 5),\n\t\tapiContainerList:  []*container.ApiInfo{},\n\t\tapiStats:          &container.ApiStats{},\n\t}\n\t// If using podman, return client\n\tif strings.Contains(dockerHost, \"podman\") {\n\t\ta.systemInfo.Podman = true\n\t\tmanager.goodDockerVersion = true\n\t\treturn manager\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 320, "end_line": 343, "text": "\t// Check docker version\n\t// (versions before 25.0.0 have a bug with one-shot which requires all requests to be made in one batch)\n\tvar versionInfo struct {\n\t\tVersion string `json:\"Version\"`\n\t}\n\tresp, err := manager.client.Get(\"http://localhost/version\")\n\tif err != nil {\n\t\treturn manager\n\t}\n\n\tif err := manager.decode(resp, &versionInfo); err != nil {\n\t\treturn manager\n\t}\n\n\t// if version > 24, one-shot works correctly and we can limit concurrent operations\n\tif dockerVersion, err := semver.Parse(versionInfo.Version); err == nil && dockerVersion.Major > 24 {\n\t\tmanager.goodDockerVersion = true\n\t} else {\n\t\tslog.Info(fmt.Sprintf(\"Docker %s is outdated. Upgrade if possible. See https://github.com/henrygd/beszel/issues/58\", versionInfo.Version))\n\t}\n\n\treturn manager\n}\n", "n_tokens": 195, "primary_symbol": "", "primary_kind": "", "primary_span": [320, 343], "def_symbols": [], "symbols": ["Check", "docker", "version", "versions", "before", "have", "bug", "with", "one", "shot", "which", "requires", "all", "requests", "made", "batch", "var", "versionInfo", "struct", "Version", "string", "json", "resp", "err", "manager", "client", "Get", "http", "localhost", "nil", "return", "decode", "works", "correctly", "and", "can", "limit", "concurrent", "operations", "dockerVersion", "semver", "Parse", "Major", "goodDockerVersion", "true", "else", "slog", "Info", "fmt", "Sprintf", "Docker", "outdated", "Upgrade", "possible", "See", "https", "github", "com", "henrygd", "beszel", "issues"], "doc_head": "\t// Check docker version\n\t// (versions before 25.0.0 have a bug with one-shot which requires all requests to be made in one batch)\n\tvar versionInfo struct {\n\t\tVersion string `json:\"Version\"`\n\t}\n\tresp, err := manager.client.Get(\"http://localhost/version\")\n\tif err != nil {\n\t\treturn manager\n\t}\n\tif err := manager.decode(resp, &versionInfo); err != nil {\n\t\treturn manager\n\t}\n\t// if version > 24, one-shot works correctly and we can limit concurrent operations\n\tif dockerVersion, err := semver.Parse(versionInfo.Version); err == nil && dockerVersion.Major > 24 {\n\t\tmanager.goodDockerVersion = true\n\t} else {\n\t\tslog.Info(fmt.Sprintf(\"Docker %s is outdated. Upgrade if possible. See https://github.com/henrygd/beszel/issues/58\", versionInfo.Version))\n\t}\n\treturn manager\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 344, "end_line": 359, "text": "// Decodes Docker API JSON response using a reusable buffer and decoder. Not thread safe.\nfunc (dm *dockerManager) decode(resp *http.Response, d any) error {\n\tif dm.buf == nil {\n\t\t// initialize buffer with 256kb starting size\n\t\tdm.buf = bytes.NewBuffer(make([]byte, 0, 1024*256))\n\t\tdm.decoder = json.NewDecoder(dm.buf)\n\t}\n\tdefer resp.Body.Close()\n\tdefer dm.buf.Reset()\n\t_, err := dm.buf.ReadFrom(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn dm.decoder.Decode(d)\n}\n", "n_tokens": 127, "primary_symbol": "decode", "primary_kind": "function", "primary_span": [345, 359], "def_symbols": ["decode"], "symbols": ["decode", "Decodes", "Docker", "API", "JSON", "response", "using", "reusable", "buffer", "and", "decoder", "Not", "thread", "safe", "func", "dockerManager", "resp", "http", "Response", "any", "error", "buf", "nil", "initialize", "with", "starting", "size", "bytes", "NewBuffer", "make", "byte", "json", "NewDecoder", "defer", "Body", "Close", "Reset", "err", "ReadFrom", "return", "Decode"], "doc_head": "// Decodes Docker API JSON response using a reusable buffer and decoder. Not thread safe.\nfunc (dm *dockerManager) decode(resp *http.Response, d any) error {\n\tif dm.buf == nil {\n\t\t// initialize buffer with 256kb starting size\n\t\tdm.buf = bytes.NewBuffer(make([]byte, 0, 1024*256))\n\t\tdm.decoder = json.NewDecoder(dm.buf)\n\t}\n\tdefer resp.Body.Close()\n\tdefer dm.buf.Reset()\n\t_, err := dm.buf.ReadFrom(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn dm.decoder.Decode(d)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/docker.go", "rel_path": "agent/docker.go", "ext": "go", "language": "go", "chunk_number": 13, "start_line": 360, "end_line": 371, "text": "// Test docker / podman sockets and return if one exists\nfunc getDockerHost() string {\n\tscheme := \"unix://\"\n\tsocks := []string{\"/var/run/docker.sock\", fmt.Sprintf(\"/run/user/%v/podman/podman.sock\", os.Getuid())}\n\tfor _, sock := range socks {\n\t\tif _, err := os.Stat(sock); err == nil {\n\t\t\treturn scheme + sock\n\t\t}\n\t}\n\treturn scheme + socks[0]\n}\n", "n_tokens": 99, "primary_symbol": "getDockerHost", "primary_kind": "function", "primary_span": [361, 371], "def_symbols": ["getDockerHost"], "symbols": ["getDockerHost", "Test", "docker", "podman", "sockets", "and", "return", "one", "exists", "func", "string", "scheme", "unix", "socks", "var", "run", "sock", "fmt", "Sprintf", "user", "Getuid", "for", "range", "err", "Stat", "nil"], "doc_head": "// Test docker / podman sockets and return if one exists\nfunc getDockerHost() string {\n\tscheme := \"unix://\"\n\tsocks := []string{\"/var/run/docker.sock\", fmt.Sprintf(\"/run/user/%v/podman/podman.sock\", os.Getuid())}\n\tfor _, sock := range socks {\n\t\tif _, err := os.Stat(sock); err == nil {\n\t\t\treturn scheme + sock\n\t\t}\n\t}\n\treturn scheme + socks[0]\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 26, "text": "//go:build testing\n// +build testing\n\npackage agent\n\nimport (\n\t\"crypto/ed25519\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc createTestAgent(t *testing.T) *Agent {\n\tdataDir := t.TempDir()\n\tagent, err := NewAgent(dataDir)\n\trequire.NoError(t, err)\n\treturn agent\n}\n", "n_tokens": 106, "primary_symbol": "createTestAgent", "primary_kind": "function", "primary_span": [20, 26], "def_symbols": ["createTestAgent"], "symbols": ["createTestAgent", "build", "testing", "package", "agent", "import", "crypto", "ed25519", "fmt", "net", "url", "time", "github", "com", "stretchr", "testify", "assert", "require", "golang", "org", "ssh", "func", "Agent", "dataDir", "TempDir", "err", "NewAgent", "NoError", "return"], "doc_head": "//go:build testing\n// +build testing\npackage agent\nimport (\n\t\"crypto/ed25519\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)\nfunc createTestAgent(t *testing.T) *Agent {\n\tdataDir := t.TempDir()\n\tagent, err := NewAgent(dataDir)\n\trequire.NoError(t, err)\n\treturn agent\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 27, "end_line": 46, "text": "func createTestServerOptions(t *testing.T) ServerOptions {\n\t// Generate test key pair\n\t_, privKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tsshPubKey, err := ssh.NewPublicKey(privKey.Public().(ed25519.PublicKey))\n\trequire.NoError(t, err)\n\n\t// Find available port\n\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\trequire.NoError(t, err)\n\tport := listener.Addr().(*net.TCPAddr).Port\n\tlistener.Close()\n\n\treturn ServerOptions{\n\t\tNetwork: \"tcp\",\n\t\tAddr:    fmt.Sprintf(\"127.0.0.1:%d\", port),\n\t\tKeys:    []ssh.PublicKey{sshPubKey},\n\t}\n}\n", "n_tokens": 165, "primary_symbol": "createTestServerOptions", "primary_kind": "function", "primary_span": [27, 46], "def_symbols": ["createTestServerOptions"], "symbols": ["createTestServerOptions", "func", "testing", "ServerOptions", "Generate", "test", "key", "pair", "privKey", "err", "ed25519", "GenerateKey", "nil", "require", "NoError", "sshPubKey", "ssh", "NewPublicKey", "Public", "PublicKey", "Find", "available", "port", "listener", "net", "Listen", "tcp", "Addr", "TCPAddr", "Port", "Close", "return", "Network", "fmt", "Sprintf", "Keys"], "doc_head": "func createTestServerOptions(t *testing.T) ServerOptions {\n\t// Generate test key pair\n\t_, privKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tsshPubKey, err := ssh.NewPublicKey(privKey.Public().(ed25519.PublicKey))\n\trequire.NoError(t, err)\n\t// Find available port\n\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\trequire.NoError(t, err)\n\tport := listener.Addr().(*net.TCPAddr).Port\n\tlistener.Close()\n\treturn ServerOptions{\n\t\tNetwork: \"tcp\",\n\t\tAddr:    fmt.Sprintf(\"127.0.0.1:%d\", port),\n\t\tKeys:    []ssh.PublicKey{sshPubKey},\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 47, "end_line": 60, "text": "// TestConnectionManager_NewConnectionManager tests connection manager creation\nfunc TestConnectionManager_NewConnectionManager(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := newConnectionManager(agent)\n\n\tassert.NotNil(t, cm, \"Connection manager should not be nil\")\n\tassert.Equal(t, agent, cm.agent, \"Agent reference should be set\")\n\tassert.Equal(t, Disconnected, cm.State, \"Initial state should be Disconnected\")\n\tassert.Nil(t, cm.eventChan, \"Event channel should be nil initially\")\n\tassert.Nil(t, cm.wsClient, \"WebSocket client should be nil initially\")\n\tassert.Nil(t, cm.wsTicker, \"WebSocket ticker should be nil initially\")\n\tassert.False(t, cm.isConnecting, \"isConnecting should be false initially\")\n}\n", "n_tokens": 153, "primary_symbol": "TestConnectionManager_NewConnectionManager", "primary_kind": "function", "primary_span": [48, 60], "def_symbols": ["TestConnectionManager_NewConnectionManager"], "symbols": ["TestConnectionManager_NewConnectionManager", "tests", "connection", "manager", "creation", "func", "testing", "agent", "createTestAgent", "newConnectionManager", "assert", "NotNil", "Connection", "should", "not", "nil", "Equal", "Agent", "reference", "set", "Disconnected", "State", "Initial", "state", "Nil", "eventChan", "Event", "channel", "initially", "wsClient", "WebSocket", "client", "wsTicker", "ticker", "False", "isConnecting", "false"], "doc_head": "// TestConnectionManager_NewConnectionManager tests connection manager creation\nfunc TestConnectionManager_NewConnectionManager(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := newConnectionManager(agent)\n\tassert.NotNil(t, cm, \"Connection manager should not be nil\")\n\tassert.Equal(t, agent, cm.agent, \"Agent reference should be set\")\n\tassert.Equal(t, Disconnected, cm.State, \"Initial state should be Disconnected\")\n\tassert.Nil(t, cm.eventChan, \"Event channel should be nil initially\")\n\tassert.Nil(t, cm.wsClient, \"WebSocket client should be nil initially\")\n\tassert.Nil(t, cm.wsTicker, \"WebSocket ticker should be nil initially\")\n\tassert.False(t, cm.isConnecting, \"isConnecting should be false initially\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 61, "end_line": 89, "text": "// TestConnectionManager_StateTransitions tests basic state transitions\nfunc TestConnectionManager_StateTransitions(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\tinitialState := cm.State\n\tcm.wsClient = &WebSocketClient{\n\t\thubURL: &url.URL{\n\t\t\tHost: \"localhost:8080\",\n\t\t},\n\t}\n\tassert.NotNil(t, cm, \"Connection manager should not be nil\")\n\tassert.Equal(t, Disconnected, initialState, \"Initial state should be Disconnected\")\n\n\t// Test state transitions\n\tcm.handleStateChange(WebSocketConnected)\n\tassert.Equal(t, WebSocketConnected, cm.State, \"State should change to WebSocketConnected\")\n\n\tcm.handleStateChange(SSHConnected)\n\tassert.Equal(t, SSHConnected, cm.State, \"State should change to SSHConnected\")\n\n\tcm.handleStateChange(Disconnected)\n\tassert.Equal(t, Disconnected, cm.State, \"State should change to Disconnected\")\n\n\t// Test that same state doesn't trigger changes\n\tcm.State = WebSocketConnected\n\tcm.handleStateChange(WebSocketConnected)\n\tassert.Equal(t, WebSocketConnected, cm.State, \"Same state should not trigger change\")\n}\n", "n_tokens": 235, "primary_symbol": "TestConnectionManager_StateTransitions", "primary_kind": "function", "primary_span": [62, 89], "def_symbols": ["TestConnectionManager_StateTransitions"], "symbols": ["TestConnectionManager_StateTransitions", "tests", "basic", "state", "transitions", "func", "testing", "agent", "createTestAgent", "connectionManager", "initialState", "State", "wsClient", "WebSocketClient", "hubURL", "url", "URL", "Host", "localhost", "assert", "NotNil", "Connection", "manager", "should", "not", "nil", "Equal", "Disconnected", "Initial", "Test", "handleStateChange", "WebSocketConnected", "change", "SSHConnected", "that", "same", "doesn", "trigger", "changes", "Same"], "doc_head": "// TestConnectionManager_StateTransitions tests basic state transitions\nfunc TestConnectionManager_StateTransitions(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\tinitialState := cm.State\n\tcm.wsClient = &WebSocketClient{\n\t\thubURL: &url.URL{\n\t\t\tHost: \"localhost:8080\",\n\t\t},\n\t}\n\tassert.NotNil(t, cm, \"Connection manager should not be nil\")\n\tassert.Equal(t, Disconnected, initialState, \"Initial state should be Disconnected\")\n\t// Test state transitions\n\tcm.handleStateChange(WebSocketConnected)\n\tassert.Equal(t, WebSocketConnected, cm.State, \"State should change to WebSocketConnected\")\n\tcm.handleStateChange(SSHConnected)\n\tassert.Equal(t, SSHConnected, cm.State, \"State should change to SSHConnected\")\n\tcm.handleStateChange(Disconnected)\n\tassert.Equal(t, Disconnected, cm.State, \"State should change to Disconnected\")\n\t// Test that same state doesn't trigger changes\n\tcm.State = WebSocketConnected\n\tcm.handleStateChange(WebSocketConnected)\n\tassert.Equal(t, WebSocketConnected, cm.State, \"Same state should not trigger change\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 90, "end_line": 99, "text": "// TestConnectionManager_EventHandling tests event handling logic\nfunc TestConnectionManager_EventHandling(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\tcm.wsClient = &WebSocketClient{\n\t\thubURL: &url.URL{\n\t\t\tHost: \"localhost:8080\",\n\t\t},\n\t}\n", "n_tokens": 69, "primary_symbol": "TestConnectionManager_EventHandling", "primary_kind": "function", "primary_span": [91, 99], "def_symbols": ["TestConnectionManager_EventHandling"], "symbols": ["TestConnectionManager_EventHandling", "tests", "event", "handling", "logic", "func", "testing", "agent", "createTestAgent", "connectionManager", "wsClient", "WebSocketClient", "hubURL", "url", "URL", "Host", "localhost"], "doc_head": "// TestConnectionManager_EventHandling tests event handling logic\nfunc TestConnectionManager_EventHandling(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\tcm.wsClient = &WebSocketClient{\n\t\thubURL: &url.URL{\n\t\t\tHost: \"localhost:8080\",\n\t\t},\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 100, "end_line": 152, "text": "\ttestCases := []struct {\n\t\tname          string\n\t\tinitialState  ConnectionState\n\t\tevent         ConnectionEvent\n\t\texpectedState ConnectionState\n\t}{\n\t\t{\n\t\t\tname:          \"WebSocket connect from disconnected\",\n\t\t\tinitialState:  Disconnected,\n\t\t\tevent:         WebSocketConnect,\n\t\t\texpectedState: WebSocketConnected,\n\t\t},\n\t\t{\n\t\t\tname:          \"SSH connect from disconnected\",\n\t\t\tinitialState:  Disconnected,\n\t\t\tevent:         SSHConnect,\n\t\t\texpectedState: SSHConnected,\n\t\t},\n\t\t{\n\t\t\tname:          \"WebSocket disconnect from connected\",\n\t\t\tinitialState:  WebSocketConnected,\n\t\t\tevent:         WebSocketDisconnect,\n\t\t\texpectedState: Disconnected,\n\t\t},\n\t\t{\n\t\t\tname:          \"SSH disconnect from connected\",\n\t\t\tinitialState:  SSHConnected,\n\t\t\tevent:         SSHDisconnect,\n\t\t\texpectedState: Disconnected,\n\t\t},\n\t\t{\n\t\t\tname:          \"WebSocket disconnect from SSH connected (no change)\",\n\t\t\tinitialState:  SSHConnected,\n\t\t\tevent:         WebSocketDisconnect,\n\t\t\texpectedState: SSHConnected,\n\t\t},\n\t\t{\n\t\t\tname:          \"SSH disconnect from WebSocket connected (no change)\",\n\t\t\tinitialState:  WebSocketConnected,\n\t\t\tevent:         SSHDisconnect,\n\t\t\texpectedState: WebSocketConnected,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tcm.State = tc.initialState\n\t\t\tcm.handleEvent(tc.event)\n\t\t\tassert.Equal(t, tc.expectedState, cm.State, \"State should match expected after event\")\n\t\t})\n\t}\n}\n", "n_tokens": 330, "primary_symbol": "", "primary_kind": "", "primary_span": [100, 152], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "initialState", "ConnectionState", "event", "ConnectionEvent", "expectedState", "WebSocket", "connect", "from", "disconnected", "Disconnected", "WebSocketConnect", "WebSocketConnected", "SSH", "SSHConnect", "SSHConnected", "disconnect", "connected", "WebSocketDisconnect", "SSHDisconnect", "change", "for", "range", "Run", "func", "testing", "State", "handleEvent", "assert", "Equal", "should", "match", "expected", "after"], "doc_head": "\ttestCases := []struct {\n\t\tname          string\n\t\tinitialState  ConnectionState\n\t\tevent         ConnectionEvent\n\t\texpectedState ConnectionState\n\t}{\n\t\t{\n\t\t\tname:          \"WebSocket connect from disconnected\",\n\t\t\tinitialState:  Disconnected,\n\t\t\tevent:         WebSocketConnect,\n\t\t\texpectedState: WebSocketConnected,\n\t\t},\n\t\t{\n\t\t\tname:          \"SSH connect from disconnected\",\n\t\t\tinitialState:  Disconnected,\n\t\t\tevent:         SSHConnect,\n\t\t\texpectedState: SSHConnected,\n\t\t},\n\t\t{\n\t\t\tname:          \"WebSocket disconnect from connected\",\n\t\t\tinitialState:  WebSocketConnected,\n\t\t\tevent:         WebSocketDisconnect,\n\t\t\texpectedState: Disconnected,\n\t\t},\n\t\t{\n\t\t\tname:          \"SSH disconnect from connected\",\n\t\t\tinitialState:  SSHConnected,\n\t\t\tevent:         SSHDisconnect,\n\t\t\texpectedState: Disconnected,\n\t\t},\n\t\t{\n\t\t\tname:          \"WebSocket disconnect from SSH connected (no change)\",\n\t\t\tinitialState:  SSHConnected,\n\t\t\tevent:         WebSocketDisconnect,\n\t\t\texpectedState: SSHConnected,\n\t\t},\n\t\t{\n\t\t\tname:          \"SSH disconnect from WebSocket connected (no change)\",\n\t\t\tinitialState:  WebSocketConnected,\n\t\t\tevent:         SSHDisconnect,\n\t\t\texpectedState: WebSocketConnected,\n\t\t},\n\t}\n\tfor _, tc := r"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 153, "end_line": 184, "text": "// TestConnectionManager_TickerManagement tests WebSocket ticker management\nfunc TestConnectionManager_TickerManagement(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\n\t// Test starting ticker\n\tcm.startWsTicker()\n\tassert.NotNil(t, cm.wsTicker, \"Ticker should be created\")\n\n\t// Test stopping ticker (should not panic)\n\tassert.NotPanics(t, func() {\n\t\tcm.stopWsTicker()\n\t}, \"Stopping ticker should not panic\")\n\n\t// Test stopping nil ticker (should not panic)\n\tcm.wsTicker = nil\n\tassert.NotPanics(t, func() {\n\t\tcm.stopWsTicker()\n\t}, \"Stopping nil ticker should not panic\")\n\n\t// Test restarting ticker\n\tcm.startWsTicker()\n\tassert.NotNil(t, cm.wsTicker, \"Ticker should be recreated\")\n\n\t// Test resetting existing ticker\n\tfirstTicker := cm.wsTicker\n\tcm.startWsTicker()\n\tassert.Equal(t, firstTicker, cm.wsTicker, \"Same ticker instance should be reused\")\n\n\tcm.stopWsTicker()\n}\n", "n_tokens": 209, "primary_symbol": "TestConnectionManager_TickerManagement", "primary_kind": "function", "primary_span": [154, 184], "def_symbols": ["TestConnectionManager_TickerManagement"], "symbols": ["TestConnectionManager_TickerManagement", "tests", "WebSocket", "ticker", "management", "func", "testing", "agent", "createTestAgent", "connectionManager", "Test", "starting", "startWsTicker", "assert", "NotNil", "wsTicker", "Ticker", "should", "created", "stopping", "not", "panic", "NotPanics", "stopWsTicker", "Stopping", "nil", "restarting", "recreated", "resetting", "existing", "firstTicker", "Equal", "Same", "instance", "reused"], "doc_head": "// TestConnectionManager_TickerManagement tests WebSocket ticker management\nfunc TestConnectionManager_TickerManagement(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\t// Test starting ticker\n\tcm.startWsTicker()\n\tassert.NotNil(t, cm.wsTicker, \"Ticker should be created\")\n\t// Test stopping ticker (should not panic)\n\tassert.NotPanics(t, func() {\n\t\tcm.stopWsTicker()\n\t}, \"Stopping ticker should not panic\")\n\t// Test stopping nil ticker (should not panic)\n\tcm.wsTicker = nil\n\tassert.NotPanics(t, func() {\n\t\tcm.stopWsTicker()\n\t}, \"Stopping nil ticker should not panic\")\n\t// Test restarting ticker\n\tcm.startWsTicker()\n\tassert.NotNil(t, cm.wsTicker, \"Ticker should be recreated\")\n\t// Test resetting existing ticker\n\tfirstTicker := cm.wsTicker\n\tcm.startWsTicker()\n\tassert.Equal(t, firstTicker, cm.wsTicker, \"Same ticker instance should be reused\")\n\tcm.stopWsTicker()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 185, "end_line": 214, "text": "// TestConnectionManager_WebSocketConnectionFlow tests WebSocket connection logic\nfunc TestConnectionManager_WebSocketConnectionFlow(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"Skipping WebSocket connection test in short mode\")\n\t}\n\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\n\t// Test WebSocket connection without proper environment\n\terr := cm.startWebSocketConnection()\n\tassert.Error(t, err, \"WebSocket connection should fail without proper environment\")\n\tassert.Equal(t, Disconnected, cm.State, \"State should remain Disconnected after failed connection\")\n\n\t// Test with invalid URL\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"invalid-url\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\n\t// Test with missing token\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"http://localhost:8080\")\n\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\n\t_, err2 := newWebSocketClient(agent)\n\tassert.Error(t, err2, \"WebSocket client creation should fail without token\")\n}\n", "n_tokens": 251, "primary_symbol": "TestConnectionManager_WebSocketConnectionFlow", "primary_kind": "function", "primary_span": [186, 214], "def_symbols": ["TestConnectionManager_WebSocketConnectionFlow"], "symbols": ["TestConnectionManager_WebSocketConnectionFlow", "tests", "WebSocket", "connection", "logic", "func", "testing", "Short", "Skip", "Skipping", "test", "short", "mode", "agent", "createTestAgent", "connectionManager", "Test", "without", "proper", "environment", "err", "startWebSocketConnection", "assert", "Error", "should", "fail", "Equal", "Disconnected", "State", "remain", "after", "failed", "with", "invalid", "URL", "Setenv", "BESZEL_AGENT_HUB_URL", "url", "BESZEL_AGENT_TOKEN", "token", "defer", "Unsetenv", "missing", "http", "localhost", "err2", "newWebSocketClient", "client", "creation"], "doc_head": "// TestConnectionManager_WebSocketConnectionFlow tests WebSocket connection logic\nfunc TestConnectionManager_WebSocketConnectionFlow(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"Skipping WebSocket connection test in short mode\")\n\t}\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\t// Test WebSocket connection without proper environment\n\terr := cm.startWebSocketConnection()\n\tassert.Error(t, err, \"WebSocket connection should fail without proper environment\")\n\tassert.Equal(t, Disconnected, cm.State, \"State should remain Disconnected after failed connection\")\n\t// Test with invalid URL\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"invalid-url\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\t// Test with missing token\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"http://localhost:8080\")\n\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t_, err2 := newWebSocketClient(agent)\n\tassert.Error(t, err2, \"WebSocket client creation should fail without token\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 215, "end_line": 231, "text": "// TestConnectionManager_ReconnectionLogic tests reconnection prevention logic\nfunc TestConnectionManager_ReconnectionLogic(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\tcm.eventChan = make(chan ConnectionEvent, 1)\n\n\t// Test that isConnecting flag prevents duplicate reconnection attempts\n\t// Start from connected state, then simulate disconnect\n\tcm.State = WebSocketConnected\n\tcm.isConnecting = false\n\n\t// First disconnect should trigger reconnection logic\n\tcm.handleStateChange(Disconnected)\n\tassert.Equal(t, Disconnected, cm.State, \"Should change to disconnected\")\n\tassert.True(t, cm.isConnecting, \"Should set isConnecting flag\")\n}\n", "n_tokens": 137, "primary_symbol": "TestConnectionManager_ReconnectionLogic", "primary_kind": "function", "primary_span": [216, 231], "def_symbols": ["TestConnectionManager_ReconnectionLogic"], "symbols": ["TestConnectionManager_ReconnectionLogic", "tests", "reconnection", "prevention", "logic", "func", "testing", "agent", "createTestAgent", "connectionManager", "eventChan", "make", "chan", "ConnectionEvent", "Test", "that", "isConnecting", "flag", "prevents", "duplicate", "attempts", "Start", "from", "connected", "state", "then", "simulate", "disconnect", "State", "WebSocketConnected", "false", "First", "should", "trigger", "handleStateChange", "Disconnected", "assert", "Equal", "Should", "change", "disconnected", "True", "set"], "doc_head": "// TestConnectionManager_ReconnectionLogic tests reconnection prevention logic\nfunc TestConnectionManager_ReconnectionLogic(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\tcm.eventChan = make(chan ConnectionEvent, 1)\n\t// Test that isConnecting flag prevents duplicate reconnection attempts\n\t// Start from connected state, then simulate disconnect\n\tcm.State = WebSocketConnected\n\tcm.isConnecting = false\n\t// First disconnect should trigger reconnection logic\n\tcm.handleStateChange(Disconnected)\n\tassert.Equal(t, Disconnected, cm.State, \"Should change to disconnected\")\n\tassert.True(t, cm.isConnecting, \"Should set isConnecting flag\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 232, "end_line": 265, "text": "// TestConnectionManager_ConnectWithRateLimit tests connection rate limiting\nfunc TestConnectionManager_ConnectWithRateLimit(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\n\t// Set up environment for WebSocket client creation\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"ws://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\n\t// Create WebSocket client\n\twsClient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)\n\tcm.wsClient = wsClient\n\n\t// Set recent connection attempt\n\tcm.wsClient.lastConnectAttempt = time.Now()\n\n\t// Test that connection is rate limited\n\terr = cm.startWebSocketConnection()\n\tassert.Error(t, err, \"Should error due to rate limiting\")\n\tassert.Contains(t, err.Error(), \"already connecting\", \"Error should indicate rate limiting\")\n\n\t// Test connection after rate limit expires\n\tcm.wsClient.lastConnectAttempt = time.Now().Add(-10 * time.Second)\n\terr = cm.startWebSocketConnection()\n\t// This will fail due to no actual server, but should not be rate limited\n\tassert.Error(t, err, \"Connection should fail but not due to rate limiting\")\n\tassert.NotContains(t, err.Error(), \"already connecting\", \"Error should not indicate rate limiting\")\n}\n", "n_tokens": 307, "primary_symbol": "TestConnectionManager_ConnectWithRateLimit", "primary_kind": "function", "primary_span": [233, 265], "def_symbols": ["TestConnectionManager_ConnectWithRateLimit"], "symbols": ["TestConnectionManager_ConnectWithRateLimit", "tests", "connection", "rate", "limiting", "func", "testing", "agent", "createTestAgent", "connectionManager", "Set", "environment", "for", "WebSocket", "client", "creation", "Setenv", "BESZEL_AGENT_HUB_URL", "localhost", "BESZEL_AGENT_TOKEN", "test", "token", "defer", "Unsetenv", "Create", "wsClient", "err", "newWebSocketClient", "require", "NoError", "recent", "attempt", "lastConnectAttempt", "time", "Now", "Test", "that", "limited", "startWebSocketConnection", "assert", "Error", "Should", "error", "due", "Contains", "already", "connecting", "should", "indicate", "after", "limit", "expires", "Add", "Second", "This", "will", "fail", "actual", "server", "but", "not", "Connection", "NotContains"], "doc_head": "// TestConnectionManager_ConnectWithRateLimit tests connection rate limiting\nfunc TestConnectionManager_ConnectWithRateLimit(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\t// Set up environment for WebSocket client creation\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"ws://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\t// Create WebSocket client\n\twsClient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)\n\tcm.wsClient = wsClient\n\t// Set recent connection attempt\n\tcm.wsClient.lastConnectAttempt = time.Now()\n\t// Test that connection is rate limited\n\terr = cm.startWebSocketConnection()\n\tassert.Error(t, err, \"Should error due to rate limiting\")\n\tassert.Contains(t, err.Error(), \"already connecting\", \"Error should indicate rate limiting\")\n\t// Test connection after rate limit expires\n\tcm.wsClient.lastConnectAttempt = time.Now().Add(-10 * time.Second)\n\terr = cm.startWebSocketConnection()\n\t// This will fail due to no actual server, but should not be rate limited\n\tassert.Error(t, err, \"Connection should fail but not due to rate limiting\")\n\tassert.NotCo"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 266, "end_line": 277, "text": "// TestConnectionManager_StartWithInvalidConfig tests starting with invalid configuration\nfunc TestConnectionManager_StartWithInvalidConfig(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\tserverOptions := createTestServerOptions(t)\n\n\t// Test starting when already started\n\tcm.eventChan = make(chan ConnectionEvent, 5)\n\terr := cm.Start(serverOptions)\n\tassert.Error(t, err, \"Should error when starting already started connection manager\")\n}\n", "n_tokens": 95, "primary_symbol": "TestConnectionManager_StartWithInvalidConfig", "primary_kind": "function", "primary_span": [267, 277], "def_symbols": ["TestConnectionManager_StartWithInvalidConfig"], "symbols": ["TestConnectionManager_StartWithInvalidConfig", "tests", "starting", "with", "invalid", "configuration", "func", "testing", "agent", "createTestAgent", "connectionManager", "serverOptions", "createTestServerOptions", "Test", "when", "already", "started", "eventChan", "make", "chan", "ConnectionEvent", "err", "Start", "assert", "Error", "Should", "error", "connection", "manager"], "doc_head": "// TestConnectionManager_StartWithInvalidConfig tests starting with invalid configuration\nfunc TestConnectionManager_StartWithInvalidConfig(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\tserverOptions := createTestServerOptions(t)\n\t// Test starting when already started\n\tcm.eventChan = make(chan ConnectionEvent, 5)\n\terr := cm.Start(serverOptions)\n\tassert.Error(t, err, \"Should error when starting already started connection manager\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 278, "end_line": 305, "text": "// TestConnectionManager_CloseWebSocket tests WebSocket closing\nfunc TestConnectionManager_CloseWebSocket(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\n\t// Test closing when no WebSocket client exists\n\tassert.NotPanics(t, func() {\n\t\tcm.closeWebSocket()\n\t}, \"Should not panic when closing nil WebSocket client\")\n\n\t// Set up environment and create WebSocket client\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"ws://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\n\twsClient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)\n\tcm.wsClient = wsClient\n\n\t// Test closing when WebSocket client exists\n\tassert.NotPanics(t, func() {\n\t\tcm.closeWebSocket()\n\t}, \"Should not panic when closing WebSocket client\")\n}\n", "n_tokens": 211, "primary_symbol": "TestConnectionManager_CloseWebSocket", "primary_kind": "function", "primary_span": [279, 305], "def_symbols": ["TestConnectionManager_CloseWebSocket"], "symbols": ["TestConnectionManager_CloseWebSocket", "tests", "WebSocket", "closing", "func", "testing", "agent", "createTestAgent", "connectionManager", "Test", "when", "client", "exists", "assert", "NotPanics", "closeWebSocket", "Should", "not", "panic", "nil", "Set", "environment", "and", "create", "Setenv", "BESZEL_AGENT_HUB_URL", "localhost", "BESZEL_AGENT_TOKEN", "test", "token", "defer", "Unsetenv", "wsClient", "err", "newWebSocketClient", "require", "NoError"], "doc_head": "// TestConnectionManager_CloseWebSocket tests WebSocket closing\nfunc TestConnectionManager_CloseWebSocket(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\t// Test closing when no WebSocket client exists\n\tassert.NotPanics(t, func() {\n\t\tcm.closeWebSocket()\n\t}, \"Should not panic when closing nil WebSocket client\")\n\t// Set up environment and create WebSocket client\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"ws://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\twsClient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)\n\tcm.wsClient = wsClient\n\t// Test closing when WebSocket client exists\n\tassert.NotPanics(t, func() {\n\t\tcm.closeWebSocket()\n\t}, \"Should not panic when closing WebSocket client\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager_test.go", "rel_path": "agent/connection_manager_test.go", "ext": "go", "language": "go", "chunk_number": 13, "start_line": 306, "end_line": 316, "text": "// TestConnectionManager_ConnectFlow tests the connect method\nfunc TestConnectionManager_ConnectFlow(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\n\t// Test connect without WebSocket client\n\tassert.NotPanics(t, func() {\n\t\tcm.connect()\n\t}, \"Connect should not panic without WebSocket client\")\n}\n", "n_tokens": 72, "primary_symbol": "TestConnectionManager_ConnectFlow", "primary_kind": "function", "primary_span": [307, 316], "def_symbols": ["TestConnectionManager_ConnectFlow"], "symbols": ["TestConnectionManager_ConnectFlow", "tests", "the", "connect", "method", "func", "testing", "agent", "createTestAgent", "connectionManager", "Test", "without", "WebSocket", "client", "assert", "NotPanics", "Connect", "should", "not", "panic"], "doc_head": "// TestConnectionManager_ConnectFlow tests the connect method\nfunc TestConnectionManager_ConnectFlow(t *testing.T) {\n\tagent := createTestAgent(t)\n\tcm := agent.connectionManager\n\t// Test connect without WebSocket client\n\tassert.NotPanics(t, func() {\n\t\tcm.connect()\n\t}, \"Connect should not panic without WebSocket client\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go", "rel_path": "agent/data_dir_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 15, "text": "//go:build testing\n// +build testing\n\npackage agent\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n", "n_tokens": 46, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 15], "def_symbols": [], "symbols": ["build", "testing", "package", "agent", "import", "path", "filepath", "runtime", "github", "com", "stretchr", "testify", "assert", "require"], "doc_head": "//go:build testing\n// +build testing\npackage agent\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go", "rel_path": "agent/data_dir_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 16, "end_line": 90, "text": "func TestGetDataDir(t *testing.T) {\n\t// Test with explicit dataDir parameter\n\tt.Run(\"explicit data dir\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tresult, err := getDataDir(tempDir)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tempDir, result)\n\t})\n\n\t// Test with explicit non-existent dataDir that can be created\n\tt.Run(\"explicit data dir - create new\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnewDir := filepath.Join(tempDir, \"new-data-dir\")\n\t\tresult, err := getDataDir(newDir)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, newDir, result)\n\n\t\t// Verify directory was created\n\t\tstat, err := os.Stat(newDir)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, stat.IsDir())\n\t})\n\n\t// Test with DATA_DIR environment variable\n\tt.Run(\"DATA_DIR environment variable\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\n\t\t// Set environment variable\n\t\toldValue := os.Getenv(\"DATA_DIR\")\n\t\tdefer func() {\n\t\t\tif oldValue == \"\" {\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_DATA_DIR\")\n\t\t\t} else {\n\t\t\t\tos.Setenv(\"BESZEL_AGENT_DATA_DIR\", oldValue)\n\t\t\t}\n\t\t}()\n\n\t\tos.Setenv(\"BESZEL_AGENT_DATA_DIR\", tempDir)\n\n\t\tresult, err := getDataDir()\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tempDir, result)\n\t})\n\n\t// Test with invalid explicit dataDir\n\tt.Run(\"invalid explicit data dir\", func(t *testing.T) {\n\t\tinvalidPath := \"/invalid/path/that/cannot/be/created\"\n\t\t_, err := getDataDir(invalidPath)\n\t\tassert.Error(t, err)\n\t})\n\n\t// Test fallback behavior (empty dataDir, no env var)\n\tt.Run(\"fallback to default directories\", func(t *testing.T) {\n\t\t// Clear DATA_DIR environment variable\n\t\toldValue := os.Getenv(\"DATA_DIR\")\n\t\tdefer func() {\n\t\t\tif oldValue == \"\" {\n\t\t\t\tos.Unsetenv(\"DATA_DIR\")\n\t\t\t} else {\n\t\t\t\tos.Setenv(\"DATA_DIR\", oldValue)\n\t\t\t}\n\t\t}()\n\t\tos.Unsetenv(\"DATA_DIR\")\n\n\t\t// This will try platform-specific defaults, which may or may not work\n\t\t// We're mainly testing that it doesn't panic and returns some result\n\t\tresult, err := getDataDir()\n\t\t// We don't assert success/failure here since it depends on system permissions\n\t\t// Just verify we get a string result if no error\n\t\tif err == nil {\n\t\t\tassert.NotEmpty(t, result)\n\t\t}\n\t})\n}\n", "n_tokens": 581, "primary_symbol": "TestGetDataDir", "primary_kind": "function", "primary_span": [16, 90], "def_symbols": ["TestGetDataDir"], "symbols": ["TestGetDataDir", "func", "testing", "Test", "with", "explicit", "dataDir", "parameter", "Run", "data", "dir", "tempDir", "TempDir", "result", "err", "getDataDir", "require", "NoError", "assert", "Equal", "non", "existent", "that", "can", "created", "create", "new", "newDir", "filepath", "Join", "Verify", "directory", "was", "stat", "Stat", "True", "IsDir", "DATA_DIR", "environment", "variable", "Set", "oldValue", "Getenv", "defer", "Unsetenv", "BESZEL_AGENT_DATA_DIR", "else", "Setenv", "invalid", "invalidPath", "path", "cannot", "Error", "fallback", "behavior", "empty", "env", "var", "default", "directories", "Clear", "This", "will", "try", "platform", "specific", "defaults", "which", "may", "not", "work", "mainly", "doesn", "panic", "and", "returns", "some", "don", "success", "failure", "here", "since", "depends", "system", "permissions", "Just", "verify", "get", "string", "error", "nil", "NotEmpty"], "doc_head": "func TestGetDataDir(t *testing.T) {\n\t// Test with explicit dataDir parameter\n\tt.Run(\"explicit data dir\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tresult, err := getDataDir(tempDir)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tempDir, result)\n\t})\n\t// Test with explicit non-existent dataDir that can be created\n\tt.Run(\"explicit data dir - create new\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnewDir := filepath.Join(tempDir, \"new-data-dir\")\n\t\tresult, err := getDataDir(newDir)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, newDir, result)\n\t\t// Verify directory was created\n\t\tstat, err := os.Stat(newDir)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, stat.IsDir())\n\t})\n\t// Test with DATA_DIR environment variable\n\tt.Run(\"DATA_DIR environment variable\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\t// Set environment variable\n\t\toldValue := os.Getenv(\"DATA_DIR\")\n\t\tdefer func() {\n\t\t\tif oldValue == \"\" {\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_DATA_DIR\")\n\t\t\t} else {\n\t\t\t\tos.Setenv(\"BESZEL_AGENT_DATA_DIR\", oldValue)\n\t\t\t}\n\t\t}()\n\t\tos.Setenv(\"BESZEL_AGENT_DATA_DIR\", tempDir)\n\t\tresult, err := getDataDir()\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tempDir, result)\n\t})\n\t// Test with invalid explicit da"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go", "rel_path": "agent/data_dir_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 91, "end_line": 140, "text": "func TestTestDataDirs(t *testing.T) {\n\t// Test with existing valid directory\n\tt.Run(\"existing valid directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tresult, err := testDataDirs([]string{tempDir})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tempDir, result)\n\t})\n\n\t// Test with multiple directories, first one valid\n\tt.Run(\"multiple dirs - first valid\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tinvalidDir := \"/invalid/path\"\n\t\tresult, err := testDataDirs([]string{tempDir, invalidDir})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tempDir, result)\n\t})\n\n\t// Test with multiple directories, second one valid\n\tt.Run(\"multiple dirs - second valid\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tinvalidDir := \"/invalid/path\"\n\t\tresult, err := testDataDirs([]string{invalidDir, tempDir})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tempDir, result)\n\t})\n\n\t// Test with non-existing directory that can be created\n\tt.Run(\"create new directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnewDir := filepath.Join(tempDir, \"new-dir\")\n\t\tresult, err := testDataDirs([]string{newDir})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, newDir, result)\n\n\t\t// Verify directory was created\n\t\tstat, err := os.Stat(newDir)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, stat.IsDir())\n\t})\n\n\t// Test with no valid directories\n\tt.Run(\"no valid directories\", func(t *testing.T) {\n\t\tinvalidPaths := []string{\"/invalid/path1\", \"/invalid/path2\"}\n\t\t_, err := testDataDirs(invalidPaths)\n\t\tassert.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"data directory not found\")\n\t})\n}\n", "n_tokens": 418, "primary_symbol": "TestTestDataDirs", "primary_kind": "function", "primary_span": [91, 140], "def_symbols": ["TestTestDataDirs"], "symbols": ["TestTestDataDirs", "func", "testing", "Test", "with", "existing", "valid", "directory", "Run", "tempDir", "TempDir", "result", "err", "testDataDirs", "string", "require", "NoError", "assert", "Equal", "multiple", "directories", "first", "one", "dirs", "invalidDir", "invalid", "path", "second", "non", "that", "can", "created", "create", "new", "newDir", "filepath", "Join", "dir", "Verify", "was", "stat", "Stat", "True", "IsDir", "invalidPaths", "path1", "path2", "Error", "Contains", "data", "not", "found"], "doc_head": "func TestTestDataDirs(t *testing.T) {\n\t// Test with existing valid directory\n\tt.Run(\"existing valid directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tresult, err := testDataDirs([]string{tempDir})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tempDir, result)\n\t})\n\t// Test with multiple directories, first one valid\n\tt.Run(\"multiple dirs - first valid\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tinvalidDir := \"/invalid/path\"\n\t\tresult, err := testDataDirs([]string{tempDir, invalidDir})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tempDir, result)\n\t})\n\t// Test with multiple directories, second one valid\n\tt.Run(\"multiple dirs - second valid\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tinvalidDir := \"/invalid/path\"\n\t\tresult, err := testDataDirs([]string{invalidDir, tempDir})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, tempDir, result)\n\t})\n\t// Test with non-existing directory that can be created\n\tt.Run(\"create new directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnewDir := filepath.Join(tempDir, \"new-dir\")\n\t\tresult, err := testDataDirs([]string{newDir})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, newDir, result)\n\t\t// Verify directory was created\n\t\tstat, err := o"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go", "rel_path": "agent/data_dir_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 141, "end_line": 186, "text": "func TestIsValidDataDir(t *testing.T) {\n\t// Test with existing directory\n\tt.Run(\"existing directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tvalid, err := isValidDataDir(tempDir, false)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, valid)\n\t})\n\n\t// Test with non-existing directory, createIfNotExists=false\n\tt.Run(\"non-existing dir - no create\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnonExistentDir := filepath.Join(tempDir, \"does-not-exist\")\n\t\tvalid, err := isValidDataDir(nonExistentDir, false)\n\t\trequire.NoError(t, err)\n\t\tassert.False(t, valid)\n\t})\n\n\t// Test with non-existing directory, createIfNotExists=true\n\tt.Run(\"non-existing dir - create\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnewDir := filepath.Join(tempDir, \"new-dir\")\n\t\tvalid, err := isValidDataDir(newDir, true)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, valid)\n\n\t\t// Verify directory was created\n\t\tstat, err := os.Stat(newDir)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, stat.IsDir())\n\t})\n\n\t// Test with file instead of directory\n\tt.Run(\"file instead of directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\ttempFile := filepath.Join(tempDir, \"testfile\")\n\t\terr := os.WriteFile(tempFile, []byte(\"test\"), 0644)\n\t\trequire.NoError(t, err)\n\n\t\tvalid, err := isValidDataDir(tempFile, false)\n\t\tassert.Error(t, err)\n\t\tassert.False(t, valid)\n\t\tassert.Contains(t, err.Error(), \"is not a directory\")\n\t})\n}\n", "n_tokens": 384, "primary_symbol": "TestIsValidDataDir", "primary_kind": "function", "primary_span": [141, 186], "def_symbols": ["TestIsValidDataDir"], "symbols": ["TestIsValidDataDir", "func", "testing", "Test", "with", "existing", "directory", "Run", "tempDir", "TempDir", "valid", "err", "isValidDataDir", "false", "require", "NoError", "assert", "True", "non", "createIfNotExists", "dir", "create", "nonExistentDir", "filepath", "Join", "does", "not", "exist", "False", "true", "newDir", "new", "Verify", "was", "created", "stat", "Stat", "IsDir", "file", "instead", "tempFile", "testfile", "WriteFile", "byte", "test", "Error", "Contains"], "doc_head": "func TestIsValidDataDir(t *testing.T) {\n\t// Test with existing directory\n\tt.Run(\"existing directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tvalid, err := isValidDataDir(tempDir, false)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, valid)\n\t})\n\t// Test with non-existing directory, createIfNotExists=false\n\tt.Run(\"non-existing dir - no create\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnonExistentDir := filepath.Join(tempDir, \"does-not-exist\")\n\t\tvalid, err := isValidDataDir(nonExistentDir, false)\n\t\trequire.NoError(t, err)\n\t\tassert.False(t, valid)\n\t})\n\t// Test with non-existing directory, createIfNotExists=true\n\tt.Run(\"non-existing dir - create\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnewDir := filepath.Join(tempDir, \"new-dir\")\n\t\tvalid, err := isValidDataDir(newDir, true)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, valid)\n\t\t// Verify directory was created\n\t\tstat, err := os.Stat(newDir)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, stat.IsDir())\n\t})\n\t// Test with file instead of directory\n\tt.Run(\"file instead of directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\ttempFile := filepath.Join(tempDir, \"testfile\")\n\t\terr := os.WriteFile(tempFile, []byte(\"test\"), 0644)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go", "rel_path": "agent/data_dir_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 187, "end_line": 218, "text": "func TestDirectoryExists(t *testing.T) {\n\t// Test with existing directory\n\tt.Run(\"existing directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\texists, err := directoryExists(tempDir)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, exists)\n\t})\n\n\t// Test with non-existing directory\n\tt.Run(\"non-existing directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnonExistentDir := filepath.Join(tempDir, \"does-not-exist\")\n\t\texists, err := directoryExists(nonExistentDir)\n\t\trequire.NoError(t, err)\n\t\tassert.False(t, exists)\n\t})\n\n\t// Test with file instead of directory\n\tt.Run(\"file instead of directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\ttempFile := filepath.Join(tempDir, \"testfile\")\n\t\terr := os.WriteFile(tempFile, []byte(\"test\"), 0644)\n\t\trequire.NoError(t, err)\n\n\t\texists, err := directoryExists(tempFile)\n\t\tassert.Error(t, err)\n\t\tassert.False(t, exists)\n\t\tassert.Contains(t, err.Error(), \"is not a directory\")\n\t})\n}\n", "n_tokens": 254, "primary_symbol": "TestDirectoryExists", "primary_kind": "function", "primary_span": [187, 218], "def_symbols": ["TestDirectoryExists"], "symbols": ["TestDirectoryExists", "func", "testing", "Test", "with", "existing", "directory", "Run", "tempDir", "TempDir", "exists", "err", "directoryExists", "require", "NoError", "assert", "True", "non", "nonExistentDir", "filepath", "Join", "does", "not", "exist", "False", "file", "instead", "tempFile", "testfile", "WriteFile", "byte", "test", "Error", "Contains"], "doc_head": "func TestDirectoryExists(t *testing.T) {\n\t// Test with existing directory\n\tt.Run(\"existing directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\texists, err := directoryExists(tempDir)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, exists)\n\t})\n\t// Test with non-existing directory\n\tt.Run(\"non-existing directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnonExistentDir := filepath.Join(tempDir, \"does-not-exist\")\n\t\texists, err := directoryExists(nonExistentDir)\n\t\trequire.NoError(t, err)\n\t\tassert.False(t, exists)\n\t})\n\t// Test with file instead of directory\n\tt.Run(\"file instead of directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\ttempFile := filepath.Join(tempDir, \"testfile\")\n\t\terr := os.WriteFile(tempFile, []byte(\"test\"), 0644)\n\t\trequire.NoError(t, err)\n\t\texists, err := directoryExists(tempFile)\n\t\tassert.Error(t, err)\n\t\tassert.False(t, exists)\n\t\tassert.Contains(t, err.Error(), \"is not a directory\")\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir_test.go", "rel_path": "agent/data_dir_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 219, "end_line": 264, "text": "func TestDirectoryIsWritable(t *testing.T) {\n\t// Test with writable directory\n\tt.Run(\"writable directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\twritable, err := directoryIsWritable(tempDir)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, writable)\n\t})\n\n\t// Test with non-existing directory\n\tt.Run(\"non-existing directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnonExistentDir := filepath.Join(tempDir, \"does-not-exist\")\n\t\twritable, err := directoryIsWritable(nonExistentDir)\n\t\tassert.Error(t, err)\n\t\tassert.False(t, writable)\n\t})\n\n\t// Test with non-writable directory (Unix-like systems only)\n\tt.Run(\"non-writable directory\", func(t *testing.T) {\n\t\tif runtime.GOOS != \"linux\" && runtime.GOOS != \"darwin\" {\n\t\t\tt.Skip(\"Skipping non-writable directory test on\", runtime.GOOS)\n\t\t}\n\n\t\ttempDir := t.TempDir()\n\t\treadOnlyDir := filepath.Join(tempDir, \"readonly\")\n\n\t\t// Create the directory\n\t\terr := os.Mkdir(readOnlyDir, 0755)\n\t\trequire.NoError(t, err)\n\n\t\t// Make it read-only\n\t\terr = os.Chmod(readOnlyDir, 0444)\n\t\trequire.NoError(t, err)\n\n\t\t// Restore permissions after test for cleanup\n\t\tdefer func() {\n\t\t\tos.Chmod(readOnlyDir, 0755)\n\t\t}()\n\n\t\twritable, err := directoryIsWritable(readOnlyDir)\n\t\tassert.Error(t, err)\n\t\tassert.False(t, writable)\n\t})\n}\n", "n_tokens": 350, "primary_symbol": "TestDirectoryIsWritable", "primary_kind": "function", "primary_span": [219, 264], "def_symbols": ["TestDirectoryIsWritable"], "symbols": ["TestDirectoryIsWritable", "func", "testing", "Test", "with", "writable", "directory", "Run", "tempDir", "TempDir", "err", "directoryIsWritable", "require", "NoError", "assert", "True", "non", "existing", "nonExistentDir", "filepath", "Join", "does", "not", "exist", "Error", "False", "Unix", "like", "systems", "only", "runtime", "GOOS", "linux", "darwin", "Skip", "Skipping", "test", "readOnlyDir", "readonly", "Create", "the", "Mkdir", "Make", "read", "Chmod", "Restore", "permissions", "after", "for", "cleanup", "defer"], "doc_head": "func TestDirectoryIsWritable(t *testing.T) {\n\t// Test with writable directory\n\tt.Run(\"writable directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\twritable, err := directoryIsWritable(tempDir)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, writable)\n\t})\n\t// Test with non-existing directory\n\tt.Run(\"non-existing directory\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\tnonExistentDir := filepath.Join(tempDir, \"does-not-exist\")\n\t\twritable, err := directoryIsWritable(nonExistentDir)\n\t\tassert.Error(t, err)\n\t\tassert.False(t, writable)\n\t})\n\t// Test with non-writable directory (Unix-like systems only)\n\tt.Run(\"non-writable directory\", func(t *testing.T) {\n\t\tif runtime.GOOS != \"linux\" && runtime.GOOS != \"darwin\" {\n\t\t\tt.Skip(\"Skipping non-writable directory test on\", runtime.GOOS)\n\t\t}\n\t\ttempDir := t.TempDir()\n\t\treadOnlyDir := filepath.Join(tempDir, \"readonly\")\n\t\t// Create the directory\n\t\terr := os.Mkdir(readOnlyDir, 0755)\n\t\trequire.NoError(t, err)\n\t\t// Make it read-only\n\t\terr = os.Chmod(readOnlyDir, 0444)\n\t\trequire.NoError(t, err)\n\t\t// Restore permissions after test for cleanup\n\t\tdefer func() {\n\t\t\tos.Chmod(readOnlyDir, 0755)\n\t\t}()\n\t\twritable, err := directoryIsWritable(readOnlyDir)\n\t\tas"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir.go", "rel_path": "agent/data_dir.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 10, "text": "package agent\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n)\n", "n_tokens": 23, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 10], "def_symbols": [], "symbols": ["package", "agent", "import", "errors", "fmt", "path", "filepath", "runtime"], "doc_head": "package agent\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir.go", "rel_path": "agent/data_dir.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 11, "end_line": 37, "text": "// getDataDir returns the path to the data directory for the agent and an error\n// if the directory is not valid. Attempts to find the optimal data directory if\n// no data directories are provided.\nfunc getDataDir(dataDirs ...string) (string, error) {\n\tif len(dataDirs) > 0 {\n\t\treturn testDataDirs(dataDirs)\n\t}\n\n\tdataDir, _ := GetEnv(\"DATA_DIR\")\n\tif dataDir != \"\" {\n\t\tdataDirs = append(dataDirs, dataDir)\n\t}\n\n\tif runtime.GOOS == \"windows\" {\n\t\tdataDirs = append(dataDirs,\n\t\t\tfilepath.Join(os.Getenv(\"APPDATA\"), \"beszel-agent\"),\n\t\t\tfilepath.Join(os.Getenv(\"LOCALAPPDATA\"), \"beszel-agent\"),\n\t\t)\n\t} else {\n\t\tdataDirs = append(dataDirs, \"/var/lib/beszel-agent\")\n\t\tif homeDir, err := os.UserHomeDir(); err == nil {\n\t\t\tdataDirs = append(dataDirs, filepath.Join(homeDir, \".config\", \"beszel\"))\n\t\t}\n\t}\n\treturn testDataDirs(dataDirs)\n}\n", "n_tokens": 222, "primary_symbol": "getDataDir", "primary_kind": "function", "primary_span": [14, 37], "def_symbols": ["getDataDir"], "symbols": ["getDataDir", "returns", "the", "path", "data", "directory", "for", "agent", "and", "error", "not", "valid", "Attempts", "find", "optimal", "directories", "are", "provided", "func", "dataDirs", "string", "len", "return", "testDataDirs", "dataDir", "GetEnv", "DATA_DIR", "append", "runtime", "GOOS", "windows", "filepath", "Join", "Getenv", "APPDATA", "beszel", "LOCALAPPDATA", "else", "var", "lib", "homeDir", "err", "UserHomeDir", "nil", "config"], "doc_head": "// getDataDir returns the path to the data directory for the agent and an error\n// if the directory is not valid. Attempts to find the optimal data directory if\n// no data directories are provided.\nfunc getDataDir(dataDirs ...string) (string, error) {\n\tif len(dataDirs) > 0 {\n\t\treturn testDataDirs(dataDirs)\n\t}\n\tdataDir, _ := GetEnv(\"DATA_DIR\")\n\tif dataDir != \"\" {\n\t\tdataDirs = append(dataDirs, dataDir)\n\t}\n\tif runtime.GOOS == \"windows\" {\n\t\tdataDirs = append(dataDirs,\n\t\t\tfilepath.Join(os.Getenv(\"APPDATA\"), \"beszel-agent\"),\n\t\t\tfilepath.Join(os.Getenv(\"LOCALAPPDATA\"), \"beszel-agent\"),\n\t\t)\n\t} else {\n\t\tdataDirs = append(dataDirs, \"/var/lib/beszel-agent\")\n\t\tif homeDir, err := os.UserHomeDir(); err == nil {\n\t\t\tdataDirs = append(dataDirs, filepath.Join(homeDir, \".config\", \"beszel\"))\n\t\t}\n\t}\n\treturn testDataDirs(dataDirs)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir.go", "rel_path": "agent/data_dir.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 38, "end_line": 67, "text": "func testDataDirs(paths []string) (string, error) {\n\t// first check if the directory exists and is writable\n\tfor _, path := range paths {\n\t\tif valid, _ := isValidDataDir(path, false); valid {\n\t\t\treturn path, nil\n\t\t}\n\t}\n\t// if the directory doesn't exist, try to create it\n\tfor _, path := range paths {\n\t\texists, _ := directoryExists(path)\n\t\tif exists {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := os.MkdirAll(path, 0755); err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Verify the created directory is actually writable\n\t\twritable, _ := directoryIsWritable(path)\n\t\tif !writable {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn path, nil\n\t}\n\n\treturn \"\", errors.New(\"data directory not found\")\n}\n", "n_tokens": 176, "primary_symbol": "testDataDirs", "primary_kind": "function", "primary_span": [38, 67], "def_symbols": ["testDataDirs"], "symbols": ["testDataDirs", "func", "paths", "string", "error", "first", "check", "the", "directory", "exists", "and", "writable", "for", "path", "range", "valid", "isValidDataDir", "false", "return", "nil", "doesn", "exist", "try", "create", "directoryExists", "continue", "err", "MkdirAll", "Verify", "created", "actually", "directoryIsWritable", "errors", "New", "data", "not", "found"], "doc_head": "func testDataDirs(paths []string) (string, error) {\n\t// first check if the directory exists and is writable\n\tfor _, path := range paths {\n\t\tif valid, _ := isValidDataDir(path, false); valid {\n\t\t\treturn path, nil\n\t\t}\n\t}\n\t// if the directory doesn't exist, try to create it\n\tfor _, path := range paths {\n\t\texists, _ := directoryExists(path)\n\t\tif exists {\n\t\t\tcontinue\n\t\t}\n\t\tif err := os.MkdirAll(path, 0755); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t// Verify the created directory is actually writable\n\t\twritable, _ := directoryIsWritable(path)\n\t\tif !writable {\n\t\t\tcontinue\n\t\t}\n\t\treturn path, nil\n\t}\n\treturn \"\", errors.New(\"data directory not found\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir.go", "rel_path": "agent/data_dir.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 68, "end_line": 90, "text": "func isValidDataDir(path string, createIfNotExists bool) (bool, error) {\n\texists, err := directoryExists(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif !exists {\n\t\tif !createIfNotExists {\n\t\t\treturn false, nil\n\t\t}\n\t\tif err = os.MkdirAll(path, 0755); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\t// Always check if the directory is writable\n\twritable, err := directoryIsWritable(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn writable, nil\n}\n", "n_tokens": 130, "primary_symbol": "isValidDataDir", "primary_kind": "function", "primary_span": [68, 90], "def_symbols": ["isValidDataDir"], "symbols": ["isValidDataDir", "func", "path", "string", "createIfNotExists", "bool", "error", "exists", "err", "directoryExists", "nil", "return", "false", "MkdirAll", "Always", "check", "the", "directory", "writable", "directoryIsWritable"], "doc_head": "func isValidDataDir(path string, createIfNotExists bool) (bool, error) {\n\texists, err := directoryExists(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif !exists {\n\t\tif !createIfNotExists {\n\t\t\treturn false, nil\n\t\t}\n\t\tif err = os.MkdirAll(path, 0755); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\t// Always check if the directory is writable\n\twritable, err := directoryIsWritable(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn writable, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/data_dir.go", "rel_path": "agent/data_dir.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 91, "end_line": 118, "text": "// directoryExists checks if a directory exists\nfunc directoryExists(path string) (bool, error) {\n\t// Check if directory exists\n\tstat, err := os.Stat(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\tif !stat.IsDir() {\n\t\treturn false, fmt.Errorf(\"%s is not a directory\", path)\n\t}\n\treturn true, nil\n}\n\n// directoryIsWritable tests if a directory is writable by creating and removing a temporary file\nfunc directoryIsWritable(path string) (bool, error) {\n\ttestFile := filepath.Join(path, \".write-test\")\n\tfile, err := os.Create(testFile)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer file.Close()\n\tdefer os.Remove(testFile)\n\treturn true, nil\n}\n", "n_tokens": 176, "primary_symbol": "directoryExists", "primary_kind": "function", "primary_span": [92, 118], "def_symbols": ["directoryExists", "directoryIsWritable"], "symbols": ["directoryExists", "directoryIsWritable", "checks", "directory", "exists", "func", "path", "string", "bool", "error", "Check", "stat", "err", "Stat", "nil", "IsNotExist", "return", "false", "IsDir", "fmt", "Errorf", "not", "true", "tests", "writable", "creating", "and", "removing", "temporary", "file", "testFile", "filepath", "Join", "write", "test", "Create", "defer", "Close", "Remove"], "doc_head": "// directoryExists checks if a directory exists\nfunc directoryExists(path string) (bool, error) {\n\t// Check if directory exists\n\tstat, err := os.Stat(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\tif !stat.IsDir() {\n\t\treturn false, fmt.Errorf(\"%s is not a directory\", path)\n\t}\n\treturn true, nil\n}\n// directoryIsWritable tests if a directory is writable by creating and removing a temporary file\nfunc directoryIsWritable(path string) (bool, error) {\n\ttestFile := filepath.Join(path, \".write-test\")\n\tfile, err := os.Create(testFile)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer file.Close()\n\tdefer os.Remove(testFile)\n\treturn true, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 27, "text": "package agent\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/common\"\n\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/lxzan/gws\"\n\t\"golang.org/x/crypto/ssh\"\n)\n\nconst (\n\twsDeadline = 70 * time.Second\n)\n", "n_tokens": 112, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 27], "def_symbols": [], "symbols": ["package", "agent", "import", "crypto", "tls", "errors", "fmt", "log", "slog", "net", "http", "url", "path", "strings", "time", "github", "com", "henrygd", "beszel", "src", "common", "fxamacker", "cbor", "lxzan", "gws", "golang", "org", "ssh", "const", "wsDeadline", "Second"], "doc_head": "package agent\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/common\"\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/lxzan/gws\"\n\t\"golang.org/x/crypto/ssh\"\n)\nconst (\n\twsDeadline = 70 * time.Second\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 28, "end_line": 42, "text": "// WebSocketClient manages the WebSocket connection between the agent and hub.\n// It handles authentication, message routing, and connection lifecycle management.\ntype WebSocketClient struct {\n\tgws.BuiltinEventHandler\n\toptions            *gws.ClientOption                   // WebSocket client configuration options\n\tagent              *Agent                              // Reference to the parent agent\n\tConn               *gws.Conn                           // Active WebSocket connection\n\thubURL             *url.URL                            // Parsed hub URL for connection\n\ttoken              string                              // Authentication token for hub registration\n\tfingerprint        string                              // System fingerprint for identification\n\thubRequest         *common.HubRequest[cbor.RawMessage] // Reusable request structure for message parsing\n\tlastConnectAttempt time.Time                           // Timestamp of last connection attempt\n\thubVerified        bool                                // Whether the hub has been cryptographically verified\n}\n", "n_tokens": 169, "primary_symbol": "", "primary_kind": "", "primary_span": [28, 42], "def_symbols": [], "symbols": ["WebSocketClient", "manages", "the", "WebSocket", "connection", "between", "agent", "and", "hub", "handles", "authentication", "message", "routing", "lifecycle", "management", "type", "struct", "gws", "BuiltinEventHandler", "options", "ClientOption", "client", "configuration", "Agent", "Reference", "parent", "Conn", "Active", "hubURL", "url", "URL", "Parsed", "for", "token", "string", "Authentication", "registration", "fingerprint", "System", "identification", "hubRequest", "common", "HubRequest", "cbor", "RawMessage", "Reusable", "request", "structure", "parsing", "lastConnectAttempt", "time", "Time", "Timestamp", "last", "attempt", "hubVerified", "bool", "Whether", "has", "been", "cryptographically", "verified"], "doc_head": "// WebSocketClient manages the WebSocket connection between the agent and hub.\n// It handles authentication, message routing, and connection lifecycle management.\ntype WebSocketClient struct {\n\tgws.BuiltinEventHandler\n\toptions            *gws.ClientOption                   // WebSocket client configuration options\n\tagent              *Agent                              // Reference to the parent agent\n\tConn               *gws.Conn                           // Active WebSocket connection\n\thubURL             *url.URL                            // Parsed hub URL for connection\n\ttoken              string                              // Authentication token for hub registration\n\tfingerprint        string                              // System fingerprint for identification\n\thubRequest         *common.HubRequest[cbor.RawMessage] // Reusable request structure for message parsing\n\tlastConnectAttempt time.Time                           // Timestamp of last connection attempt\n\thubVerified        bool                                // Whether the hub has been cryptographically verified\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 43, "end_line": 69, "text": "// newWebSocketClient creates a new WebSocket client for the given agent.\n// It reads configuration from environment variables and validates the hub URL.\nfunc newWebSocketClient(agent *Agent) (client *WebSocketClient, err error) {\n\thubURLStr, exists := GetEnv(\"HUB_URL\")\n\tif !exists {\n\t\treturn nil, errors.New(\"HUB_URL environment variable not set\")\n\t}\n\n\tclient = &WebSocketClient{}\n\n\tclient.hubURL, err = url.Parse(hubURLStr)\n\tif err != nil {\n\t\treturn nil, errors.New(\"invalid hub URL\")\n\t}\n\t// get registration token\n\tclient.token, err = getToken()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient.agent = agent\n\tclient.hubRequest = &common.HubRequest[cbor.RawMessage]{}\n\tclient.fingerprint = agent.getFingerprint()\n\n\treturn client, nil\n}\n", "n_tokens": 181, "primary_symbol": "newWebSocketClient", "primary_kind": "function", "primary_span": [45, 69], "def_symbols": ["newWebSocketClient"], "symbols": ["newWebSocketClient", "creates", "new", "WebSocket", "client", "for", "the", "given", "agent", "reads", "configuration", "from", "environment", "variables", "and", "validates", "hub", "URL", "func", "Agent", "WebSocketClient", "err", "error", "hubURLStr", "exists", "GetEnv", "HUB_URL", "return", "nil", "errors", "New", "variable", "not", "set", "hubURL", "url", "Parse", "invalid", "get", "registration", "token", "getToken", "hubRequest", "common", "HubRequest", "cbor", "RawMessage", "fingerprint", "getFingerprint"], "doc_head": "// newWebSocketClient creates a new WebSocket client for the given agent.\n// It reads configuration from environment variables and validates the hub URL.\nfunc newWebSocketClient(agent *Agent) (client *WebSocketClient, err error) {\n\thubURLStr, exists := GetEnv(\"HUB_URL\")\n\tif !exists {\n\t\treturn nil, errors.New(\"HUB_URL environment variable not set\")\n\t}\n\tclient = &WebSocketClient{}\n\tclient.hubURL, err = url.Parse(hubURLStr)\n\tif err != nil {\n\t\treturn nil, errors.New(\"invalid hub URL\")\n\t}\n\t// get registration token\n\tclient.token, err = getToken()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient.agent = agent\n\tclient.hubRequest = &common.HubRequest[cbor.RawMessage]{}\n\tclient.fingerprint = agent.getFingerprint()\n\treturn client, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 70, "end_line": 90, "text": "// getToken returns the token for the WebSocket client.\n// It first checks the TOKEN environment variable, then the TOKEN_FILE environment variable.\n// If neither is set, it returns an error.\nfunc getToken() (string, error) {\n\t// get token from env var\n\ttoken, _ := GetEnv(\"TOKEN\")\n\tif token != \"\" {\n\t\treturn token, nil\n\t}\n\t// get token from file\n\ttokenFile, _ := GetEnv(\"TOKEN_FILE\")\n\tif tokenFile == \"\" {\n\t\treturn \"\", errors.New(\"must set TOKEN or TOKEN_FILE\")\n\t}\n\ttokenBytes, err := os.ReadFile(tokenFile)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(tokenBytes), nil\n}\n", "n_tokens": 145, "primary_symbol": "getToken", "primary_kind": "function", "primary_span": [73, 90], "def_symbols": ["getToken"], "symbols": ["getToken", "returns", "the", "token", "for", "WebSocket", "client", "first", "checks", "TOKEN", "environment", "variable", "then", "TOKEN_FILE", "neither", "set", "error", "func", "string", "get", "from", "env", "var", "GetEnv", "return", "nil", "file", "tokenFile", "errors", "New", "must", "tokenBytes", "err", "ReadFile"], "doc_head": "// getToken returns the token for the WebSocket client.\n// It first checks the TOKEN environment variable, then the TOKEN_FILE environment variable.\n// If neither is set, it returns an error.\nfunc getToken() (string, error) {\n\t// get token from env var\n\ttoken, _ := GetEnv(\"TOKEN\")\n\tif token != \"\" {\n\t\treturn token, nil\n\t}\n\t// get token from file\n\ttokenFile, _ := GetEnv(\"TOKEN_FILE\")\n\tif tokenFile == \"\" {\n\t\treturn \"\", errors.New(\"must set TOKEN or TOKEN_FILE\")\n\t}\n\ttokenBytes, err := os.ReadFile(tokenFile)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(tokenBytes), nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 91, "end_line": 117, "text": "// getOptions returns the WebSocket client options, creating them if necessary.\n// It configures the connection URL, TLS settings, and authentication headers.\nfunc (client *WebSocketClient) getOptions() *gws.ClientOption {\n\tif client.options != nil {\n\t\treturn client.options\n\t}\n\n\t// update the hub url to use websocket scheme and api path\n\tif client.hubURL.Scheme == \"https\" {\n\t\tclient.hubURL.Scheme = \"wss\"\n\t} else {\n\t\tclient.hubURL.Scheme = \"ws\"\n\t}\n\tclient.hubURL.Path = path.Join(client.hubURL.Path, \"api/beszel/agent-connect\")\n\n\tclient.options = &gws.ClientOption{\n\t\tAddr:      client.hubURL.String(),\n\t\tTlsConfig: &tls.Config{InsecureSkipVerify: true},\n\t\tRequestHeader: http.Header{\n\t\t\t\"User-Agent\": []string{getUserAgent()},\n\t\t\t\"X-Token\":    []string{client.token},\n\t\t\t\"X-Beszel\":   []string{beszel.Version},\n\t\t},\n\t}\n\treturn client.options\n}\n", "n_tokens": 227, "primary_symbol": "getOptions", "primary_kind": "function", "primary_span": [93, 117], "def_symbols": ["getOptions"], "symbols": ["getOptions", "returns", "the", "WebSocket", "client", "options", "creating", "them", "necessary", "configures", "connection", "URL", "TLS", "settings", "and", "authentication", "headers", "func", "WebSocketClient", "gws", "ClientOption", "nil", "return", "update", "hub", "url", "use", "websocket", "scheme", "api", "path", "hubURL", "Scheme", "https", "wss", "else", "Path", "Join", "beszel", "agent", "connect", "Addr", "String", "TlsConfig", "tls", "Config", "InsecureSkipVerify", "true", "RequestHeader", "http", "Header", "User", "Agent", "string", "getUserAgent", "Token", "token", "Beszel", "Version"], "doc_head": "// getOptions returns the WebSocket client options, creating them if necessary.\n// It configures the connection URL, TLS settings, and authentication headers.\nfunc (client *WebSocketClient) getOptions() *gws.ClientOption {\n\tif client.options != nil {\n\t\treturn client.options\n\t}\n\t// update the hub url to use websocket scheme and api path\n\tif client.hubURL.Scheme == \"https\" {\n\t\tclient.hubURL.Scheme = \"wss\"\n\t} else {\n\t\tclient.hubURL.Scheme = \"ws\"\n\t}\n\tclient.hubURL.Path = path.Join(client.hubURL.Path, \"api/beszel/agent-connect\")\n\tclient.options = &gws.ClientOption{\n\t\tAddr:      client.hubURL.String(),\n\t\tTlsConfig: &tls.Config{InsecureSkipVerify: true},\n\t\tRequestHeader: http.Header{\n\t\t\t\"User-Agent\": []string{getUserAgent()},\n\t\t\t\"X-Token\":    []string{client.token},\n\t\t\t\"X-Beszel\":   []string{beszel.Version},\n\t\t},\n\t}\n\treturn client.options\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 118, "end_line": 141, "text": "// Connect establishes a WebSocket connection to the hub.\n// It closes any existing connection before attempting to reconnect.\nfunc (client *WebSocketClient) Connect() (err error) {\n\tclient.lastConnectAttempt = time.Now()\n\n\t// make sure previous connection is closed\n\tclient.Close()\n\n\tclient.Conn, _, err = gws.NewClient(client, client.getOptions())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgo client.Conn.ReadLoop()\n\n\treturn nil\n}\n\n// OnOpen handles WebSocket connection establishment.\n// It sets a deadline for the connection to prevent hanging.\nfunc (client *WebSocketClient) OnOpen(conn *gws.Conn) {\n\tconn.SetDeadline(time.Now().Add(wsDeadline))\n}\n", "n_tokens": 139, "primary_symbol": "Connect", "primary_kind": "function", "primary_span": [120, 141], "def_symbols": ["Connect", "OnOpen"], "symbols": ["Connect", "OnOpen", "establishes", "WebSocket", "connection", "the", "hub", "closes", "any", "existing", "before", "attempting", "reconnect", "func", "client", "WebSocketClient", "err", "error", "lastConnectAttempt", "time", "Now", "make", "sure", "previous", "closed", "Close", "Conn", "gws", "NewClient", "getOptions", "nil", "return", "ReadLoop", "handles", "establishment", "sets", "deadline", "for", "prevent", "hanging", "conn", "SetDeadline", "Add", "wsDeadline"], "doc_head": "// Connect establishes a WebSocket connection to the hub.\n// It closes any existing connection before attempting to reconnect.\nfunc (client *WebSocketClient) Connect() (err error) {\n\tclient.lastConnectAttempt = time.Now()\n\t// make sure previous connection is closed\n\tclient.Close()\n\tclient.Conn, _, err = gws.NewClient(client, client.getOptions())\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo client.Conn.ReadLoop()\n\treturn nil\n}\n// OnOpen handles WebSocket connection establishment.\n// It sets a deadline for the connection to prevent hanging.\nfunc (client *WebSocketClient) OnOpen(conn *gws.Conn) {\n\tconn.SetDeadline(time.Now().Add(wsDeadline))\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 142, "end_line": 148, "text": "// OnClose handles WebSocket connection closure.\n// It logs the closure reason and notifies the connection manager.\nfunc (client *WebSocketClient) OnClose(conn *gws.Conn, err error) {\n\tslog.Warn(\"Connection closed\", \"err\", strings.TrimPrefix(err.Error(), \"gws: \"))\n\tclient.agent.connectionManager.eventChan <- WebSocketDisconnect\n}\n", "n_tokens": 71, "primary_symbol": "OnClose", "primary_kind": "function", "primary_span": [144, 148], "def_symbols": ["OnClose"], "symbols": ["OnClose", "handles", "WebSocket", "connection", "closure", "logs", "the", "reason", "and", "notifies", "manager", "func", "client", "WebSocketClient", "conn", "gws", "Conn", "err", "error", "slog", "Warn", "Connection", "closed", "strings", "TrimPrefix", "Error", "agent", "connectionManager", "eventChan", "WebSocketDisconnect"], "doc_head": "// OnClose handles WebSocket connection closure.\n// It logs the closure reason and notifies the connection manager.\nfunc (client *WebSocketClient) OnClose(conn *gws.Conn, err error) {\n\tslog.Warn(\"Connection closed\", \"err\", strings.TrimPrefix(err.Error(), \"gws: \"))\n\tclient.agent.connectionManager.eventChan <- WebSocketDisconnect\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 149, "end_line": 167, "text": "// OnMessage handles incoming WebSocket messages from the hub.\n// It decodes CBOR messages and routes them to appropriate handlers.\nfunc (client *WebSocketClient) OnMessage(conn *gws.Conn, message *gws.Message) {\n\tdefer message.Close()\n\tconn.SetDeadline(time.Now().Add(wsDeadline))\n\n\tif message.Opcode != gws.OpcodeBinary {\n\t\treturn\n\t}\n\n\tif err := cbor.NewDecoder(message.Data).Decode(client.hubRequest); err != nil {\n\t\tslog.Error(\"Error parsing message\", \"err\", err)\n\t\treturn\n\t}\n\tif err := client.handleHubRequest(client.hubRequest); err != nil {\n\t\tslog.Error(\"Error handling message\", \"err\", err)\n\t}\n}\n", "n_tokens": 149, "primary_symbol": "OnMessage", "primary_kind": "function", "primary_span": [151, 167], "def_symbols": ["OnMessage"], "symbols": ["OnMessage", "handles", "incoming", "WebSocket", "messages", "from", "the", "hub", "decodes", "CBOR", "and", "routes", "them", "appropriate", "handlers", "func", "client", "WebSocketClient", "conn", "gws", "Conn", "message", "Message", "defer", "Close", "SetDeadline", "time", "Now", "Add", "wsDeadline", "Opcode", "OpcodeBinary", "return", "err", "cbor", "NewDecoder", "Data", "Decode", "hubRequest", "nil", "slog", "Error", "parsing", "handleHubRequest", "handling"], "doc_head": "// OnMessage handles incoming WebSocket messages from the hub.\n// It decodes CBOR messages and routes them to appropriate handlers.\nfunc (client *WebSocketClient) OnMessage(conn *gws.Conn, message *gws.Message) {\n\tdefer message.Close()\n\tconn.SetDeadline(time.Now().Add(wsDeadline))\n\tif message.Opcode != gws.OpcodeBinary {\n\t\treturn\n\t}\n\tif err := cbor.NewDecoder(message.Data).Decode(client.hubRequest); err != nil {\n\t\tslog.Error(\"Error parsing message\", \"err\", err)\n\t\treturn\n\t}\n\tif err := client.handleHubRequest(client.hubRequest); err != nil {\n\t\tslog.Error(\"Error handling message\", \"err\", err)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 168, "end_line": 174, "text": "// OnPing handles WebSocket ping frames.\n// It responds with a pong and updates the connection deadline.\nfunc (client *WebSocketClient) OnPing(conn *gws.Conn, message []byte) {\n\tconn.SetDeadline(time.Now().Add(wsDeadline))\n\tconn.WritePong(message)\n}\n", "n_tokens": 57, "primary_symbol": "OnPing", "primary_kind": "function", "primary_span": [170, 174], "def_symbols": ["OnPing"], "symbols": ["OnPing", "handles", "WebSocket", "ping", "frames", "responds", "with", "pong", "and", "updates", "the", "connection", "deadline", "func", "client", "WebSocketClient", "conn", "gws", "Conn", "message", "byte", "SetDeadline", "time", "Now", "Add", "wsDeadline", "WritePong"], "doc_head": "// OnPing handles WebSocket ping frames.\n// It responds with a pong and updates the connection deadline.\nfunc (client *WebSocketClient) OnPing(conn *gws.Conn, message []byte) {\n\tconn.SetDeadline(time.Now().Add(wsDeadline))\n\tconn.WritePong(message)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 175, "end_line": 201, "text": "// handleAuthChallenge verifies the authenticity of the hub and returns the system's fingerprint.\nfunc (client *WebSocketClient) handleAuthChallenge(msg *common.HubRequest[cbor.RawMessage]) (err error) {\n\tvar authRequest common.FingerprintRequest\n\tif err := cbor.Unmarshal(msg.Data, &authRequest); err != nil {\n\t\treturn err\n\t}\n\n\tif err := client.verifySignature(authRequest.Signature); err != nil {\n\t\treturn err\n\t}\n\n\tclient.hubVerified = true\n\tclient.agent.connectionManager.eventChan <- WebSocketConnect\n\n\tresponse := &common.FingerprintResponse{\n\t\tFingerprint: client.fingerprint,\n\t}\n\n\tif authRequest.NeedSysInfo {\n\t\tresponse.Hostname = client.agent.systemInfo.Hostname\n\t\tserverAddr := client.agent.connectionManager.serverOptions.Addr\n\t\t_, response.Port, _ = net.SplitHostPort(serverAddr)\n\t}\n\n\treturn client.sendMessage(response)\n}\n", "n_tokens": 186, "primary_symbol": "handleAuthChallenge", "primary_kind": "function", "primary_span": [176, 201], "def_symbols": ["handleAuthChallenge"], "symbols": ["handleAuthChallenge", "verifies", "the", "authenticity", "hub", "and", "returns", "system", "fingerprint", "func", "client", "WebSocketClient", "msg", "common", "HubRequest", "cbor", "RawMessage", "err", "error", "var", "authRequest", "FingerprintRequest", "Unmarshal", "Data", "nil", "return", "verifySignature", "Signature", "hubVerified", "true", "agent", "connectionManager", "eventChan", "WebSocketConnect", "response", "FingerprintResponse", "Fingerprint", "NeedSysInfo", "Hostname", "systemInfo", "serverAddr", "serverOptions", "Addr", "Port", "net", "SplitHostPort", "sendMessage"], "doc_head": "// handleAuthChallenge verifies the authenticity of the hub and returns the system's fingerprint.\nfunc (client *WebSocketClient) handleAuthChallenge(msg *common.HubRequest[cbor.RawMessage]) (err error) {\n\tvar authRequest common.FingerprintRequest\n\tif err := cbor.Unmarshal(msg.Data, &authRequest); err != nil {\n\t\treturn err\n\t}\n\tif err := client.verifySignature(authRequest.Signature); err != nil {\n\t\treturn err\n\t}\n\tclient.hubVerified = true\n\tclient.agent.connectionManager.eventChan <- WebSocketConnect\n\tresponse := &common.FingerprintResponse{\n\t\tFingerprint: client.fingerprint,\n\t}\n\tif authRequest.NeedSysInfo {\n\t\tresponse.Hostname = client.agent.systemInfo.Hostname\n\t\tserverAddr := client.agent.connectionManager.serverOptions.Addr\n\t\t_, response.Port, _ = net.SplitHostPort(serverAddr)\n\t}\n\treturn client.sendMessage(response)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 202, "end_line": 223, "text": "// verifySignature verifies the signature of the token using the public keys.\nfunc (client *WebSocketClient) verifySignature(signature []byte) (err error) {\n\tfor _, pubKey := range client.agent.keys {\n\t\tsig := ssh.Signature{\n\t\t\tFormat: pubKey.Type(),\n\t\t\tBlob:   signature,\n\t\t}\n\t\tif err = pubKey.Verify([]byte(client.token), &sig); err == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(\"invalid signature - check KEY value\")\n}\n\n// Close closes the WebSocket connection gracefully.\n// This method is safe to call multiple times.\nfunc (client *WebSocketClient) Close() {\n\tif client.Conn != nil {\n\t\t_ = client.Conn.WriteClose(1000, nil)\n\t}\n}\n", "n_tokens": 158, "primary_symbol": "verifySignature", "primary_kind": "function", "primary_span": [203, 223], "def_symbols": ["verifySignature", "Close"], "symbols": ["verifySignature", "Close", "verifies", "the", "signature", "token", "using", "public", "keys", "func", "client", "WebSocketClient", "byte", "err", "error", "for", "pubKey", "range", "agent", "sig", "ssh", "Signature", "Format", "Type", "Blob", "Verify", "nil", "return", "errors", "New", "invalid", "check", "KEY", "value", "closes", "WebSocket", "connection", "gracefully", "This", "method", "safe", "call", "multiple", "times", "Conn", "WriteClose"], "doc_head": "// verifySignature verifies the signature of the token using the public keys.\nfunc (client *WebSocketClient) verifySignature(signature []byte) (err error) {\n\tfor _, pubKey := range client.agent.keys {\n\t\tsig := ssh.Signature{\n\t\t\tFormat: pubKey.Type(),\n\t\t\tBlob:   signature,\n\t\t}\n\t\tif err = pubKey.Verify([]byte(client.token), &sig); err == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(\"invalid signature - check KEY value\")\n}\n// Close closes the WebSocket connection gracefully.\n// This method is safe to call multiple times.\nfunc (client *WebSocketClient) Close() {\n\tif client.Conn != nil {\n\t\t_ = client.Conn.WriteClose(1000, nil)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 224, "end_line": 244, "text": "// handleHubRequest routes the request to the appropriate handler.\n// It ensures the hub is verified before processing most requests.\nfunc (client *WebSocketClient) handleHubRequest(msg *common.HubRequest[cbor.RawMessage]) error {\n\tif !client.hubVerified && msg.Action != common.CheckFingerprint {\n\t\treturn errors.New(\"hub not verified\")\n\t}\n\tswitch msg.Action {\n\tcase common.GetData:\n\t\treturn client.sendSystemData()\n\tcase common.CheckFingerprint:\n\t\treturn client.handleAuthChallenge(msg)\n\t}\n\treturn nil\n}\n\n// sendSystemData gathers and sends current system statistics to the hub.\nfunc (client *WebSocketClient) sendSystemData() error {\n\tsysStats := client.agent.gatherStats(client.token)\n\treturn client.sendMessage(sysStats)\n}\n", "n_tokens": 154, "primary_symbol": "handleHubRequest", "primary_kind": "function", "primary_span": [226, 244], "def_symbols": ["handleHubRequest", "sendSystemData"], "symbols": ["handleHubRequest", "sendSystemData", "routes", "the", "request", "appropriate", "handler", "ensures", "hub", "verified", "before", "processing", "most", "requests", "func", "client", "WebSocketClient", "msg", "common", "HubRequest", "cbor", "RawMessage", "error", "hubVerified", "Action", "CheckFingerprint", "return", "errors", "New", "not", "switch", "case", "GetData", "handleAuthChallenge", "nil", "gathers", "and", "sends", "current", "system", "statistics", "sysStats", "agent", "gatherStats", "token", "sendMessage"], "doc_head": "// handleHubRequest routes the request to the appropriate handler.\n// It ensures the hub is verified before processing most requests.\nfunc (client *WebSocketClient) handleHubRequest(msg *common.HubRequest[cbor.RawMessage]) error {\n\tif !client.hubVerified && msg.Action != common.CheckFingerprint {\n\t\treturn errors.New(\"hub not verified\")\n\t}\n\tswitch msg.Action {\n\tcase common.GetData:\n\t\treturn client.sendSystemData()\n\tcase common.CheckFingerprint:\n\t\treturn client.handleAuthChallenge(msg)\n\t}\n\treturn nil\n}\n// sendSystemData gathers and sends current system statistics to the hub.\nfunc (client *WebSocketClient) sendSystemData() error {\n\tsysStats := client.agent.gatherStats(client.token)\n\treturn client.sendMessage(sysStats)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 13, "start_line": 245, "end_line": 253, "text": "// sendMessage encodes the given data to CBOR and sends it as a binary message over the WebSocket connection to the hub.\nfunc (client *WebSocketClient) sendMessage(data any) error {\n\tbytes, err := cbor.Marshal(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn client.Conn.WriteMessage(gws.OpcodeBinary, bytes)\n}\n", "n_tokens": 72, "primary_symbol": "sendMessage", "primary_kind": "function", "primary_span": [246, 253], "def_symbols": ["sendMessage"], "symbols": ["sendMessage", "encodes", "the", "given", "data", "CBOR", "and", "sends", "binary", "message", "over", "WebSocket", "connection", "hub", "func", "client", "WebSocketClient", "any", "error", "bytes", "err", "cbor", "Marshal", "nil", "return", "Conn", "WriteMessage", "gws", "OpcodeBinary"], "doc_head": "// sendMessage encodes the given data to CBOR and sends it as a binary message over the WebSocket connection to the hub.\nfunc (client *WebSocketClient) sendMessage(data any) error {\n\tbytes, err := cbor.Marshal(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn client.Conn.WriteMessage(gws.OpcodeBinary, bytes)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client.go", "rel_path": "agent/client.go", "ext": "go", "language": "go", "chunk_number": 14, "start_line": 254, "end_line": 267, "text": "// getUserAgent returns one of two User-Agent strings based on current time.\n// This is used to avoid being blocked by Cloudflare or other anti-bot measures.\nfunc getUserAgent() string {\n\tconst (\n\t\tuaBase    = \"Mozilla/5.0 (%s) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36\"\n\t\tuaWindows = \"Windows NT 11.0; Win64; x64\"\n\t\tuaMac     = \"Macintosh; Intel Mac OS X 14_0_0\"\n\t)\n\tif time.Now().UnixNano()%2 == 0 {\n\t\treturn fmt.Sprintf(uaBase, uaWindows)\n\t}\n\treturn fmt.Sprintf(uaBase, uaMac)\n}\n", "n_tokens": 159, "primary_symbol": "getUserAgent", "primary_kind": "function", "primary_span": [256, 267], "def_symbols": ["getUserAgent"], "symbols": ["getUserAgent", "returns", "one", "two", "User", "Agent", "strings", "based", "current", "time", "This", "used", "avoid", "being", "blocked", "Cloudflare", "other", "anti", "bot", "measures", "func", "string", "const", "uaBase", "Mozilla", "AppleWebKit", "KHTML", "like", "Gecko", "Chrome", "Safari", "uaWindows", "Windows", "Win64", "x64", "uaMac", "Macintosh", "Intel", "Mac", "Now", "UnixNano", "return", "fmt", "Sprintf"], "doc_head": "// getUserAgent returns one of two User-Agent strings based on current time.\n// This is used to avoid being blocked by Cloudflare or other anti-bot measures.\nfunc getUserAgent() string {\n\tconst (\n\t\tuaBase    = \"Mozilla/5.0 (%s) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36\"\n\t\tuaWindows = \"Windows NT 11.0; Win64; x64\"\n\t\tuaMac     = \"Macintosh; Intel Mac OS X 14_0_0\"\n\t)\n\tif time.Now().UnixNano()%2 == 0 {\n\t\treturn fmt.Sprintf(uaBase, uaWindows)\n\t}\n\treturn fmt.Sprintf(uaBase, uaMac)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 30, "text": "//go:build testing\n// +build testing\n\npackage agent\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/shirou/gopsutil/v4/common\"\n\t\"github.com/shirou/gopsutil/v4/sensors\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestIsValidSensor(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tsensorName    string\n\t\tconfig        *SensorConfig\n\t\texpectedValid bool\n\t}{\n\t\t{\n\t\t\tname:       \"Whitelist - sensor in list\",\n\t\t\tsensorName: \"cpu_temp\",\n\t\t\tconfig: &SensorConfig{", "n_tokens": 157, "primary_symbol": "TestIsValidSensor", "primary_kind": "function", "primary_span": [20, 30], "def_symbols": ["TestIsValidSensor"], "symbols": ["TestIsValidSensor", "build", "testing", "package", "agent", "import", "context", "fmt", "github", "com", "henrygd", "beszel", "src", "entities", "system", "shirou", "gopsutil", "common", "sensors", "stretchr", "testify", "assert", "require", "func", "tests", "struct", "name", "string", "sensorName", "config", "SensorConfig", "expectedValid", "bool", "Whitelist", "sensor", "list", "cpu_temp"], "doc_head": "//go:build testing\n// +build testing\npackage agent\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/shirou/gopsutil/v4/common\"\n\t\"github.com/shirou/gopsutil/v4/sensors\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\nfunc TestIsValidSensor(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tsensorName    string\n\t\tconfig        *SensorConfig\n\t\texpectedValid bool\n\t}{\n\t\t{\n\t\t\tname:       \"Whitelist - sensor in list\",\n\t\t\tsensorName: \"cpu_temp\",\n\t\t\tconfig: &SensorConfig{"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 31, "end_line": 57, "text": "\t\t\t\tsensors:     map[string]struct{}{\"cpu_temp\": {}},\n\t\t\t\tisBlacklist: false,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Whitelist - sensor not in list\",\n\t\t\tsensorName: \"gpu_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:     map[string]struct{}{\"cpu_temp\": {}},\n\t\t\t\tisBlacklist: false,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Blacklist - sensor in list\",\n\t\t\tsensorName: \"cpu_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:     map[string]struct{}{\"cpu_temp\": {}},\n\t\t\t\tisBlacklist: true,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Blacklist - sensor not in list\",\n\t\t\tsensorName: \"gpu_temp\",\n\t\t\tconfig: &SensorConfig{", "n_tokens": 200, "primary_symbol": "", "primary_kind": "", "primary_span": [31, 57], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "cpu_temp", "isBlacklist", "false", "expectedValid", "true", "name", "Whitelist", "sensor", "not", "list", "sensorName", "gpu_temp", "config", "SensorConfig", "Blacklist"], "doc_head": "\t\t\t\tsensors:     map[string]struct{}{\"cpu_temp\": {}},\n\t\t\t\tisBlacklist: false,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Whitelist - sensor not in list\",\n\t\t\tsensorName: \"gpu_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:     map[string]struct{}{\"cpu_temp\": {}},\n\t\t\t\tisBlacklist: false,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Blacklist - sensor in list\",\n\t\t\tsensorName: \"cpu_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:     map[string]struct{}{\"cpu_temp\": {}},\n\t\t\t\tisBlacklist: true,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Blacklist - sensor not in list\",\n\t\t\tsensorName: \"gpu_temp\",\n\t\t\tconfig: &SensorConfig{"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 58, "end_line": 76, "text": "\t\t\t\tsensors:     map[string]struct{}{\"cpu_temp\": {}},\n\t\t\t\tisBlacklist: true,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Whitelist with wildcard - matching pattern\",\n\t\t\tsensorName: \"core_0_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:      map[string]struct{}{\"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Whitelist with wildcard - non-matching pattern\",\n\t\t\tsensorName: \"gpu_temp\",\n\t\t\tconfig: &SensorConfig{", "n_tokens": 148, "primary_symbol": "", "primary_kind": "", "primary_span": [58, 76], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "cpu_temp", "isBlacklist", "true", "expectedValid", "name", "Whitelist", "with", "wildcard", "matching", "pattern", "sensorName", "core_0_temp", "config", "SensorConfig", "core_", "_temp", "false", "hasWildcards", "non", "gpu_temp"], "doc_head": "\t\t\t\tsensors:     map[string]struct{}{\"cpu_temp\": {}},\n\t\t\t\tisBlacklist: true,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Whitelist with wildcard - matching pattern\",\n\t\t\tsensorName: \"core_0_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:      map[string]struct{}{\"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Whitelist with wildcard - non-matching pattern\",\n\t\t\tsensorName: \"gpu_temp\",\n\t\t\tconfig: &SensorConfig{"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 77, "end_line": 96, "text": "\t\t\t\tsensors:      map[string]struct{}{\"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Blacklist with wildcard - matching pattern\",\n\t\t\tsensorName: \"core_0_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:      map[string]struct{}{\"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  true,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Blacklist with wildcard - non-matching pattern\",\n\t\t\tsensorName: \"gpu_temp\",\n\t\t\tconfig: &SensorConfig{", "n_tokens": 158, "primary_symbol": "", "primary_kind": "", "primary_span": [77, 96], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "core_", "_temp", "isBlacklist", "false", "hasWildcards", "true", "expectedValid", "name", "Blacklist", "with", "wildcard", "matching", "pattern", "sensorName", "core_0_temp", "config", "SensorConfig", "non", "gpu_temp"], "doc_head": "\t\t\t\tsensors:      map[string]struct{}{\"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Blacklist with wildcard - matching pattern\",\n\t\t\tsensorName: \"core_0_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:      map[string]struct{}{\"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  true,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Blacklist with wildcard - non-matching pattern\",\n\t\t\tsensorName: \"gpu_temp\",\n\t\t\tconfig: &SensorConfig{"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 97, "end_line": 117, "text": "\t\t\t\tsensors:      map[string]struct{}{\"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  true,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"No sensors configured\",\n\t\t\tsensorName: \"any_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:        map[string]struct{}{},\n\t\t\t\tisBlacklist:    false,\n\t\t\t\thasWildcards:   false,\n\t\t\t\tskipCollection: false,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Mixed patterns in whitelist - exact match\",\n\t\t\tsensorName: \"cpu_temp\",\n\t\t\tconfig: &SensorConfig{", "n_tokens": 151, "primary_symbol": "", "primary_kind": "", "primary_span": [97, 117], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "core_", "_temp", "isBlacklist", "true", "hasWildcards", "expectedValid", "name", "configured", "sensorName", "any_temp", "config", "SensorConfig", "false", "skipCollection", "Mixed", "patterns", "whitelist", "exact", "match", "cpu_temp"], "doc_head": "\t\t\t\tsensors:      map[string]struct{}{\"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  true,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"No sensors configured\",\n\t\t\tsensorName: \"any_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:        map[string]struct{}{},\n\t\t\t\tisBlacklist:    false,\n\t\t\t\thasWildcards:   false,\n\t\t\t\tskipCollection: false,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Mixed patterns in whitelist - exact match\",\n\t\t\tsensorName: \"cpu_temp\",\n\t\t\tconfig: &SensorConfig{"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 118, "end_line": 137, "text": "\t\t\t\tsensors:      map[string]struct{}{\"cpu_temp\": {}, \"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Mixed patterns in whitelist - wildcard match\",\n\t\t\tsensorName: \"core_1_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:      map[string]struct{}{\"cpu_temp\": {}, \"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Mixed patterns in blacklist - exact match\",\n\t\t\tsensorName: \"cpu_temp\",\n\t\t\tconfig: &SensorConfig{", "n_tokens": 166, "primary_symbol": "", "primary_kind": "", "primary_span": [118, 137], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "cpu_temp", "core_", "_temp", "isBlacklist", "false", "hasWildcards", "true", "expectedValid", "name", "Mixed", "patterns", "whitelist", "wildcard", "match", "sensorName", "core_1_temp", "config", "SensorConfig", "blacklist", "exact"], "doc_head": "\t\t\t\tsensors:      map[string]struct{}{\"cpu_temp\": {}, \"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Mixed patterns in whitelist - wildcard match\",\n\t\t\tsensorName: \"core_1_temp\",\n\t\t\tconfig: &SensorConfig{\n\t\t\t\tsensors:      map[string]struct{}{\"cpu_temp\": {}, \"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Mixed patterns in blacklist - exact match\",\n\t\t\tsensorName: \"cpu_temp\",\n\t\t\tconfig: &SensorConfig{"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 138, "end_line": 147, "text": "\t\t\t\tsensors:      map[string]struct{}{\"cpu_temp\": {}, \"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  true,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Mixed patterns in blacklist - wildcard match\",\n\t\t\tsensorName: \"core_1_temp\",\n\t\t\tconfig: &SensorConfig{", "n_tokens": 84, "primary_symbol": "", "primary_kind": "", "primary_span": [138, 147], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "cpu_temp", "core_", "_temp", "isBlacklist", "true", "hasWildcards", "expectedValid", "false", "name", "Mixed", "patterns", "blacklist", "wildcard", "match", "sensorName", "core_1_temp", "config", "SensorConfig"], "doc_head": "\t\t\t\tsensors:      map[string]struct{}{\"cpu_temp\": {}, \"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  true,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Mixed patterns in blacklist - wildcard match\",\n\t\t\tsensorName: \"core_1_temp\",\n\t\t\tconfig: &SensorConfig{"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 148, "end_line": 166, "text": "\t\t\t\tsensors:      map[string]struct{}{\"cpu_temp\": {}, \"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  true,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := isValidSensor(tt.sensorName, tt.config)\n\t\t\tassert.Equal(t, tt.expectedValid, result, \"isValidSensor(%q, config) returned unexpected result\", tt.sensorName)\n\t\t})\n\t}\n}\n\nfunc TestNewSensorConfigWithEnv(t *testing.T) {\n\tagent := &Agent{}\n", "n_tokens": 136, "primary_symbol": "TestNewSensorConfigWithEnv", "primary_kind": "function", "primary_span": [164, 166], "def_symbols": ["TestNewSensorConfigWithEnv"], "symbols": ["TestNewSensorConfigWithEnv", "sensors", "map", "string", "struct", "cpu_temp", "core_", "_temp", "isBlacklist", "true", "hasWildcards", "expectedValid", "false", "for", "range", "tests", "Run", "name", "func", "testing", "result", "isValidSensor", "sensorName", "config", "assert", "Equal", "returned", "unexpected", "agent", "Agent"], "doc_head": "\t\t\t\tsensors:      map[string]struct{}{\"cpu_temp\": {}, \"core_*_temp\": {}},\n\t\t\t\tisBlacklist:  true,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t\texpectedValid: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := isValidSensor(tt.sensorName, tt.config)\n\t\t\tassert.Equal(t, tt.expectedValid, result, \"isValidSensor(%q, config) returned unexpected result\", tt.sensorName)\n\t\t})\n\t}\n}\nfunc TestNewSensorConfigWithEnv(t *testing.T) {\n\tagent := &Agent{}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 167, "end_line": 197, "text": "\ttests := []struct {\n\t\tname           string\n\t\tprimarySensor  string\n\t\tsysSensors     string\n\t\tsensors        string\n\t\tskipCollection bool\n\t\texpectedConfig *SensorConfig\n\t}{\n\t\t{\n\t\t\tname:          \"Empty configuration\",\n\t\t\tprimarySensor: \"\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:        context.Background(),\n\t\t\t\tprimarySensor:  \"\",\n\t\t\t\tsensors:        map[string]struct{}{},\n\t\t\t\tisBlacklist:    false,\n\t\t\t\thasWildcards:   false,\n\t\t\t\tskipCollection: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:           \"Explicitly set to empty string\",\n\t\t\tprimarySensor:  \"\",\n\t\t\tsysSensors:     \"\",\n\t\t\tsensors:        \"\",\n\t\t\tskipCollection: true,\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:        context.Background(),\n\t\t\t\tprimarySensor:  \"\",", "n_tokens": 201, "primary_symbol": "", "primary_kind": "", "primary_span": [167, 197], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "primarySensor", "sysSensors", "sensors", "skipCollection", "bool", "expectedConfig", "SensorConfig", "Empty", "configuration", "context", "Background", "map", "isBlacklist", "false", "hasWildcards", "Explicitly", "set", "empty", "true"], "doc_head": "\ttests := []struct {\n\t\tname           string\n\t\tprimarySensor  string\n\t\tsysSensors     string\n\t\tsensors        string\n\t\tskipCollection bool\n\t\texpectedConfig *SensorConfig\n\t}{\n\t\t{\n\t\t\tname:          \"Empty configuration\",\n\t\t\tprimarySensor: \"\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:        context.Background(),\n\t\t\t\tprimarySensor:  \"\",\n\t\t\t\tsensors:        map[string]struct{}{},\n\t\t\t\tisBlacklist:    false,\n\t\t\t\thasWildcards:   false,\n\t\t\t\tskipCollection: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:           \"Explicitly set to empty string\",\n\t\t\tprimarySensor:  \"\",\n\t\t\tsysSensors:     \"\",\n\t\t\tsensors:        \"\",\n\t\t\tskipCollection: true,\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:        context.Background(),\n\t\t\t\tprimarySensor:  \"\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 198, "end_line": 224, "text": "\t\t\t\tsensors:        map[string]struct{}{},\n\t\t\t\tisBlacklist:    false,\n\t\t\t\thasWildcards:   false,\n\t\t\t\tskipCollection: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"Primary sensor only - should create sensor map\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:       context.Background(),\n\t\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\t\tsensors:       map[string]struct{}{},\n\t\t\t\tisBlacklist:   false,\n\t\t\t\thasWildcards:  false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"Whitelist sensors\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"cpu_temp,gpu_temp\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:       context.Background(),\n\t\t\t\tprimarySensor: \"cpu_temp\",", "n_tokens": 200, "primary_symbol": "", "primary_kind": "", "primary_span": [198, 224], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "isBlacklist", "false", "hasWildcards", "skipCollection", "true", "name", "Primary", "sensor", "only", "should", "create", "primarySensor", "cpu_temp", "sysSensors", "expectedConfig", "SensorConfig", "context", "Background", "Whitelist", "gpu_temp"], "doc_head": "\t\t\t\tsensors:        map[string]struct{}{},\n\t\t\t\tisBlacklist:    false,\n\t\t\t\thasWildcards:   false,\n\t\t\t\tskipCollection: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"Primary sensor only - should create sensor map\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:       context.Background(),\n\t\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\t\tsensors:       map[string]struct{}{},\n\t\t\t\tisBlacklist:   false,\n\t\t\t\thasWildcards:  false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"Whitelist sensors\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"cpu_temp,gpu_temp\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:       context.Background(),\n\t\t\t\tprimarySensor: \"cpu_temp\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 225, "end_line": 240, "text": "\t\t\t\tsensors: map[string]struct{}{\n\t\t\t\t\t\"cpu_temp\": {},\n\t\t\t\t\t\"gpu_temp\": {},\n\t\t\t\t},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"Blacklist sensors\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"-cpu_temp,gpu_temp\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:       context.Background(),\n\t\t\t\tprimarySensor: \"cpu_temp\",", "n_tokens": 111, "primary_symbol": "", "primary_kind": "", "primary_span": [225, 240], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "cpu_temp", "gpu_temp", "isBlacklist", "false", "hasWildcards", "name", "Blacklist", "primarySensor", "sysSensors", "expectedConfig", "SensorConfig", "context", "Background"], "doc_head": "\t\t\t\tsensors: map[string]struct{}{\n\t\t\t\t\t\"cpu_temp\": {},\n\t\t\t\t\t\"gpu_temp\": {},\n\t\t\t\t},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"Blacklist sensors\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"-cpu_temp,gpu_temp\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:       context.Background(),\n\t\t\t\tprimarySensor: \"cpu_temp\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 241, "end_line": 256, "text": "\t\t\t\tsensors: map[string]struct{}{\n\t\t\t\t\t\"cpu_temp\": {},\n\t\t\t\t\t\"gpu_temp\": {},\n\t\t\t\t},\n\t\t\t\tisBlacklist:  true,\n\t\t\t\thasWildcards: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"Sensors with wildcard\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"cpu_*,gpu_temp\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:       context.Background(),\n\t\t\t\tprimarySensor: \"cpu_temp\",", "n_tokens": 112, "primary_symbol": "", "primary_kind": "", "primary_span": [241, 256], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "cpu_temp", "gpu_temp", "isBlacklist", "true", "hasWildcards", "false", "name", "Sensors", "with", "wildcard", "primarySensor", "sysSensors", "cpu_", "expectedConfig", "SensorConfig", "context", "Background"], "doc_head": "\t\t\t\tsensors: map[string]struct{}{\n\t\t\t\t\t\"cpu_temp\": {},\n\t\t\t\t\t\"gpu_temp\": {},\n\t\t\t\t},\n\t\t\t\tisBlacklist:  true,\n\t\t\t\thasWildcards: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"Sensors with wildcard\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"cpu_*,gpu_temp\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:       context.Background(),\n\t\t\t\tprimarySensor: \"cpu_temp\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 13, "start_line": 257, "end_line": 272, "text": "\t\t\t\tsensors: map[string]struct{}{\n\t\t\t\t\t\"cpu_*\":    {},\n\t\t\t\t\t\"gpu_temp\": {},\n\t\t\t\t},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"Sensors with whitespace\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"cpu_*, gpu_temp\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:       context.Background(),\n\t\t\t\tprimarySensor: \"cpu_temp\",", "n_tokens": 113, "primary_symbol": "", "primary_kind": "", "primary_span": [257, 272], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "cpu_", "gpu_temp", "isBlacklist", "false", "hasWildcards", "true", "name", "Sensors", "with", "whitespace", "primarySensor", "cpu_temp", "sysSensors", "expectedConfig", "SensorConfig", "context", "Background"], "doc_head": "\t\t\t\tsensors: map[string]struct{}{\n\t\t\t\t\t\"cpu_*\":    {},\n\t\t\t\t\t\"gpu_temp\": {},\n\t\t\t\t},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"Sensors with whitespace\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"\",\n\t\t\tsensors:       \"cpu_*, gpu_temp\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tcontext:       context.Background(),\n\t\t\t\tprimarySensor: \"cpu_temp\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 14, "start_line": 273, "end_line": 287, "text": "\t\t\t\tsensors: map[string]struct{}{\n\t\t\t\t\t\"cpu_*\":    {},\n\t\t\t\t\t\"gpu_temp\": {},\n\t\t\t\t},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"With SYS_SENSORS path\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"/custom/path\",\n\t\t\tsensors:       \"cpu_temp\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tprimarySensor: \"cpu_temp\",", "n_tokens": 107, "primary_symbol": "", "primary_kind": "", "primary_span": [273, 287], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "cpu_", "gpu_temp", "isBlacklist", "false", "hasWildcards", "true", "name", "With", "SYS_SENSORS", "path", "primarySensor", "cpu_temp", "sysSensors", "custom", "expectedConfig", "SensorConfig"], "doc_head": "\t\t\t\tsensors: map[string]struct{}{\n\t\t\t\t\t\"cpu_*\":    {},\n\t\t\t\t\t\"gpu_temp\": {},\n\t\t\t\t},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"With SYS_SENSORS path\",\n\t\t\tprimarySensor: \"cpu_temp\",\n\t\t\tsysSensors:    \"/custom/path\",\n\t\t\tsensors:       \"cpu_temp\",\n\t\t\texpectedConfig: &SensorConfig{\n\t\t\t\tprimarySensor: \"cpu_temp\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 15, "start_line": 288, "end_line": 331, "text": "\t\t\t\tsensors: map[string]struct{}{\n\t\t\t\t\t\"cpu_temp\": {},\n\t\t\t\t},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: false,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := agent.newSensorConfigWithEnv(tt.primarySensor, tt.sysSensors, tt.sensors, tt.skipCollection)\n\n\t\t\t// Check primary sensor\n\t\t\tassert.Equal(t, tt.expectedConfig.primarySensor, result.primarySensor)\n\n\t\t\t// Check sensor map\n\t\t\tif tt.expectedConfig.sensors == nil {\n\t\t\t\tassert.Nil(t, result.sensors)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, len(tt.expectedConfig.sensors), len(result.sensors))\n\t\t\t\tfor sensor := range tt.expectedConfig.sensors {\n\t\t\t\t\t_, exists := result.sensors[sensor]\n\t\t\t\t\tassert.True(t, exists, \"Sensor %s should exist in the result\", sensor)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check flags\n\t\t\tassert.Equal(t, tt.expectedConfig.isBlacklist, result.isBlacklist)\n\t\t\tassert.Equal(t, tt.expectedConfig.hasWildcards, result.hasWildcards)\n\n\t\t\t// Check context\n\t\t\tif tt.sysSensors != \"\" {\n\t\t\t\t// Verify context contains correct values\n\t\t\t\tenvMap, ok := result.context.Value(common.EnvKey).(common.EnvMap)\n\t\t\t\trequire.True(t, ok, \"Context should contain EnvMap\")\n\t\t\t\tsysPath, ok := envMap[common.HostSysEnvKey]\n\t\t\t\trequire.True(t, ok, \"EnvMap should contain HostSysEnvKey\")\n\t\t\t\tassert.Equal(t, tt.sysSensors, sysPath)\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 354, "primary_symbol": "", "primary_kind": "", "primary_span": [288, 331], "def_symbols": [], "symbols": ["sensors", "map", "string", "struct", "cpu_temp", "isBlacklist", "false", "hasWildcards", "for", "range", "tests", "Run", "name", "func", "testing", "result", "agent", "newSensorConfigWithEnv", "primarySensor", "sysSensors", "skipCollection", "Check", "primary", "sensor", "assert", "Equal", "expectedConfig", "nil", "Nil", "else", "len", "exists", "True", "Sensor", "should", "exist", "the", "flags", "context", "Verify", "contains", "correct", "values", "envMap", "Value", "common", "EnvKey", "EnvMap", "require", "Context", "contain", "sysPath", "HostSysEnvKey"], "doc_head": "\t\t\t\tsensors: map[string]struct{}{\n\t\t\t\t\t\"cpu_temp\": {},\n\t\t\t\t},\n\t\t\t\tisBlacklist:  false,\n\t\t\t\thasWildcards: false,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := agent.newSensorConfigWithEnv(tt.primarySensor, tt.sysSensors, tt.sensors, tt.skipCollection)\n\t\t\t// Check primary sensor\n\t\t\tassert.Equal(t, tt.expectedConfig.primarySensor, result.primarySensor)\n\t\t\t// Check sensor map\n\t\t\tif tt.expectedConfig.sensors == nil {\n\t\t\t\tassert.Nil(t, result.sensors)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, len(tt.expectedConfig.sensors), len(result.sensors))\n\t\t\t\tfor sensor := range tt.expectedConfig.sensors {\n\t\t\t\t\t_, exists := result.sensors[sensor]\n\t\t\t\t\tassert.True(t, exists, \"Sensor %s should exist in the result\", sensor)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check flags\n\t\t\tassert.Equal(t, tt.expectedConfig.isBlacklist, result.isBlacklist)\n\t\t\tassert.Equal(t, tt.expectedConfig.hasWildcards, result.hasWildcards)\n\t\t\t// Check context\n\t\t\tif tt.sysSensors != \"\" {\n\t\t\t\t// Verify context contains correct values\n\t\t\t\tenvMap, ok := result.context.Value(common.EnvKey).(common.EnvMap)\n\t\t\t\trequire.True(t, ok, \"Context should contain EnvMap\")\n\t\t\t\tsysPath, ok := envMap[common.HostSysEnvKey]\n\t\t\t\trequi"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#16", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 16, "start_line": 332, "end_line": 379, "text": "func TestNewSensorConfig(t *testing.T) {\n\t// Save original environment variables\n\toriginalPrimary, hasPrimary := os.LookupEnv(\"BESZEL_AGENT_PRIMARY_SENSOR\")\n\toriginalSys, hasSys := os.LookupEnv(\"BESZEL_AGENT_SYS_SENSORS\")\n\toriginalSensors, hasSensors := os.LookupEnv(\"BESZEL_AGENT_SENSORS\")\n\n\t// Restore environment variables after the test\n\tdefer func() {\n\t\t// Clean up test environment variables\n\t\tos.Unsetenv(\"BESZEL_AGENT_PRIMARY_SENSOR\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_SYS_SENSORS\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_SENSORS\")\n\n\t\t// Restore original values if they existed\n\t\tif hasPrimary {\n\t\t\tos.Setenv(\"BESZEL_AGENT_PRIMARY_SENSOR\", originalPrimary)\n\t\t}\n\t\tif hasSys {\n\t\t\tos.Setenv(\"BESZEL_AGENT_SYS_SENSORS\", originalSys)\n\t\t}\n\t\tif hasSensors {\n\t\t\tos.Setenv(\"BESZEL_AGENT_SENSORS\", originalSensors)\n\t\t}\n\t}()\n\n\t// Set test environment variables\n\tos.Setenv(\"BESZEL_AGENT_PRIMARY_SENSOR\", \"test_primary\")\n\tos.Setenv(\"BESZEL_AGENT_SYS_SENSORS\", \"/test/path\")\n\tos.Setenv(\"BESZEL_AGENT_SENSORS\", \"test_sensor1,test_*,test_sensor3\")\n\n\tagent := &Agent{}\n\tresult := agent.newSensorConfig()\n\n\t// Verify results\n\tassert.Equal(t, \"test_primary\", result.primarySensor)\n\tassert.NotNil(t, result.sensors)\n\tassert.Equal(t, 3, len(result.sensors))\n\tassert.True(t, result.hasWildcards)\n\tassert.False(t, result.isBlacklist)\n\n\t// Check that sys sensors path is in context\n\tenvMap, ok := result.context.Value(common.EnvKey).(common.EnvMap)\n\trequire.True(t, ok, \"Context should contain EnvMap\")\n\tsysPath, ok := envMap[common.HostSysEnvKey]\n\trequire.True(t, ok, \"EnvMap should contain HostSysEnvKey\")\n\tassert.Equal(t, \"/test/path\", sysPath)\n}\n", "n_tokens": 443, "primary_symbol": "TestNewSensorConfig", "primary_kind": "function", "primary_span": [332, 379], "def_symbols": ["TestNewSensorConfig"], "symbols": ["TestNewSensorConfig", "func", "testing", "Save", "original", "environment", "variables", "originalPrimary", "hasPrimary", "LookupEnv", "BESZEL_AGENT_PRIMARY_SENSOR", "originalSys", "hasSys", "BESZEL_AGENT_SYS_SENSORS", "originalSensors", "hasSensors", "BESZEL_AGENT_SENSORS", "Restore", "after", "the", "test", "defer", "Clean", "Unsetenv", "values", "they", "existed", "Setenv", "Set", "test_primary", "path", "test_sensor1", "test_", "test_sensor3", "agent", "Agent", "result", "newSensorConfig", "Verify", "results", "assert", "Equal", "primarySensor", "NotNil", "sensors", "len", "True", "hasWildcards", "False", "isBlacklist", "Check", "that", "sys", "context", "envMap", "Value", "common", "EnvKey", "EnvMap", "require", "Context", "should", "contain", "sysPath", "HostSysEnvKey"], "doc_head": "func TestNewSensorConfig(t *testing.T) {\n\t// Save original environment variables\n\toriginalPrimary, hasPrimary := os.LookupEnv(\"BESZEL_AGENT_PRIMARY_SENSOR\")\n\toriginalSys, hasSys := os.LookupEnv(\"BESZEL_AGENT_SYS_SENSORS\")\n\toriginalSensors, hasSensors := os.LookupEnv(\"BESZEL_AGENT_SENSORS\")\n\t// Restore environment variables after the test\n\tdefer func() {\n\t\t// Clean up test environment variables\n\t\tos.Unsetenv(\"BESZEL_AGENT_PRIMARY_SENSOR\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_SYS_SENSORS\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_SENSORS\")\n\t\t// Restore original values if they existed\n\t\tif hasPrimary {\n\t\t\tos.Setenv(\"BESZEL_AGENT_PRIMARY_SENSOR\", originalPrimary)\n\t\t}\n\t\tif hasSys {\n\t\t\tos.Setenv(\"BESZEL_AGENT_SYS_SENSORS\", originalSys)\n\t\t}\n\t\tif hasSensors {\n\t\t\tos.Setenv(\"BESZEL_AGENT_SENSORS\", originalSensors)\n\t\t}\n\t}()\n\t// Set test environment variables\n\tos.Setenv(\"BESZEL_AGENT_PRIMARY_SENSOR\", \"test_primary\")\n\tos.Setenv(\"BESZEL_AGENT_SYS_SENSORS\", \"/test/path\")\n\tos.Setenv(\"BESZEL_AGENT_SENSORS\", \"test_sensor1,test_*,test_sensor3\")\n\tagent := &Agent{}\n\tresult := agent.newSensorConfig()\n\t// Verify results\n\tassert.Equal(t, \"test_primary\", result.primarySensor)\n\tassert.NotNil(t, result.sensors)\n\tassert.Equal(t, 3"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#17", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 17, "start_line": 380, "end_line": 380, "text": "func TestScaleTemperature(t *testing.T) {", "n_tokens": 10, "primary_symbol": "TestScaleTemperature", "primary_kind": "function", "primary_span": [380, 380], "def_symbols": ["TestScaleTemperature"], "symbols": ["TestScaleTemperature", "func", "testing"], "doc_head": "func TestScaleTemperature(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#18", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 18, "start_line": 381, "end_line": 428, "text": "\ttests := []struct {\n\t\tname     string\n\t\tinput    float64\n\t\texpected float64\n\t\tdesc     string\n\t}{\n\t\t// Normal temperatures (no scaling needed)\n\t\t{\"normal_cpu_temp\", 45.0, 45.0, \"Normal CPU temperature\"},\n\t\t{\"normal_room_temp\", 25.0, 25.0, \"Normal room temperature\"},\n\t\t{\"high_cpu_temp\", 85.0, 85.0, \"High CPU temperature\"},\n\t\t// Zero temperature\n\t\t{\"zero_temp\", 0.0, 0.0, \"Zero temperature\"},\n\t\t// Fractional values that should use 100x scaling\n\t\t{\"fractional_45c\", 0.45, 45.0, \"0.45 should become 45C (100x)\"},\n\t\t{\"fractional_25c\", 0.25, 25.0, \"0.25 should become 25C (100x)\"},\n\t\t{\"fractional_60c\", 0.60, 60.0, \"0.60 should become 60C (100x)\"},\n\t\t{\"fractional_75c\", 0.75, 75.0, \"0.75 should become 75C (100x)\"},\n\t\t{\"fractional_30c\", 0.30, 30.0, \"0.30 should become 30C (100x)\"},\n\t\t// Fractional values that should use 1000x scaling\n\t\t{\"millifractional_45c\", 0.045, 45.0, \"0.045 should become 45C (1000x)\"},\n\t\t{\"millifractional_25c\", 0.025, 25.0, \"0.025 should become 25C (1000x)\"},\n\t\t{\"millifractional_60c\", 0.060, 60.0, \"0.060 should become 60C (1000x)\"},\n\t\t{\"millifractional_75c\", 0.075, 75.0, \"0.075 should become 75C (1000x)\"},\n\t\t{\"millifractional_35c\", 0.035, 35.0, \"0.035 should become 35C (1000x)\"},\n\t\t// Edge cases - values outside reasonable range\n\t\t{\"very_low_fractional\", 0.01, 1.0, \"0.01 should default to 100x scaling (1C)\"},\n\t\t{\"very_high_fractional\", 0.99, 99.0, \"0.99 should default to 100x scaling (99C)\"},\n\t\t{\"extremely_low\", 0.001, 0.1, \"0.001 should default to 100x scaling (0.1C)\"},\n\t\t// Boundary cases around the reasonable range (15-95C)\n\t\t{\"boundary_low_100x\", 0.15, 15.0, \"0.15 should use 100x scaling (15C)\"},\n\t\t{\"boundary_high_100x\", 0.95, 95.0, \"0.95 should use 100x scaling (95C)\"},\n\t\t{\"boundary_low_1000x\", 0.015, 15.0, \"0.015 should use 1000x scaling (15C)\"},\n\t\t{\"boundary_high_1000x\", 0.095, 95.0, \"0.095 should use 1000x scaling (95C)\"},\n\t\t// Values just outside reasonable range\n\t\t{\"just_below_range_100x\", 0.14, 14.0, \"0.14 should default to 100x (14C)\"},\n\t\t{\"just_above_range_100x\", 0.96, 96.0, \"0.96 should default to 100x (96C)\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := scaleTemperature(tt.input)\n\t\t\tassert.InDelta(t, tt.expected, result, 0.001,\n\t\t\t\t\"scaleTemperature(%v) = %v, expected %v (%s)\",\n\t\t\t\ttt.input, result, tt.expected, tt.desc)\n\t\t})\n\t}\n}\n", "n_tokens": 916, "primary_symbol": "", "primary_kind": "", "primary_span": [381, 428], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "input", "float64", "expected", "desc", "Normal", "temperatures", "scaling", "needed", "normal_cpu_temp", "CPU", "temperature", "normal_room_temp", "room", "high_cpu_temp", "High", "Zero", "zero_temp", "Fractional", "values", "that", "should", "use", "fractional_45c", "become", "fractional_25c", "fractional_60c", "fractional_75c", "fractional_30c", "millifractional_45c", "millifractional_25c", "millifractional_60c", "millifractional_75c", "millifractional_35c", "Edge", "cases", "outside", "reasonable", "range", "very_low_fractional", "default", "very_high_fractional", "extremely_low", "Boundary", "around", "the", "boundary_low_100x", "boundary_high_100x", "boundary_low_1000x", "boundary_high_1000x", "Values", "just", "just_below_range_100x", "just_above_range_100x", "for", "Run", "func", "testing", "result", "scaleTemperature", "assert", "InDelta"], "doc_head": "\ttests := []struct {\n\t\tname     string\n\t\tinput    float64\n\t\texpected float64\n\t\tdesc     string\n\t}{\n\t\t// Normal temperatures (no scaling needed)\n\t\t{\"normal_cpu_temp\", 45.0, 45.0, \"Normal CPU temperature\"},\n\t\t{\"normal_room_temp\", 25.0, 25.0, \"Normal room temperature\"},\n\t\t{\"high_cpu_temp\", 85.0, 85.0, \"High CPU temperature\"},\n\t\t// Zero temperature\n\t\t{\"zero_temp\", 0.0, 0.0, \"Zero temperature\"},\n\t\t// Fractional values that should use 100x scaling\n\t\t{\"fractional_45c\", 0.45, 45.0, \"0.45 should become 45C (100x)\"},\n\t\t{\"fractional_25c\", 0.25, 25.0, \"0.25 should become 25C (100x)\"},\n\t\t{\"fractional_60c\", 0.60, 60.0, \"0.60 should become 60C (100x)\"},\n\t\t{\"fractional_75c\", 0.75, 75.0, \"0.75 should become 75C (100x)\"},\n\t\t{\"fractional_30c\", 0.30, 30.0, \"0.30 should become 30C (100x)\"},\n\t\t// Fractional values that should use 1000x scaling\n\t\t{\"millifractional_45c\", 0.045, 45.0, \"0.045 should become 45C (1000x)\"},\n\t\t{\"millifractional_25c\", 0.025, 25.0, \"0.025 should become 25C (1000x)\"},\n\t\t{\"millifractional_60c\", 0.060, 60.0, \"0.060 should become 60C (1000x)\"},\n\t\t{\"millifractional_75c\", 0.075, 75.0, \"0.075 should become 75C (1000x)\"},\n\t\t{\"millifractional_35c\", 0.035, 35.0, \"0.035 should beco"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#19", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 19, "start_line": 429, "end_line": 461, "text": "func TestScaleTemperatureLogic(t *testing.T) {\n\t// Test the logic flow for ambiguous cases\n\tt.Run(\"prefers_100x_when_both_valid\", func(t *testing.T) {\n\t\t// 0.5 could be 50C (100x) or 500C (1000x)\n\t\t// Should prefer 100x since it's tried first and is in range\n\t\tresult := scaleTemperature(0.5)\n\t\texpected := 50.0\n\t\tassert.InDelta(t, expected, result, 0.001,\n\t\t\t\"scaleTemperature(0.5) = %v, expected %v (should prefer 100x scaling)\",\n\t\t\tresult, expected)\n\t})\n\n\tt.Run(\"uses_1000x_when_100x_too_low\", func(t *testing.T) {\n\t\t// 0.05 -> 5C (100x, too low) or 50C (1000x, in range)\n\t\t// Should use 1000x since 100x is below reasonable range\n\t\tresult := scaleTemperature(0.05)\n\t\texpected := 50.0\n\t\tassert.InDelta(t, expected, result, 0.001,\n\t\t\t\"scaleTemperature(0.05) = %v, expected %v (should use 1000x scaling)\",\n\t\t\tresult, expected)\n\t})\n\n\tt.Run(\"defaults_to_100x_when_both_invalid\", func(t *testing.T) {\n\t\t// 0.005 -> 0.5C (100x, too low) or 5C (1000x, too low)\n\t\t// Should default to 100x scaling\n\t\tresult := scaleTemperature(0.005)\n\t\texpected := 0.5\n\t\tassert.InDelta(t, expected, result, 0.001,\n\t\t\t\"scaleTemperature(0.005) = %v, expected %v (should default to 100x)\",\n\t\t\tresult, expected)\n\t})\n}\n", "n_tokens": 413, "primary_symbol": "TestScaleTemperatureLogic", "primary_kind": "function", "primary_span": [429, 461], "def_symbols": ["TestScaleTemperatureLogic"], "symbols": ["TestScaleTemperatureLogic", "func", "testing", "Test", "the", "logic", "flow", "for", "ambiguous", "cases", "Run", "prefers_100x_when_both_valid", "could", "Should", "prefer", "since", "tried", "first", "and", "range", "result", "scaleTemperature", "expected", "assert", "InDelta", "should", "scaling", "uses_1000x_when_100x_too_low", "too", "low", "use", "below", "reasonable", "defaults_to_100x_when_both_invalid", "default"], "doc_head": "func TestScaleTemperatureLogic(t *testing.T) {\n\t// Test the logic flow for ambiguous cases\n\tt.Run(\"prefers_100x_when_both_valid\", func(t *testing.T) {\n\t\t// 0.5 could be 50C (100x) or 500C (1000x)\n\t\t// Should prefer 100x since it's tried first and is in range\n\t\tresult := scaleTemperature(0.5)\n\t\texpected := 50.0\n\t\tassert.InDelta(t, expected, result, 0.001,\n\t\t\t\"scaleTemperature(0.5) = %v, expected %v (should prefer 100x scaling)\",\n\t\t\tresult, expected)\n\t})\n\tt.Run(\"uses_1000x_when_100x_too_low\", func(t *testing.T) {\n\t\t// 0.05 -> 5C (100x, too low) or 50C (1000x, in range)\n\t\t// Should use 1000x since 100x is below reasonable range\n\t\tresult := scaleTemperature(0.05)\n\t\texpected := 50.0\n\t\tassert.InDelta(t, expected, result, 0.001,\n\t\t\t\"scaleTemperature(0.05) = %v, expected %v (should use 1000x scaling)\",\n\t\t\tresult, expected)\n\t})\n\tt.Run(\"defaults_to_100x_when_both_invalid\", func(t *testing.T) {\n\t\t// 0.005 -> 0.5C (100x, too low) or 5C (1000x, too low)\n\t\t// Should default to 100x scaling\n\t\tresult := scaleTemperature(0.005)\n\t\texpected := 0.5\n\t\tassert.InDelta(t, expected, result, 0.001,\n\t\t\t\"scaleTemperature(0.005) = %v, expected %v (should default to 100x)\",\n\t\t\tresult, expected)\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#20", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 20, "start_line": 462, "end_line": 469, "text": "func TestGetTempsWithPanicRecovery(t *testing.T) {\n\tagent := &Agent{\n\t\tsystemInfo: system.Info{},\n\t\tsensorConfig: &SensorConfig{\n\t\t\tcontext: context.Background(),\n\t\t},\n\t}\n", "n_tokens": 49, "primary_symbol": "TestGetTempsWithPanicRecovery", "primary_kind": "function", "primary_span": [462, 469], "def_symbols": ["TestGetTempsWithPanicRecovery"], "symbols": ["TestGetTempsWithPanicRecovery", "func", "testing", "agent", "Agent", "systemInfo", "system", "Info", "sensorConfig", "SensorConfig", "context", "Background"], "doc_head": "func TestGetTempsWithPanicRecovery(t *testing.T) {\n\tagent := &Agent{\n\t\tsystemInfo: system.Info{},\n\t\tsensorConfig: &SensorConfig{\n\t\t\tcontext: context.Background(),\n\t\t},\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go#21", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_test.go", "rel_path": "agent/sensors_test.go", "ext": "go", "language": "go", "chunk_number": 21, "start_line": 470, "end_line": 555, "text": "\ttests := []struct {\n\t\tname        string\n\t\tgetTempsFn  getTempsFn\n\t\texpectError bool\n\t\terrorMsg    string\n\t}{\n\t\t{\n\t\t\tname: \"successful_function_call\",\n\t\t\tgetTempsFn: func(ctx context.Context) ([]sensors.TemperatureStat, error) {\n\t\t\t\treturn []sensors.TemperatureStat{\n\t\t\t\t\t{SensorKey: \"test_sensor\", Temperature: 45.0},\n\t\t\t\t}, nil\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"function_returns_error\",\n\t\t\tgetTempsFn: func(ctx context.Context) ([]sensors.TemperatureStat, error) {\n\t\t\t\treturn []sensors.TemperatureStat{\n\t\t\t\t\t{SensorKey: \"test_sensor\", Temperature: 45.0},\n\t\t\t\t}, fmt.Errorf(\"sensor error\")\n\t\t\t},\n\t\t\texpectError: false, // getTempsWithPanicRecovery ignores errors from the function\n\t\t},\n\t\t{\n\t\t\tname: \"function_panics_with_string\",\n\t\t\tgetTempsFn: func(ctx context.Context) ([]sensors.TemperatureStat, error) {\n\t\t\t\tpanic(\"test panic\")\n\t\t\t},\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"panic: test panic\",\n\t\t},\n\t\t{\n\t\t\tname: \"function_panics_with_error\",\n\t\t\tgetTempsFn: func(ctx context.Context) ([]sensors.TemperatureStat, error) {\n\t\t\t\tpanic(fmt.Errorf(\"panic error\"))\n\t\t\t},\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"panic:\",\n\t\t},\n\t\t{\n\t\t\tname: \"function_panics_with_index_out_of_bounds\",\n\t\t\tgetTempsFn: func(ctx context.Context) ([]sensors.TemperatureStat, error) {\n\t\t\t\tslice := []int{1, 2, 3}\n\t\t\t\t_ = slice[10] // out of bounds panic\n\t\t\t\treturn nil, nil\n\t\t\t},\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"panic:\",\n\t\t},\n\t\t{\n\t\t\tname: \"function_panics_with_any_conversion\",\n\t\t\tgetTempsFn: func(ctx context.Context) ([]sensors.TemperatureStat, error) {\n\t\t\t\tvar i any = \"string\"\n\t\t\t\t_ = i.(int) // type assertion panic\n\t\t\t\treturn nil, nil\n\t\t\t},\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"panic:\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar temps []sensors.TemperatureStat\n\t\t\tvar err error\n\n\t\t\t// The function should not panic, regardless of what the injected function does\n\t\t\tassert.NotPanics(t, func() {\n\t\t\t\ttemps, err = agent.getTempsWithPanicRecovery(tt.getTempsFn)\n\t\t\t}, \"getTempsWithPanicRecovery should not panic\")\n\n\t\t\tif tt.expectError {\n\t\t\t\tassert.Error(t, err, \"Expected an error to be returned\")\n\t\t\t\tif tt.errorMsg != \"\" {\n\t\t\t\t\tassert.Contains(t, err.Error(), tt.errorMsg,\n\t\t\t\t\t\t\"Error message should contain expected text\")\n\t\t\t\t}\n\t\t\t\tassert.Nil(t, temps, \"Temps should be nil when panic occurs\")\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err, \"Should not return error for successful calls\")\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 704, "primary_symbol": "", "primary_kind": "", "primary_span": [470, 555], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "getTempsFn", "expectError", "bool", "errorMsg", "successful_function_call", "func", "ctx", "context", "Context", "sensors", "TemperatureStat", "error", "return", "SensorKey", "test_sensor", "Temperature", "nil", "false", "function_returns_error", "fmt", "Errorf", "sensor", "getTempsWithPanicRecovery", "ignores", "errors", "from", "the", "function", "function_panics_with_string", "panic", "test", "true", "function_panics_with_error", "function_panics_with_index_out_of_bounds", "slice", "int", "out", "bounds", "function_panics_with_any_conversion", "var", "any", "type", "assertion", "for", "range", "Run", "testing", "temps", "err", "The", "should", "not", "regardless", "what", "injected", "does", "assert", "NotPanics", "agent", "Error", "Expected", "returned", "Contains", "message", "contain", "expected", "text", "Nil", "Temps", "when", "occurs", "else", "NoError", "Should", "successful", "calls"], "doc_head": "\ttests := []struct {\n\t\tname        string\n\t\tgetTempsFn  getTempsFn\n\t\texpectError bool\n\t\terrorMsg    string\n\t}{\n\t\t{\n\t\t\tname: \"successful_function_call\",\n\t\t\tgetTempsFn: func(ctx context.Context) ([]sensors.TemperatureStat, error) {\n\t\t\t\treturn []sensors.TemperatureStat{\n\t\t\t\t\t{SensorKey: \"test_sensor\", Temperature: 45.0},\n\t\t\t\t}, nil\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"function_returns_error\",\n\t\t\tgetTempsFn: func(ctx context.Context) ([]sensors.TemperatureStat, error) {\n\t\t\t\treturn []sensors.TemperatureStat{\n\t\t\t\t\t{SensorKey: \"test_sensor\", Temperature: 45.0},\n\t\t\t\t}, fmt.Errorf(\"sensor error\")\n\t\t\t},\n\t\t\texpectError: false, // getTempsWithPanicRecovery ignores errors from the function\n\t\t},\n\t\t{\n\t\t\tname: \"function_panics_with_string\",\n\t\t\tgetTempsFn: func(ctx context.Context) ([]sensors.TemperatureStat, error) {\n\t\t\t\tpanic(\"test panic\")\n\t\t\t},\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"panic: test panic\",\n\t\t},\n\t\t{\n\t\t\tname: \"function_panics_with_error\",\n\t\t\tgetTempsFn: func(ctx context.Context) ([]sensors.TemperatureStat, error) {\n\t\t\t\tpanic(fmt.Errorf(\"panic error\"))\n\t\t\t},\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"panic:\",\n\t\t},\n\t\t{\n\t\t\tname: \"function_panics_with_index_out_of_bounds\",\n\t\t\tgetTe"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/network.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/network.go", "rel_path": "agent/network.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 20, "text": "package agent\n\nimport (\n\t\"log/slog\"\n\t\"strings\"\n\t\"time\"\n\n\tpsutilNet \"github.com/shirou/gopsutil/v4/net\"\n)\n\nfunc (a *Agent) initializeNetIoStats() {\n\t// reset valid network interfaces\n\ta.netInterfaces = make(map[string]struct{}, 0)\n\n\t// map of network interface names passed in via NICS env var\n\tvar nicsMap map[string]struct{}\n\tnics, nicsEnvExists := GetEnv(\"NICS\")\n\tif nicsEnvExists {\n\t\tnicsMap = make(map[string]struct{}, 0)\n\t\tfor nic := range strings.SplitSeq(nics, \",\") {", "n_tokens": 137, "primary_symbol": "initializeNetIoStats", "primary_kind": "function", "primary_span": [11, 20], "def_symbols": ["initializeNetIoStats"], "symbols": ["initializeNetIoStats", "package", "agent", "import", "log", "slog", "strings", "time", "psutilNet", "github", "com", "shirou", "gopsutil", "net", "func", "Agent", "reset", "valid", "network", "interfaces", "netInterfaces", "make", "map", "string", "struct", "interface", "names", "passed", "via", "NICS", "env", "var", "nicsMap", "nics", "nicsEnvExists", "GetEnv", "for", "nic", "range", "SplitSeq"], "doc_head": "package agent\nimport (\n\t\"log/slog\"\n\t\"strings\"\n\t\"time\"\n\tpsutilNet \"github.com/shirou/gopsutil/v4/net\"\n)\nfunc (a *Agent) initializeNetIoStats() {\n\t// reset valid network interfaces\n\ta.netInterfaces = make(map[string]struct{}, 0)\n\t// map of network interface names passed in via NICS env var\n\tvar nicsMap map[string]struct{}\n\tnics, nicsEnvExists := GetEnv(\"NICS\")\n\tif nicsEnvExists {\n\t\tnicsMap = make(map[string]struct{}, 0)\n\t\tfor nic := range strings.SplitSeq(nics, \",\") {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/network.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/network.go", "rel_path": "agent/network.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 21, "end_line": 47, "text": "\t\t\tnicsMap[nic] = struct{}{}\n\t\t}\n\t}\n\n\t// reset network I/O stats\n\ta.netIoStats.BytesSent = 0\n\ta.netIoStats.BytesRecv = 0\n\n\t// get intial network I/O stats\n\tif netIO, err := psutilNet.IOCounters(true); err == nil {\n\t\ta.netIoStats.Time = time.Now()\n\t\tfor _, v := range netIO {\n\t\t\tswitch {\n\t\t\t// skip if nics exists and the interface is not in the list\n\t\t\tcase nicsEnvExists:\n\t\t\t\tif _, nameInNics := nicsMap[v.Name]; !nameInNics {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t// otherwise run the interface name through the skipNetworkInterface function\n\t\t\tdefault:\n\t\t\t\tif a.skipNetworkInterface(v) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tslog.Info(\"Detected network interface\", \"name\", v.Name, \"sent\", v.BytesSent, \"recv\", v.BytesRecv)\n\t\t\ta.netIoStats.BytesSent += v.BytesSent\n\t\t\ta.netIoStats.BytesRecv += v.BytesRecv", "n_tokens": 233, "primary_symbol": "", "primary_kind": "", "primary_span": [21, 47], "def_symbols": [], "symbols": ["nicsMap", "nic", "struct", "reset", "network", "stats", "netIoStats", "BytesSent", "BytesRecv", "get", "intial", "netIO", "err", "psutilNet", "IOCounters", "true", "nil", "Time", "time", "Now", "for", "range", "switch", "skip", "nics", "exists", "and", "the", "interface", "not", "list", "case", "nicsEnvExists", "nameInNics", "Name", "continue", "otherwise", "run", "name", "through", "skipNetworkInterface", "function", "default", "slog", "Info", "Detected", "sent", "recv"], "doc_head": "\t\t\tnicsMap[nic] = struct{}{}\n\t\t}\n\t}\n\t// reset network I/O stats\n\ta.netIoStats.BytesSent = 0\n\ta.netIoStats.BytesRecv = 0\n\t// get intial network I/O stats\n\tif netIO, err := psutilNet.IOCounters(true); err == nil {\n\t\ta.netIoStats.Time = time.Now()\n\t\tfor _, v := range netIO {\n\t\t\tswitch {\n\t\t\t// skip if nics exists and the interface is not in the list\n\t\t\tcase nicsEnvExists:\n\t\t\t\tif _, nameInNics := nicsMap[v.Name]; !nameInNics {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t// otherwise run the interface name through the skipNetworkInterface function\n\t\t\tdefault:\n\t\t\t\tif a.skipNetworkInterface(v) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tslog.Info(\"Detected network interface\", \"name\", v.Name, \"sent\", v.BytesSent, \"recv\", v.BytesRecv)\n\t\t\ta.netIoStats.BytesSent += v.BytesSent\n\t\t\ta.netIoStats.BytesRecv += v.BytesRecv"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/network.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/network.go", "rel_path": "agent/network.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 48, "end_line": 68, "text": "\t\t\t// store as a valid network interface\n\t\t\ta.netInterfaces[v.Name] = struct{}{}\n\t\t}\n\t}\n}\n\nfunc (a *Agent) skipNetworkInterface(v psutilNet.IOCountersStat) bool {\n\tswitch {\n\tcase strings.HasPrefix(v.Name, \"lo\"),\n\t\tstrings.HasPrefix(v.Name, \"docker\"),\n\t\tstrings.HasPrefix(v.Name, \"br-\"),\n\t\tstrings.HasPrefix(v.Name, \"veth\"),\n\t\tstrings.HasPrefix(v.Name, \"bond\"),\n\t\tv.BytesRecv == 0,\n\t\tv.BytesSent == 0:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n", "n_tokens": 129, "primary_symbol": "skipNetworkInterface", "primary_kind": "function", "primary_span": [54, 68], "def_symbols": ["skipNetworkInterface"], "symbols": ["skipNetworkInterface", "store", "valid", "network", "interface", "netInterfaces", "Name", "struct", "func", "Agent", "psutilNet", "IOCountersStat", "bool", "switch", "case", "strings", "HasPrefix", "docker", "veth", "bond", "BytesRecv", "BytesSent", "return", "true", "default", "false"], "doc_head": "\t\t\t// store as a valid network interface\n\t\t\ta.netInterfaces[v.Name] = struct{}{}\n\t\t}\n\t}\n}\nfunc (a *Agent) skipNetworkInterface(v psutilNet.IOCountersStat) bool {\n\tswitch {\n\tcase strings.HasPrefix(v.Name, \"lo\"),\n\t\tstrings.HasPrefix(v.Name, \"docker\"),\n\t\tstrings.HasPrefix(v.Name, \"br-\"),\n\t\tstrings.HasPrefix(v.Name, \"veth\"),\n\t\tstrings.HasPrefix(v.Name, \"bond\"),\n\t\tv.BytesRecv == 0,\n\t\tv.BytesSent == 0:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go", "rel_path": "agent/agent.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 21, "text": "// Package agent handles the agent's SSH server and system stats collection.\npackage agent\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gliderlabs/ssh\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/shirou/gopsutil/v4/host\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\ntype Agent struct {", "n_tokens": 115, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 21], "def_symbols": [], "symbols": ["Package", "agent", "handles", "the", "SSH", "server", "and", "system", "stats", "collection", "package", "import", "crypto", "sha256", "encoding", "hex", "log", "slog", "path", "filepath", "strings", "sync", "time", "github", "com", "gliderlabs", "ssh", "henrygd", "beszel", "src", "entities", "shirou", "gopsutil", "host", "gossh", "golang", "org", "type", "Agent", "struct"], "doc_head": "// Package agent handles the agent's SSH server and system stats collection.\npackage agent\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"github.com/gliderlabs/ssh\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/shirou/gopsutil/v4/host\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)\ntype Agent struct {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go", "rel_path": "agent/agent.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 22, "end_line": 40, "text": "\tsync.Mutex                                   // Used to lock agent while collecting data\n\tdebug             bool                       // true if LOG_LEVEL is set to debug\n\tzfs               bool                       // true if system has arcstats\n\tmemCalc           string                     // Memory calculation formula\n\tfsNames           []string                   // List of filesystem device names being monitored\n\tfsStats           map[string]*system.FsStats // Keeps track of disk stats for each filesystem\n\tnetInterfaces     map[string]struct{}        // Stores all valid network interfaces\n\tnetIoStats        system.NetIoStats          // Keeps track of bandwidth usage\n\tdockerManager     *dockerManager             // Manages Docker API requests\n\tsensorConfig      *SensorConfig              // Sensors config\n\tsystemInfo        system.Info                // Host system info\n\tgpuManager        *GPUManager                // Manages GPU data\n\tcache             *SessionCache              // Cache for system stats based on primary session ID\n\tconnectionManager *ConnectionManager         // Channel to signal connection events\n\tserver            *ssh.Server                // SSH server\n\tdataDir           string                     // Directory for persisting data\n\tkeys              []gossh.PublicKey          // SSH public keys\n}\n", "n_tokens": 235, "primary_symbol": "", "primary_kind": "", "primary_span": [22, 40], "def_symbols": [], "symbols": ["sync", "Mutex", "Used", "lock", "agent", "while", "collecting", "data", "debug", "bool", "true", "LOG_LEVEL", "set", "zfs", "system", "has", "arcstats", "memCalc", "string", "Memory", "calculation", "formula", "fsNames", "List", "filesystem", "device", "names", "being", "monitored", "fsStats", "map", "FsStats", "Keeps", "track", "disk", "stats", "for", "each", "netInterfaces", "struct", "Stores", "all", "valid", "network", "interfaces", "netIoStats", "NetIoStats", "bandwidth", "usage", "dockerManager", "Manages", "Docker", "API", "requests", "sensorConfig", "SensorConfig", "Sensors", "config", "systemInfo", "Info", "Host", "info", "gpuManager", "GPUManager", "GPU", "cache", "SessionCache", "Cache", "based", "primary", "session", "connectionManager", "ConnectionManager", "Channel", "signal", "connection", "events", "server", "ssh", "Server", "SSH", "dataDir", "Directory", "persisting", "keys", "gossh", "PublicKey", "public"], "doc_head": "\tsync.Mutex                                   // Used to lock agent while collecting data\n\tdebug             bool                       // true if LOG_LEVEL is set to debug\n\tzfs               bool                       // true if system has arcstats\n\tmemCalc           string                     // Memory calculation formula\n\tfsNames           []string                   // List of filesystem device names being monitored\n\tfsStats           map[string]*system.FsStats // Keeps track of disk stats for each filesystem\n\tnetInterfaces     map[string]struct{}        // Stores all valid network interfaces\n\tnetIoStats        system.NetIoStats          // Keeps track of bandwidth usage\n\tdockerManager     *dockerManager             // Manages Docker API requests\n\tsensorConfig      *SensorConfig              // Sensors config\n\tsystemInfo        system.Info                // Host system info\n\tgpuManager        *GPUManager                // Manages GPU data\n\tcache             *SessionCache              // Cache for system stats based on primary session ID\n\tconnectionManager *ConnectionManager         // Channel to signal connection events\n\tserver            *ssh.Server                // SSH server"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go", "rel_path": "agent/agent.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 41, "end_line": 102, "text": "// NewAgent creates a new agent with the given data directory for persisting data.\n// If the data directory is not set, it will attempt to find the optimal directory.\nfunc NewAgent(dataDir ...string) (agent *Agent, err error) {\n\tagent = &Agent{\n\t\tfsStats: make(map[string]*system.FsStats),\n\t\tcache:   NewSessionCache(69 * time.Second),\n\t}\n\n\tagent.dataDir, err = getDataDir(dataDir...)\n\tif err != nil {\n\t\tslog.Warn(\"Data directory not found\")\n\t} else {\n\t\tslog.Info(\"Data directory\", \"path\", agent.dataDir)\n\t}\n\n\tagent.memCalc, _ = GetEnv(\"MEM_CALC\")\n\tagent.sensorConfig = agent.newSensorConfig()\n\t// Set up slog with a log level determined by the LOG_LEVEL env var\n\tif logLevelStr, exists := GetEnv(\"LOG_LEVEL\"); exists {\n\t\tswitch strings.ToLower(logLevelStr) {\n\t\tcase \"debug\":\n\t\t\tagent.debug = true\n\t\t\tslog.SetLogLoggerLevel(slog.LevelDebug)\n\t\tcase \"warn\":\n\t\t\tslog.SetLogLoggerLevel(slog.LevelWarn)\n\t\tcase \"error\":\n\t\t\tslog.SetLogLoggerLevel(slog.LevelError)\n\t\t}\n\t}\n\n\tslog.Debug(beszel.Version)\n\n\t// initialize system info\n\tagent.initializeSystemInfo()\n\n\t// initialize connection manager\n\tagent.connectionManager = newConnectionManager(agent)\n\n\t// initialize disk info\n\tagent.initializeDiskInfo()\n\n\t// initialize net io stats\n\tagent.initializeNetIoStats()\n\n\t// initialize docker manager\n\tagent.dockerManager = newDockerManager(agent)\n\n\t// initialize GPU manager\n\tif gm, err := NewGPUManager(); err != nil {\n\t\tslog.Debug(\"GPU\", \"err\", err)\n\t} else {\n\t\tagent.gpuManager = gm\n\t}\n\n\t// if debugging, print stats\n\tif agent.debug {\n\t\tslog.Debug(\"Stats\", \"data\", agent.gatherStats(\"\"))\n\t}\n\n\treturn agent, nil\n}\n", "n_tokens": 420, "primary_symbol": "NewAgent", "primary_kind": "function", "primary_span": [43, 102], "def_symbols": ["NewAgent"], "symbols": ["NewAgent", "creates", "new", "agent", "with", "the", "given", "data", "directory", "for", "persisting", "not", "set", "will", "attempt", "find", "optimal", "func", "dataDir", "string", "Agent", "err", "error", "fsStats", "make", "map", "system", "FsStats", "cache", "NewSessionCache", "time", "Second", "getDataDir", "nil", "slog", "Warn", "Data", "found", "else", "Info", "path", "memCalc", "GetEnv", "MEM_CALC", "sensorConfig", "newSensorConfig", "Set", "log", "level", "determined", "LOG_LEVEL", "env", "var", "logLevelStr", "exists", "switch", "strings", "ToLower", "case", "debug", "true", "SetLogLoggerLevel", "LevelDebug", "warn", "LevelWarn", "LevelError", "Debug", "beszel", "Version", "initialize", "info", "initializeSystemInfo", "connection", "manager", "connectionManager", "newConnectionManager", "disk", "initializeDiskInfo", "net", "stats", "initializeNetIoStats", "docker", "dockerManager", "newDockerManager", "GPU", "NewGPUManager", "gpuManager", "debugging", "print", "Stats", "gatherStats", "return"], "doc_head": "// NewAgent creates a new agent with the given data directory for persisting data.\n// If the data directory is not set, it will attempt to find the optimal directory.\nfunc NewAgent(dataDir ...string) (agent *Agent, err error) {\n\tagent = &Agent{\n\t\tfsStats: make(map[string]*system.FsStats),\n\t\tcache:   NewSessionCache(69 * time.Second),\n\t}\n\tagent.dataDir, err = getDataDir(dataDir...)\n\tif err != nil {\n\t\tslog.Warn(\"Data directory not found\")\n\t} else {\n\t\tslog.Info(\"Data directory\", \"path\", agent.dataDir)\n\t}\n\tagent.memCalc, _ = GetEnv(\"MEM_CALC\")\n\tagent.sensorConfig = agent.newSensorConfig()\n\t// Set up slog with a log level determined by the LOG_LEVEL env var\n\tif logLevelStr, exists := GetEnv(\"LOG_LEVEL\"); exists {\n\t\tswitch strings.ToLower(logLevelStr) {\n\t\tcase \"debug\":\n\t\t\tagent.debug = true\n\t\t\tslog.SetLogLoggerLevel(slog.LevelDebug)\n\t\tcase \"warn\":\n\t\t\tslog.SetLogLoggerLevel(slog.LevelWarn)\n\t\tcase \"error\":\n\t\t\tslog.SetLogLoggerLevel(slog.LevelError)\n\t\t}\n\t}\n\tslog.Debug(beszel.Version)\n\t// initialize system info\n\tagent.initializeSystemInfo()\n\t// initialize connection manager\n\tagent.connectionManager = newConnectionManager(agent)\n\t// initialize disk info\n\tagent.initializeDiskInfo()\n\t// initial"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go", "rel_path": "agent/agent.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 103, "end_line": 111, "text": "// GetEnv retrieves an environment variable with a \"BESZEL_AGENT_\" prefix, or falls back to the unprefixed key.\nfunc GetEnv(key string) (value string, exists bool) {\n\tif value, exists = os.LookupEnv(\"BESZEL_AGENT_\" + key); exists {\n\t\treturn value, exists\n\t}\n\t// Fallback to the old unprefixed key\n\treturn os.LookupEnv(key)\n}\n", "n_tokens": 89, "primary_symbol": "GetEnv", "primary_kind": "function", "primary_span": [104, 111], "def_symbols": ["GetEnv"], "symbols": ["GetEnv", "retrieves", "environment", "variable", "with", "BESZEL_AGENT_", "prefix", "falls", "back", "the", "unprefixed", "key", "func", "string", "value", "exists", "bool", "LookupEnv", "return", "Fallback", "old"], "doc_head": "// GetEnv retrieves an environment variable with a \"BESZEL_AGENT_\" prefix, or falls back to the unprefixed key.\nfunc GetEnv(key string) (value string, exists bool) {\n\tif value, exists = os.LookupEnv(\"BESZEL_AGENT_\" + key); exists {\n\t\treturn value, exists\n\t}\n\t// Fallback to the old unprefixed key\n\treturn os.LookupEnv(key)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go", "rel_path": "agent/agent.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 112, "end_line": 148, "text": "func (a *Agent) gatherStats(sessionID string) *system.CombinedData {\n\ta.Lock()\n\tdefer a.Unlock()\n\n\tdata, isCached := a.cache.Get(sessionID)\n\tif isCached {\n\t\tslog.Debug(\"Cached data\", \"session\", sessionID)\n\t\treturn data\n\t}\n\n\t*data = system.CombinedData{\n\t\tStats: a.getSystemStats(),\n\t\tInfo:  a.systemInfo,\n\t}\n\tslog.Debug(\"System data\", \"data\", data)\n\n\tif a.dockerManager != nil {\n\t\tif containerStats, err := a.dockerManager.getDockerStats(); err == nil {\n\t\t\tdata.Containers = containerStats\n\t\t\tslog.Debug(\"Containers\", \"data\", data.Containers)\n\t\t} else {\n\t\t\tslog.Debug(\"Containers\", \"err\", err)\n\t\t}\n\t}\n\n\tdata.Stats.ExtraFs = make(map[string]*system.FsStats)\n\tfor name, stats := range a.fsStats {\n\t\tif !stats.Root && stats.DiskTotal > 0 {\n\t\t\tdata.Stats.ExtraFs[name] = stats\n\t\t}\n\t}\n\tslog.Debug(\"Extra FS\", \"data\", data.Stats.ExtraFs)\n\n\ta.cache.Set(sessionID, data)\n\treturn data\n}\n", "n_tokens": 258, "primary_symbol": "gatherStats", "primary_kind": "function", "primary_span": [112, 148], "def_symbols": ["gatherStats"], "symbols": ["gatherStats", "func", "Agent", "sessionID", "string", "system", "CombinedData", "Lock", "defer", "Unlock", "data", "isCached", "cache", "Get", "slog", "Debug", "Cached", "session", "return", "Stats", "getSystemStats", "Info", "systemInfo", "System", "dockerManager", "nil", "containerStats", "err", "getDockerStats", "Containers", "else", "ExtraFs", "make", "map", "FsStats", "for", "name", "stats", "range", "fsStats", "Root", "DiskTotal", "Extra", "Set"], "doc_head": "func (a *Agent) gatherStats(sessionID string) *system.CombinedData {\n\ta.Lock()\n\tdefer a.Unlock()\n\tdata, isCached := a.cache.Get(sessionID)\n\tif isCached {\n\t\tslog.Debug(\"Cached data\", \"session\", sessionID)\n\t\treturn data\n\t}\n\t*data = system.CombinedData{\n\t\tStats: a.getSystemStats(),\n\t\tInfo:  a.systemInfo,\n\t}\n\tslog.Debug(\"System data\", \"data\", data)\n\tif a.dockerManager != nil {\n\t\tif containerStats, err := a.dockerManager.getDockerStats(); err == nil {\n\t\t\tdata.Containers = containerStats\n\t\t\tslog.Debug(\"Containers\", \"data\", data.Containers)\n\t\t} else {\n\t\t\tslog.Debug(\"Containers\", \"err\", err)\n\t\t}\n\t}\n\tdata.Stats.ExtraFs = make(map[string]*system.FsStats)\n\tfor name, stats := range a.fsStats {\n\t\tif !stats.Root && stats.DiskTotal > 0 {\n\t\t\tdata.Stats.ExtraFs[name] = stats\n\t\t}\n\t}\n\tslog.Debug(\"Extra FS\", \"data\", data.Stats.ExtraFs)\n\ta.cache.Set(sessionID, data)\n\treturn data\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go", "rel_path": "agent/agent.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 149, "end_line": 154, "text": "// StartAgent initializes and starts the agent with optional WebSocket connection\nfunc (a *Agent) Start(serverOptions ServerOptions) error {\n\ta.keys = serverOptions.Keys\n\treturn a.connectionManager.Start(serverOptions)\n}\n", "n_tokens": 43, "primary_symbol": "Start", "primary_kind": "function", "primary_span": [150, 154], "def_symbols": ["Start"], "symbols": ["Start", "StartAgent", "initializes", "and", "starts", "the", "agent", "with", "optional", "WebSocket", "connection", "func", "Agent", "serverOptions", "ServerOptions", "error", "keys", "Keys", "return", "connectionManager"], "doc_head": "// StartAgent initializes and starts the agent with optional WebSocket connection\nfunc (a *Agent) Start(serverOptions ServerOptions) error {\n\ta.keys = serverOptions.Keys\n\treturn a.connectionManager.Start(serverOptions)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent.go", "rel_path": "agent/agent.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 155, "end_line": 183, "text": "func (a *Agent) getFingerprint() string {\n\t// first look for a fingerprint in the data directory\n\tif a.dataDir != \"\" {\n\t\tif fp, err := os.ReadFile(filepath.Join(a.dataDir, \"fingerprint\")); err == nil {\n\t\t\treturn string(fp)\n\t\t}\n\t}\n\n\t// if no fingerprint is found, generate one\n\tfingerprint, err := host.HostID()\n\tif err != nil || fingerprint == \"\" {\n\t\tfingerprint = a.systemInfo.Hostname + a.systemInfo.CpuModel\n\t}\n\n\t// hash fingerprint\n\tsum := sha256.Sum256([]byte(fingerprint))\n\tfingerprint = hex.EncodeToString(sum[:24])\n\n\t// save fingerprint to data directory\n\tif a.dataDir != \"\" {\n\t\terr = os.WriteFile(filepath.Join(a.dataDir, \"fingerprint\"), []byte(fingerprint), 0644)\n\t\tif err != nil {\n\t\t\tslog.Warn(\"Failed to save fingerprint\", \"err\", err)\n\t\t}\n\t}\n\n\treturn fingerprint\n}\n", "n_tokens": 207, "primary_symbol": "getFingerprint", "primary_kind": "function", "primary_span": [155, 183], "def_symbols": ["getFingerprint"], "symbols": ["getFingerprint", "func", "Agent", "string", "first", "look", "for", "fingerprint", "the", "data", "directory", "dataDir", "err", "ReadFile", "filepath", "Join", "nil", "return", "found", "generate", "one", "host", "HostID", "systemInfo", "Hostname", "CpuModel", "hash", "sum", "sha256", "Sum256", "byte", "hex", "EncodeToString", "save", "WriteFile", "slog", "Warn", "Failed"], "doc_head": "func (a *Agent) getFingerprint() string {\n\t// first look for a fingerprint in the data directory\n\tif a.dataDir != \"\" {\n\t\tif fp, err := os.ReadFile(filepath.Join(a.dataDir, \"fingerprint\")); err == nil {\n\t\t\treturn string(fp)\n\t\t}\n\t}\n\t// if no fingerprint is found, generate one\n\tfingerprint, err := host.HostID()\n\tif err != nil || fingerprint == \"\" {\n\t\tfingerprint = a.systemInfo.Hostname + a.systemInfo.CpuModel\n\t}\n\t// hash fingerprint\n\tsum := sha256.Sum256([]byte(fingerprint))\n\tfingerprint = hex.EncodeToString(sum[:24])\n\t// save fingerprint to data directory\n\tif a.dataDir != \"\" {\n\t\terr = os.WriteFile(filepath.Join(a.dataDir, \"fingerprint\"), []byte(fingerprint), 0644)\n\t\tif err != nil {\n\t\t\tslog.Warn(\"Failed to save fingerprint\", \"err\", err)\n\t\t}\n\t}\n\treturn fingerprint\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go", "rel_path": "agent/connection_manager.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 29, "text": "package agent\n\nimport (\n\t\"errors\"\n\t\"log/slog\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/agent/health\"\n)\n\n// ConnectionManager manages the connection state and events for the agent.\n// It handles both WebSocket and SSH connections, automatically switching between\n// them based on availability and managing reconnection attempts.\ntype ConnectionManager struct {\n\tagent         *Agent               // Reference to the parent agent\n\tState         ConnectionState      // Current connection state\n\teventChan     chan ConnectionEvent // Channel for connection events\n\twsClient      *WebSocketClient     // WebSocket client for hub communication\n\tserverOptions ServerOptions        // Configuration for SSH server\n\twsTicker      *time.Ticker         // Ticker for WebSocket connection attempts\n\tisConnecting  bool                 // Prevents multiple simultaneous reconnection attempts\n}\n\n// ConnectionState represents the current connection state of the agent.\ntype ConnectionState uint8\n", "n_tokens": 194, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 29], "def_symbols": [], "symbols": ["package", "agent", "import", "errors", "log", "slog", "signal", "syscall", "time", "github", "com", "henrygd", "beszel", "health", "ConnectionManager", "manages", "the", "connection", "state", "and", "events", "for", "handles", "both", "WebSocket", "SSH", "connections", "automatically", "switching", "between", "them", "based", "availability", "managing", "reconnection", "attempts", "type", "struct", "Agent", "Reference", "parent", "State", "ConnectionState", "Current", "eventChan", "chan", "ConnectionEvent", "Channel", "wsClient", "WebSocketClient", "client", "hub", "communication", "serverOptions", "ServerOptions", "Configuration", "server", "wsTicker", "Ticker", "isConnecting", "bool", "Prevents", "multiple", "simultaneous", "represents", "current", "uint8"], "doc_head": "package agent\nimport (\n\t\"errors\"\n\t\"log/slog\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/agent/health\"\n)\n// ConnectionManager manages the connection state and events for the agent.\n// It handles both WebSocket and SSH connections, automatically switching between\n// them based on availability and managing reconnection attempts.\ntype ConnectionManager struct {\n\tagent         *Agent               // Reference to the parent agent\n\tState         ConnectionState      // Current connection state\n\teventChan     chan ConnectionEvent // Channel for connection events\n\twsClient      *WebSocketClient     // WebSocket client for hub communication\n\tserverOptions ServerOptions        // Configuration for SSH server\n\twsTicker      *time.Ticker         // Ticker for WebSocket connection attempts\n\tisConnecting  bool                 // Prevents multiple simultaneous reconnection attempts\n}\n// ConnectionState represents the current connection state of the agent.\ntype ConnectionState uint8"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go", "rel_path": "agent/connection_manager.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 30, "end_line": 58, "text": "// ConnectionEvent represents connection-related events that can occur.\ntype ConnectionEvent uint8\n\n// Connection states\nconst (\n\tDisconnected       ConnectionState = iota // No active connection\n\tWebSocketConnected                        // Connected via WebSocket\n\tSSHConnected                              // Connected via SSH\n)\n\n// Connection events\nconst (\n\tWebSocketConnect    ConnectionEvent = iota // WebSocket connection established\n\tWebSocketDisconnect                        // WebSocket connection lost\n\tSSHConnect                                 // SSH connection established\n\tSSHDisconnect                              // SSH connection lost\n)\n\nconst wsTickerInterval = 10 * time.Second\n\n// newConnectionManager creates a new connection manager for the given agent.\nfunc newConnectionManager(agent *Agent) *ConnectionManager {\n\tcm := &ConnectionManager{\n\t\tagent: agent,\n\t\tState: Disconnected,\n\t}\n\treturn cm\n}\n", "n_tokens": 161, "primary_symbol": "newConnectionManager", "primary_kind": "function", "primary_span": [51, 58], "def_symbols": ["newConnectionManager"], "symbols": ["newConnectionManager", "ConnectionEvent", "represents", "connection", "related", "events", "that", "can", "occur", "type", "uint8", "Connection", "states", "const", "Disconnected", "ConnectionState", "iota", "active", "WebSocketConnected", "Connected", "via", "WebSocket", "SSHConnected", "SSH", "WebSocketConnect", "established", "WebSocketDisconnect", "lost", "SSHConnect", "SSHDisconnect", "wsTickerInterval", "time", "Second", "creates", "new", "manager", "for", "the", "given", "agent", "func", "Agent", "ConnectionManager", "State", "return"], "doc_head": "// ConnectionEvent represents connection-related events that can occur.\ntype ConnectionEvent uint8\n// Connection states\nconst (\n\tDisconnected       ConnectionState = iota // No active connection\n\tWebSocketConnected                        // Connected via WebSocket\n\tSSHConnected                              // Connected via SSH\n)\n// Connection events\nconst (\n\tWebSocketConnect    ConnectionEvent = iota // WebSocket connection established\n\tWebSocketDisconnect                        // WebSocket connection lost\n\tSSHConnect                                 // SSH connection established\n\tSSHDisconnect                              // SSH connection lost\n)\nconst wsTickerInterval = 10 * time.Second\n// newConnectionManager creates a new connection manager for the given agent.\nfunc newConnectionManager(agent *Agent) *ConnectionManager {\n\tcm := &ConnectionManager{\n\t\tagent: agent,\n\t\tState: Disconnected,\n\t}\n\treturn cm\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go", "rel_path": "agent/connection_manager.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 59, "end_line": 74, "text": "// startWsTicker starts or resets the WebSocket connection attempt ticker.\nfunc (c *ConnectionManager) startWsTicker() {\n\tif c.wsTicker == nil {\n\t\tc.wsTicker = time.NewTicker(wsTickerInterval)\n\t} else {\n\t\tc.wsTicker.Reset(wsTickerInterval)\n\t}\n}\n\n// stopWsTicker stops the WebSocket connection attempt ticker.\nfunc (c *ConnectionManager) stopWsTicker() {\n\tif c.wsTicker != nil {\n\t\tc.wsTicker.Stop()\n\t}\n}\n", "n_tokens": 99, "primary_symbol": "startWsTicker", "primary_kind": "function", "primary_span": [60, 74], "def_symbols": ["startWsTicker", "stopWsTicker"], "symbols": ["startWsTicker", "stopWsTicker", "starts", "resets", "the", "WebSocket", "connection", "attempt", "ticker", "func", "ConnectionManager", "wsTicker", "nil", "time", "NewTicker", "wsTickerInterval", "else", "Reset", "stops", "Stop"], "doc_head": "// startWsTicker starts or resets the WebSocket connection attempt ticker.\nfunc (c *ConnectionManager) startWsTicker() {\n\tif c.wsTicker == nil {\n\t\tc.wsTicker = time.NewTicker(wsTickerInterval)\n\t} else {\n\t\tc.wsTicker.Reset(wsTickerInterval)\n\t}\n}\n// stopWsTicker stops the WebSocket connection attempt ticker.\nfunc (c *ConnectionManager) stopWsTicker() {\n\tif c.wsTicker != nil {\n\t\tc.wsTicker.Stop()\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go", "rel_path": "agent/connection_manager.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 75, "end_line": 118, "text": "// Start begins connection attempts and enters the main event loop.\n// It handles connection events, periodic health updates, and graceful shutdown.\nfunc (c *ConnectionManager) Start(serverOptions ServerOptions) error {\n\tif c.eventChan != nil {\n\t\treturn errors.New(\"already started\")\n\t}\n\n\twsClient, err := newWebSocketClient(c.agent)\n\tif err != nil {\n\t\tslog.Warn(\"Error creating WebSocket client\", \"err\", err)\n\t}\n\tc.wsClient = wsClient\n\n\tc.serverOptions = serverOptions\n\tc.eventChan = make(chan ConnectionEvent, 1)\n\n\t// signal handling for shutdown\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\tc.startWsTicker()\n\tc.connect()\n\n\t// update health status immediately and every 90 seconds\n\t_ = health.Update()\n\thealthTicker := time.Tick(90 * time.Second)\n\n\tfor {\n\t\tselect {\n\t\tcase connectionEvent := <-c.eventChan:\n\t\t\tc.handleEvent(connectionEvent)\n\t\tcase <-c.wsTicker.C:\n\t\t\t_ = c.startWebSocketConnection()\n\t\tcase <-healthTicker:\n\t\t\t_ = health.Update()\n\t\tcase <-sigChan:\n\t\t\tslog.Info(\"Shutting down\")\n\t\t\t_ = c.agent.StopServer()\n\t\t\tc.closeWebSocket()\n\t\t\treturn health.CleanUp()\n\t\t}\n\t}\n}\n", "n_tokens": 281, "primary_symbol": "Start", "primary_kind": "function", "primary_span": [77, 118], "def_symbols": ["Start"], "symbols": ["Start", "begins", "connection", "attempts", "and", "enters", "the", "main", "event", "loop", "handles", "events", "periodic", "health", "updates", "graceful", "shutdown", "func", "ConnectionManager", "serverOptions", "ServerOptions", "error", "eventChan", "nil", "return", "errors", "New", "already", "started", "wsClient", "err", "newWebSocketClient", "agent", "slog", "Warn", "Error", "creating", "WebSocket", "client", "make", "chan", "ConnectionEvent", "signal", "handling", "for", "sigChan", "Signal", "Notify", "syscall", "SIGINT", "SIGTERM", "startWsTicker", "connect", "update", "status", "immediately", "every", "seconds", "Update", "healthTicker", "time", "Tick", "Second", "select", "case", "connectionEvent", "handleEvent", "wsTicker", "startWebSocketConnection", "Info", "Shutting", "down", "StopServer", "closeWebSocket", "CleanUp"], "doc_head": "// Start begins connection attempts and enters the main event loop.\n// It handles connection events, periodic health updates, and graceful shutdown.\nfunc (c *ConnectionManager) Start(serverOptions ServerOptions) error {\n\tif c.eventChan != nil {\n\t\treturn errors.New(\"already started\")\n\t}\n\twsClient, err := newWebSocketClient(c.agent)\n\tif err != nil {\n\t\tslog.Warn(\"Error creating WebSocket client\", \"err\", err)\n\t}\n\tc.wsClient = wsClient\n\tc.serverOptions = serverOptions\n\tc.eventChan = make(chan ConnectionEvent, 1)\n\t// signal handling for shutdown\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\tc.startWsTicker()\n\tc.connect()\n\t// update health status immediately and every 90 seconds\n\t_ = health.Update()\n\thealthTicker := time.Tick(90 * time.Second)\n\tfor {\n\t\tselect {\n\t\tcase connectionEvent := <-c.eventChan:\n\t\t\tc.handleEvent(connectionEvent)\n\t\tcase <-c.wsTicker.C:\n\t\t\t_ = c.startWebSocketConnection()\n\t\tcase <-healthTicker:\n\t\t\t_ = health.Update()\n\t\tcase <-sigChan:\n\t\t\tslog.Info(\"Shutting down\")\n\t\t\t_ = c.agent.StopServer()\n\t\t\tc.closeWebSocket()\n\t\t\treturn health.CleanUp()\n\t\t}\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go", "rel_path": "agent/connection_manager.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 119, "end_line": 136, "text": "// handleEvent processes connection events and updates the connection state accordingly.\nfunc (c *ConnectionManager) handleEvent(event ConnectionEvent) {\n\tswitch event {\n\tcase WebSocketConnect:\n\t\tc.handleStateChange(WebSocketConnected)\n\tcase SSHConnect:\n\t\tc.handleStateChange(SSHConnected)\n\tcase WebSocketDisconnect:\n\t\tif c.State == WebSocketConnected {\n\t\t\tc.handleStateChange(Disconnected)\n\t\t}\n\tcase SSHDisconnect:\n\t\tif c.State == SSHConnected {\n\t\t\tc.handleStateChange(Disconnected)\n\t\t}\n\t}\n}\n", "n_tokens": 105, "primary_symbol": "handleEvent", "primary_kind": "function", "primary_span": [120, 136], "def_symbols": ["handleEvent"], "symbols": ["handleEvent", "processes", "connection", "events", "and", "updates", "the", "state", "accordingly", "func", "ConnectionManager", "event", "ConnectionEvent", "switch", "case", "WebSocketConnect", "handleStateChange", "WebSocketConnected", "SSHConnect", "SSHConnected", "WebSocketDisconnect", "State", "Disconnected", "SSHDisconnect"], "doc_head": "// handleEvent processes connection events and updates the connection state accordingly.\nfunc (c *ConnectionManager) handleEvent(event ConnectionEvent) {\n\tswitch event {\n\tcase WebSocketConnect:\n\t\tc.handleStateChange(WebSocketConnected)\n\tcase SSHConnect:\n\t\tc.handleStateChange(SSHConnected)\n\tcase WebSocketDisconnect:\n\t\tif c.State == WebSocketConnected {\n\t\t\tc.handleStateChange(Disconnected)\n\t\t}\n\tcase SSHDisconnect:\n\t\tif c.State == SSHConnected {\n\t\t\tc.handleStateChange(Disconnected)\n\t\t}\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go", "rel_path": "agent/connection_manager.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 137, "end_line": 168, "text": "// handleStateChange updates the connection state and performs necessary actions\n// based on the new state, including stopping services and initiating reconnections.\nfunc (c *ConnectionManager) handleStateChange(newState ConnectionState) {\n\tif c.State == newState {\n\t\treturn\n\t}\n\tc.State = newState\n\tswitch newState {\n\tcase WebSocketConnected:\n\t\tslog.Info(\"WebSocket connected\", \"host\", c.wsClient.hubURL.Host)\n\t\tc.stopWsTicker()\n\t\t_ = c.agent.StopServer()\n\t\tc.isConnecting = false\n\tcase SSHConnected:\n\t\t// stop new ws connection attempts\n\t\tslog.Info(\"SSH connection established\")\n\t\tc.stopWsTicker()\n\t\tc.isConnecting = false\n\tcase Disconnected:\n\t\tif c.isConnecting {\n\t\t\t// Already handling reconnection, avoid duplicate attempts\n\t\t\treturn\n\t\t}\n\t\tc.isConnecting = true\n\t\tslog.Warn(\"Disconnected from hub\")\n\t\t// make sure old ws connection is closed\n\t\tc.closeWebSocket()\n\t\t// reconnect\n\t\tgo c.connect()\n\t}\n}\n", "n_tokens": 214, "primary_symbol": "handleStateChange", "primary_kind": "function", "primary_span": [139, 168], "def_symbols": ["handleStateChange"], "symbols": ["handleStateChange", "updates", "the", "connection", "state", "and", "performs", "necessary", "actions", "based", "new", "including", "stopping", "services", "initiating", "reconnections", "func", "ConnectionManager", "newState", "ConnectionState", "State", "return", "switch", "case", "WebSocketConnected", "slog", "Info", "WebSocket", "connected", "host", "wsClient", "hubURL", "Host", "stopWsTicker", "agent", "StopServer", "isConnecting", "false", "SSHConnected", "stop", "attempts", "SSH", "established", "Disconnected", "Already", "handling", "reconnection", "avoid", "duplicate", "true", "Warn", "from", "hub", "make", "sure", "old", "closed", "closeWebSocket", "reconnect", "connect"], "doc_head": "// handleStateChange updates the connection state and performs necessary actions\n// based on the new state, including stopping services and initiating reconnections.\nfunc (c *ConnectionManager) handleStateChange(newState ConnectionState) {\n\tif c.State == newState {\n\t\treturn\n\t}\n\tc.State = newState\n\tswitch newState {\n\tcase WebSocketConnected:\n\t\tslog.Info(\"WebSocket connected\", \"host\", c.wsClient.hubURL.Host)\n\t\tc.stopWsTicker()\n\t\t_ = c.agent.StopServer()\n\t\tc.isConnecting = false\n\tcase SSHConnected:\n\t\t// stop new ws connection attempts\n\t\tslog.Info(\"SSH connection established\")\n\t\tc.stopWsTicker()\n\t\tc.isConnecting = false\n\tcase Disconnected:\n\t\tif c.isConnecting {\n\t\t\t// Already handling reconnection, avoid duplicate attempts\n\t\t\treturn\n\t\t}\n\t\tc.isConnecting = true\n\t\tslog.Warn(\"Disconnected from hub\")\n\t\t// make sure old ws connection is closed\n\t\tc.closeWebSocket()\n\t\t// reconnect\n\t\tgo c.connect()\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go", "rel_path": "agent/connection_manager.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 169, "end_line": 188, "text": "// connect handles the connection logic with proper delays and priority.\n// It attempts WebSocket connection first, falling back to SSH server if needed.\nfunc (c *ConnectionManager) connect() {\n\tc.isConnecting = true\n\tdefer func() {\n\t\tc.isConnecting = false\n\t}()\n\n\tif c.wsClient != nil && time.Since(c.wsClient.lastConnectAttempt) < 5*time.Second {\n\t\ttime.Sleep(5 * time.Second)\n\t}\n\n\t// Try WebSocket first, if it fails, start SSH server\n\terr := c.startWebSocketConnection()\n\tif err != nil && c.State == Disconnected {\n\t\tc.startSSHServer()\n\t\tc.startWsTicker()\n\t}\n}\n", "n_tokens": 136, "primary_symbol": "connect", "primary_kind": "function", "primary_span": [171, 188], "def_symbols": ["connect"], "symbols": ["connect", "handles", "the", "connection", "logic", "with", "proper", "delays", "and", "priority", "attempts", "WebSocket", "first", "falling", "back", "SSH", "server", "needed", "func", "ConnectionManager", "isConnecting", "true", "defer", "false", "wsClient", "nil", "time", "Since", "lastConnectAttempt", "Second", "Sleep", "Try", "fails", "start", "err", "startWebSocketConnection", "State", "Disconnected", "startSSHServer", "startWsTicker"], "doc_head": "// connect handles the connection logic with proper delays and priority.\n// It attempts WebSocket connection first, falling back to SSH server if needed.\nfunc (c *ConnectionManager) connect() {\n\tc.isConnecting = true\n\tdefer func() {\n\t\tc.isConnecting = false\n\t}()\n\tif c.wsClient != nil && time.Since(c.wsClient.lastConnectAttempt) < 5*time.Second {\n\t\ttime.Sleep(5 * time.Second)\n\t}\n\t// Try WebSocket first, if it fails, start SSH server\n\terr := c.startWebSocketConnection()\n\tif err != nil && c.State == Disconnected {\n\t\tc.startSSHServer()\n\t\tc.startWsTicker()\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go", "rel_path": "agent/connection_manager.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 189, "end_line": 215, "text": "// startWebSocketConnection attempts to establish a WebSocket connection to the hub.\nfunc (c *ConnectionManager) startWebSocketConnection() error {\n\tif c.State != Disconnected {\n\t\treturn errors.New(\"already connected\")\n\t}\n\tif c.wsClient == nil {\n\t\treturn errors.New(\"WebSocket client not initialized\")\n\t}\n\tif time.Since(c.wsClient.lastConnectAttempt) < 5*time.Second {\n\t\treturn errors.New(\"already connecting\")\n\t}\n\n\terr := c.wsClient.Connect()\n\tif err != nil {\n\t\tslog.Warn(\"WebSocket connection failed\", \"err\", err)\n\t\tc.closeWebSocket()\n\t}\n\treturn err\n}\n\n// startSSHServer starts the SSH server if the agent is currently disconnected.\nfunc (c *ConnectionManager) startSSHServer() {\n\tif c.State == Disconnected {\n\t\tgo c.agent.StartServer(c.serverOptions)\n\t}\n}\n", "n_tokens": 173, "primary_symbol": "startWebSocketConnection", "primary_kind": "function", "primary_span": [190, 215], "def_symbols": ["startWebSocketConnection", "startSSHServer"], "symbols": ["startWebSocketConnection", "startSSHServer", "attempts", "establish", "WebSocket", "connection", "the", "hub", "func", "ConnectionManager", "error", "State", "Disconnected", "return", "errors", "New", "already", "connected", "wsClient", "nil", "client", "not", "initialized", "time", "Since", "lastConnectAttempt", "Second", "connecting", "err", "Connect", "slog", "Warn", "failed", "closeWebSocket", "starts", "SSH", "server", "agent", "currently", "disconnected", "StartServer", "serverOptions"], "doc_head": "// startWebSocketConnection attempts to establish a WebSocket connection to the hub.\nfunc (c *ConnectionManager) startWebSocketConnection() error {\n\tif c.State != Disconnected {\n\t\treturn errors.New(\"already connected\")\n\t}\n\tif c.wsClient == nil {\n\t\treturn errors.New(\"WebSocket client not initialized\")\n\t}\n\tif time.Since(c.wsClient.lastConnectAttempt) < 5*time.Second {\n\t\treturn errors.New(\"already connecting\")\n\t}\n\terr := c.wsClient.Connect()\n\tif err != nil {\n\t\tslog.Warn(\"WebSocket connection failed\", \"err\", err)\n\t\tc.closeWebSocket()\n\t}\n\treturn err\n}\n// startSSHServer starts the SSH server if the agent is currently disconnected.\nfunc (c *ConnectionManager) startSSHServer() {\n\tif c.State == Disconnected {\n\t\tgo c.agent.StartServer(c.serverOptions)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/connection_manager.go", "rel_path": "agent/connection_manager.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 216, "end_line": 222, "text": "// closeWebSocket closes the WebSocket connection if it exists.\nfunc (c *ConnectionManager) closeWebSocket() {\n\tif c.wsClient != nil {\n\t\tc.wsClient.Close()\n\t}\n}\n", "n_tokens": 38, "primary_symbol": "closeWebSocket", "primary_kind": "function", "primary_span": [217, 222], "def_symbols": ["closeWebSocket"], "symbols": ["closeWebSocket", "closes", "the", "WebSocket", "connection", "exists", "func", "ConnectionManager", "wsClient", "nil", "Close"], "doc_head": "// closeWebSocket closes the WebSocket connection if it exists.\nfunc (c *ConnectionManager) closeWebSocket() {\n\tif c.wsClient != nil {\n\t\tc.wsClient.Close()\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/utils.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/utils.go", "rel_path": "agent/utils.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 16, "text": "package agent\n\nimport \"math\"\n\nfunc bytesToMegabytes(b float64) float64 {\n\treturn twoDecimals(b / 1048576)\n}\n\nfunc bytesToGigabytes(b uint64) float64 {\n\treturn twoDecimals(float64(b) / 1073741824)\n}\n\nfunc twoDecimals(value float64) float64 {\n\treturn math.Round(value*100) / 100\n}\n", "n_tokens": 83, "primary_symbol": "bytesToMegabytes", "primary_kind": "function", "primary_span": [5, 16], "def_symbols": ["bytesToMegabytes", "bytesToGigabytes", "twoDecimals"], "symbols": ["bytesToMegabytes", "bytesToGigabytes", "twoDecimals", "package", "agent", "import", "math", "func", "float64", "return", "uint64", "value", "Round"], "doc_head": "package agent\nimport \"math\"\nfunc bytesToMegabytes(b float64) float64 {\n\treturn twoDecimals(b / 1048576)\n}\nfunc bytesToGigabytes(b uint64) float64 {\n\treturn twoDecimals(float64(b) / 1073741824)\n}\nfunc twoDecimals(value float64) float64 {\n\treturn math.Round(value*100) / 100\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go", "rel_path": "agent/sensors_windows.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 29, "text": "//go:build windows\n\n//go:generate dotnet build -c Release lhm/beszel_lhm.csproj\n\npackage agent\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"embed\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/shirou/gopsutil/v4/sensors\"\n)\n\n// Note: This is always called from Agent.gatherStats() which holds Agent.Lock(),\n// so no internal concurrency protection is needed.\n", "n_tokens": 124, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 29], "def_symbols": [], "symbols": ["build", "windows", "generate", "dotnet", "Release", "lhm", "beszel_lhm", "csproj", "package", "agent", "import", "bufio", "context", "embed", "errors", "fmt", "log", "slog", "exec", "path", "filepath", "strconv", "strings", "sync", "time", "github", "com", "shirou", "gopsutil", "sensors", "Note", "This", "always", "called", "from", "Agent", "gatherStats", "which", "holds", "Lock", "internal", "concurrency", "protection", "needed"], "doc_head": "//go:build windows\n//go:generate dotnet build -c Release lhm/beszel_lhm.csproj\npackage agent\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"embed\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"github.com/shirou/gopsutil/v4/sensors\"\n)\n// Note: This is always called from Agent.gatherStats() which holds Agent.Lock(),\n// so no internal concurrency protection is needed."}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go", "rel_path": "agent/sensors_windows.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 30, "end_line": 53, "text": "// lhmProcess is a wrapper around the LHM .NET process.\ntype lhmProcess struct {\n\tcmd                  *exec.Cmd\n\tstdin                io.WriteCloser\n\tstdout               io.ReadCloser\n\tscanner              *bufio.Scanner\n\tisRunning            bool\n\tstoppedNoSensors     bool\n\tconsecutiveNoSensors uint8\n\texecPath             string\n\ttempDir              string\n}\n\n//go:embed all:lhm/bin/Release/net48\nvar lhmFs embed.FS\n\nvar (\n\tbeszelLhm     *lhmProcess\n\tbeszelLhmOnce sync.Once\n\tuseLHM        = os.Getenv(\"LHM\") == \"true\"\n)\n\nvar errNoSensors = errors.New(\"no sensors found (try running as admin with LHM=true)\")\n", "n_tokens": 163, "primary_symbol": "", "primary_kind": "", "primary_span": [30, 53], "def_symbols": [], "symbols": ["lhmProcess", "wrapper", "around", "the", "LHM", "NET", "process", "type", "struct", "cmd", "exec", "Cmd", "stdin", "WriteCloser", "stdout", "ReadCloser", "scanner", "bufio", "Scanner", "isRunning", "bool", "stoppedNoSensors", "consecutiveNoSensors", "uint8", "execPath", "string", "tempDir", "embed", "all", "lhm", "bin", "Release", "net48", "var", "lhmFs", "beszelLhm", "beszelLhmOnce", "sync", "Once", "useLHM", "Getenv", "true", "errNoSensors", "errors", "New", "sensors", "found", "try", "running", "admin", "with"], "doc_head": "// lhmProcess is a wrapper around the LHM .NET process.\ntype lhmProcess struct {\n\tcmd                  *exec.Cmd\n\tstdin                io.WriteCloser\n\tstdout               io.ReadCloser\n\tscanner              *bufio.Scanner\n\tisRunning            bool\n\tstoppedNoSensors     bool\n\tconsecutiveNoSensors uint8\n\texecPath             string\n\ttempDir              string\n}\n//go:embed all:lhm/bin/Release/net48\nvar lhmFs embed.FS\nvar (\n\tbeszelLhm     *lhmProcess\n\tbeszelLhmOnce sync.Once\n\tuseLHM        = os.Getenv(\"LHM\") == \"true\"\n)\nvar errNoSensors = errors.New(\"no sensors found (try running as admin with LHM=true)\")"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go", "rel_path": "agent/sensors_windows.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 54, "end_line": 81, "text": "// newlhmProcess copies the embedded LHM executable to a temporary directory and starts it.\nfunc newlhmProcess() (*lhmProcess, error) {\n\tdestDir := filepath.Join(os.TempDir(), \"beszel\")\n\texecPath := filepath.Join(destDir, \"beszel_lhm.exe\")\n\n\tif err := os.MkdirAll(destDir, 0755); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create temp directory: %w\", err)\n\t}\n\n\t// Only copy if executable doesn't exist\n\tif _, err := os.Stat(execPath); os.IsNotExist(err) {\n\t\tif err := copyEmbeddedDir(lhmFs, \"lhm/bin/Release/net48\", destDir); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to copy embedded directory: %w\", err)\n\t\t}\n\t}\n\n\tlhm := &lhmProcess{\n\t\texecPath: execPath,\n\t\ttempDir:  destDir,\n\t}\n\n\tif err := lhm.startProcess(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to start process: %w\", err)\n\t}\n\n\treturn lhm, nil\n}\n", "n_tokens": 237, "primary_symbol": "newlhmProcess", "primary_kind": "function", "primary_span": [55, 81], "def_symbols": ["newlhmProcess"], "symbols": ["newlhmProcess", "copies", "the", "embedded", "LHM", "executable", "temporary", "directory", "and", "starts", "func", "lhmProcess", "error", "destDir", "filepath", "Join", "TempDir", "beszel", "execPath", "beszel_lhm", "exe", "err", "MkdirAll", "nil", "return", "fmt", "Errorf", "failed", "create", "temp", "Only", "copy", "doesn", "exist", "Stat", "IsNotExist", "copyEmbeddedDir", "lhmFs", "lhm", "bin", "Release", "net48", "tempDir", "startProcess", "start", "process"], "doc_head": "// newlhmProcess copies the embedded LHM executable to a temporary directory and starts it.\nfunc newlhmProcess() (*lhmProcess, error) {\n\tdestDir := filepath.Join(os.TempDir(), \"beszel\")\n\texecPath := filepath.Join(destDir, \"beszel_lhm.exe\")\n\tif err := os.MkdirAll(destDir, 0755); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create temp directory: %w\", err)\n\t}\n\t// Only copy if executable doesn't exist\n\tif _, err := os.Stat(execPath); os.IsNotExist(err) {\n\t\tif err := copyEmbeddedDir(lhmFs, \"lhm/bin/Release/net48\", destDir); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to copy embedded directory: %w\", err)\n\t\t}\n\t}\n\tlhm := &lhmProcess{\n\t\texecPath: execPath,\n\t\ttempDir:  destDir,\n\t}\n\tif err := lhm.startProcess(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to start process: %w\", err)\n\t}\n\treturn lhm, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go", "rel_path": "agent/sensors_windows.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 82, "end_line": 117, "text": "// startProcess starts the external LHM process\nfunc (lhm *lhmProcess) startProcess() error {\n\t// Clean up any existing process\n\tlhm.cleanupProcess()\n\n\tcmd := exec.Command(lhm.execPath)\n\tstdin, err := cmd.StdinPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\tstdin.Close()\n\t\treturn err\n\t}\n\n\tif err := cmd.Start(); err != nil {\n\t\tstdin.Close()\n\t\tstdout.Close()\n\t\treturn err\n\t}\n\n\t// Update process state\n\tlhm.cmd = cmd\n\tlhm.stdin = stdin\n\tlhm.stdout = stdout\n\tlhm.scanner = bufio.NewScanner(stdout)\n\tlhm.isRunning = true\n\n\t// Give process a moment to initialize\n\ttime.Sleep(100 * time.Millisecond)\n\n\treturn nil\n}\n", "n_tokens": 180, "primary_symbol": "startProcess", "primary_kind": "function", "primary_span": [83, 117], "def_symbols": ["startProcess"], "symbols": ["startProcess", "starts", "the", "external", "LHM", "process", "func", "lhm", "lhmProcess", "error", "Clean", "any", "existing", "cleanupProcess", "cmd", "exec", "Command", "execPath", "stdin", "err", "StdinPipe", "nil", "return", "stdout", "StdoutPipe", "Close", "Start", "Update", "state", "scanner", "bufio", "NewScanner", "isRunning", "true", "Give", "moment", "initialize", "time", "Sleep", "Millisecond"], "doc_head": "// startProcess starts the external LHM process\nfunc (lhm *lhmProcess) startProcess() error {\n\t// Clean up any existing process\n\tlhm.cleanupProcess()\n\tcmd := exec.Command(lhm.execPath)\n\tstdin, err := cmd.StdinPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\tstdin.Close()\n\t\treturn err\n\t}\n\tif err := cmd.Start(); err != nil {\n\t\tstdin.Close()\n\t\tstdout.Close()\n\t\treturn err\n\t}\n\t// Update process state\n\tlhm.cmd = cmd\n\tlhm.stdin = stdin\n\tlhm.stdout = stdout\n\tlhm.scanner = bufio.NewScanner(stdout)\n\tlhm.isRunning = true\n\t// Give process a moment to initialize\n\ttime.Sleep(100 * time.Millisecond)\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go", "rel_path": "agent/sensors_windows.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 118, "end_line": 141, "text": "// cleanupProcess terminates the process and closes resources but preserves files\nfunc (lhm *lhmProcess) cleanupProcess() {\n\tlhm.isRunning = false\n\n\tif lhm.cmd != nil && lhm.cmd.Process != nil {\n\t\tlhm.cmd.Process.Kill()\n\t\tlhm.cmd.Wait()\n\t}\n\n\tif lhm.stdin != nil {\n\t\tlhm.stdin.Close()\n\t\tlhm.stdin = nil\n\t}\n\tif lhm.stdout != nil {\n\t\tlhm.stdout.Close()\n\t\tlhm.stdout = nil\n\t}\n\n\tlhm.cmd = nil\n\tlhm.scanner = nil\n\tlhm.stoppedNoSensors = false\n\tlhm.consecutiveNoSensors = 0\n}\n", "n_tokens": 142, "primary_symbol": "cleanupProcess", "primary_kind": "function", "primary_span": [119, 141], "def_symbols": ["cleanupProcess"], "symbols": ["cleanupProcess", "terminates", "the", "process", "and", "closes", "resources", "but", "preserves", "files", "func", "lhm", "lhmProcess", "isRunning", "false", "cmd", "nil", "Process", "Kill", "Wait", "stdin", "Close", "stdout", "scanner", "stoppedNoSensors", "consecutiveNoSensors"], "doc_head": "// cleanupProcess terminates the process and closes resources but preserves files\nfunc (lhm *lhmProcess) cleanupProcess() {\n\tlhm.isRunning = false\n\tif lhm.cmd != nil && lhm.cmd.Process != nil {\n\t\tlhm.cmd.Process.Kill()\n\t\tlhm.cmd.Wait()\n\t}\n\tif lhm.stdin != nil {\n\t\tlhm.stdin.Close()\n\t\tlhm.stdin = nil\n\t}\n\tif lhm.stdout != nil {\n\t\tlhm.stdout.Close()\n\t\tlhm.stdout = nil\n\t}\n\tlhm.cmd = nil\n\tlhm.scanner = nil\n\tlhm.stoppedNoSensors = false\n\tlhm.consecutiveNoSensors = 0\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go", "rel_path": "agent/sensors_windows.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 142, "end_line": 216, "text": "func (lhm *lhmProcess) getTemps(ctx context.Context) (temps []sensors.TemperatureStat, err error) {\n\tif !useLHM || lhm.stoppedNoSensors {\n\t\t// Fall back to gopsutil if we can't get sensors from LHM\n\t\treturn sensors.TemperaturesWithContext(ctx)\n\t}\n\n\t// Start process if it's not running\n\tif !lhm.isRunning || lhm.stdin == nil || lhm.scanner == nil {\n\t\terr := lhm.startProcess()\n\t\tif err != nil {\n\t\t\treturn temps, err\n\t\t}\n\t}\n\n\t// Send command to process\n\t_, err = fmt.Fprintln(lhm.stdin, \"getTemps\")\n\tif err != nil {\n\t\tlhm.isRunning = false\n\t\treturn temps, fmt.Errorf(\"failed to send command: %w\", err)\n\t}\n\n\t// Read all sensor lines until we hit an empty line or EOF\n\tfor lhm.scanner.Scan() {\n\t\tline := strings.TrimSpace(lhm.scanner.Text())\n\t\tif line == \"\" {\n\t\t\tbreak\n\t\t}\n\n\t\tparts := strings.Split(line, \"|\")\n\t\tif len(parts) != 2 {\n\t\t\tslog.Debug(\"Invalid sensor format\", \"line\", line)\n\t\t\tcontinue\n\t\t}\n\n\t\tname := strings.TrimSpace(parts[0])\n\t\tvalueStr := strings.TrimSpace(parts[1])\n\n\t\tvalue, err := strconv.ParseFloat(valueStr, 64)\n\t\tif err != nil {\n\t\t\tslog.Debug(\"Failed to parse sensor\", \"err\", err, \"line\", line)\n\t\t\tcontinue\n\t\t}\n\n\t\tif name == \"\" || value <= 0 || value > 150 {\n\t\t\tslog.Debug(\"Invalid sensor\", \"name\", name, \"val\", value, \"line\", line)\n\t\t\tcontinue\n\t\t}\n\n\t\ttemps = append(temps, sensors.TemperatureStat{\n\t\t\tSensorKey:   name,\n\t\t\tTemperature: value,\n\t\t})\n\t}\n\n\tif err := lhm.scanner.Err(); err != nil {\n\t\tlhm.isRunning = false\n\t\treturn temps, err\n\t}\n\n\t// Handle no sensors case\n\tif len(temps) == 0 {\n\t\tlhm.consecutiveNoSensors++\n\t\tif lhm.consecutiveNoSensors >= 3 {\n\t\t\tlhm.stoppedNoSensors = true\n\t\t\tslog.Warn(errNoSensors.Error())\n\t\t\tlhm.cleanup()\n\t\t}\n\t\treturn sensors.TemperaturesWithContext(ctx)\n\t}\n\n\tlhm.consecutiveNoSensors = 0\n\n\treturn temps, nil\n}\n", "n_tokens": 536, "primary_symbol": "getTemps", "primary_kind": "function", "primary_span": [142, 216], "def_symbols": ["getTemps"], "symbols": ["getTemps", "func", "lhm", "lhmProcess", "ctx", "context", "Context", "temps", "sensors", "TemperatureStat", "err", "error", "useLHM", "stoppedNoSensors", "Fall", "back", "gopsutil", "can", "get", "from", "LHM", "return", "TemperaturesWithContext", "Start", "process", "not", "running", "isRunning", "stdin", "nil", "scanner", "startProcess", "Send", "command", "fmt", "Fprintln", "false", "Errorf", "failed", "send", "Read", "all", "sensor", "lines", "until", "hit", "empty", "line", "EOF", "for", "Scan", "strings", "TrimSpace", "Text", "break", "parts", "Split", "len", "slog", "Debug", "Invalid", "format", "continue", "name", "valueStr", "value", "strconv", "ParseFloat", "Failed", "parse", "val", "append", "SensorKey", "Temperature", "Err", "Handle", "case", "consecutiveNoSensors", "true", "Warn", "errNoSensors", "Error", "cleanup"], "doc_head": "func (lhm *lhmProcess) getTemps(ctx context.Context) (temps []sensors.TemperatureStat, err error) {\n\tif !useLHM || lhm.stoppedNoSensors {\n\t\t// Fall back to gopsutil if we can't get sensors from LHM\n\t\treturn sensors.TemperaturesWithContext(ctx)\n\t}\n\t// Start process if it's not running\n\tif !lhm.isRunning || lhm.stdin == nil || lhm.scanner == nil {\n\t\terr := lhm.startProcess()\n\t\tif err != nil {\n\t\t\treturn temps, err\n\t\t}\n\t}\n\t// Send command to process\n\t_, err = fmt.Fprintln(lhm.stdin, \"getTemps\")\n\tif err != nil {\n\t\tlhm.isRunning = false\n\t\treturn temps, fmt.Errorf(\"failed to send command: %w\", err)\n\t}\n\t// Read all sensor lines until we hit an empty line or EOF\n\tfor lhm.scanner.Scan() {\n\t\tline := strings.TrimSpace(lhm.scanner.Text())\n\t\tif line == \"\" {\n\t\t\tbreak\n\t\t}\n\t\tparts := strings.Split(line, \"|\")\n\t\tif len(parts) != 2 {\n\t\t\tslog.Debug(\"Invalid sensor format\", \"line\", line)\n\t\t\tcontinue\n\t\t}\n\t\tname := strings.TrimSpace(parts[0])\n\t\tvalueStr := strings.TrimSpace(parts[1])\n\t\tvalue, err := strconv.ParseFloat(valueStr, 64)\n\t\tif err != nil {\n\t\t\tslog.Debug(\"Failed to parse sensor\", \"err\", err, \"line\", line)\n\t\t\tcontinue\n\t\t}\n\t\tif name == \"\" || value <= 0 || value > 150 {\n\t\t\tslog.Debug(\"Invalid sensor"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go", "rel_path": "agent/sensors_windows.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 217, "end_line": 245, "text": "// getSensorTemps attempts to pull sensor temperatures from the embedded LHM process.\n// NB: LibreHardwareMonitorLib requires admin privileges to access all available sensors.\nfunc getSensorTemps(ctx context.Context) (temps []sensors.TemperatureStat, err error) {\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tslog.Debug(\"Error reading sensors\", \"err\", err)\n\t\t}\n\t}()\n\n\tif !useLHM {\n\t\treturn sensors.TemperaturesWithContext(ctx)\n\t}\n\n\t// Initialize process once\n\tbeszelLhmOnce.Do(func() {\n\t\tbeszelLhm, err = newlhmProcess()\n\t})\n\n\tif err != nil {\n\t\treturn temps, fmt.Errorf(\"failed to initialize lhm: %w\", err)\n\t}\n\n\tif beszelLhm == nil {\n\t\treturn temps, fmt.Errorf(\"lhm not available\")\n\t}\n\n\treturn beszelLhm.getTemps(ctx)\n}\n", "n_tokens": 192, "primary_symbol": "getSensorTemps", "primary_kind": "function", "primary_span": [219, 245], "def_symbols": ["getSensorTemps"], "symbols": ["getSensorTemps", "attempts", "pull", "sensor", "temperatures", "from", "the", "embedded", "LHM", "process", "LibreHardwareMonitorLib", "requires", "admin", "privileges", "access", "all", "available", "sensors", "func", "ctx", "context", "Context", "temps", "TemperatureStat", "err", "error", "defer", "nil", "slog", "Debug", "Error", "reading", "useLHM", "return", "TemperaturesWithContext", "Initialize", "once", "beszelLhmOnce", "beszelLhm", "newlhmProcess", "fmt", "Errorf", "failed", "initialize", "lhm", "not", "getTemps"], "doc_head": "// getSensorTemps attempts to pull sensor temperatures from the embedded LHM process.\n// NB: LibreHardwareMonitorLib requires admin privileges to access all available sensors.\nfunc getSensorTemps(ctx context.Context) (temps []sensors.TemperatureStat, err error) {\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tslog.Debug(\"Error reading sensors\", \"err\", err)\n\t\t}\n\t}()\n\tif !useLHM {\n\t\treturn sensors.TemperaturesWithContext(ctx)\n\t}\n\t// Initialize process once\n\tbeszelLhmOnce.Do(func() {\n\t\tbeszelLhm, err = newlhmProcess()\n\t})\n\tif err != nil {\n\t\treturn temps, fmt.Errorf(\"failed to initialize lhm: %w\", err)\n\t}\n\tif beszelLhm == nil {\n\t\treturn temps, fmt.Errorf(\"lhm not available\")\n\t}\n\treturn beszelLhm.getTemps(ctx)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go", "rel_path": "agent/sensors_windows.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 246, "end_line": 253, "text": "// cleanup terminates the process and closes resources\nfunc (lhm *lhmProcess) cleanup() {\n\tlhm.cleanupProcess()\n\tif lhm.tempDir != \"\" {\n\t\tos.RemoveAll(lhm.tempDir)\n\t}\n}\n", "n_tokens": 45, "primary_symbol": "cleanup", "primary_kind": "function", "primary_span": [247, 253], "def_symbols": ["cleanup"], "symbols": ["cleanup", "terminates", "the", "process", "and", "closes", "resources", "func", "lhm", "lhmProcess", "cleanupProcess", "tempDir", "RemoveAll"], "doc_head": "// cleanup terminates the process and closes resources\nfunc (lhm *lhmProcess) cleanup() {\n\tlhm.cleanupProcess()\n\tif lhm.tempDir != \"\" {\n\t\tos.RemoveAll(lhm.tempDir)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_windows.go", "rel_path": "agent/sensors_windows.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 254, "end_line": 287, "text": "// copyEmbeddedDir copies the embedded directory to the destination path\nfunc copyEmbeddedDir(fs embed.FS, srcPath, destPath string) error {\n\tentries, err := fs.ReadDir(srcPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(destPath, 0755); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, entry := range entries {\n\t\tsrcEntryPath := path.Join(srcPath, entry.Name())\n\t\tdestEntryPath := filepath.Join(destPath, entry.Name())\n\n\t\tif entry.IsDir() {\n\t\t\tif err := copyEmbeddedDir(fs, srcEntryPath, destEntryPath); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tdata, err := fs.ReadFile(srcEntryPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := os.WriteFile(destEntryPath, data, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n", "n_tokens": 209, "primary_symbol": "copyEmbeddedDir", "primary_kind": "function", "primary_span": [255, 287], "def_symbols": ["copyEmbeddedDir"], "symbols": ["copyEmbeddedDir", "copies", "the", "embedded", "directory", "destination", "path", "func", "embed", "srcPath", "destPath", "string", "error", "entries", "err", "ReadDir", "nil", "return", "MkdirAll", "for", "entry", "range", "srcEntryPath", "Join", "Name", "destEntryPath", "filepath", "IsDir", "continue", "data", "ReadFile", "WriteFile"], "doc_head": "// copyEmbeddedDir copies the embedded directory to the destination path\nfunc copyEmbeddedDir(fs embed.FS, srcPath, destPath string) error {\n\tentries, err := fs.ReadDir(srcPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(destPath, 0755); err != nil {\n\t\treturn err\n\t}\n\tfor _, entry := range entries {\n\t\tsrcEntryPath := path.Join(srcPath, entry.Name())\n\t\tdestEntryPath := filepath.Join(destPath, entry.Name())\n\t\tif entry.IsDir() {\n\t\t\tif err := copyEmbeddedDir(fs, srcEntryPath, destEntryPath); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tdata, err := fs.ReadFile(srcEntryPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.WriteFile(destEntryPath, data, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 27, "text": "//go:build testing\n// +build testing\n\npackage agent\n\nimport (\n\t\"crypto/ed25519\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel\"\n\n\t\"github.com/henrygd/beszel/src/common\"\n\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)\n\n// TestNewWebSocketClient tests WebSocket client creation\nfunc TestNewWebSocketClient(t *testing.T) {\n\tagent := createTestAgent(t)\n", "n_tokens": 129, "primary_symbol": "TestNewWebSocketClient", "primary_kind": "function", "primary_span": [25, 27], "def_symbols": ["TestNewWebSocketClient"], "symbols": ["TestNewWebSocketClient", "build", "testing", "package", "agent", "import", "crypto", "ed25519", "net", "url", "strings", "time", "github", "com", "henrygd", "beszel", "src", "common", "fxamacker", "cbor", "stretchr", "testify", "assert", "require", "golang", "org", "ssh", "tests", "WebSocket", "client", "creation", "func", "createTestAgent"], "doc_head": "//go:build testing\n// +build testing\npackage agent\nimport (\n\t\"crypto/ed25519\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/common\"\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)\n// TestNewWebSocketClient tests WebSocket client creation\nfunc TestNewWebSocketClient(t *testing.T) {\n\tagent := createTestAgent(t)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 28, "end_line": 108, "text": "\ttestCases := []struct {\n\t\tname        string\n\t\thubURL      string\n\t\ttoken       string\n\t\texpectError bool\n\t\terrorMsg    string\n\t}{\n\t\t{\n\t\t\tname:        \"valid configuration\",\n\t\t\thubURL:      \"http://localhost:8080\",\n\t\t\ttoken:       \"test-token-123\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"valid https URL\",\n\t\t\thubURL:      \"https://hub.example.com\",\n\t\t\ttoken:       \"secure-token\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"missing hub URL\",\n\t\t\thubURL:      \"\",\n\t\t\ttoken:       \"test-token\",\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"HUB_URL environment variable not set\",\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid URL\",\n\t\t\thubURL:      \"ht\\ttp://invalid\",\n\t\t\ttoken:       \"test-token\",\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"invalid hub URL\",\n\t\t},\n\t\t{\n\t\t\tname:        \"missing token\",\n\t\t\thubURL:      \"http://localhost:8080\",\n\t\t\ttoken:       \"\",\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"must set TOKEN or TOKEN_FILE\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Set up environment\n\t\t\tif tc.hubURL != \"\" {\n\t\t\t\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", tc.hubURL)\n\t\t\t} else {\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\t\t}\n\t\t\tif tc.token != \"\" {\n\t\t\t\tos.Setenv(\"BESZEL_AGENT_TOKEN\", tc.token)\n\t\t\t} else {\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t\t\t}()\n\n\t\t\tclient, err := newWebSocketClient(agent)\n\n\t\t\tif tc.expectError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tif err != nil && tc.errorMsg != \"\" {\n\t\t\t\t\tassert.Contains(t, err.Error(), tc.errorMsg)\n\t\t\t\t}\n\t\t\t\tassert.Nil(t, client)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotNil(t, client)\n\t\t\t\tassert.Equal(t, agent, client.agent)\n\t\t\t\tassert.Equal(t, tc.token, client.token)\n\t\t\t\tassert.Equal(t, tc.hubURL, client.hubURL.String())\n\t\t\t\tassert.NotEmpty(t, client.fingerprint)\n\t\t\t\tassert.NotNil(t, client.hubRequest)\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 577, "primary_symbol": "", "primary_kind": "", "primary_span": [28, 108], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "hubURL", "token", "expectError", "bool", "errorMsg", "valid", "configuration", "http", "localhost", "test", "false", "https", "URL", "hub", "example", "com", "secure", "missing", "true", "HUB_URL", "environment", "variable", "not", "set", "invalid", "ttp", "must", "TOKEN", "TOKEN_FILE", "for", "range", "Run", "func", "testing", "Set", "Setenv", "BESZEL_AGENT_HUB_URL", "else", "Unsetenv", "BESZEL_AGENT_TOKEN", "defer", "client", "err", "newWebSocketClient", "agent", "assert", "Error", "nil", "Contains", "Nil", "require", "NoError", "NotNil", "Equal", "String", "NotEmpty", "fingerprint", "hubRequest"], "doc_head": "\ttestCases := []struct {\n\t\tname        string\n\t\thubURL      string\n\t\ttoken       string\n\t\texpectError bool\n\t\terrorMsg    string\n\t}{\n\t\t{\n\t\t\tname:        \"valid configuration\",\n\t\t\thubURL:      \"http://localhost:8080\",\n\t\t\ttoken:       \"test-token-123\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"valid https URL\",\n\t\t\thubURL:      \"https://hub.example.com\",\n\t\t\ttoken:       \"secure-token\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"missing hub URL\",\n\t\t\thubURL:      \"\",\n\t\t\ttoken:       \"test-token\",\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"HUB_URL environment variable not set\",\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid URL\",\n\t\t\thubURL:      \"ht\\ttp://invalid\",\n\t\t\ttoken:       \"test-token\",\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"invalid hub URL\",\n\t\t},\n\t\t{\n\t\t\tname:        \"missing token\",\n\t\t\thubURL:      \"http://localhost:8080\",\n\t\t\ttoken:       \"\",\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"must set TOKEN or TOKEN_FILE\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Set up environment\n\t\t\tif tc.hubURL != \"\" {\n\t\t\t\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", tc.hubURL)\n\t\t\t} else {\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\t\t}\n\t\t\tif tc.token != \"\" {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 109, "end_line": 112, "text": "// TestWebSocketClient_GetOptions tests WebSocket client options configuration\nfunc TestWebSocketClient_GetOptions(t *testing.T) {\n\tagent := createTestAgent(t)\n", "n_tokens": 32, "primary_symbol": "TestWebSocketClient_GetOptions", "primary_kind": "function", "primary_span": [110, 112], "def_symbols": ["TestWebSocketClient_GetOptions"], "symbols": ["TestWebSocketClient_GetOptions", "tests", "WebSocket", "client", "options", "configuration", "func", "testing", "agent", "createTestAgent"], "doc_head": "// TestWebSocketClient_GetOptions tests WebSocket client options configuration\nfunc TestWebSocketClient_GetOptions(t *testing.T) {\n\tagent := createTestAgent(t)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 113, "end_line": 172, "text": "\ttestCases := []struct {\n\t\tname           string\n\t\tinputURL       string\n\t\texpectedScheme string\n\t\texpectedPath   string\n\t}{\n\t\t{\n\t\t\tname:           \"http to ws conversion\",\n\t\t\tinputURL:       \"http://localhost:8080\",\n\t\t\texpectedScheme: \"ws\",\n\t\t\texpectedPath:   \"/api/beszel/agent-connect\",\n\t\t},\n\t\t{\n\t\t\tname:           \"https to wss conversion\",\n\t\t\tinputURL:       \"https://hub.example.com\",\n\t\t\texpectedScheme: \"wss\",\n\t\t\texpectedPath:   \"/api/beszel/agent-connect\",\n\t\t},\n\t\t{\n\t\t\tname:           \"existing path preservation\",\n\t\t\tinputURL:       \"http://localhost:8080/custom/path\",\n\t\t\texpectedScheme: \"ws\",\n\t\t\texpectedPath:   \"/custom/path/api/beszel/agent-connect\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Set up environment\n\t\t\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", tc.inputURL)\n\t\t\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\t\t\tdefer func() {\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t\t\t}()\n\n\t\t\tclient, err := newWebSocketClient(agent)\n\t\t\trequire.NoError(t, err)\n\n\t\t\toptions := client.getOptions()\n\n\t\t\t// Parse the WebSocket URL\n\t\t\twsURL, err := url.Parse(options.Addr)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, tc.expectedScheme, wsURL.Scheme)\n\t\t\tassert.Equal(t, tc.expectedPath, wsURL.Path)\n\n\t\t\t// Check headers\n\t\t\tassert.Equal(t, \"test-token\", options.RequestHeader.Get(\"X-Token\"))\n\t\t\tassert.Equal(t, beszel.Version, options.RequestHeader.Get(\"X-Beszel\"))\n\t\t\tassert.Contains(t, options.RequestHeader.Get(\"User-Agent\"), \"Mozilla/5.0\")\n\n\t\t\t// Test options caching\n\t\t\toptions2 := client.getOptions()\n\t\t\tassert.Same(t, options, options2, \"Options should be cached\")\n\t\t})\n\t}\n}\n", "n_tokens": 461, "primary_symbol": "", "primary_kind": "", "primary_span": [113, 172], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "inputURL", "expectedScheme", "expectedPath", "http", "conversion", "localhost", "api", "beszel", "agent", "connect", "https", "wss", "hub", "example", "com", "existing", "path", "preservation", "custom", "for", "range", "Run", "func", "testing", "Set", "environment", "Setenv", "BESZEL_AGENT_HUB_URL", "BESZEL_AGENT_TOKEN", "test", "token", "defer", "Unsetenv", "client", "err", "newWebSocketClient", "require", "NoError", "options", "getOptions", "Parse", "the", "WebSocket", "URL", "wsURL", "url", "Addr", "assert", "Equal", "Scheme", "Path", "Check", "headers", "RequestHeader", "Get", "Token", "Version", "Beszel", "Contains", "User", "Agent", "Mozilla", "Test", "caching", "options2", "Same", "Options", "should", "cached"], "doc_head": "\ttestCases := []struct {\n\t\tname           string\n\t\tinputURL       string\n\t\texpectedScheme string\n\t\texpectedPath   string\n\t}{\n\t\t{\n\t\t\tname:           \"http to ws conversion\",\n\t\t\tinputURL:       \"http://localhost:8080\",\n\t\t\texpectedScheme: \"ws\",\n\t\t\texpectedPath:   \"/api/beszel/agent-connect\",\n\t\t},\n\t\t{\n\t\t\tname:           \"https to wss conversion\",\n\t\t\tinputURL:       \"https://hub.example.com\",\n\t\t\texpectedScheme: \"wss\",\n\t\t\texpectedPath:   \"/api/beszel/agent-connect\",\n\t\t},\n\t\t{\n\t\t\tname:           \"existing path preservation\",\n\t\t\tinputURL:       \"http://localhost:8080/custom/path\",\n\t\t\texpectedScheme: \"ws\",\n\t\t\texpectedPath:   \"/custom/path/api/beszel/agent-connect\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Set up environment\n\t\t\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", tc.inputURL)\n\t\t\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\t\t\tdefer func() {\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t\t\t}()\n\t\t\tclient, err := newWebSocketClient(agent)\n\t\t\trequire.NoError(t, err)\n\t\t\toptions := client.getOptions()\n\t\t\t// Parse the WebSocket URL\n\t\t\twsURL, err := url.Parse(options.Addr)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, tc.expect"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 173, "end_line": 198, "text": "// TestWebSocketClient_VerifySignature tests signature verification\nfunc TestWebSocketClient_VerifySignature(t *testing.T) {\n\tagent := createTestAgent(t)\n\n\t// Generate test key pairs\n\t_, goodPrivKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tgoodPubKey, err := ssh.NewPublicKey(goodPrivKey.Public().(ed25519.PublicKey))\n\trequire.NoError(t, err)\n\n\t_, badPrivKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tbadPubKey, err := ssh.NewPublicKey(badPrivKey.Public().(ed25519.PublicKey))\n\trequire.NoError(t, err)\n\n\t// Set up environment\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"http://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\n\tclient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)\n", "n_tokens": 232, "primary_symbol": "TestWebSocketClient_VerifySignature", "primary_kind": "function", "primary_span": [174, 198], "def_symbols": ["TestWebSocketClient_VerifySignature"], "symbols": ["TestWebSocketClient_VerifySignature", "tests", "signature", "verification", "func", "testing", "agent", "createTestAgent", "Generate", "test", "key", "pairs", "goodPrivKey", "err", "ed25519", "GenerateKey", "nil", "require", "NoError", "goodPubKey", "ssh", "NewPublicKey", "Public", "PublicKey", "badPrivKey", "badPubKey", "Set", "environment", "Setenv", "BESZEL_AGENT_HUB_URL", "http", "localhost", "BESZEL_AGENT_TOKEN", "token", "defer", "Unsetenv", "client", "newWebSocketClient"], "doc_head": "// TestWebSocketClient_VerifySignature tests signature verification\nfunc TestWebSocketClient_VerifySignature(t *testing.T) {\n\tagent := createTestAgent(t)\n\t// Generate test key pairs\n\t_, goodPrivKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tgoodPubKey, err := ssh.NewPublicKey(goodPrivKey.Public().(ed25519.PublicKey))\n\trequire.NoError(t, err)\n\t_, badPrivKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tbadPubKey, err := ssh.NewPublicKey(badPrivKey.Public().(ed25519.PublicKey))\n\trequire.NoError(t, err)\n\t// Set up environment\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"http://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\tclient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 199, "end_line": 256, "text": "\ttestCases := []struct {\n\t\tname        string\n\t\tkeys        []ssh.PublicKey\n\t\ttoken       string\n\t\tsignWith    ed25519.PrivateKey\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:        \"valid signature with correct key\",\n\t\t\tkeys:        []ssh.PublicKey{goodPubKey},\n\t\t\ttoken:       \"test-token\",\n\t\t\tsignWith:    goodPrivKey,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid signature with wrong key\",\n\t\t\tkeys:        []ssh.PublicKey{goodPubKey},\n\t\t\ttoken:       \"test-token\",\n\t\t\tsignWith:    badPrivKey,\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"valid signature with multiple keys\",\n\t\t\tkeys:        []ssh.PublicKey{badPubKey, goodPubKey},\n\t\t\ttoken:       \"test-token\",\n\t\t\tsignWith:    goodPrivKey,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"no valid keys\",\n\t\t\tkeys:        []ssh.PublicKey{badPubKey},\n\t\t\ttoken:       \"test-token\",\n\t\t\tsignWith:    goodPrivKey,\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Set up agent with test keys\n\t\t\tagent.keys = tc.keys\n\t\t\tclient.token = tc.token\n\n\t\t\t// Create signature\n\t\t\tsignature := ed25519.Sign(tc.signWith, []byte(tc.token))\n\n\t\t\terr := client.verifySignature(signature)\n\n\t\t\tif tc.expectError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tassert.Contains(t, err.Error(), \"invalid signature\")\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 380, "primary_symbol": "", "primary_kind": "", "primary_span": [199, 256], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "keys", "ssh", "PublicKey", "token", "signWith", "ed25519", "PrivateKey", "expectError", "bool", "valid", "signature", "with", "correct", "key", "goodPubKey", "test", "goodPrivKey", "false", "invalid", "wrong", "badPrivKey", "true", "multiple", "badPubKey", "for", "range", "Run", "func", "testing", "Set", "agent", "client", "Create", "Sign", "byte", "err", "verifySignature", "assert", "Error", "Contains", "else", "NoError"], "doc_head": "\ttestCases := []struct {\n\t\tname        string\n\t\tkeys        []ssh.PublicKey\n\t\ttoken       string\n\t\tsignWith    ed25519.PrivateKey\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:        \"valid signature with correct key\",\n\t\t\tkeys:        []ssh.PublicKey{goodPubKey},\n\t\t\ttoken:       \"test-token\",\n\t\t\tsignWith:    goodPrivKey,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid signature with wrong key\",\n\t\t\tkeys:        []ssh.PublicKey{goodPubKey},\n\t\t\ttoken:       \"test-token\",\n\t\t\tsignWith:    badPrivKey,\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"valid signature with multiple keys\",\n\t\t\tkeys:        []ssh.PublicKey{badPubKey, goodPubKey},\n\t\t\ttoken:       \"test-token\",\n\t\t\tsignWith:    goodPrivKey,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"no valid keys\",\n\t\t\tkeys:        []ssh.PublicKey{badPubKey},\n\t\t\ttoken:       \"test-token\",\n\t\t\tsignWith:    goodPrivKey,\n\t\t\texpectError: true,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Set up agent with test keys\n\t\t\tagent.keys = tc.keys\n\t\t\tclient.token = tc.token\n\t\t\t// Create signature\n\t\t\tsignature := ed25519.Sign(tc.signWith, []byte(tc.token))\n\t\t\terr := client.verifySignature(signature)\n\t\t\tif tc.expectError"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 257, "end_line": 271, "text": "// TestWebSocketClient_HandleHubRequest tests hub request routing (basic verification logic)\nfunc TestWebSocketClient_HandleHubRequest(t *testing.T) {\n\tagent := createTestAgent(t)\n\n\t// Set up environment\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"http://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\n\tclient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)\n", "n_tokens": 128, "primary_symbol": "TestWebSocketClient_HandleHubRequest", "primary_kind": "function", "primary_span": [258, 271], "def_symbols": ["TestWebSocketClient_HandleHubRequest"], "symbols": ["TestWebSocketClient_HandleHubRequest", "tests", "hub", "request", "routing", "basic", "verification", "logic", "func", "testing", "agent", "createTestAgent", "Set", "environment", "Setenv", "BESZEL_AGENT_HUB_URL", "http", "localhost", "BESZEL_AGENT_TOKEN", "test", "token", "defer", "Unsetenv", "client", "err", "newWebSocketClient", "require", "NoError"], "doc_head": "// TestWebSocketClient_HandleHubRequest tests hub request routing (basic verification logic)\nfunc TestWebSocketClient_HandleHubRequest(t *testing.T) {\n\tagent := createTestAgent(t)\n\t// Set up environment\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"http://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\tclient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 272, "end_line": 321, "text": "\ttestCases := []struct {\n\t\tname        string\n\t\taction      common.WebSocketAction\n\t\thubVerified bool\n\t\texpectError bool\n\t\terrorMsg    string\n\t}{\n\t\t{\n\t\t\tname:        \"CheckFingerprint without verification\",\n\t\t\taction:      common.CheckFingerprint,\n\t\t\thubVerified: false,\n\t\t\texpectError: false, // CheckFingerprint is allowed without verification\n\t\t},\n\t\t{\n\t\t\tname:        \"GetData without verification\",\n\t\t\taction:      common.GetData,\n\t\t\thubVerified: false,\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"hub not verified\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tclient.hubVerified = tc.hubVerified\n\n\t\t\t// Create minimal request\n\t\t\thubRequest := &common.HubRequest[cbor.RawMessage]{\n\t\t\t\tAction: tc.action,\n\t\t\t\tData:   cbor.RawMessage{},\n\t\t\t}\n\n\t\t\terr := client.handleHubRequest(hubRequest)\n\n\t\t\tif tc.expectError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tif tc.errorMsg != \"\" {\n\t\t\t\t\tassert.Contains(t, err.Error(), tc.errorMsg)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For CheckFingerprint, we expect a decode error since we're not providing valid data,\n\t\t\t\t// but it shouldn't be the \"hub not verified\" error\n\t\t\t\tif err != nil && tc.errorMsg != \"\" {\n\t\t\t\t\tassert.NotContains(t, err.Error(), tc.errorMsg)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 333, "primary_symbol": "", "primary_kind": "", "primary_span": [272, 321], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "action", "common", "WebSocketAction", "hubVerified", "bool", "expectError", "errorMsg", "CheckFingerprint", "without", "verification", "false", "allowed", "GetData", "true", "hub", "not", "verified", "for", "range", "Run", "func", "testing", "client", "Create", "minimal", "request", "hubRequest", "HubRequest", "cbor", "RawMessage", "Action", "Data", "err", "handleHubRequest", "assert", "Error", "Contains", "else", "For", "expect", "decode", "error", "since", "providing", "valid", "data", "but", "shouldn", "the", "nil", "NotContains"], "doc_head": "\ttestCases := []struct {\n\t\tname        string\n\t\taction      common.WebSocketAction\n\t\thubVerified bool\n\t\texpectError bool\n\t\terrorMsg    string\n\t}{\n\t\t{\n\t\t\tname:        \"CheckFingerprint without verification\",\n\t\t\taction:      common.CheckFingerprint,\n\t\t\thubVerified: false,\n\t\t\texpectError: false, // CheckFingerprint is allowed without verification\n\t\t},\n\t\t{\n\t\t\tname:        \"GetData without verification\",\n\t\t\taction:      common.GetData,\n\t\t\thubVerified: false,\n\t\t\texpectError: true,\n\t\t\terrorMsg:    \"hub not verified\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tclient.hubVerified = tc.hubVerified\n\t\t\t// Create minimal request\n\t\t\thubRequest := &common.HubRequest[cbor.RawMessage]{\n\t\t\t\tAction: tc.action,\n\t\t\t\tData:   cbor.RawMessage{},\n\t\t\t}\n\t\t\terr := client.handleHubRequest(hubRequest)\n\t\t\tif tc.expectError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tif tc.errorMsg != \"\" {\n\t\t\t\t\tassert.Contains(t, err.Error(), tc.errorMsg)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For CheckFingerprint, we expect a decode error since we're not providing valid data,\n\t\t\t\t// but it shouldn't be the \"hub not verified\" error\n\t\t\t\tif err != nil && tc.errorMsg != \"\" {\n\t\t\t\t\tassert.NotContains(t, err.Error(), tc.erro"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 322, "end_line": 349, "text": "// TestWebSocketClient_GetUserAgent tests user agent generation\nfunc TestGetUserAgent(t *testing.T) {\n\t// Run multiple times to check both variants\n\tuserAgents := make(map[string]bool)\n\n\tfor range 20 {\n\t\tua := getUserAgent()\n\t\tuserAgents[ua] = true\n\n\t\t// Check that it's a valid Mozilla user agent\n\t\tassert.Contains(t, ua, \"Mozilla/5.0\")\n\t\tassert.Contains(t, ua, \"AppleWebKit/537.36\")\n\t\tassert.Contains(t, ua, \"Chrome/124.0.0.0\")\n\t\tassert.Contains(t, ua, \"Safari/537.36\")\n\n\t\t// Should contain either Windows or Mac\n\t\tisWindows := strings.Contains(ua, \"Windows NT 11.0\")\n\t\tisMac := strings.Contains(ua, \"Macintosh; Intel Mac OS X 14_0_0\")\n\t\tassert.True(t, isWindows || isMac, \"User agent should contain either Windows or Mac identifier\")\n\t}\n\n\t// With enough iterations, we should see both variants\n\t// though this might occasionally fail\n\tif len(userAgents) == 1 {\n\t\tt.Log(\"Note: Only one user agent variant was generated in this test run\")\n\t}\n}\n", "n_tokens": 262, "primary_symbol": "TestGetUserAgent", "primary_kind": "function", "primary_span": [323, 349], "def_symbols": ["TestGetUserAgent"], "symbols": ["TestGetUserAgent", "TestWebSocketClient_GetUserAgent", "tests", "user", "agent", "generation", "func", "testing", "Run", "multiple", "times", "check", "both", "variants", "userAgents", "make", "map", "string", "bool", "for", "range", "getUserAgent", "true", "Check", "that", "valid", "Mozilla", "assert", "Contains", "AppleWebKit", "Chrome", "Safari", "Should", "contain", "either", "Windows", "Mac", "isWindows", "strings", "isMac", "Macintosh", "Intel", "True", "User", "should", "identifier", "With", "enough", "iterations", "see", "though", "this", "might", "occasionally", "fail", "len", "Log", "Note", "Only", "one", "variant", "was", "generated", "test", "run"], "doc_head": "// TestWebSocketClient_GetUserAgent tests user agent generation\nfunc TestGetUserAgent(t *testing.T) {\n\t// Run multiple times to check both variants\n\tuserAgents := make(map[string]bool)\n\tfor range 20 {\n\t\tua := getUserAgent()\n\t\tuserAgents[ua] = true\n\t\t// Check that it's a valid Mozilla user agent\n\t\tassert.Contains(t, ua, \"Mozilla/5.0\")\n\t\tassert.Contains(t, ua, \"AppleWebKit/537.36\")\n\t\tassert.Contains(t, ua, \"Chrome/124.0.0.0\")\n\t\tassert.Contains(t, ua, \"Safari/537.36\")\n\t\t// Should contain either Windows or Mac\n\t\tisWindows := strings.Contains(ua, \"Windows NT 11.0\")\n\t\tisMac := strings.Contains(ua, \"Macintosh; Intel Mac OS X 14_0_0\")\n\t\tassert.True(t, isWindows || isMac, \"User agent should contain either Windows or Mac identifier\")\n\t}\n\t// With enough iterations, we should see both variants\n\t// though this might occasionally fail\n\tif len(userAgents) == 1 {\n\t\tt.Log(\"Note: Only one user agent variant was generated in this test run\")\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 350, "end_line": 370, "text": "// TestWebSocketClient_Close tests connection closing\nfunc TestWebSocketClient_Close(t *testing.T) {\n\tagent := createTestAgent(t)\n\n\t// Set up environment\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"http://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\n\tclient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)\n\n\t// Test closing with nil connection (should not panic)\n\tassert.NotPanics(t, func() {\n\t\tclient.Close()\n\t})\n}\n", "n_tokens": 147, "primary_symbol": "TestWebSocketClient_Close", "primary_kind": "function", "primary_span": [351, 370], "def_symbols": ["TestWebSocketClient_Close"], "symbols": ["TestWebSocketClient_Close", "tests", "connection", "closing", "func", "testing", "agent", "createTestAgent", "Set", "environment", "Setenv", "BESZEL_AGENT_HUB_URL", "http", "localhost", "BESZEL_AGENT_TOKEN", "test", "token", "defer", "Unsetenv", "client", "err", "newWebSocketClient", "require", "NoError", "Test", "with", "nil", "should", "not", "panic", "assert", "NotPanics", "Close"], "doc_head": "// TestWebSocketClient_Close tests connection closing\nfunc TestWebSocketClient_Close(t *testing.T) {\n\tagent := createTestAgent(t)\n\t// Set up environment\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"http://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\tclient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)\n\t// Test closing with nil connection (should not panic)\n\tassert.NotPanics(t, func() {\n\t\tclient.Close()\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 371, "end_line": 394, "text": "// TestWebSocketClient_ConnectRateLimit tests connection rate limiting\nfunc TestWebSocketClient_ConnectRateLimit(t *testing.T) {\n\tagent := createTestAgent(t)\n\n\t// Set up environment\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"http://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\n\tclient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)\n\n\t// Set recent connection attempt\n\tclient.lastConnectAttempt = time.Now()\n\n\t// Test that connection fails quickly due to rate limiting\n\t// This won't actually connect but should fail fast\n\terr = client.Connect()\n\tassert.Error(t, err, \"Connection should fail but not hang\")\n}\n", "n_tokens": 185, "primary_symbol": "TestWebSocketClient_ConnectRateLimit", "primary_kind": "function", "primary_span": [372, 394], "def_symbols": ["TestWebSocketClient_ConnectRateLimit"], "symbols": ["TestWebSocketClient_ConnectRateLimit", "tests", "connection", "rate", "limiting", "func", "testing", "agent", "createTestAgent", "Set", "environment", "Setenv", "BESZEL_AGENT_HUB_URL", "http", "localhost", "BESZEL_AGENT_TOKEN", "test", "token", "defer", "Unsetenv", "client", "err", "newWebSocketClient", "require", "NoError", "recent", "attempt", "lastConnectAttempt", "time", "Now", "Test", "that", "fails", "quickly", "due", "This", "won", "actually", "connect", "but", "should", "fail", "fast", "Connect", "assert", "Error", "Connection", "not", "hang"], "doc_head": "// TestWebSocketClient_ConnectRateLimit tests connection rate limiting\nfunc TestWebSocketClient_ConnectRateLimit(t *testing.T) {\n\tagent := createTestAgent(t)\n\t// Set up environment\n\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", \"http://localhost:8080\")\n\tos.Setenv(\"BESZEL_AGENT_TOKEN\", \"test-token\")\n\tdefer func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t}()\n\tclient, err := newWebSocketClient(agent)\n\trequire.NoError(t, err)\n\t// Set recent connection attempt\n\tclient.lastConnectAttempt = time.Now()\n\t// Test that connection fails quickly due to rate limiting\n\t// This won't actually connect but should fail fast\n\terr = client.Connect()\n\tassert.Error(t, err, \"Connection should fail but not hang\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/client_test.go", "rel_path": "agent/client_test.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 395, "end_line": 541, "text": "// TestGetToken tests the getToken function with various scenarios\nfunc TestGetToken(t *testing.T) {\n\tunsetEnvVars := func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t\tos.Unsetenv(\"TOKEN\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN_FILE\")\n\t\tos.Unsetenv(\"TOKEN_FILE\")\n\t}\n\n\tt.Run(\"token from TOKEN environment variable\", func(t *testing.T) {\n\t\tunsetEnvVars()\n\n\t\t// Set TOKEN env var\n\t\texpectedToken := \"test-token-from-env\"\n\t\tos.Setenv(\"TOKEN\", expectedToken)\n\t\tdefer os.Unsetenv(\"TOKEN\")\n\n\t\ttoken, err := getToken()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, expectedToken, token)\n\t})\n\n\tt.Run(\"token from BESZEL_AGENT_TOKEN environment variable\", func(t *testing.T) {\n\t\tunsetEnvVars()\n\n\t\t// Set BESZEL_AGENT_TOKEN env var (should take precedence)\n\t\texpectedToken := \"test-token-from-beszel-env\"\n\t\tos.Setenv(\"BESZEL_AGENT_TOKEN\", expectedToken)\n\t\tdefer os.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\n\t\ttoken, err := getToken()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, expectedToken, token)\n\t})\n\n\tt.Run(\"token from TOKEN_FILE\", func(t *testing.T) {\n\t\tunsetEnvVars()\n\n\t\t// Create a temporary token file\n\t\texpectedToken := \"test-token-from-file\"\n\t\ttokenFile, err := os.CreateTemp(\"\", \"token-test-*.txt\")\n\t\trequire.NoError(t, err)\n\t\tdefer os.Remove(tokenFile.Name())\n\n\t\t_, err = tokenFile.WriteString(expectedToken)\n\t\trequire.NoError(t, err)\n\t\ttokenFile.Close()\n\n\t\t// Set TOKEN_FILE env var\n\t\tos.Setenv(\"TOKEN_FILE\", tokenFile.Name())\n\t\tdefer os.Unsetenv(\"TOKEN_FILE\")\n\n\t\ttoken, err := getToken()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, expectedToken, token)\n\t})\n\n\tt.Run(\"token from BESZEL_AGENT_TOKEN_FILE\", func(t *testing.T) {\n\t\tunsetEnvVars()\n\n\t\t// Create a temporary token file\n\t\texpectedToken := \"test-token-from-beszel-file\"\n\t\ttokenFile, err := os.CreateTemp(\"\", \"token-test-*.txt\")\n\t\trequire.NoError(t, err)\n\t\tdefer os.Remove(tokenFile.Name())\n\n\t\t_, err = tokenFile.WriteString(expectedToken)\n\t\trequire.NoError(t, err)\n\t\ttokenFile.Close()\n\n\t\t// Set BESZEL_AGENT_TOKEN_FILE env var (should take precedence)\n\t\tos.Setenv(\"BESZEL_AGENT_TOKEN_FILE\", tokenFile.Name())\n\t\tdefer os.Unsetenv(\"BESZEL_AGENT_TOKEN_FILE\")\n\n\t\ttoken, err := getToken()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, expectedToken, token)\n\t})\n\n\tt.Run(\"TOKEN takes precedence over TOKEN_FILE\", func(t *testing.T) {\n\t\tunsetEnvVars()\n\n\t\t// Create a temporary token file\n\t\tfileToken := \"token-from-file\"\n\t\ttokenFile, err := os.CreateTemp(\"\", \"token-test-*.txt\")\n\t\trequire.NoError(t, err)\n\t\tdefer os.Remove(tokenFile.Name())\n\n\t\t_, err = tokenFile.WriteString(fileToken)\n\t\trequire.NoError(t, err)\n\t\ttokenFile.Close()\n\n\t\t// Set both TOKEN and TOKEN_FILE\n\t\tenvToken := \"token-from-env\"\n\t\tos.Setenv(\"TOKEN\", envToken)\n\t\tos.Setenv(\"TOKEN_FILE\", tokenFile.Name())\n\t\tdefer func() {\n\t\t\tos.Unsetenv(\"TOKEN\")\n\t\t\tos.Unsetenv(\"TOKEN_FILE\")\n\t\t}()\n\n\t\ttoken, err := getToken()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, envToken, token, \"TOKEN should take precedence over TOKEN_FILE\")\n\t})\n\n\tt.Run(\"error when neither TOKEN nor TOKEN_FILE is set\", func(t *testing.T) {\n\t\tunsetEnvVars()\n\n\t\ttoken, err := getToken()\n\t\tassert.Error(t, err)\n\t\tassert.Equal(t, \"\", token)\n\t\tassert.Contains(t, err.Error(), \"must set TOKEN or TOKEN_FILE\")\n\t})\n\n\tt.Run(\"error when TOKEN_FILE points to non-existent file\", func(t *testing.T) {\n\t\tunsetEnvVars()\n\n\t\t// Set TOKEN_FILE to a non-existent file\n\t\tos.Setenv(\"TOKEN_FILE\", \"/non/existent/file.txt\")\n\t\tdefer os.Unsetenv(\"TOKEN_FILE\")\n\n\t\ttoken, err := getToken()\n\t\tassert.Error(t, err)\n\t\tassert.Equal(t, \"\", token)\n\t\tassert.Contains(t, err.Error(), \"no such file or directory\")\n\t})\n\n\tt.Run(\"handles empty token file\", func(t *testing.T) {\n\t\tunsetEnvVars()\n\n\t\t// Create an empty token file\n\t\ttokenFile, err := os.CreateTemp(\"\", \"token-test-*.txt\")\n\t\trequire.NoError(t, err)\n\t\tdefer os.Remove(tokenFile.Name())\n\t\ttokenFile.Close()\n\n\t\t// Set TOKEN_FILE env var\n\t\tos.Setenv(\"TOKEN_FILE\", tokenFile.Name())\n\t\tdefer os.Unsetenv(\"TOKEN_FILE\")\n\n\t\ttoken, err := getToken()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"\", token, \"Empty file should return empty string\")\n\t})\n}\n", "n_tokens": 1091, "primary_symbol": "TestGetToken", "primary_kind": "function", "primary_span": [395, 541], "def_symbols": ["TestGetToken"], "symbols": ["TestGetToken", "tests", "the", "getToken", "function", "with", "various", "scenarios", "func", "testing", "unsetEnvVars", "Unsetenv", "BESZEL_AGENT_TOKEN", "TOKEN", "BESZEL_AGENT_TOKEN_FILE", "TOKEN_FILE", "Run", "token", "from", "environment", "variable", "Set", "env", "var", "expectedToken", "test", "Setenv", "defer", "err", "assert", "NoError", "Equal", "should", "take", "precedence", "beszel", "Create", "temporary", "file", "tokenFile", "CreateTemp", "txt", "require", "Remove", "Name", "WriteString", "Close", "takes", "over", "fileToken", "both", "and", "envToken", "error", "when", "neither", "nor", "set", "Error", "Contains", "must", "points", "non", "existent", "such", "directory", "handles", "empty", "Empty", "return", "string"], "doc_head": "// TestGetToken tests the getToken function with various scenarios\nfunc TestGetToken(t *testing.T) {\n\tunsetEnvVars := func() {\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t\tos.Unsetenv(\"TOKEN\")\n\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN_FILE\")\n\t\tos.Unsetenv(\"TOKEN_FILE\")\n\t}\n\tt.Run(\"token from TOKEN environment variable\", func(t *testing.T) {\n\t\tunsetEnvVars()\n\t\t// Set TOKEN env var\n\t\texpectedToken := \"test-token-from-env\"\n\t\tos.Setenv(\"TOKEN\", expectedToken)\n\t\tdefer os.Unsetenv(\"TOKEN\")\n\t\ttoken, err := getToken()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, expectedToken, token)\n\t})\n\tt.Run(\"token from BESZEL_AGENT_TOKEN environment variable\", func(t *testing.T) {\n\t\tunsetEnvVars()\n\t\t// Set BESZEL_AGENT_TOKEN env var (should take precedence)\n\t\texpectedToken := \"test-token-from-beszel-env\"\n\t\tos.Setenv(\"BESZEL_AGENT_TOKEN\", expectedToken)\n\t\tdefer os.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t\ttoken, err := getToken()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, expectedToken, token)\n\t})\n\tt.Run(\"token from TOKEN_FILE\", func(t *testing.T) {\n\t\tunsetEnvVars()\n\t\t// Create a temporary token file\n\t\texpectedToken := \"test-token-from-file\"\n\t\ttokenFile, err := os.CreateTemp(\"\", \"token-test-*.txt\")\n\t\trequire.NoError(t, err)\n\t\tdef"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 18, "text": "//go:build testing\n// +build testing\n\npackage agent\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestParseNvidiaData(t *testing.T) {", "n_tokens": 71, "primary_symbol": "TestParseNvidiaData", "primary_kind": "function", "primary_span": [18, 18], "def_symbols": ["TestParseNvidiaData"], "symbols": ["TestParseNvidiaData", "build", "testing", "package", "agent", "import", "path", "filepath", "time", "github", "com", "henrygd", "beszel", "src", "entities", "system", "stretchr", "testify", "assert", "require", "func"], "doc_head": "//go:build testing\n// +build testing\npackage agent\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\nfunc TestParseNvidiaData(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 19, "end_line": 134, "text": "\ttests := []struct {\n\t\tname      string\n\t\tinput     string\n\t\twantData  map[string]system.GPUData\n\t\twantValid bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid multi-gpu data\",\n\t\t\tinput: \"0, NVIDIA GeForce RTX 3050 Ti Laptop GPU, 48, 12, 4096, 26.3, 12.73\\n1, NVIDIA A100-PCIE-40GB, 38, 74, 40960, [N/A], 36.79\",\n\t\t\twantData: map[string]system.GPUData{\n\t\t\t\t\"0\": {\n\t\t\t\t\tName:        \"GeForce RTX 3050 Ti\",\n\t\t\t\t\tTemperature: 48.0,\n\t\t\t\t\tMemoryUsed:  12.0 / 1.024,\n\t\t\t\t\tMemoryTotal: 4096.0 / 1.024,\n\t\t\t\t\tUsage:       26.3,\n\t\t\t\t\tPower:       12.73,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t\t\"1\": {\n\t\t\t\t\tName:        \"A100-PCIE-40GB\",\n\t\t\t\t\tTemperature: 38.0,\n\t\t\t\t\tMemoryUsed:  74.0 / 1.024,\n\t\t\t\t\tMemoryTotal: 40960.0 / 1.024,\n\t\t\t\t\tUsage:       0.0,\n\t\t\t\t\tPower:       36.79,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantValid: true,\n\t\t},\n\t\t{\n\t\t\tname: \"more valid multi-gpu data\",\n\t\t\tinput: `0, NVIDIA A10, 45, 19676, 23028, 0, 58.98\n1, NVIDIA A10, 45, 19638, 23028, 0, 62.35\n2, NVIDIA A10, 44, 21700, 23028, 0, 59.57\n3, NVIDIA A10, 45, 18222, 23028, 0, 61.76`,\n\t\t\twantData: map[string]system.GPUData{\n\t\t\t\t\"0\": {\n\t\t\t\t\tName:        \"A10\",\n\t\t\t\t\tTemperature: 45.0,\n\t\t\t\t\tMemoryUsed:  19676.0 / 1.024,\n\t\t\t\t\tMemoryTotal: 23028.0 / 1.024,\n\t\t\t\t\tUsage:       0.0,\n\t\t\t\t\tPower:       58.98,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t\t\"1\": {\n\t\t\t\t\tName:        \"A10\",\n\t\t\t\t\tTemperature: 45.0,\n\t\t\t\t\tMemoryUsed:  19638.0 / 1.024,\n\t\t\t\t\tMemoryTotal: 23028.0 / 1.024,\n\t\t\t\t\tUsage:       0.0,\n\t\t\t\t\tPower:       62.35,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t\t\"2\": {\n\t\t\t\t\tName:        \"A10\",\n\t\t\t\t\tTemperature: 44.0,\n\t\t\t\t\tMemoryUsed:  21700.0 / 1.024,\n\t\t\t\t\tMemoryTotal: 23028.0 / 1.024,\n\t\t\t\t\tUsage:       0.0,\n\t\t\t\t\tPower:       59.57,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t\t\"3\": {\n\t\t\t\t\tName:        \"A10\",\n\t\t\t\t\tTemperature: 45.0,\n\t\t\t\t\tMemoryUsed:  18222.0 / 1.024,\n\t\t\t\t\tMemoryTotal: 23028.0 / 1.024,\n\t\t\t\t\tUsage:       0.0,\n\t\t\t\t\tPower:       61.76,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantValid: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"empty input\",\n\t\t\tinput:     \"\",\n\t\t\twantData:  map[string]system.GPUData{},\n\t\t\twantValid: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"malformed data\",\n\t\t\tinput:     \"bad, data, here\",\n\t\t\twantData:  map[string]system.GPUData{},\n\t\t\twantValid: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgm := &GPUManager{\n\t\t\t\tGpuDataMap: make(map[string]*system.GPUData),\n\t\t\t}\n\t\t\tvalid := gm.parseNvidiaData([]byte(tt.input))\n\t\t\tassert.Equal(t, tt.wantValid, valid)\n\n\t\t\tif tt.wantValid {\n\t\t\t\tfor id, want := range tt.wantData {\n\t\t\t\t\tgot := gm.GpuDataMap[id]\n\t\t\t\t\trequire.NotNil(t, got)\n\t\t\t\t\tassert.Equal(t, want.Name, got.Name)\n\t\t\t\t\tassert.InDelta(t, want.Temperature, got.Temperature, 0.01)\n\t\t\t\t\tassert.InDelta(t, want.MemoryUsed, got.MemoryUsed, 0.01)\n\t\t\t\t\tassert.InDelta(t, want.MemoryTotal, got.MemoryTotal, 0.01)\n\t\t\t\t\tassert.InDelta(t, want.Usage, got.Usage, 0.01)\n\t\t\t\t\tassert.InDelta(t, want.Power, got.Power, 0.01)\n\t\t\t\t\tassert.Equal(t, want.Count, got.Count)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 1129, "primary_symbol": "", "primary_kind": "", "primary_span": [19, 134], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "input", "wantData", "map", "system", "GPUData", "wantValid", "bool", "valid", "multi", "gpu", "data", "NVIDIA", "GeForce", "RTX", "Laptop", "GPU", "A100", "PCIE", "Name", "Temperature", "MemoryUsed", "MemoryTotal", "Usage", "Power", "Count", "true", "more", "A10", "empty", "false", "malformed", "bad", "here", "for", "range", "Run", "func", "testing", "GPUManager", "GpuDataMap", "make", "parseNvidiaData", "byte", "assert", "Equal", "want", "got", "require", "NotNil", "InDelta"], "doc_head": "\ttests := []struct {\n\t\tname      string\n\t\tinput     string\n\t\twantData  map[string]system.GPUData\n\t\twantValid bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid multi-gpu data\",\n\t\t\tinput: \"0, NVIDIA GeForce RTX 3050 Ti Laptop GPU, 48, 12, 4096, 26.3, 12.73\\n1, NVIDIA A100-PCIE-40GB, 38, 74, 40960, [N/A], 36.79\",\n\t\t\twantData: map[string]system.GPUData{\n\t\t\t\t\"0\": {\n\t\t\t\t\tName:        \"GeForce RTX 3050 Ti\",\n\t\t\t\t\tTemperature: 48.0,\n\t\t\t\t\tMemoryUsed:  12.0 / 1.024,\n\t\t\t\t\tMemoryTotal: 4096.0 / 1.024,\n\t\t\t\t\tUsage:       26.3,\n\t\t\t\t\tPower:       12.73,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t\t\"1\": {\n\t\t\t\t\tName:        \"A100-PCIE-40GB\",\n\t\t\t\t\tTemperature: 38.0,\n\t\t\t\t\tMemoryUsed:  74.0 / 1.024,\n\t\t\t\t\tMemoryTotal: 40960.0 / 1.024,\n\t\t\t\t\tUsage:       0.0,\n\t\t\t\t\tPower:       36.79,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantValid: true,\n\t\t},\n\t\t{\n\t\t\tname: \"more valid multi-gpu data\",\n\t\t\tinput: `0, NVIDIA A10, 45, 19676, 23028, 0, 58.98\n1, NVIDIA A10, 45, 19638, 23028, 0, 62.35\n2, NVIDIA A10, 44, 21700, 23028, 0, 59.57\n3, NVIDIA A10, 45, 18222, 23028, 0, 61.76`,\n\t\t\twantData: map[string]system.GPUData{\n\t\t\t\t\"0\": {\n\t\t\t\t\tName:        \"A10\",\n\t\t\t\t\tTemperature: 45.0,\n\t\t\t\t\tMemoryUsed:  19676.0 / 1.024,\n\t\t\t\t\tMemoryTotal: 23028.0 / 1.024,\n\t\t\t\t\tUsage:"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 135, "end_line": 135, "text": "func TestParseAmdData(t *testing.T) {", "n_tokens": 12, "primary_symbol": "TestParseAmdData", "primary_kind": "function", "primary_span": [135, 135], "def_symbols": ["TestParseAmdData"], "symbols": ["TestParseAmdData", "func", "testing"], "doc_head": "func TestParseAmdData(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 136, "end_line": 250, "text": "\ttests := []struct {\n\t\tname      string\n\t\tinput     string\n\t\twantData  map[string]system.GPUData\n\t\twantValid bool\n\t}{\n\t\t{\n\t\t\tname: \"valid single gpu data\",\n\t\t\tinput: `{\n\t\t\t\t\"card0\": {\n\t\t\t\t\t\"GUID\": \"34756\",\n\t\t\t\t\t\"Temperature (Sensor edge) (C)\": \"47.0\",\n\t\t\t\t\t\"Current Socket Graphics Package Power (W)\": \"9.215\",\n\t\t\t\t\t\"GPU use (%)\": \"0\",\n\t\t\t\t\t\"VRAM Total Memory (B)\": \"536870912\",\n\t\t\t\t\t\"VRAM Total Used Memory (B)\": \"482263040\",\n\t\t\t\t\t\"Card Series\": \"Rembrandt [Radeon 680M]\"\n\t\t\t\t}\n\t\t\t}`,\n\t\t\twantData: map[string]system.GPUData{\n\t\t\t\t\"34756\": {\n\t\t\t\t\tName:        \"Rembrandt [Radeon 680M]\",\n\t\t\t\t\tTemperature: 47.0,\n\t\t\t\t\tMemoryUsed:  482263040.0 / (1024 * 1024),\n\t\t\t\t\tMemoryTotal: 536870912.0 / (1024 * 1024),\n\t\t\t\t\tUsage:       0.0,\n\t\t\t\t\tPower:       9.215,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantValid: true,\n\t\t},\n\t\t{\n\t\t\tname: \"valid multi gpu data\",\n\t\t\tinput: `{\n\t\t\t\t\"card0\": {\n\t\t\t\t\t\"GUID\": \"34756\",\n\t\t\t\t\t\"Temperature (Sensor edge) (C)\": \"47.0\",\n\t\t\t\t\t\"Current Socket Graphics Package Power (W)\": \"9.215\",\n\t\t\t\t\t\"GPU use (%)\": \"0\",\n\t\t\t\t\t\"VRAM Total Memory (B)\": \"536870912\",\n\t\t\t\t\t\"VRAM Total Used Memory (B)\": \"482263040\",\n\t\t\t\t\t\"Card Series\": \"Rembrandt [Radeon 680M]\"\n\t\t\t\t},\n\t\t\t\t\"card1\": {\n\t\t\t\t\t\"GUID\": \"38294\",\n\t\t\t\t\t\"Temperature (Sensor edge) (C)\": \"49.0\",\n\t\t\t\t\t\"Temperature (Sensor junction) (C)\": \"49.0\",\n\t\t\t\t\t\"Temperature (Sensor memory) (C)\": \"62.0\",\n\t\t\t\t\t\"Average Graphics Package Power (W)\": \"19.0\",\n\t\t\t\t\t\"GPU use (%)\": \"20.3\",\n\t\t\t\t\t\"VRAM Total Memory (B)\": \"25753026560\",\n\t\t\t\t\t\"VRAM Total Used Memory (B)\": \"794341376\",\n\t\t\t\t\t\"Card Series\": \"Navi 31 [Radeon RX 7900 XT]\"\n\t\t\t\t}\n\t\t\t}`,\n\t\t\twantData: map[string]system.GPUData{\n\t\t\t\t\"34756\": {\n\t\t\t\t\tName:        \"Rembrandt [Radeon 680M]\",\n\t\t\t\t\tTemperature: 47.0,\n\t\t\t\t\tMemoryUsed:  482263040.0 / (1024 * 1024),\n\t\t\t\t\tMemoryTotal: 536870912.0 / (1024 * 1024),\n\t\t\t\t\tUsage:       0.0,\n\t\t\t\t\tPower:       9.215,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t\t\"38294\": {\n\t\t\t\t\tName:        \"Navi 31 [Radeon RX 7900 XT]\",\n\t\t\t\t\tTemperature: 49.0,\n\t\t\t\t\tMemoryUsed:  794341376.0 / (1024 * 1024),\n\t\t\t\t\tMemoryTotal: 25753026560.0 / (1024 * 1024),\n\t\t\t\t\tUsage:       20.3,\n\t\t\t\t\tPower:       19.0,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantValid: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid json\",\n\t\t\tinput: \"{bad json\",\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid json\",\n\t\t\tinput:     \"{bad json\",\n\t\t\twantData:  map[string]system.GPUData{},\n\t\t\twantValid: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgm := &GPUManager{\n\t\t\t\tGpuDataMap: make(map[string]*system.GPUData),\n\t\t\t}\n\t\t\tvalid := gm.parseAmdData([]byte(tt.input))\n\t\t\tassert.Equal(t, tt.wantValid, valid)\n\n\t\t\tif tt.wantValid {\n\t\t\t\tfor id, want := range tt.wantData {\n\t\t\t\t\tgot := gm.GpuDataMap[id]\n\t\t\t\t\trequire.NotNil(t, got)\n\t\t\t\t\tassert.Equal(t, want.Name, got.Name)\n\t\t\t\t\tassert.InDelta(t, want.Temperature, got.Temperature, 0.01)\n\t\t\t\t\tassert.InDelta(t, want.MemoryUsed, got.MemoryUsed, 0.01)\n\t\t\t\t\tassert.InDelta(t, want.MemoryTotal, got.MemoryTotal, 0.01)\n\t\t\t\t\tassert.InDelta(t, want.Usage, got.Usage, 0.01)\n\t\t\t\t\tassert.InDelta(t, want.Power, got.Power, 0.01)\n\t\t\t\t\tassert.Equal(t, want.Count, got.Count)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 1093, "primary_symbol": "", "primary_kind": "", "primary_span": [136, 250], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "input", "wantData", "map", "system", "GPUData", "wantValid", "bool", "valid", "single", "gpu", "data", "card0", "GUID", "Temperature", "Sensor", "edge", "Current", "Socket", "Graphics", "Package", "Power", "GPU", "use", "VRAM", "Total", "Memory", "Used", "Card", "Series", "Rembrandt", "Radeon", "Name", "MemoryUsed", "MemoryTotal", "Usage", "Count", "true", "multi", "card1", "junction", "memory", "Average", "Navi", "invalid", "json", "bad", "false", "for", "range", "Run", "func", "testing", "GPUManager", "GpuDataMap", "make", "parseAmdData", "byte", "assert", "Equal", "want", "got", "require", "NotNil", "InDelta"], "doc_head": "\ttests := []struct {\n\t\tname      string\n\t\tinput     string\n\t\twantData  map[string]system.GPUData\n\t\twantValid bool\n\t}{\n\t\t{\n\t\t\tname: \"valid single gpu data\",\n\t\t\tinput: `{\n\t\t\t\t\"card0\": {\n\t\t\t\t\t\"GUID\": \"34756\",\n\t\t\t\t\t\"Temperature (Sensor edge) (C)\": \"47.0\",\n\t\t\t\t\t\"Current Socket Graphics Package Power (W)\": \"9.215\",\n\t\t\t\t\t\"GPU use (%)\": \"0\",\n\t\t\t\t\t\"VRAM Total Memory (B)\": \"536870912\",\n\t\t\t\t\t\"VRAM Total Used Memory (B)\": \"482263040\",\n\t\t\t\t\t\"Card Series\": \"Rembrandt [Radeon 680M]\"\n\t\t\t\t}\n\t\t\t}`,\n\t\t\twantData: map[string]system.GPUData{\n\t\t\t\t\"34756\": {\n\t\t\t\t\tName:        \"Rembrandt [Radeon 680M]\",\n\t\t\t\t\tTemperature: 47.0,\n\t\t\t\t\tMemoryUsed:  482263040.0 / (1024 * 1024),\n\t\t\t\t\tMemoryTotal: 536870912.0 / (1024 * 1024),\n\t\t\t\t\tUsage:       0.0,\n\t\t\t\t\tPower:       9.215,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantValid: true,\n\t\t},\n\t\t{\n\t\t\tname: \"valid multi gpu data\",\n\t\t\tinput: `{\n\t\t\t\t\"card0\": {\n\t\t\t\t\t\"GUID\": \"34756\",\n\t\t\t\t\t\"Temperature (Sensor edge) (C)\": \"47.0\",\n\t\t\t\t\t\"Current Socket Graphics Package Power (W)\": \"9.215\",\n\t\t\t\t\t\"GPU use (%)\": \"0\",\n\t\t\t\t\t\"VRAM Total Memory (B)\": \"536870912\",\n\t\t\t\t\t\"VRAM Total Used Memory (B)\": \"482263040\",\n\t\t\t\t\t\"Card Series\": \"Rembrandt [Radeon 680M]\"\n\t\t\t\t},\n\t\t\t\t\"card1\": {\n\t\t\t\t\t\"GUID\": "}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 251, "end_line": 251, "text": "func TestParseJetsonData(t *testing.T) {", "n_tokens": 12, "primary_symbol": "TestParseJetsonData", "primary_kind": "function", "primary_span": [251, 251], "def_symbols": ["TestParseJetsonData"], "symbols": ["TestParseJetsonData", "func", "testing"], "doc_head": "func TestParseJetsonData(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 252, "end_line": 333, "text": "\ttests := []struct {\n\t\tname        string\n\t\tinput       string\n\t\twantMetrics *system.GPUData\n\t}{\n\t\t{\n\t\t\tname:  \"valid data\",\n\t\t\tinput: \"11-14-2024 22:54:33 RAM 4300/30698MB GR3D_FREQ 45% tj@52.468C VDD_GPU_SOC 2171mW\",\n\t\t\twantMetrics: &system.GPUData{\n\t\t\t\tName:        \"GPU\",\n\t\t\t\tMemoryUsed:  4300.0,\n\t\t\t\tMemoryTotal: 30698.0,\n\t\t\t\tUsage:       45.0,\n\t\t\t\tTemperature: 52.468,\n\t\t\t\tPower:       2.171,\n\t\t\t\tCount:       1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"more valid data\",\n\t\t\tinput: \"11-15-2024 08:38:09 RAM 6185/7620MB (lfb 8x2MB) SWAP 851/3810MB (cached 1MB) CPU [15%@729,11%@729,14%@729,13%@729,11%@729,8%@729] EMC_FREQ 43%@2133 GR3D_FREQ 63%@[621] NVDEC off NVJPG off NVJPG1 off VIC off OFA off APE 200 cpu@53.968C soc2@52.437C soc0@50.75C gpu@53.343C tj@53.968C soc1@51.656C VDD_IN 12479mW/12479mW VDD_CPU_GPU_CV 4667mW/4667mW VDD_SOC 2817mW/2817mW\",\n\t\t\twantMetrics: &system.GPUData{\n\t\t\t\tName:        \"GPU\",\n\t\t\t\tMemoryUsed:  6185.0,\n\t\t\t\tMemoryTotal: 7620.0,\n\t\t\t\tUsage:       63.0,\n\t\t\t\tTemperature: 53.968,\n\t\t\t\tPower:       4.667,\n\t\t\t\tCount:       1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"orin nano\",\n\t\t\tinput: \"06-18-2025 11:25:24 RAM 3452/7620MB (lfb 25x4MB) SWAP 1518/16384MB (cached 174MB) CPU [1%@1420,2%@1420,0%@1420,2%@1420,2%@729,1%@729] GR3D_FREQ 0% cpu@50.031C soc2@49.031C soc0@50C gpu@49.031C tj@50.25C soc1@50.25C VDD_IN 4824mW/4824mW VDD_CPU_GPU_CV 518mW/518mW VDD_SOC 1475mW/1475mW\",\n\t\t\twantMetrics: &system.GPUData{\n\t\t\t\tName:        \"GPU\",\n\t\t\t\tMemoryUsed:  3452.0,\n\t\t\t\tMemoryTotal: 7620.0,\n\t\t\t\tUsage:       0.0,\n\t\t\t\tTemperature: 50.25,\n\t\t\t\tPower:       0.518,\n\t\t\t\tCount:       1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"missing temperature\",\n\t\t\tinput: \"11-14-2024 22:54:33 RAM 4300/30698MB GR3D_FREQ 45% VDD_GPU_SOC 2171mW\",\n\t\t\twantMetrics: &system.GPUData{\n\t\t\t\tName:        \"GPU\",\n\t\t\t\tMemoryUsed:  4300.0,\n\t\t\t\tMemoryTotal: 30698.0,\n\t\t\t\tUsage:       45.0,\n\t\t\t\tPower:       2.171,\n\t\t\t\tCount:       1,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgm := &GPUManager{\n\t\t\t\tGpuDataMap: make(map[string]*system.GPUData),\n\t\t\t}\n\t\t\tparser := gm.getJetsonParser()\n\t\t\tvalid := parser([]byte(tt.input))\n\t\t\tassert.Equal(t, true, valid)\n\n\t\t\tgot := gm.GpuDataMap[\"0\"]\n\t\t\trequire.NotNil(t, got)\n\t\t\tassert.Equal(t, tt.wantMetrics.Name, got.Name)\n\t\t\tassert.InDelta(t, tt.wantMetrics.MemoryUsed, got.MemoryUsed, 0.01)\n\t\t\tassert.InDelta(t, tt.wantMetrics.MemoryTotal, got.MemoryTotal, 0.01)\n\t\t\tassert.InDelta(t, tt.wantMetrics.Usage, got.Usage, 0.01)\n\t\t\tif tt.wantMetrics.Temperature > 0 {\n\t\t\t\tassert.InDelta(t, tt.wantMetrics.Temperature, got.Temperature, 0.01)\n\t\t\t}\n\t\t\tassert.InDelta(t, tt.wantMetrics.Power, got.Power, 0.01)\n\t\t\tassert.Equal(t, tt.wantMetrics.Count, got.Count)\n\t\t})\n\t}\n}\n", "n_tokens": 1080, "primary_symbol": "", "primary_kind": "", "primary_span": [252, 333], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "input", "wantMetrics", "system", "GPUData", "valid", "data", "RAM", "GR3D_FREQ", "VDD_GPU_SOC", "Name", "GPU", "MemoryUsed", "MemoryTotal", "Usage", "Temperature", "Power", "Count", "more", "lfb", "SWAP", "cached", "CPU", "EMC_FREQ", "NVDEC", "off", "NVJPG", "NVJPG1", "VIC", "OFA", "APE", "cpu", "soc2", "soc0", "gpu", "soc1", "VDD_IN", "VDD_CPU_GPU_CV", "VDD_SOC", "orin", "nano", "missing", "temperature", "for", "range", "Run", "func", "testing", "GPUManager", "GpuDataMap", "make", "map", "parser", "getJetsonParser", "byte", "assert", "Equal", "true", "got", "require", "NotNil", "InDelta"], "doc_head": "\ttests := []struct {\n\t\tname        string\n\t\tinput       string\n\t\twantMetrics *system.GPUData\n\t}{\n\t\t{\n\t\t\tname:  \"valid data\",\n\t\t\tinput: \"11-14-2024 22:54:33 RAM 4300/30698MB GR3D_FREQ 45% tj@52.468C VDD_GPU_SOC 2171mW\",\n\t\t\twantMetrics: &system.GPUData{\n\t\t\t\tName:        \"GPU\",\n\t\t\t\tMemoryUsed:  4300.0,\n\t\t\t\tMemoryTotal: 30698.0,\n\t\t\t\tUsage:       45.0,\n\t\t\t\tTemperature: 52.468,\n\t\t\t\tPower:       2.171,\n\t\t\t\tCount:       1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"more valid data\",\n\t\t\tinput: \"11-15-2024 08:38:09 RAM 6185/7620MB (lfb 8x2MB) SWAP 851/3810MB (cached 1MB) CPU [15%@729,11%@729,14%@729,13%@729,11%@729,8%@729] EMC_FREQ 43%@2133 GR3D_FREQ 63%@[621] NVDEC off NVJPG off NVJPG1 off VIC off OFA off APE 200 cpu@53.968C soc2@52.437C soc0@50.75C gpu@53.343C tj@53.968C soc1@51.656C VDD_IN 12479mW/12479mW VDD_CPU_GPU_CV 4667mW/4667mW VDD_SOC 2817mW/2817mW\",\n\t\t\twantMetrics: &system.GPUData{\n\t\t\t\tName:        \"GPU\",\n\t\t\t\tMemoryUsed:  6185.0,\n\t\t\t\tMemoryTotal: 7620.0,\n\t\t\t\tUsage:       63.0,\n\t\t\t\tTemperature: 53.968,\n\t\t\t\tPower:       4.667,\n\t\t\t\tCount:       1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"orin nano\",\n\t\t\tinput: \"06-18-2025 11:25:24 RAM 3452/7620MB (lfb 25x4MB) SWAP 1518/16384MB (cached 174MB) CPU [1%@1420,2%@1420,0%@"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 334, "end_line": 415, "text": "func TestGetCurrentData(t *testing.T) {\n\tt.Run(\"calculates averages and resets accumulators\", func(t *testing.T) {\n\t\tgm := &GPUManager{\n\t\t\tGpuDataMap: map[string]*system.GPUData{\n\t\t\t\t\"0\": {\n\t\t\t\t\tName:        \"GPU1\",\n\t\t\t\t\tTemperature: 50,\n\t\t\t\t\tMemoryUsed:  2048,\n\t\t\t\t\tMemoryTotal: 4096,\n\t\t\t\t\tUsage:       100, // 100 over 2 counts = 50 avg\n\t\t\t\t\tPower:       200, // 200 over 2 counts = 100 avg\n\t\t\t\t\tCount:       2,\n\t\t\t\t},\n\t\t\t\t\"1\": {\n\t\t\t\t\tName:        \"GPU1\",\n\t\t\t\t\tTemperature: 60,\n\t\t\t\t\tMemoryUsed:  3072,\n\t\t\t\t\tMemoryTotal: 8192,\n\t\t\t\t\tUsage:       30,\n\t\t\t\t\tPower:       60,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t\t\"2\": {\n\t\t\t\t\tName:        \"GPU 2\",\n\t\t\t\t\tTemperature: 70,\n\t\t\t\t\tMemoryUsed:  4096,\n\t\t\t\t\tMemoryTotal: 8192,\n\t\t\t\t\tUsage:       200,\n\t\t\t\t\tPower:       400,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tresult := gm.GetCurrentData()\n\n\t\t// Verify name disambiguation\n\t\tassert.Equal(t, \"GPU1 0\", result[\"0\"].Name)\n\t\tassert.Equal(t, \"GPU1 1\", result[\"1\"].Name)\n\t\tassert.Equal(t, \"GPU 2\", result[\"2\"].Name)\n\n\t\t// Check averaged values in the result\n\t\tassert.InDelta(t, 50.0, result[\"0\"].Usage, 0.01)\n\t\tassert.InDelta(t, 100.0, result[\"0\"].Power, 0.01)\n\t\tassert.InDelta(t, 30.0, result[\"1\"].Usage, 0.01)\n\t\tassert.InDelta(t, 60.0, result[\"1\"].Power, 0.01)\n\n\t\t// Verify that accumulators in the original map are reset\n\t\tassert.Equal(t, float64(0), gm.GpuDataMap[\"0\"].Count, \"GPU 0 Count should be reset\")\n\t\tassert.Equal(t, float64(0), gm.GpuDataMap[\"0\"].Usage, \"GPU 0 Usage should be reset\")\n\t\tassert.Equal(t, float64(0), gm.GpuDataMap[\"0\"].Power, \"GPU 0 Power should be reset\")\n\t\tassert.Equal(t, float64(0), gm.GpuDataMap[\"1\"].Count, \"GPU 1 Count should be reset\")\n\t\tassert.Equal(t, float64(0), gm.GpuDataMap[\"1\"].Usage, \"GPU 1 Usage should be reset\")\n\t\tassert.Equal(t, float64(0), gm.GpuDataMap[\"1\"].Power, \"GPU 1 Power should be reset\")\n\t})\n\n\tt.Run(\"handles zero count without panicking\", func(t *testing.T) {\n\t\tgm := &GPUManager{\n\t\t\tGpuDataMap: map[string]*system.GPUData{\n\t\t\t\t\"0\": {\n\t\t\t\t\tName:  \"TestGPU\",\n\t\t\t\t\tCount: 0,\n\t\t\t\t\tUsage: 0,\n\t\t\t\t\tPower: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tvar result map[string]system.GPUData\n\t\tassert.NotPanics(t, func() {\n\t\t\tresult = gm.GetCurrentData()\n\t\t})\n\n\t\t// Check that usage and power are 0\n\t\tassert.Equal(t, 0.0, result[\"0\"].Usage)\n\t\tassert.Equal(t, 0.0, result[\"0\"].Power)\n\n\t\t// Verify reset count\n\t\tassert.Equal(t, float64(0), gm.GpuDataMap[\"0\"].Count)\n\t})\n}\n", "n_tokens": 825, "primary_symbol": "TestGetCurrentData", "primary_kind": "function", "primary_span": [334, 415], "def_symbols": ["TestGetCurrentData"], "symbols": ["TestGetCurrentData", "func", "testing", "Run", "calculates", "averages", "and", "resets", "accumulators", "GPUManager", "GpuDataMap", "map", "string", "system", "GPUData", "Name", "GPU1", "Temperature", "MemoryUsed", "MemoryTotal", "Usage", "over", "counts", "avg", "Power", "Count", "GPU", "result", "GetCurrentData", "Verify", "name", "disambiguation", "assert", "Equal", "Check", "averaged", "values", "the", "InDelta", "that", "original", "are", "reset", "float64", "should", "handles", "zero", "count", "without", "panicking", "TestGPU", "var", "NotPanics", "usage", "power"], "doc_head": "func TestGetCurrentData(t *testing.T) {\n\tt.Run(\"calculates averages and resets accumulators\", func(t *testing.T) {\n\t\tgm := &GPUManager{\n\t\t\tGpuDataMap: map[string]*system.GPUData{\n\t\t\t\t\"0\": {\n\t\t\t\t\tName:        \"GPU1\",\n\t\t\t\t\tTemperature: 50,\n\t\t\t\t\tMemoryUsed:  2048,\n\t\t\t\t\tMemoryTotal: 4096,\n\t\t\t\t\tUsage:       100, // 100 over 2 counts = 50 avg\n\t\t\t\t\tPower:       200, // 200 over 2 counts = 100 avg\n\t\t\t\t\tCount:       2,\n\t\t\t\t},\n\t\t\t\t\"1\": {\n\t\t\t\t\tName:        \"GPU1\",\n\t\t\t\t\tTemperature: 60,\n\t\t\t\t\tMemoryUsed:  3072,\n\t\t\t\t\tMemoryTotal: 8192,\n\t\t\t\t\tUsage:       30,\n\t\t\t\t\tPower:       60,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t\t\"2\": {\n\t\t\t\t\tName:        \"GPU 2\",\n\t\t\t\t\tTemperature: 70,\n\t\t\t\t\tMemoryUsed:  4096,\n\t\t\t\t\tMemoryTotal: 8192,\n\t\t\t\t\tUsage:       200,\n\t\t\t\t\tPower:       400,\n\t\t\t\t\tCount:       1,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tresult := gm.GetCurrentData()\n\t\t// Verify name disambiguation\n\t\tassert.Equal(t, \"GPU1 0\", result[\"0\"].Name)\n\t\tassert.Equal(t, \"GPU1 1\", result[\"1\"].Name)\n\t\tassert.Equal(t, \"GPU 2\", result[\"2\"].Name)\n\t\t// Check averaged values in the result\n\t\tassert.InDelta(t, 50.0, result[\"0\"].Usage, 0.01)\n\t\tassert.InDelta(t, 100.0, result[\"0\"].Power, 0.01)\n\t\tassert.InDelta(t, 30.0, result[\"1\"].Usage, 0.01)\n\t\tassert.InD"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 416, "end_line": 424, "text": "func TestDetectGPUs(t *testing.T) {\n\t// Save original PATH\n\torigPath := os.Getenv(\"PATH\")\n\tdefer os.Setenv(\"PATH\", origPath)\n\n\t// Set up temp dir with the commands\n\ttempDir := t.TempDir()\n\tos.Setenv(\"PATH\", tempDir)\n", "n_tokens": 62, "primary_symbol": "TestDetectGPUs", "primary_kind": "function", "primary_span": [416, 424], "def_symbols": ["TestDetectGPUs"], "symbols": ["TestDetectGPUs", "func", "testing", "Save", "original", "PATH", "origPath", "Getenv", "defer", "Setenv", "Set", "temp", "dir", "with", "the", "commands", "tempDir", "TempDir"], "doc_head": "func TestDetectGPUs(t *testing.T) {\n\t// Save original PATH\n\torigPath := os.Getenv(\"PATH\")\n\tdefer os.Setenv(\"PATH\", origPath)\n\t// Set up temp dir with the commands\n\ttempDir := t.TempDir()\n\tos.Setenv(\"PATH\", tempDir)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 425, "end_line": 524, "text": "\ttests := []struct {\n\t\tname           string\n\t\tsetupCommands  func() error\n\t\twantNvidiaSmi  bool\n\t\twantRocmSmi    bool\n\t\twantTegrastats bool\n\t\twantErr        bool\n\t}{\n\t\t{\n\t\t\tname: \"nvidia-smi not available\",\n\t\t\tsetupCommands: func() error {\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\twantNvidiaSmi:  false,\n\t\t\twantRocmSmi:    false,\n\t\t\twantTegrastats: false,\n\t\t\twantErr:        true,\n\t\t},\n\t\t{\n\t\t\tname: \"nvidia-smi available\",\n\t\t\tsetupCommands: func() error {\n\t\t\t\tpath := filepath.Join(tempDir, \"nvidia-smi\")\n\t\t\t\tscript := `#!/bin/sh\necho \"test\"`\n\t\t\t\tif err := os.WriteFile(path, []byte(script), 0755); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\twantNvidiaSmi:  true,\n\t\t\twantTegrastats: false,\n\t\t\twantRocmSmi:    false,\n\t\t\twantErr:        false,\n\t\t},\n\t\t{\n\t\t\tname: \"rocm-smi available\",\n\t\t\tsetupCommands: func() error {\n\t\t\t\tpath := filepath.Join(tempDir, \"rocm-smi\")\n\t\t\t\tscript := `#!/bin/sh\necho \"test\"`\n\t\t\t\tif err := os.WriteFile(path, []byte(script), 0755); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\twantNvidiaSmi:  true,\n\t\t\twantRocmSmi:    true,\n\t\t\twantTegrastats: false,\n\t\t\twantErr:        false,\n\t\t},\n\t\t{\n\t\t\tname: \"tegrastats available\",\n\t\t\tsetupCommands: func() error {\n\t\t\t\tpath := filepath.Join(tempDir, \"tegrastats\")\n\t\t\t\tscript := `#!/bin/sh\necho \"test\"`\n\t\t\t\tif err := os.WriteFile(path, []byte(script), 0755); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\twantNvidiaSmi:  false,\n\t\t\twantRocmSmi:    true,\n\t\t\twantTegrastats: true,\n\t\t\twantErr:        false,\n\t\t},\n\t\t{\n\t\t\tname: \"no gpu tools available\",\n\t\t\tsetupCommands: func() error {\n\t\t\t\tos.Setenv(\"PATH\", \"\")\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := tt.setupCommands(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tgm := &GPUManager{}\n\t\t\terr := gm.detectGPUs()\n\n\t\t\tt.Logf(\"nvidiaSmi: %v, rocmSmi: %v, tegrastats: %v\", gm.nvidiaSmi, gm.rocmSmi, gm.tegrastats)\n\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tt.wantNvidiaSmi, gm.nvidiaSmi)\n\t\t\tassert.Equal(t, tt.wantRocmSmi, gm.rocmSmi)\n\t\t\tassert.Equal(t, tt.wantTegrastats, gm.tegrastats)\n\t\t})\n\t}\n}\n", "n_tokens": 723, "primary_symbol": "", "primary_kind": "", "primary_span": [425, 524], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "setupCommands", "func", "error", "wantNvidiaSmi", "bool", "wantRocmSmi", "wantTegrastats", "wantErr", "nvidia", "smi", "not", "available", "return", "nil", "false", "true", "path", "filepath", "Join", "tempDir", "script", "bin", "echo", "test", "err", "WriteFile", "byte", "rocm", "tegrastats", "gpu", "tools", "Setenv", "PATH", "for", "range", "Run", "testing", "Fatal", "GPUManager", "detectGPUs", "Logf", "nvidiaSmi", "rocmSmi", "assert", "Error", "NoError", "Equal"], "doc_head": "\ttests := []struct {\n\t\tname           string\n\t\tsetupCommands  func() error\n\t\twantNvidiaSmi  bool\n\t\twantRocmSmi    bool\n\t\twantTegrastats bool\n\t\twantErr        bool\n\t}{\n\t\t{\n\t\t\tname: \"nvidia-smi not available\",\n\t\t\tsetupCommands: func() error {\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\twantNvidiaSmi:  false,\n\t\t\twantRocmSmi:    false,\n\t\t\twantTegrastats: false,\n\t\t\twantErr:        true,\n\t\t},\n\t\t{\n\t\t\tname: \"nvidia-smi available\",\n\t\t\tsetupCommands: func() error {\n\t\t\t\tpath := filepath.Join(tempDir, \"nvidia-smi\")\n\t\t\t\tscript := `#!/bin/sh\necho \"test\"`\n\t\t\t\tif err := os.WriteFile(path, []byte(script), 0755); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\twantNvidiaSmi:  true,\n\t\t\twantTegrastats: false,\n\t\t\twantRocmSmi:    false,\n\t\t\twantErr:        false,\n\t\t},\n\t\t{\n\t\t\tname: \"rocm-smi available\",\n\t\t\tsetupCommands: func() error {\n\t\t\t\tpath := filepath.Join(tempDir, \"rocm-smi\")\n\t\t\t\tscript := `#!/bin/sh\necho \"test\"`\n\t\t\t\tif err := os.WriteFile(path, []byte(script), 0755); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\twantNvidiaSmi:  true,\n\t\t\twantRocmSmi:    true,\n\t\t\twantTegrastats: false,\n\t\t\twantErr:        false,\n\t\t},"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 525, "end_line": 533, "text": "func TestStartCollector(t *testing.T) {\n\t// Save original PATH\n\torigPath := os.Getenv(\"PATH\")\n\tdefer os.Setenv(\"PATH\", origPath)\n\n\t// Set up temp dir with the commands\n\tdir := t.TempDir()\n\tos.Setenv(\"PATH\", dir)\n", "n_tokens": 59, "primary_symbol": "TestStartCollector", "primary_kind": "function", "primary_span": [525, 533], "def_symbols": ["TestStartCollector"], "symbols": ["TestStartCollector", "func", "testing", "Save", "original", "PATH", "origPath", "Getenv", "defer", "Setenv", "Set", "temp", "dir", "with", "the", "commands", "TempDir"], "doc_head": "func TestStartCollector(t *testing.T) {\n\t// Save original PATH\n\torigPath := os.Getenv(\"PATH\")\n\tdefer os.Setenv(\"PATH\", origPath)\n\t// Set up temp dir with the commands\n\tdir := t.TempDir()\n\tos.Setenv(\"PATH\", dir)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 534, "end_line": 628, "text": "\ttests := []struct {\n\t\tname     string\n\t\tcommand  string\n\t\tsetup    func(t *testing.T) error\n\t\tvalidate func(t *testing.T, gm *GPUManager)\n\t\tgm       *GPUManager\n\t}{\n\t\t{\n\t\t\tname:    \"nvidia-smi collector\",\n\t\t\tcommand: \"nvidia-smi\",\n\t\t\tsetup: func(t *testing.T) error {\n\t\t\t\tpath := filepath.Join(dir, \"nvidia-smi\")\n\t\t\t\tscript := `#!/bin/sh\necho \"0, NVIDIA Test GPU, 50, 1024, 4096, 25, 100\"`\n\t\t\t\tif err := os.WriteFile(path, []byte(script), 0755); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, gm *GPUManager) {\n\t\t\t\tgpu, exists := gm.GpuDataMap[\"0\"]\n\t\t\t\tassert.True(t, exists)\n\t\t\t\tif exists {\n\t\t\t\t\tassert.Equal(t, \"Test GPU\", gpu.Name)\n\t\t\t\t\tassert.Equal(t, 50.0, gpu.Temperature)\n\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"rocm-smi collector\",\n\t\t\tcommand: \"rocm-smi\",\n\t\t\tsetup: func(t *testing.T) error {\n\t\t\t\tpath := filepath.Join(dir, \"rocm-smi\")\n\t\t\t\tscript := `#!/bin/sh\necho '{\"card0\": {\"Temperature (Sensor edge) (C)\": \"49.0\", \"Current Socket Graphics Package Power (W)\": \"28.159\", \"GPU use (%)\": \"0\", \"VRAM Total Memory (B)\": \"536870912\", \"VRAM Total Used Memory (B)\": \"445550592\", \"Card Series\": \"Rembrandt [Radeon 680M]\", \"Card Model\": \"0x1681\", \"Card Vendor\": \"Advanced Micro Devices, Inc. [AMD/ATI]\", \"Card SKU\": \"REMBRANDT\", \"Subsystem ID\": \"0x8a22\", \"Device Rev\": \"0xc8\", \"Node ID\": \"1\", \"GUID\": \"34756\", \"GFX Version\": \"gfx1035\"}}'`\n\t\t\t\tif err := os.WriteFile(path, []byte(script), 0755); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, gm *GPUManager) {\n\t\t\t\tgpu, exists := gm.GpuDataMap[\"34756\"]\n\t\t\t\tassert.True(t, exists)\n\t\t\t\tif exists {\n\t\t\t\t\tassert.Equal(t, \"Rembrandt [Radeon 680M]\", gpu.Name)\n\t\t\t\t\tassert.InDelta(t, 49.0, gpu.Temperature, 0.01)\n\t\t\t\t\tassert.InDelta(t, 28.159, gpu.Power, 0.01)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"tegrastats collector\",\n\t\t\tcommand: \"tegrastats\",\n\t\t\tsetup: func(t *testing.T) error {\n\t\t\t\tpath := filepath.Join(dir, \"tegrastats\")\n\t\t\t\tscript := `#!/bin/sh\necho \"11-14-2024 22:54:33 RAM 1024/4096MB GR3D_FREQ 80% tj@70C VDD_GPU_SOC 1000mW\"`\n\t\t\t\tif err := os.WriteFile(path, []byte(script), 0755); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, gm *GPUManager) {\n\t\t\t\tgpu, exists := gm.GpuDataMap[\"0\"]\n\t\t\t\tassert.True(t, exists)\n\t\t\t\tif exists {\n\t\t\t\t\tassert.InDelta(t, 70.0, gpu.Temperature, 0.1)\n\t\t\t\t}\n\t\t\t},\n\t\t\tgm: &GPUManager{\n\t\t\t\tGpuDataMap: map[string]*system.GPUData{\n\t\t\t\t\t\"0\": {},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := tt.setup(t); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif tt.gm == nil {\n\t\t\t\ttt.gm = &GPUManager{\n\t\t\t\t\tGpuDataMap: make(map[string]*system.GPUData),\n\t\t\t\t}\n\t\t\t}\n\t\t\ttt.gm.startCollector(tt.command)\n\t\t\ttime.Sleep(50 * time.Millisecond) // Give collector time to run\n\t\t\ttt.validate(t, tt.gm)\n\t\t})\n\t}\n}\n", "n_tokens": 966, "primary_symbol": "", "primary_kind": "", "primary_span": [534, 628], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "command", "setup", "func", "testing", "error", "validate", "GPUManager", "nvidia", "smi", "collector", "path", "filepath", "Join", "dir", "script", "bin", "echo", "NVIDIA", "Test", "GPU", "err", "WriteFile", "byte", "nil", "return", "gpu", "exists", "GpuDataMap", "assert", "True", "Equal", "Name", "Temperature", "rocm", "card0", "Sensor", "edge", "Current", "Socket", "Graphics", "Package", "Power", "use", "VRAM", "Total", "Memory", "Used", "Card", "Series", "Rembrandt", "Radeon", "Model", "Vendor", "Advanced", "Micro", "Devices", "Inc", "AMD", "ATI", "SKU", "REMBRANDT", "Subsystem", "Device", "Rev", "Node", "GUID", "GFX", "Version", "gfx1035", "InDelta", "tegrastats", "RAM", "GR3D_FREQ", "VDD_GPU_SOC", "map", "system", "GPUData", "for", "range", "Run", "Fatal", "make", "startCollector", "time", "Sleep", "Millisecond", "Give", "run"], "doc_head": "\ttests := []struct {\n\t\tname     string\n\t\tcommand  string\n\t\tsetup    func(t *testing.T) error\n\t\tvalidate func(t *testing.T, gm *GPUManager)\n\t\tgm       *GPUManager\n\t}{\n\t\t{\n\t\t\tname:    \"nvidia-smi collector\",\n\t\t\tcommand: \"nvidia-smi\",\n\t\t\tsetup: func(t *testing.T) error {\n\t\t\t\tpath := filepath.Join(dir, \"nvidia-smi\")\n\t\t\t\tscript := `#!/bin/sh\necho \"0, NVIDIA Test GPU, 50, 1024, 4096, 25, 100\"`\n\t\t\t\tif err := os.WriteFile(path, []byte(script), 0755); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, gm *GPUManager) {\n\t\t\t\tgpu, exists := gm.GpuDataMap[\"0\"]\n\t\t\t\tassert.True(t, exists)\n\t\t\t\tif exists {\n\t\t\t\t\tassert.Equal(t, \"Test GPU\", gpu.Name)\n\t\t\t\t\tassert.Equal(t, 50.0, gpu.Temperature)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"rocm-smi collector\",\n\t\t\tcommand: \"rocm-smi\",\n\t\t\tsetup: func(t *testing.T) error {\n\t\t\t\tpath := filepath.Join(dir, \"rocm-smi\")\n\t\t\t\tscript := `#!/bin/sh\necho '{\"card0\": {\"Temperature (Sensor edge) (C)\": \"49.0\", \"Current Socket Graphics Package Power (W)\": \"28.159\", \"GPU use (%)\": \"0\", \"VRAM Total Memory (B)\": \"536870912\", \"VRAM Total Used Memory (B)\": \"445550592\", \"Card Series\": \"Rembrandt [Radeon 680M]\", \"Card Model\": \"0x1681\", \"Card Vendor\": "}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 629, "end_line": 641, "text": "// TestAccumulationTableDriven tests the accumulation behavior for all three GPU types\nfunc TestAccumulation(t *testing.T) {\n\ttype expectedGPUValues struct {\n\t\ttemperature float64\n\t\tmemoryUsed  float64\n\t\tmemoryTotal float64\n\t\tusage       float64\n\t\tpower       float64\n\t\tcount       float64\n\t\tavgUsage    float64\n\t\tavgPower    float64\n\t}\n", "n_tokens": 92, "primary_symbol": "TestAccumulation", "primary_kind": "function", "primary_span": [630, 641], "def_symbols": ["TestAccumulation"], "symbols": ["TestAccumulation", "TestAccumulationTableDriven", "tests", "the", "accumulation", "behavior", "for", "all", "three", "GPU", "types", "func", "testing", "type", "expectedGPUValues", "struct", "temperature", "float64", "memoryUsed", "memoryTotal", "usage", "power", "count", "avgUsage", "avgPower"], "doc_head": "// TestAccumulationTableDriven tests the accumulation behavior for all three GPU types\nfunc TestAccumulation(t *testing.T) {\n\ttype expectedGPUValues struct {\n\t\ttemperature float64\n\t\tmemoryUsed  float64\n\t\tmemoryTotal float64\n\t\tusage       float64\n\t\tpower       float64\n\t\tcount       float64\n\t\tavgUsage    float64\n\t\tavgPower    float64\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu_test.go", "rel_path": "agent/gpu_test.go", "ext": "go", "language": "go", "chunk_number": 13, "start_line": 642, "end_line": 795, "text": "\ttests := []struct {\n\t\tname           string\n\t\tinitialGPUData map[string]*system.GPUData\n\t\tdataSamples    [][]byte\n\t\tparser         func(*GPUManager) func([]byte) bool\n\t\texpectedValues map[string]expectedGPUValues\n\t}{\n\t\t{\n\t\t\tname: \"Jetson GPU accumulation\",\n\t\t\tinitialGPUData: map[string]*system.GPUData{\n\t\t\t\t\"0\": {\n\t\t\t\t\tName:        \"Jetson\",\n\t\t\t\t\tTemperature: 0,\n\t\t\t\t\tUsage:       0,\n\t\t\t\t\tPower:       0,\n\t\t\t\t\tCount:       0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tdataSamples: [][]byte{\n\t\t\t\t[]byte(\"11-14-2024 22:54:33 RAM 1024/4096MB GR3D_FREQ 30% tj@50.5C VDD_GPU_SOC 1000mW\"),\n\t\t\t\t[]byte(\"11-14-2024 22:54:33 RAM 1024/4096MB GR3D_FREQ 40% tj@60.5C VDD_GPU_SOC 1200mW\"),\n\t\t\t\t[]byte(\"11-14-2024 22:54:33 RAM 1024/4096MB GR3D_FREQ 50% tj@70.5C VDD_GPU_SOC 1400mW\"),\n\t\t\t},\n\t\t\tparser: func(gm *GPUManager) func([]byte) bool {\n\t\t\t\treturn gm.getJetsonParser()\n\t\t\t},\n\t\t\texpectedValues: map[string]expectedGPUValues{\n\t\t\t\t\"0\": {\n\t\t\t\t\ttemperature: 70.5,  // Last value\n\t\t\t\t\tmemoryUsed:  1024,  // Last value\n\t\t\t\t\tmemoryTotal: 4096,  // Last value\n\t\t\t\t\tusage:       120.0, // Accumulated: 30 + 40 + 50\n\t\t\t\t\tpower:       3.6,   // Accumulated: 1.0 + 1.2 + 1.4\n\t\t\t\t\tcount:       3,\n\t\t\t\t\tavgUsage:    40.0, // 120 / 3\n\t\t\t\t\tavgPower:    1.2,  // 3.6 / 3\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:           \"NVIDIA GPU accumulation\",\n\t\t\tinitialGPUData: map[string]*system.GPUData{\n\t\t\t\t// NVIDIA parser will create the GPU data entries\n\t\t\t},\n\t\t\tdataSamples: [][]byte{\n\t\t\t\t[]byte(\"0, NVIDIA GeForce RTX 3080, 50, 5000, 10000, 30, 200\"),\n\t\t\t\t[]byte(\"0, NVIDIA GeForce RTX 3080, 60, 6000, 10000, 40, 250\"),\n\t\t\t\t[]byte(\"0, NVIDIA GeForce RTX 3080, 70, 7000, 10000, 50, 300\"),\n\t\t\t},\n\t\t\tparser: func(gm *GPUManager) func([]byte) bool {\n\t\t\t\treturn gm.parseNvidiaData\n\t\t\t},\n\t\t\texpectedValues: map[string]expectedGPUValues{\n\t\t\t\t\"0\": {\n\t\t\t\t\ttemperature: 70.0,            // Last value\n\t\t\t\t\tmemoryUsed:  7000.0 / 1.024,  // Last value\n\t\t\t\t\tmemoryTotal: 10000.0 / 1.024, // Last value\n\t\t\t\t\tusage:       120.0,           // Accumulated: 30 + 40 + 50\n\t\t\t\t\tpower:       750.0,           // Accumulated: 200 + 250 + 300\n\t\t\t\t\tcount:       3,\n\t\t\t\t\tavgUsage:    40.0,  // 120 / 3\n\t\t\t\t\tavgPower:    250.0, // 750 / 3\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:           \"AMD GPU accumulation\",\n\t\t\tinitialGPUData: map[string]*system.GPUData{\n\t\t\t\t// AMD parser will create the GPU data entries\n\t\t\t},\n\t\t\tdataSamples: [][]byte{\n\t\t\t\t[]byte(`{\"card0\": {\"GUID\": \"34756\", \"Temperature (Sensor edge) (C)\": \"50.0\", \"Current Socket Graphics Package Power (W)\": \"100.0\", \"GPU use (%)\": \"30\", \"VRAM Total Memory (B)\": \"10737418240\", \"VRAM Total Used Memory (B)\": \"1073741824\", \"Card Series\": \"Radeon RX 6800\"}}`),\n\t\t\t\t[]byte(`{\"card0\": {\"GUID\": \"34756\", \"Temperature (Sensor edge) (C)\": \"60.0\", \"Current Socket Graphics Package Power (W)\": \"150.0\", \"GPU use (%)\": \"40\", \"VRAM Total Memory (B)\": \"10737418240\", \"VRAM Total Used Memory (B)\": \"2147483648\", \"Card Series\": \"Radeon RX 6800\"}}`),\n\t\t\t\t[]byte(`{\"card0\": {\"GUID\": \"34756\", \"Temperature (Sensor edge) (C)\": \"70.0\", \"Current Socket Graphics Package Power (W)\": \"200.0\", \"GPU use (%)\": \"50\", \"VRAM Total Memory (B)\": \"10737418240\", \"VRAM Total Used Memory (B)\": \"3221225472\", \"Card Series\": \"Radeon RX 6800\"}}`),\n\t\t\t},\n\t\t\tparser: func(gm *GPUManager) func([]byte) bool {\n\t\t\t\treturn gm.parseAmdData\n\t\t\t},\n\t\t\texpectedValues: map[string]expectedGPUValues{\n\t\t\t\t\"34756\": {\n\t\t\t\t\ttemperature: 70.0,                          // Last value\n\t\t\t\t\tmemoryUsed:  3221225472.0 / (1024 * 1024),  // Last value\n\t\t\t\t\tmemoryTotal: 10737418240.0 / (1024 * 1024), // Last value\n\t\t\t\t\tusage:       120.0,                         // Accumulated: 30 + 40 + 50\n\t\t\t\t\tpower:       450.0,                         // Accumulated: 100 + 150 + 200\n\t\t\t\t\tcount:       3,\n\t\t\t\t\tavgUsage:    40.0,  // 120 / 3\n\t\t\t\t\tavgPower:    150.0, // 450 / 3\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Create a new GPUManager for each test\n\t\t\tgm := &GPUManager{\n\t\t\t\tGpuDataMap: tt.initialGPUData,\n\t\t\t}\n\n\t\t\t// Get the parser function\n\t\t\tparser := tt.parser(gm)\n\n\t\t\t// Process each data sample\n\t\t\tfor i, sample := range tt.dataSamples {\n\t\t\t\tvalid := parser(sample)\n\t\t\t\tassert.True(t, valid, \"Sample %d should be valid\", i)\n\t\t\t}\n\n\t\t\t// Check accumulated values\n\t\t\tfor id, expected := range tt.expectedValues {\n\t\t\t\tgpu, exists := gm.GpuDataMap[id]\n\t\t\t\tassert.True(t, exists, \"GPU with ID %s should exist\", id)\n\t\t\t\tif !exists {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tassert.InDelta(t, expected.temperature, gpu.Temperature, 0.01, \"Temperature should match\")\n\t\t\t\tassert.InDelta(t, expected.memoryUsed, gpu.MemoryUsed, 0.01, \"Memory used should match\")\n\t\t\t\tassert.InDelta(t, expected.memoryTotal, gpu.MemoryTotal, 0.01, \"Memory total should match\")\n\t\t\t\tassert.InDelta(t, expected.usage, gpu.Usage, 0.01, \"Usage should match\")\n\t\t\t\tassert.InDelta(t, expected.power, gpu.Power, 0.01, \"Power should match\")\n\t\t\t\tassert.Equal(t, expected.count, gpu.Count, \"Count should match\")\n\t\t\t}\n\n\t\t\t// Verify average calculation in GetCurrentData\n\t\t\tresult := gm.GetCurrentData()\n\t\t\tfor id, expected := range tt.expectedValues {\n\t\t\t\tgpu, exists := result[id]\n\t\t\t\tassert.True(t, exists, \"GPU with ID %s should exist in GetCurrentData result\", id)\n\t\t\t\tif !exists {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tassert.InDelta(t, expected.temperature, gpu.Temperature, 0.01, \"Temperature in GetCurrentData should match\")\n\t\t\t\tassert.InDelta(t, expected.avgUsage, gpu.Usage, 0.01, \"Average usage in GetCurrentData should match\")\n\t\t\t\tassert.InDelta(t, expected.avgPower, gpu.Power, 0.01, \"Average power in GetCurrentData should match\")\n\t\t\t}\n\n\t\t\t// Verify that accumulators in the original map are reset\n\t\t\tfor id := range tt.expectedValues {\n\t\t\t\tgpu, exists := gm.GpuDataMap[id]\n\t\t\t\tassert.True(t, exists, \"GPU with ID %s should still exist after GetCurrentData\", id)\n\t\t\t\tif !exists {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tassert.Equal(t, float64(0), gpu.Count, \"Count should be reset for GPU ID %s\", id)\n\t\t\t\tassert.Equal(t, float64(0), gpu.Usage, \"Usage should be reset for GPU ID %s\", id)\n\t\t\t\tassert.Equal(t, float64(0), gpu.Power, \"Power should be reset for GPU ID %s\", id)\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 1991, "primary_symbol": "", "primary_kind": "", "primary_span": [642, 795], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "initialGPUData", "map", "system", "GPUData", "dataSamples", "byte", "parser", "func", "GPUManager", "bool", "expectedValues", "expectedGPUValues", "Jetson", "GPU", "accumulation", "Name", "Temperature", "Usage", "Power", "Count", "RAM", "GR3D_FREQ", "VDD_GPU_SOC", "return", "getJetsonParser", "temperature", "Last", "value", "memoryUsed", "memoryTotal", "usage", "Accumulated", "power", "count", "avgUsage", "avgPower", "NVIDIA", "will", "create", "the", "data", "entries", "GeForce", "RTX", "parseNvidiaData", "AMD", "card0", "GUID", "Sensor", "edge", "Current", "Socket", "Graphics", "Package", "use", "VRAM", "Total", "Memory", "Used", "Card", "Series", "Radeon", "parseAmdData", "for", "range", "Run", "testing", "Create", "new", "each", "test", "GpuDataMap", "Get", "function", "Process", "sample", "valid", "assert", "True", "Sample", "should", "Check", "accumulated", "values", "expected", "gpu", "exists", "with", "exist", "continue", "InDelta", "match", "MemoryUsed", "used", "MemoryTotal", "total", "Equal", "Verify", "average", "calculation", "GetCurrentData", "result", "Average", "that", "accumulators", "original", "are", "reset", "still", "after", "float64"], "doc_head": "\ttests := []struct {\n\t\tname           string\n\t\tinitialGPUData map[string]*system.GPUData\n\t\tdataSamples    [][]byte\n\t\tparser         func(*GPUManager) func([]byte) bool\n\t\texpectedValues map[string]expectedGPUValues\n\t}{\n\t\t{\n\t\t\tname: \"Jetson GPU accumulation\",\n\t\t\tinitialGPUData: map[string]*system.GPUData{\n\t\t\t\t\"0\": {\n\t\t\t\t\tName:        \"Jetson\",\n\t\t\t\t\tTemperature: 0,\n\t\t\t\t\tUsage:       0,\n\t\t\t\t\tPower:       0,\n\t\t\t\t\tCount:       0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tdataSamples: [][]byte{\n\t\t\t\t[]byte(\"11-14-2024 22:54:33 RAM 1024/4096MB GR3D_FREQ 30% tj@50.5C VDD_GPU_SOC 1000mW\"),\n\t\t\t\t[]byte(\"11-14-2024 22:54:33 RAM 1024/4096MB GR3D_FREQ 40% tj@60.5C VDD_GPU_SOC 1200mW\"),\n\t\t\t\t[]byte(\"11-14-2024 22:54:33 RAM 1024/4096MB GR3D_FREQ 50% tj@70.5C VDD_GPU_SOC 1400mW\"),\n\t\t\t},\n\t\t\tparser: func(gm *GPUManager) func([]byte) bool {\n\t\t\t\treturn gm.getJetsonParser()\n\t\t\t},\n\t\t\texpectedValues: map[string]expectedGPUValues{\n\t\t\t\t\"0\": {\n\t\t\t\t\ttemperature: 70.5,  // Last value\n\t\t\t\t\tmemoryUsed:  1024,  // Last value\n\t\t\t\t\tmemoryTotal: 4096,  // Last value\n\t\t\t\t\tusage:       120.0, // Accumulated: 30 + 40 + 50\n\t\t\t\t\tpower:       3.6,   // Accumulated: 1.0 + 1.2 + 1.4\n\t\t\t\t\tcount:       3,\n\t\t\t\t\tavgUsage:    40.0, // 120 / 3\n\t\t\t\t\tavgPower:"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 26, "text": "package agent\n\nimport (\n\t\"context\"\n\t\"crypto/ed25519\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/entities/container\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/blang/semver\"\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/gliderlabs/ssh\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n", "n_tokens": 130, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 26], "def_symbols": [], "symbols": ["package", "agent", "import", "context", "crypto", "ed25519", "encoding", "json", "fmt", "net", "path", "filepath", "strings", "sync", "testing", "time", "github", "com", "henrygd", "beszel", "src", "entities", "container", "system", "blang", "semver", "fxamacker", "cbor", "gliderlabs", "ssh", "stretchr", "testify", "assert", "require", "gossh", "golang", "org"], "doc_head": "package agent\nimport (\n\t\"context\"\n\t\"crypto/ed25519\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/entities/container\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/blang/semver\"\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/gliderlabs/ssh\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 27, "end_line": 45, "text": "func TestStartServer(t *testing.T) {\n\t// Generate a test key pair\n\tpubKey, privKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tsigner, err := gossh.NewSignerFromKey(privKey)\n\trequire.NoError(t, err)\n\tsshPubKey, err := gossh.NewPublicKey(pubKey)\n\trequire.NoError(t, err)\n\n\t// Generate a different key pair for bad key test\n\tbadPubKey, badPrivKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tbadSigner, err := gossh.NewSignerFromKey(badPrivKey)\n\trequire.NoError(t, err)\n\tsshBadPubKey, err := gossh.NewPublicKey(badPubKey)\n\trequire.NoError(t, err)\n\n\tsocketFile := filepath.Join(t.TempDir(), \"beszel-test.sock\")\n", "n_tokens": 183, "primary_symbol": "TestStartServer", "primary_kind": "function", "primary_span": [27, 45], "def_symbols": ["TestStartServer"], "symbols": ["TestStartServer", "func", "testing", "Generate", "test", "key", "pair", "pubKey", "privKey", "err", "ed25519", "GenerateKey", "nil", "require", "NoError", "signer", "gossh", "NewSignerFromKey", "sshPubKey", "NewPublicKey", "different", "for", "bad", "badPubKey", "badPrivKey", "badSigner", "sshBadPubKey", "socketFile", "filepath", "Join", "TempDir", "beszel", "sock"], "doc_head": "func TestStartServer(t *testing.T) {\n\t// Generate a test key pair\n\tpubKey, privKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tsigner, err := gossh.NewSignerFromKey(privKey)\n\trequire.NoError(t, err)\n\tsshPubKey, err := gossh.NewPublicKey(pubKey)\n\trequire.NoError(t, err)\n\t// Generate a different key pair for bad key test\n\tbadPubKey, badPrivKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tbadSigner, err := gossh.NewSignerFromKey(badPrivKey)\n\trequire.NoError(t, err)\n\tsshBadPubKey, err := gossh.NewPublicKey(badPubKey)\n\trequire.NoError(t, err)\n\tsocketFile := filepath.Join(t.TempDir(), \"beszel-test.sock\")"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 46, "end_line": 186, "text": "\ttests := []struct {\n\t\tname        string\n\t\tconfig      ServerOptions\n\t\twantErr     bool\n\t\terrContains string\n\t\tsetup       func() error\n\t\tcleanup     func() error\n\t}{\n\t\t{\n\t\t\tname: \"tcp port only\",\n\t\t\tconfig: ServerOptions{\n\t\t\t\tNetwork: \"tcp\",\n\t\t\t\tAddr:    \":45987\",\n\t\t\t\tKeys:    []gossh.PublicKey{sshPubKey},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"tcp with ipv4\",\n\t\t\tconfig: ServerOptions{\n\t\t\t\tNetwork: \"tcp4\",\n\t\t\t\tAddr:    \"127.0.0.1:45988\",\n\t\t\t\tKeys:    []gossh.PublicKey{sshPubKey},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"tcp with ipv6\",\n\t\t\tconfig: ServerOptions{\n\t\t\t\tNetwork: \"tcp6\",\n\t\t\t\tAddr:    \"[::1]:45989\",\n\t\t\t\tKeys:    []gossh.PublicKey{sshPubKey},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unix socket\",\n\t\t\tconfig: ServerOptions{\n\t\t\t\tNetwork: \"unix\",\n\t\t\t\tAddr:    socketFile,\n\t\t\t\tKeys:    []gossh.PublicKey{sshPubKey},\n\t\t\t},\n\t\t\tsetup: func() error {\n\t\t\t\t// Create a socket file that should be removed\n\t\t\t\tf, err := os.Create(socketFile)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn f.Close()\n\t\t\t},\n\t\t\tcleanup: func() error {\n\t\t\t\treturn os.Remove(socketFile)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"bad key should fail\",\n\t\t\tconfig: ServerOptions{\n\t\t\t\tNetwork: \"tcp\",\n\t\t\t\tAddr:    \":45987\",\n\t\t\t\tKeys:    []gossh.PublicKey{sshBadPubKey},\n\t\t\t},\n\t\t\twantErr:     true,\n\t\t\terrContains: \"ssh: handshake failed\",\n\t\t},\n\t\t{\n\t\t\tname: \"good key still good\",\n\t\t\tconfig: ServerOptions{\n\t\t\t\tNetwork: \"tcp\",\n\t\t\t\tAddr:    \":45987\",\n\t\t\t\tKeys:    []gossh.PublicKey{sshPubKey},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.setup != nil {\n\t\t\t\terr := tt.setup()\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\n\t\t\tif tt.cleanup != nil {\n\t\t\t\tdefer tt.cleanup()\n\t\t\t}\n\n\t\t\tagent, err := NewAgent(\"\")\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Start server in a goroutine since it blocks\n\t\t\terrChan := make(chan error, 1)\n\t\t\tgo func() {\n\t\t\t\terrChan <- agent.StartServer(tt.config)\n\t\t\t}()\n\n\t\t\t// Add a short delay to allow the server to start\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\t\t// Try to connect to verify server is running\n\t\t\tvar client *gossh.Client\n\n\t\t\t// Choose the appropriate signer based on the test case\n\t\t\ttestSigner := signer\n\t\t\tif tt.name == \"bad key should fail\" {\n\t\t\t\ttestSigner = badSigner\n\t\t\t}\n\n\t\t\tsshClientConfig := &gossh.ClientConfig{\n\t\t\t\tUser: \"a\",\n\t\t\t\tAuth: []gossh.AuthMethod{\n\t\t\t\t\tgossh.PublicKeys(testSigner),\n\t\t\t\t},\n\t\t\t\tHostKeyCallback: gossh.InsecureIgnoreHostKey(),\n\t\t\t\tTimeout:         4 * time.Second,\n\t\t\t}\n\n\t\t\tswitch tt.config.Network {\n\t\t\tcase \"unix\":\n\t\t\t\tclient, err = gossh.Dial(\"unix\", tt.config.Addr, sshClientConfig)\n\t\t\tdefault:\n\t\t\t\tif !strings.Contains(tt.config.Addr, \":\") {\n\t\t\t\t\ttt.config.Addr = \":\" + tt.config.Addr\n\t\t\t\t}\n\t\t\t\tclient, err = gossh.Dial(\"tcp\", tt.config.Addr, sshClientConfig)\n\t\t\t}\n\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tif tt.errContains != \"\" {\n\t\t\t\t\tassert.Contains(t, err.Error(), tt.errContains)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, client)\n\t\t\tclient.Close()\n\t\t})\n\t}\n}\n\n/////////////////////////////////////////////////////////////////\n//////////////////// ParseKeys Tests ////////////////////////////\n/////////////////////////////////////////////////////////////////\n", "n_tokens": 906, "primary_symbol": "", "primary_kind": "", "primary_span": [46, 186], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "config", "ServerOptions", "wantErr", "bool", "errContains", "setup", "func", "error", "cleanup", "tcp", "port", "only", "Network", "Addr", "Keys", "gossh", "PublicKey", "sshPubKey", "with", "ipv4", "tcp4", "ipv6", "tcp6", "unix", "socket", "socketFile", "Create", "file", "that", "should", "removed", "err", "nil", "return", "Close", "Remove", "bad", "key", "fail", "sshBadPubKey", "true", "ssh", "handshake", "failed", "good", "still", "for", "range", "Run", "testing", "require", "NoError", "defer", "agent", "NewAgent", "Start", "server", "goroutine", "since", "blocks", "errChan", "make", "chan", "StartServer", "Add", "short", "delay", "allow", "the", "start", "time", "Sleep", "Millisecond", "Try", "connect", "verify", "running", "var", "client", "Client", "Choose", "appropriate", "signer", "based", "test", "case", "testSigner", "badSigner", "sshClientConfig", "ClientConfig", "User", "Auth", "AuthMethod", "PublicKeys", "HostKeyCallback", "InsecureIgnoreHostKey", "Timeout", "Second", "switch", "Dial", "default", "strings", "Contains", "assert", "Error", "NotNil", "ParseKeys", "Tests"], "doc_head": "\ttests := []struct {\n\t\tname        string\n\t\tconfig      ServerOptions\n\t\twantErr     bool\n\t\terrContains string\n\t\tsetup       func() error\n\t\tcleanup     func() error\n\t}{\n\t\t{\n\t\t\tname: \"tcp port only\",\n\t\t\tconfig: ServerOptions{\n\t\t\t\tNetwork: \"tcp\",\n\t\t\t\tAddr:    \":45987\",\n\t\t\t\tKeys:    []gossh.PublicKey{sshPubKey},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"tcp with ipv4\",\n\t\t\tconfig: ServerOptions{\n\t\t\t\tNetwork: \"tcp4\",\n\t\t\t\tAddr:    \"127.0.0.1:45988\",\n\t\t\t\tKeys:    []gossh.PublicKey{sshPubKey},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"tcp with ipv6\",\n\t\t\tconfig: ServerOptions{\n\t\t\t\tNetwork: \"tcp6\",\n\t\t\t\tAddr:    \"[::1]:45989\",\n\t\t\t\tKeys:    []gossh.PublicKey{sshPubKey},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unix socket\",\n\t\t\tconfig: ServerOptions{\n\t\t\t\tNetwork: \"unix\",\n\t\t\t\tAddr:    socketFile,\n\t\t\t\tKeys:    []gossh.PublicKey{sshPubKey},\n\t\t\t},\n\t\t\tsetup: func() error {\n\t\t\t\t// Create a socket file that should be removed\n\t\t\t\tf, err := os.Create(socketFile)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn f.Close()\n\t\t\t},\n\t\t\tcleanup: func() error {\n\t\t\t\treturn os.Remove(socketFile)\n\t\t\t},"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 187, "end_line": 201, "text": "// Helper function to generate a temporary file with content\nfunc createTempFile(content string) (string, error) {\n\ttmpFile, err := os.CreateTemp(\"\", \"ssh_keys_*.txt\")\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to create temp file: %w\", err)\n\t}\n\tdefer tmpFile.Close()\n\n\tif _, err := tmpFile.WriteString(content); err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to write to temp file: %w\", err)\n\t}\n\n\treturn tmpFile.Name(), nil\n}\n", "n_tokens": 110, "primary_symbol": "createTempFile", "primary_kind": "function", "primary_span": [188, 201], "def_symbols": ["createTempFile"], "symbols": ["createTempFile", "Helper", "function", "generate", "temporary", "file", "with", "content", "func", "string", "error", "tmpFile", "err", "CreateTemp", "ssh_keys_", "txt", "nil", "return", "fmt", "Errorf", "failed", "create", "temp", "defer", "Close", "WriteString", "write", "Name"], "doc_head": "// Helper function to generate a temporary file with content\nfunc createTempFile(content string) (string, error) {\n\ttmpFile, err := os.CreateTemp(\"\", \"ssh_keys_*.txt\")\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to create temp file: %w\", err)\n\t}\n\tdefer tmpFile.Close()\n\tif _, err := tmpFile.WriteString(content); err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to write to temp file: %w\", err)\n\t}\n\treturn tmpFile.Name(), nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 202, "end_line": 216, "text": "// Test case 1: String with a single SSH key\nfunc TestParseSingleKeyFromString(t *testing.T) {\n\tinput := \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo\"\n\tkeys, err := ParseKeys(input)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t}\n\tif len(keys) != 1 {\n\t\tt.Fatalf(\"Expected 1 key, got %d keys\", len(keys))\n\t}\n\tif keys[0].Type() != \"ssh-ed25519\" {\n\t\tt.Fatalf(\"Expected key type 'ssh-ed25519', got '%s'\", keys[0].Type())\n\t}\n}\n", "n_tokens": 175, "primary_symbol": "TestParseSingleKeyFromString", "primary_kind": "function", "primary_span": [203, 216], "def_symbols": ["TestParseSingleKeyFromString"], "symbols": ["TestParseSingleKeyFromString", "Test", "case", "String", "with", "single", "SSH", "key", "func", "testing", "input", "ssh", "ed25519", "AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo", "keys", "err", "ParseKeys", "nil", "Fatalf", "Expected", "error", "got", "len", "Type", "type"], "doc_head": "// Test case 1: String with a single SSH key\nfunc TestParseSingleKeyFromString(t *testing.T) {\n\tinput := \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo\"\n\tkeys, err := ParseKeys(input)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t}\n\tif len(keys) != 1 {\n\t\tt.Fatalf(\"Expected 1 key, got %d keys\", len(keys))\n\t}\n\tif keys[0].Type() != \"ssh-ed25519\" {\n\t\tt.Fatalf(\"Expected key type 'ssh-ed25519', got '%s'\", keys[0].Type())\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 217, "end_line": 231, "text": "// Test case 2: String with multiple SSH keys\nfunc TestParseMultipleKeysFromString(t *testing.T) {\n\tinput := \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo\\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJDMtAOQfxDlCxe+A5lVbUY/DHxK1LAF2Z3AV0FYv36D \\n #comment\\n ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJDMtAOQfxDlCxe+A5lVbUY/DHxK1LAF2Z3AV0FYv36D\"\n\tkeys, err := ParseKeys(input)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t}\n\tif len(keys) != 3 {\n\t\tt.Fatalf(\"Expected 3 keys, got %d keys\", len(keys))\n\t}\n\tif keys[0].Type() != \"ssh-ed25519\" || keys[1].Type() != \"ssh-ed25519\" || keys[2].Type() != \"ssh-ed25519\" {\n\t\tt.Fatalf(\"Unexpected key types: %s, %s, %s\", keys[0].Type(), keys[1].Type(), keys[2].Type())\n\t}\n}\n", "n_tokens": 322, "primary_symbol": "TestParseMultipleKeysFromString", "primary_kind": "function", "primary_span": [218, 231], "def_symbols": ["TestParseMultipleKeysFromString"], "symbols": ["TestParseMultipleKeysFromString", "Test", "case", "String", "with", "multiple", "SSH", "keys", "func", "testing", "input", "ssh", "ed25519", "AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo", "nssh", "AAAAC3NzaC1lZDI1NTE5AAAAIJDMtAOQfxDlCxe", "A5lVbUY", "DHxK1LAF2Z3AV0FYv36D", "comment", "err", "ParseKeys", "nil", "Fatalf", "Expected", "error", "got", "len", "Type", "Unexpected", "key", "types"], "doc_head": "// Test case 2: String with multiple SSH keys\nfunc TestParseMultipleKeysFromString(t *testing.T) {\n\tinput := \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo\\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJDMtAOQfxDlCxe+A5lVbUY/DHxK1LAF2Z3AV0FYv36D \\n #comment\\n ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJDMtAOQfxDlCxe+A5lVbUY/DHxK1LAF2Z3AV0FYv36D\"\n\tkeys, err := ParseKeys(input)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t}\n\tif len(keys) != 3 {\n\t\tt.Fatalf(\"Expected 3 keys, got %d keys\", len(keys))\n\t}\n\tif keys[0].Type() != \"ssh-ed25519\" || keys[1].Type() != \"ssh-ed25519\" || keys[2].Type() != \"ssh-ed25519\" {\n\t\tt.Fatalf(\"Unexpected key types: %s, %s, %s\", keys[0].Type(), keys[1].Type(), keys[2].Type())\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 232, "end_line": 259, "text": "// Test case 3: File with a single SSH key\nfunc TestParseSingleKeyFromFile(t *testing.T) {\n\tcontent := \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo\"\n\tfilePath, err := createTempFile(content)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temp file: %v\", err)\n\t}\n\tdefer os.Remove(filePath) // Clean up the file after the test\n\n\t// Read the file content\n\tfileContent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to read temp file: %v\", err)\n\t}\n\n\t// Parse the keys\n\tkeys, err := ParseKeys(string(fileContent))\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t}\n\tif len(keys) != 1 {\n\t\tt.Fatalf(\"Expected 1 key, got %d keys\", len(keys))\n\t}\n\tif keys[0].Type() != \"ssh-ed25519\" {\n\t\tt.Fatalf(\"Expected key type 'ssh-ed25519', got '%s'\", keys[0].Type())\n\t}\n}\n", "n_tokens": 267, "primary_symbol": "TestParseSingleKeyFromFile", "primary_kind": "function", "primary_span": [233, 259], "def_symbols": ["TestParseSingleKeyFromFile"], "symbols": ["TestParseSingleKeyFromFile", "Test", "case", "File", "with", "single", "SSH", "key", "func", "testing", "content", "ssh", "ed25519", "AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo", "filePath", "err", "createTempFile", "nil", "Fatalf", "Failed", "create", "temp", "file", "defer", "Remove", "Clean", "the", "after", "test", "Read", "fileContent", "ReadFile", "read", "Parse", "keys", "ParseKeys", "string", "Expected", "error", "got", "len", "Type", "type"], "doc_head": "// Test case 3: File with a single SSH key\nfunc TestParseSingleKeyFromFile(t *testing.T) {\n\tcontent := \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo\"\n\tfilePath, err := createTempFile(content)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temp file: %v\", err)\n\t}\n\tdefer os.Remove(filePath) // Clean up the file after the test\n\t// Read the file content\n\tfileContent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to read temp file: %v\", err)\n\t}\n\t// Parse the keys\n\tkeys, err := ParseKeys(string(fileContent))\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t}\n\tif len(keys) != 1 {\n\t\tt.Fatalf(\"Expected 1 key, got %d keys\", len(keys))\n\t}\n\tif keys[0].Type() != \"ssh-ed25519\" {\n\t\tt.Fatalf(\"Expected key type 'ssh-ed25519', got '%s'\", keys[0].Type())\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 260, "end_line": 287, "text": "// Test case 4: File with multiple SSH keys\nfunc TestParseMultipleKeysFromFile(t *testing.T) {\n\tcontent := \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo\\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJDMtAOQfxDlCxe+A5lVbUY/DHxK1LAF2Z3AV0FYv36D \\n #comment\\n ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJDMtAOQfxDlCxe+A5lVbUY/DHxK1LAF2Z3AV0FYv36D\"\n\tfilePath, err := createTempFile(content)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temp file: %v\", err)\n\t}\n\t// defer os.Remove(filePath) // Clean up the file after the test\n\n\t// Read the file content\n\tfileContent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to read temp file: %v\", err)\n\t}\n\n\t// Parse the keys\n\tkeys, err := ParseKeys(string(fileContent))\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t}\n\tif len(keys) != 3 {\n\t\tt.Fatalf(\"Expected 3 keys, got %d keys\", len(keys))\n\t}\n\tif keys[0].Type() != \"ssh-ed25519\" || keys[1].Type() != \"ssh-ed25519\" || keys[2].Type() != \"ssh-ed25519\" {\n\t\tt.Fatalf(\"Unexpected key types: %s, %s, %s\", keys[0].Type(), keys[1].Type(), keys[2].Type())\n\t}\n}\n", "n_tokens": 416, "primary_symbol": "TestParseMultipleKeysFromFile", "primary_kind": "function", "primary_span": [261, 287], "def_symbols": ["TestParseMultipleKeysFromFile"], "symbols": ["TestParseMultipleKeysFromFile", "Test", "case", "File", "with", "multiple", "SSH", "keys", "func", "testing", "content", "ssh", "ed25519", "AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo", "nssh", "AAAAC3NzaC1lZDI1NTE5AAAAIJDMtAOQfxDlCxe", "A5lVbUY", "DHxK1LAF2Z3AV0FYv36D", "comment", "filePath", "err", "createTempFile", "nil", "Fatalf", "Failed", "create", "temp", "file", "defer", "Remove", "Clean", "the", "after", "test", "Read", "fileContent", "ReadFile", "read", "Parse", "ParseKeys", "string", "Expected", "error", "got", "len", "Type", "Unexpected", "key", "types"], "doc_head": "// Test case 4: File with multiple SSH keys\nfunc TestParseMultipleKeysFromFile(t *testing.T) {\n\tcontent := \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKCBM91kukN7hbvFKtbpEeo2JXjCcNxXcdBH7V7ADMBo\\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJDMtAOQfxDlCxe+A5lVbUY/DHxK1LAF2Z3AV0FYv36D \\n #comment\\n ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJDMtAOQfxDlCxe+A5lVbUY/DHxK1LAF2Z3AV0FYv36D\"\n\tfilePath, err := createTempFile(content)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temp file: %v\", err)\n\t}\n\t// defer os.Remove(filePath) // Clean up the file after the test\n\t// Read the file content\n\tfileContent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to read temp file: %v\", err)\n\t}\n\t// Parse the keys\n\tkeys, err := ParseKeys(string(fileContent))\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t}\n\tif len(keys) != 3 {\n\t\tt.Fatalf(\"Expected 3 keys, got %d keys\", len(keys))\n\t}\n\tif keys[0].Type() != \"ssh-ed25519\" || keys[1].Type() != \"ssh-ed25519\" || keys[2].Type() != \"ssh-ed25519\" {\n\t\tt.Fatalf(\"Unexpected key types: %s, %s, %s\", keys[0].Type(), keys[1].Type(), keys[2].Type())\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 288, "end_line": 305, "text": "// Test case 5: Invalid SSH key input\nfunc TestParseInvalidKey(t *testing.T) {\n\tinput := \"invalid-key-data\"\n\t_, err := ParseKeys(input)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected an error for invalid key, got nil\")\n\t}\n\texpectedErrMsg := \"failed to parse key\"\n\tif !strings.Contains(err.Error(), expectedErrMsg) {\n\t\tt.Fatalf(\"Expected error message to contain '%s', got: %v\", expectedErrMsg, err)\n\t}\n}\n\n/////////////////////////////////////////////////////////////////\n//////////////////// Hub Version Tests //////////////////////////\n/////////////////////////////////////////////////////////////////\n\nfunc TestExtractHubVersion(t *testing.T) {", "n_tokens": 126, "primary_symbol": "TestParseInvalidKey", "primary_kind": "function", "primary_span": [289, 305], "def_symbols": ["TestParseInvalidKey", "TestExtractHubVersion"], "symbols": ["TestParseInvalidKey", "TestExtractHubVersion", "Test", "case", "Invalid", "SSH", "key", "input", "func", "testing", "invalid", "data", "err", "ParseKeys", "nil", "Fatalf", "Expected", "error", "for", "got", "expectedErrMsg", "failed", "parse", "strings", "Contains", "Error", "message", "contain", "Hub", "Version", "Tests"], "doc_head": "// Test case 5: Invalid SSH key input\nfunc TestParseInvalidKey(t *testing.T) {\n\tinput := \"invalid-key-data\"\n\t_, err := ParseKeys(input)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected an error for invalid key, got nil\")\n\t}\n\texpectedErrMsg := \"failed to parse key\"\n\tif !strings.Contains(err.Error(), expectedErrMsg) {\n\t\tt.Fatalf(\"Expected error message to contain '%s', got: %v\", expectedErrMsg, err)\n\t}\n}\n/////////////////////////////////////////////////////////////////\n//////////////////// Hub Version Tests //////////////////////////\n/////////////////////////////////////////////////////////////////\nfunc TestExtractHubVersion(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 306, "end_line": 378, "text": "\ttests := []struct {\n\t\tname            string\n\t\tclientVersion   string\n\t\texpectedVersion string\n\t\texpectError     bool\n\t}{\n\t\t{\n\t\t\tname:            \"valid beszel client version with underscore\",\n\t\t\tclientVersion:   \"SSH-2.0-beszel_0.11.1\",\n\t\t\texpectedVersion: \"0.11.1\",\n\t\t\texpectError:     false,\n\t\t},\n\t\t{\n\t\t\tname:            \"valid beszel client version with beta\",\n\t\t\tclientVersion:   \"SSH-2.0-beszel_1.0.0-beta\",\n\t\t\texpectedVersion: \"1.0.0-beta\",\n\t\t\texpectError:     false,\n\t\t},\n\t\t{\n\t\t\tname:            \"valid beszel client version with rc\",\n\t\t\tclientVersion:   \"SSH-2.0-beszel_0.12.0-rc1\",\n\t\t\texpectedVersion: \"0.12.0-rc1\",\n\t\t\texpectError:     false,\n\t\t},\n\t\t{\n\t\t\tname:            \"different SSH client\",\n\t\t\tclientVersion:   \"SSH-2.0-OpenSSH_8.0\",\n\t\t\texpectedVersion: \"8.0\",\n\t\t\texpectError:     true,\n\t\t},\n\t\t{\n\t\t\tname:          \"malformed version string without underscore\",\n\t\t\tclientVersion: \"SSH-2.0-beszel\",\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\tname:          \"empty version string\",\n\t\t\tclientVersion: \"\",\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\tname:            \"version string with underscore but no version\",\n\t\t\tclientVersion:   \"beszel_\",\n\t\t\texpectedVersion: \"\",\n\t\t\texpectError:     true,\n\t\t},\n\t\t{\n\t\t\tname:            \"version with patch and build metadata\",\n\t\t\tclientVersion:   \"SSH-2.0-beszel_1.2.3+build.123\",\n\t\t\texpectedVersion: \"1.2.3+build.123\",\n\t\t\texpectError:     false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := extractHubVersion(tt.clientVersion)\n\n\t\t\tif tt.expectError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, tt.expectedVersion, result.String())\n\t\t})\n\t}\n}\n\n/////////////////////////////////////////////////////////////////\n/////////////// Hub Version Detection Tests ////////////////////\n/////////////////////////////////////////////////////////////////\n", "n_tokens": 523, "primary_symbol": "", "primary_kind": "", "primary_span": [306, 378], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "clientVersion", "expectedVersion", "expectError", "bool", "valid", "beszel", "client", "version", "with", "underscore", "SSH", "beszel_0", "false", "beta", "beszel_1", "rc1", "different", "OpenSSH_8", "true", "malformed", "without", "empty", "but", "beszel_", "patch", "and", "build", "metadata", "for", "range", "Run", "func", "testing", "result", "err", "extractHubVersion", "assert", "Error", "return", "require", "NoError", "Equal", "String", "Hub", "Version", "Detection", "Tests"], "doc_head": "\ttests := []struct {\n\t\tname            string\n\t\tclientVersion   string\n\t\texpectedVersion string\n\t\texpectError     bool\n\t}{\n\t\t{\n\t\t\tname:            \"valid beszel client version with underscore\",\n\t\t\tclientVersion:   \"SSH-2.0-beszel_0.11.1\",\n\t\t\texpectedVersion: \"0.11.1\",\n\t\t\texpectError:     false,\n\t\t},\n\t\t{\n\t\t\tname:            \"valid beszel client version with beta\",\n\t\t\tclientVersion:   \"SSH-2.0-beszel_1.0.0-beta\",\n\t\t\texpectedVersion: \"1.0.0-beta\",\n\t\t\texpectError:     false,\n\t\t},\n\t\t{\n\t\t\tname:            \"valid beszel client version with rc\",\n\t\t\tclientVersion:   \"SSH-2.0-beszel_0.12.0-rc1\",\n\t\t\texpectedVersion: \"0.12.0-rc1\",\n\t\t\texpectError:     false,\n\t\t},\n\t\t{\n\t\t\tname:            \"different SSH client\",\n\t\t\tclientVersion:   \"SSH-2.0-OpenSSH_8.0\",\n\t\t\texpectedVersion: \"8.0\",\n\t\t\texpectError:     true,\n\t\t},\n\t\t{\n\t\t\tname:          \"malformed version string without underscore\",\n\t\t\tclientVersion: \"SSH-2.0-beszel\",\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\tname:          \"empty version string\",\n\t\t\tclientVersion: \"\",\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\tname:            \"version string with underscore but no version\",\n\t\t\tclientVersion:   \"beszel_\",\n\t\t\texpectedVersion: \"\",\n\t\t\texpectError:     true,\n\t\t},\n\t\t"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 379, "end_line": 412, "text": "func TestGetHubVersion(t *testing.T) {\n\tagent, err := NewAgent(\"\")\n\trequire.NoError(t, err)\n\n\t// Mock SSH context that implements the ssh.Context interface\n\tmockCtx := &mockSSHContext{\n\t\tsessionID:     \"test-session-123\",\n\t\tclientVersion: \"SSH-2.0-beszel_0.12.0\",\n\t}\n\n\t// Test first call - should extract and cache version\n\tversion := agent.getHubVersion(\"test-session-123\", mockCtx)\n\tassert.Equal(t, \"0.12.0\", version.String())\n\n\t// Test second call - should return cached version\n\tmockCtx.clientVersion = \"SSH-2.0-beszel_0.11.0\" // Change version but should still return cached\n\tversion = agent.getHubVersion(\"test-session-123\", mockCtx)\n\tassert.Equal(t, \"0.12.0\", version.String()) // Should still be cached version\n\n\t// Test different session - should extract new version\n\tversion = agent.getHubVersion(\"different-session\", mockCtx)\n\tassert.Equal(t, \"0.11.0\", version.String())\n\n\t// Test with invalid version string (non-beszel client)\n\tmockCtx.clientVersion = \"SSH-2.0-OpenSSH_8.0\"\n\tversion = agent.getHubVersion(\"invalid-session\", mockCtx)\n\tassert.Equal(t, \"0.0.0\", version.String()) // Should be empty version for non-beszel clients\n\n\t// Test with no client version\n\tmockCtx.clientVersion = \"\"\n\tversion = agent.getHubVersion(\"no-version-session\", mockCtx)\n\tassert.True(t, version.EQ(semver.Version{})) // Should be empty version\n}\n", "n_tokens": 353, "primary_symbol": "TestGetHubVersion", "primary_kind": "function", "primary_span": [379, 412], "def_symbols": ["TestGetHubVersion"], "symbols": ["TestGetHubVersion", "func", "testing", "agent", "err", "NewAgent", "require", "NoError", "Mock", "SSH", "context", "that", "implements", "the", "ssh", "Context", "interface", "mockCtx", "mockSSHContext", "sessionID", "test", "session", "clientVersion", "beszel_0", "Test", "first", "call", "should", "extract", "and", "cache", "version", "getHubVersion", "assert", "Equal", "String", "second", "return", "cached", "Change", "but", "still", "Should", "different", "new", "with", "invalid", "string", "non", "beszel", "client", "OpenSSH_8", "empty", "for", "clients", "True", "semver", "Version"], "doc_head": "func TestGetHubVersion(t *testing.T) {\n\tagent, err := NewAgent(\"\")\n\trequire.NoError(t, err)\n\t// Mock SSH context that implements the ssh.Context interface\n\tmockCtx := &mockSSHContext{\n\t\tsessionID:     \"test-session-123\",\n\t\tclientVersion: \"SSH-2.0-beszel_0.12.0\",\n\t}\n\t// Test first call - should extract and cache version\n\tversion := agent.getHubVersion(\"test-session-123\", mockCtx)\n\tassert.Equal(t, \"0.12.0\", version.String())\n\t// Test second call - should return cached version\n\tmockCtx.clientVersion = \"SSH-2.0-beszel_0.11.0\" // Change version but should still return cached\n\tversion = agent.getHubVersion(\"test-session-123\", mockCtx)\n\tassert.Equal(t, \"0.12.0\", version.String()) // Should still be cached version\n\t// Test different session - should extract new version\n\tversion = agent.getHubVersion(\"different-session\", mockCtx)\n\tassert.Equal(t, \"0.11.0\", version.String())\n\t// Test with invalid version string (non-beszel client)\n\tmockCtx.clientVersion = \"SSH-2.0-OpenSSH_8.0\"\n\tversion = agent.getHubVersion(\"invalid-session\", mockCtx)\n\tassert.Equal(t, \"0.0.0\", version.String()) // Should be empty version for non-beszel clients\n\t// Test with no client version\n\tmockCtx.clientVersion = \"\"\n\tvers"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 413, "end_line": 443, "text": "// mockSSHContext implements ssh.Context for testing\ntype mockSSHContext struct {\n\tcontext.Context\n\tsync.Mutex\n\tsessionID     string\n\tclientVersion string\n}\n\nfunc (m *mockSSHContext) SessionID() string {\n\treturn m.sessionID\n}\n\nfunc (m *mockSSHContext) ClientVersion() string {\n\treturn m.clientVersion\n}\n\nfunc (m *mockSSHContext) ServerVersion() string {\n\treturn \"SSH-2.0-beszel_test\"\n}\n\nfunc (m *mockSSHContext) Value(key interface{}) interface{} {\n\tif key == ssh.ContextKeyClientVersion {\n\t\treturn m.clientVersion\n\t}\n\treturn nil\n}\n\nfunc (m *mockSSHContext) User() string                    { return \"test-user\" }\nfunc (m *mockSSHContext) RemoteAddr() net.Addr            { return nil }\nfunc (m *mockSSHContext) LocalAddr() net.Addr             { return nil }\nfunc (m *mockSSHContext) Permissions() *ssh.Permissions   { return nil }", "n_tokens": 207, "primary_symbol": "SessionID", "primary_kind": "function", "primary_span": [421, 443], "def_symbols": ["SessionID", "ClientVersion", "ServerVersion", "Value", "User", "RemoteAddr", "LocalAddr", "Permissions"], "symbols": ["SessionID", "ClientVersion", "ServerVersion", "Value", "User", "RemoteAddr", "LocalAddr", "Permissions", "mockSSHContext", "implements", "ssh", "Context", "for", "testing", "type", "struct", "context", "sync", "Mutex", "sessionID", "string", "clientVersion", "func", "return", "SSH", "beszel_test", "key", "interface", "ContextKeyClientVersion", "nil", "test", "user", "net", "Addr"], "doc_head": "// mockSSHContext implements ssh.Context for testing\ntype mockSSHContext struct {\n\tcontext.Context\n\tsync.Mutex\n\tsessionID     string\n\tclientVersion string\n}\nfunc (m *mockSSHContext) SessionID() string {\n\treturn m.sessionID\n}\nfunc (m *mockSSHContext) ClientVersion() string {\n\treturn m.clientVersion\n}\nfunc (m *mockSSHContext) ServerVersion() string {\n\treturn \"SSH-2.0-beszel_test\"\n}\nfunc (m *mockSSHContext) Value(key interface{}) interface{} {\n\tif key == ssh.ContextKeyClientVersion {\n\t\treturn m.clientVersion\n\t}\n\treturn nil\n}\nfunc (m *mockSSHContext) User() string                    { return \"test-user\" }\nfunc (m *mockSSHContext) RemoteAddr() net.Addr            { return nil }\nfunc (m *mockSSHContext) LocalAddr() net.Addr             { return nil }\nfunc (m *mockSSHContext) Permissions() *ssh.Permissions   { return nil }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 13, "start_line": 444, "end_line": 451, "text": "func (m *mockSSHContext) SetValue(key, value interface{}) {}\n\n/////////////////////////////////////////////////////////////////\n/////////////// CBOR vs JSON Encoding Tests ////////////////////\n/////////////////////////////////////////////////////////////////\n\n// TestWriteToSessionEncoding tests that writeToSession actually encodes data in the correct format\nfunc TestWriteToSessionEncoding(t *testing.T) {", "n_tokens": 60, "primary_symbol": "SetValue", "primary_kind": "function", "primary_span": [444, 451], "def_symbols": ["SetValue", "TestWriteToSessionEncoding"], "symbols": ["SetValue", "TestWriteToSessionEncoding", "func", "mockSSHContext", "key", "value", "interface", "CBOR", "JSON", "Encoding", "Tests", "tests", "that", "writeToSession", "actually", "encodes", "data", "the", "correct", "format", "testing"], "doc_head": "func (m *mockSSHContext) SetValue(key, value interface{}) {}\n/////////////////////////////////////////////////////////////////\n/////////////// CBOR vs JSON Encoding Tests ////////////////////\n/////////////////////////////////////////////////////////////////\n// TestWriteToSessionEncoding tests that writeToSession actually encodes data in the correct format\nfunc TestWriteToSessionEncoding(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 14, "start_line": 452, "end_line": 540, "text": "\ttests := []struct {\n\t\tname             string\n\t\thubVersion       string\n\t\texpectedUsesCbor bool\n\t}{\n\t\t{\n\t\t\tname:             \"old hub version should use JSON\",\n\t\t\thubVersion:       \"0.11.1\",\n\t\t\texpectedUsesCbor: false,\n\t\t},\n\t\t{\n\t\t\tname:             \"non-beta release should use CBOR\",\n\t\t\thubVersion:       \"0.12.0\",\n\t\t\texpectedUsesCbor: true,\n\t\t},\n\t\t{\n\t\t\tname:             \"even newer hub version should use CBOR\",\n\t\t\thubVersion:       \"0.16.4\",\n\t\t\texpectedUsesCbor: true,\n\t\t},\n\t\t{\n\t\t\tname:             \"beta version below release threshold should use JSON\",\n\t\t\thubVersion:       \"0.12.0-beta0\",\n\t\t\texpectedUsesCbor: false,\n\t\t},\n\t\t// {\n\t\t// \tname:             \"matching beta version should use CBOR\",\n\t\t// \thubVersion:       \"0.12.0-beta2\",\n\t\t// \texpectedUsesCbor: true,\n\t\t// },\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Reset the global hubVersions map to ensure clean state for each test\n\t\t\thubVersions = nil\n\n\t\t\tagent, err := NewAgent(\"\")\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Parse the test version\n\t\t\tversion, err := semver.Parse(tt.hubVersion)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Create test data to encode\n\t\t\ttestData := createTestCombinedData()\n\n\t\t\tvar buf strings.Builder\n\t\t\terr = agent.writeToSession(&buf, testData, version)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tencodedData := buf.String()\n\t\t\trequire.NotEmpty(t, encodedData)\n\n\t\t\t// Verify the encoding format by attempting to decode\n\t\t\tif tt.expectedUsesCbor {\n\t\t\t\tvar decodedCbor system.CombinedData\n\t\t\t\terr = cbor.Unmarshal([]byte(encodedData), &decodedCbor)\n\t\t\t\tassert.NoError(t, err, \"Should be valid CBOR data\")\n\n\t\t\t\tvar decodedJson system.CombinedData\n\t\t\t\terr = json.Unmarshal([]byte(encodedData), &decodedJson)\n\t\t\t\tassert.Error(t, err, \"Should not be valid JSON data\")\n\n\t\t\t\tassert.Equal(t, testData.Info.Hostname, decodedCbor.Info.Hostname)\n\t\t\t\tassert.Equal(t, testData.Stats.Cpu, decodedCbor.Stats.Cpu)\n\t\t\t} else {\n\t\t\t\t// Should be JSON - try to decode as JSON\n\t\t\t\tvar decodedJson system.CombinedData\n\t\t\t\terr = json.Unmarshal([]byte(encodedData), &decodedJson)\n\t\t\t\tassert.NoError(t, err, \"Should be valid JSON data\")\n\n\t\t\t\tvar decodedCbor system.CombinedData\n\t\t\t\terr = cbor.Unmarshal([]byte(encodedData), &decodedCbor)\n\t\t\t\tassert.Error(t, err, \"Should not be valid CBOR data\")\n\n\t\t\t\t// Verify the decoded JSON data matches our test data\n\t\t\t\tassert.Equal(t, testData.Info.Hostname, decodedJson.Info.Hostname)\n\t\t\t\tassert.Equal(t, testData.Stats.Cpu, decodedJson.Stats.Cpu)\n\n\t\t\t\t// Verify it looks like JSON (starts with '{' and contains readable field names)\n\t\t\t\tassert.True(t, strings.HasPrefix(encodedData, \"{\"), \"JSON should start with '{'\")\n\t\t\t\tassert.Contains(t, encodedData, `\"info\"`, \"JSON should contain readable field names\")\n\t\t\t\tassert.Contains(t, encodedData, `\"stats\"`, \"JSON should contain readable field names\")\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 764, "primary_symbol": "", "primary_kind": "", "primary_span": [452, 540], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "hubVersion", "expectedUsesCbor", "bool", "old", "hub", "version", "should", "use", "JSON", "false", "non", "beta", "release", "CBOR", "true", "even", "newer", "below", "threshold", "beta0", "matching", "beta2", "for", "range", "Run", "func", "testing", "Reset", "the", "global", "hubVersions", "map", "ensure", "clean", "state", "each", "test", "nil", "agent", "err", "NewAgent", "require", "NoError", "Parse", "semver", "Create", "data", "encode", "testData", "createTestCombinedData", "var", "buf", "strings", "Builder", "writeToSession", "encodedData", "String", "NotEmpty", "Verify", "encoding", "format", "attempting", "decode", "decodedCbor", "system", "CombinedData", "cbor", "Unmarshal", "byte", "assert", "Should", "valid", "decodedJson", "json", "Error", "not", "Equal", "Info", "Hostname", "Stats", "Cpu", "else", "try", "decoded", "matches", "our", "looks", "like", "starts", "with", "and", "contains", "readable", "field", "names", "True", "HasPrefix", "start", "Contains", "info", "contain", "stats"], "doc_head": "\ttests := []struct {\n\t\tname             string\n\t\thubVersion       string\n\t\texpectedUsesCbor bool\n\t}{\n\t\t{\n\t\t\tname:             \"old hub version should use JSON\",\n\t\t\thubVersion:       \"0.11.1\",\n\t\t\texpectedUsesCbor: false,\n\t\t},\n\t\t{\n\t\t\tname:             \"non-beta release should use CBOR\",\n\t\t\thubVersion:       \"0.12.0\",\n\t\t\texpectedUsesCbor: true,\n\t\t},\n\t\t{\n\t\t\tname:             \"even newer hub version should use CBOR\",\n\t\t\thubVersion:       \"0.16.4\",\n\t\t\texpectedUsesCbor: true,\n\t\t},\n\t\t{\n\t\t\tname:             \"beta version below release threshold should use JSON\",\n\t\t\thubVersion:       \"0.12.0-beta0\",\n\t\t\texpectedUsesCbor: false,\n\t\t},\n\t\t// {\n\t\t// \tname:             \"matching beta version should use CBOR\",\n\t\t// \thubVersion:       \"0.12.0-beta2\",\n\t\t// \texpectedUsesCbor: true,\n\t\t// },\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Reset the global hubVersions map to ensure clean state for each test\n\t\t\thubVersions = nil\n\t\t\tagent, err := NewAgent(\"\")\n\t\t\trequire.NoError(t, err)\n\t\t\t// Parse the test version\n\t\t\tversion, err := semver.Parse(tt.hubVersion)\n\t\t\trequire.NoError(t, err)\n\t\t\t// Create test data to encode\n\t\t\ttestData := createTestCombinedData()\n\t\t\tvar buf strings.Bui"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 15, "start_line": 541, "end_line": 570, "text": "// Helper function to create test data for encoding tests\nfunc createTestCombinedData() *system.CombinedData {\n\treturn &system.CombinedData{\n\t\tStats: system.Stats{\n\t\t\tCpu:       25.5,\n\t\t\tMem:       8589934592, // 8GB\n\t\t\tMemUsed:   4294967296, // 4GB\n\t\t\tMemPct:    50.0,\n\t\t\tDiskTotal: 1099511627776, // 1TB\n\t\t\tDiskUsed:  549755813888,  // 512GB\n\t\t\tDiskPct:   50.0,\n\t\t},\n\t\tInfo: system.Info{\n\t\t\tHostname:     \"test-host\",\n\t\t\tCores:        8,\n\t\t\tCpuModel:     \"Test CPU Model\",\n\t\t\tUptime:       3600,\n\t\t\tAgentVersion: \"0.12.0\",\n\t\t\tOs:           system.Linux,\n\t\t},\n\t\tContainers: []*container.Stats{\n\t\t\t{\n\t\t\t\tName: \"test-container\",\n\t\t\t\tCpu:  10.5,\n\t\t\t\tMem:  1073741824, // 1GB\n\t\t\t},\n\t\t},\n\t}\n}\n", "n_tokens": 267, "primary_symbol": "createTestCombinedData", "primary_kind": "function", "primary_span": [542, 570], "def_symbols": ["createTestCombinedData"], "symbols": ["createTestCombinedData", "Helper", "function", "create", "test", "data", "for", "encoding", "tests", "func", "system", "CombinedData", "return", "Stats", "Cpu", "Mem", "MemUsed", "MemPct", "DiskTotal", "DiskUsed", "DiskPct", "Info", "Hostname", "host", "Cores", "CpuModel", "Test", "CPU", "Model", "Uptime", "AgentVersion", "Linux", "Containers", "container", "Name"], "doc_head": "// Helper function to create test data for encoding tests\nfunc createTestCombinedData() *system.CombinedData {\n\treturn &system.CombinedData{\n\t\tStats: system.Stats{\n\t\t\tCpu:       25.5,\n\t\t\tMem:       8589934592, // 8GB\n\t\t\tMemUsed:   4294967296, // 4GB\n\t\t\tMemPct:    50.0,\n\t\t\tDiskTotal: 1099511627776, // 1TB\n\t\t\tDiskUsed:  549755813888,  // 512GB\n\t\t\tDiskPct:   50.0,\n\t\t},\n\t\tInfo: system.Info{\n\t\t\tHostname:     \"test-host\",\n\t\t\tCores:        8,\n\t\t\tCpuModel:     \"Test CPU Model\",\n\t\t\tUptime:       3600,\n\t\t\tAgentVersion: \"0.12.0\",\n\t\t\tOs:           system.Linux,\n\t\t},\n\t\tContainers: []*container.Stats{\n\t\t\t{\n\t\t\t\tName: \"test-container\",\n\t\t\t\tCpu:  10.5,\n\t\t\t\tMem:  1073741824, // 1GB\n\t\t\t},\n\t\t},\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go#16", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/server_test.go", "rel_path": "agent/server_test.go", "ext": "go", "language": "go", "chunk_number": 16, "start_line": 571, "end_line": 607, "text": "func TestHubVersionCaching(t *testing.T) {\n\t// Reset the global hubVersions map to ensure clean state\n\thubVersions = nil\n\n\tagent, err := NewAgent(\"\")\n\trequire.NoError(t, err)\n\n\tctx1 := &mockSSHContext{\n\t\tsessionID:     \"session1\",\n\t\tclientVersion: \"SSH-2.0-beszel_0.12.0\",\n\t}\n\tctx2 := &mockSSHContext{\n\t\tsessionID:     \"session2\",\n\t\tclientVersion: \"SSH-2.0-beszel_0.11.0\",\n\t}\n\n\t// First calls should cache the versions\n\tv1 := agent.getHubVersion(\"session1\", ctx1)\n\tv2 := agent.getHubVersion(\"session2\", ctx2)\n\n\tassert.Equal(t, \"0.12.0\", v1.String())\n\tassert.Equal(t, \"0.11.0\", v2.String())\n\n\t// Verify caching by changing context but keeping same session ID\n\tctx1.clientVersion = \"SSH-2.0-beszel_0.10.0\"\n\tv1Cached := agent.getHubVersion(\"session1\", ctx1)\n\tassert.Equal(t, \"0.12.0\", v1Cached.String()) // Should still be cached version\n\n\t// New session should get new version\n\tctx3 := &mockSSHContext{\n\t\tsessionID:     \"session3\",\n\t\tclientVersion: \"SSH-2.0-beszel_0.13.0\",\n\t}\n\tv3 := agent.getHubVersion(\"session3\", ctx3)\n\tassert.Equal(t, \"0.13.0\", v3.String())\n}\n", "n_tokens": 340, "primary_symbol": "TestHubVersionCaching", "primary_kind": "function", "primary_span": [571, 607], "def_symbols": ["TestHubVersionCaching"], "symbols": ["TestHubVersionCaching", "func", "testing", "Reset", "the", "global", "hubVersions", "map", "ensure", "clean", "state", "nil", "agent", "err", "NewAgent", "require", "NoError", "ctx1", "mockSSHContext", "sessionID", "session1", "clientVersion", "SSH", "beszel_0", "ctx2", "session2", "First", "calls", "should", "cache", "versions", "getHubVersion", "assert", "Equal", "String", "Verify", "caching", "changing", "context", "but", "keeping", "same", "session", "v1Cached", "Should", "still", "cached", "version", "New", "get", "new", "ctx3", "session3"], "doc_head": "func TestHubVersionCaching(t *testing.T) {\n\t// Reset the global hubVersions map to ensure clean state\n\thubVersions = nil\n\tagent, err := NewAgent(\"\")\n\trequire.NoError(t, err)\n\tctx1 := &mockSSHContext{\n\t\tsessionID:     \"session1\",\n\t\tclientVersion: \"SSH-2.0-beszel_0.12.0\",\n\t}\n\tctx2 := &mockSSHContext{\n\t\tsessionID:     \"session2\",\n\t\tclientVersion: \"SSH-2.0-beszel_0.11.0\",\n\t}\n\t// First calls should cache the versions\n\tv1 := agent.getHubVersion(\"session1\", ctx1)\n\tv2 := agent.getHubVersion(\"session2\", ctx2)\n\tassert.Equal(t, \"0.12.0\", v1.String())\n\tassert.Equal(t, \"0.11.0\", v2.String())\n\t// Verify caching by changing context but keeping same session ID\n\tctx1.clientVersion = \"SSH-2.0-beszel_0.10.0\"\n\tv1Cached := agent.getHubVersion(\"session1\", ctx1)\n\tassert.Equal(t, \"0.12.0\", v1Cached.String()) // Should still be cached version\n\t// New session should get new version\n\tctx3 := &mockSSHContext{\n\t\tsessionID:     \"session3\",\n\t\tclientVersion: \"SSH-2.0-beszel_0.13.0\",\n\t}\n\tv3 := agent.getHubVersion(\"session3\", ctx3)\n\tassert.Equal(t, \"0.13.0\", v3.String())\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_cache.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_cache.go", "rel_path": "agent/agent_cache.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 30, "text": "package agent\n\nimport (\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/entities/system\"\n)\n\n// Not thread safe since we only access from gatherStats which is already locked\ntype SessionCache struct {\n\tdata           *system.CombinedData\n\tlastUpdate     time.Time\n\tprimarySession string\n\tleaseTime      time.Duration\n}\n\nfunc NewSessionCache(leaseTime time.Duration) *SessionCache {\n\treturn &SessionCache{\n\t\tleaseTime: leaseTime,\n\t\tdata:      &system.CombinedData{},\n\t}\n}\n\nfunc (c *SessionCache) Get(sessionID string) (stats *system.CombinedData, isCached bool) {\n\tif sessionID != c.primarySession && time.Since(c.lastUpdate) < c.leaseTime {\n\t\treturn c.data, true\n\t}\n\treturn c.data, false\n}\n", "n_tokens": 175, "primary_symbol": "NewSessionCache", "primary_kind": "function", "primary_span": [17, 30], "def_symbols": ["NewSessionCache", "Get"], "symbols": ["NewSessionCache", "Get", "package", "agent", "import", "time", "github", "com", "henrygd", "beszel", "src", "entities", "system", "Not", "thread", "safe", "since", "only", "access", "from", "gatherStats", "which", "already", "locked", "type", "SessionCache", "struct", "data", "CombinedData", "lastUpdate", "Time", "primarySession", "string", "leaseTime", "Duration", "func", "return", "sessionID", "stats", "isCached", "bool", "Since", "true", "false"], "doc_head": "package agent\nimport (\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n)\n// Not thread safe since we only access from gatherStats which is already locked\ntype SessionCache struct {\n\tdata           *system.CombinedData\n\tlastUpdate     time.Time\n\tprimarySession string\n\tleaseTime      time.Duration\n}\nfunc NewSessionCache(leaseTime time.Duration) *SessionCache {\n\treturn &SessionCache{\n\t\tleaseTime: leaseTime,\n\t\tdata:      &system.CombinedData{},\n\t}\n}\nfunc (c *SessionCache) Get(sessionID string) (stats *system.CombinedData, isCached bool) {\n\tif sessionID != c.primarySession && time.Since(c.lastUpdate) < c.leaseTime {\n\t\treturn c.data, true\n\t}\n\treturn c.data, false\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_cache.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_cache.go", "rel_path": "agent/agent_cache.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 31, "end_line": 38, "text": "func (c *SessionCache) Set(sessionID string, data *system.CombinedData) {\n\tif data != nil {\n\t\t*c.data = *data\n\t}\n\tc.primarySession = sessionID\n\tc.lastUpdate = time.Now()\n}\n", "n_tokens": 51, "primary_symbol": "Set", "primary_kind": "function", "primary_span": [31, 38], "def_symbols": ["Set"], "symbols": ["Set", "func", "SessionCache", "sessionID", "string", "data", "system", "CombinedData", "nil", "primarySession", "lastUpdate", "time", "Now"], "doc_head": "func (c *SessionCache) Set(sessionID string, data *system.CombinedData) {\n\tif data != nil {\n\t\t*c.data = *data\n\t}\n\tc.primarySession = sessionID\n\tc.lastUpdate = time.Now()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 2, "text": "package agent\n", "n_tokens": 3, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 2], "def_symbols": [], "symbols": ["package", "agent"], "doc_head": "package agent"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 3, "end_line": 41, "text": "import (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"golang.org/x/exp/slog\"\n)\n\nconst (\n\t// Commands\n\tnvidiaSmiCmd  string = \"nvidia-smi\"\n\trocmSmiCmd    string = \"rocm-smi\"\n\ttegraStatsCmd string = \"tegrastats\"\n\n\t// Polling intervals\n\tnvidiaSmiInterval  string        = \"4\"    // in seconds\n\ttegraStatsInterval string        = \"3700\" // in milliseconds\n\trocmSmiInterval    time.Duration = 4300 * time.Millisecond\n\n\t// Command retry and timeout constants\n\tretryWaitTime     time.Duration = 5 * time.Second\n\tmaxFailureRetries int           = 5\n\n\tcmdBufferSize uint16 = 10 * 1024\n\n\t// Unit Conversions\n\tmebibytesInAMegabyte float64 = 1.024  // nvidia-smi reports memory in MiB\n\tmilliwattsInAWatt    float64 = 1000.0 // tegrastats reports power in mW\n)\n", "n_tokens": 270, "primary_symbol": "", "primary_kind": "", "primary_span": [3, 41], "def_symbols": [], "symbols": ["import", "bufio", "bytes", "encoding", "json", "fmt", "exec", "regexp", "strconv", "strings", "sync", "time", "github", "com", "henrygd", "beszel", "src", "entities", "system", "golang", "org", "exp", "slog", "const", "Commands", "nvidiaSmiCmd", "string", "nvidia", "smi", "rocmSmiCmd", "rocm", "tegraStatsCmd", "tegrastats", "Polling", "intervals", "nvidiaSmiInterval", "seconds", "tegraStatsInterval", "milliseconds", "rocmSmiInterval", "Duration", "Millisecond", "Command", "retry", "and", "timeout", "constants", "retryWaitTime", "Second", "maxFailureRetries", "int", "cmdBufferSize", "uint16", "Unit", "Conversions", "mebibytesInAMegabyte", "float64", "reports", "memory", "MiB", "milliwattsInAWatt", "power"], "doc_head": "import (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"golang.org/x/exp/slog\"\n)\nconst (\n\t// Commands\n\tnvidiaSmiCmd  string = \"nvidia-smi\"\n\trocmSmiCmd    string = \"rocm-smi\"\n\ttegraStatsCmd string = \"tegrastats\"\n\t// Polling intervals\n\tnvidiaSmiInterval  string        = \"4\"    // in seconds\n\ttegraStatsInterval string        = \"3700\" // in milliseconds\n\trocmSmiInterval    time.Duration = 4300 * time.Millisecond\n\t// Command retry and timeout constants\n\tretryWaitTime     time.Duration = 5 * time.Second\n\tmaxFailureRetries int           = 5\n\tcmdBufferSize uint16 = 10 * 1024\n\t// Unit Conversions\n\tmebibytesInAMegabyte float64 = 1.024  // nvidia-smi reports memory in MiB\n\tmilliwattsInAWatt    float64 = 1000.0 // tegrastats reports power in mW\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 42, "end_line": 62, "text": "// GPUManager manages data collection for GPUs (either Nvidia or AMD)\ntype GPUManager struct {\n\tsync.Mutex\n\tnvidiaSmi  bool\n\trocmSmi    bool\n\ttegrastats bool\n\tGpuDataMap map[string]*system.GPUData\n}\n\n// RocmSmiJson represents the JSON structure of rocm-smi output\ntype RocmSmiJson struct {\n\tID           string `json:\"GUID\"`\n\tName         string `json:\"Card series\"`\n\tTemperature  string `json:\"Temperature (Sensor edge) (C)\"`\n\tMemoryUsed   string `json:\"VRAM Total Used Memory (B)\"`\n\tMemoryTotal  string `json:\"VRAM Total Memory (B)\"`\n\tUsage        string `json:\"GPU use (%)\"`\n\tPowerPackage string `json:\"Average Graphics Package Power (W)\"`\n\tPowerSocket  string `json:\"Current Socket Graphics Package Power (W)\"`\n}\n", "n_tokens": 193, "primary_symbol": "", "primary_kind": "", "primary_span": [42, 62], "def_symbols": [], "symbols": ["GPUManager", "manages", "data", "collection", "for", "GPUs", "either", "Nvidia", "AMD", "type", "struct", "sync", "Mutex", "nvidiaSmi", "bool", "rocmSmi", "tegrastats", "GpuDataMap", "map", "string", "system", "GPUData", "RocmSmiJson", "represents", "the", "JSON", "structure", "rocm", "smi", "output", "json", "GUID", "Name", "Card", "series", "Temperature", "Sensor", "edge", "MemoryUsed", "VRAM", "Total", "Used", "Memory", "MemoryTotal", "Usage", "GPU", "use", "PowerPackage", "Average", "Graphics", "Package", "Power", "PowerSocket", "Current", "Socket"], "doc_head": "// GPUManager manages data collection for GPUs (either Nvidia or AMD)\ntype GPUManager struct {\n\tsync.Mutex\n\tnvidiaSmi  bool\n\trocmSmi    bool\n\ttegrastats bool\n\tGpuDataMap map[string]*system.GPUData\n}\n// RocmSmiJson represents the JSON structure of rocm-smi output\ntype RocmSmiJson struct {\n\tID           string `json:\"GUID\"`\n\tName         string `json:\"Card series\"`\n\tTemperature  string `json:\"Temperature (Sensor edge) (C)\"`\n\tMemoryUsed   string `json:\"VRAM Total Used Memory (B)\"`\n\tMemoryTotal  string `json:\"VRAM Total Memory (B)\"`\n\tUsage        string `json:\"GPU use (%)\"`\n\tPowerPackage string `json:\"Average Graphics Package Power (W)\"`\n\tPowerSocket  string `json:\"Current Socket Graphics Package Power (W)\"`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 63, "end_line": 88, "text": "// gpuCollector defines a collector for a specific GPU management utility (nvidia-smi or rocm-smi)\ntype gpuCollector struct {\n\tname    string\n\tcmdArgs []string\n\tparse   func([]byte) bool // returns true if valid data was found\n\tbuf     []byte\n}\n\nvar errNoValidData = fmt.Errorf(\"no valid GPU data found\") // Error for missing data\n\n// starts and manages the ongoing collection of GPU data for the specified GPU management utility\nfunc (c *gpuCollector) start() {\n\tfor {\n\t\terr := c.collect()\n\t\tif err != nil {\n\t\t\tif err == errNoValidData {\n\t\t\t\tslog.Warn(c.name + \" found no valid GPU data, stopping\")\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tslog.Warn(c.name+\" failed, restarting\", \"err\", err)\n\t\t\ttime.Sleep(retryWaitTime)\n\t\t\tcontinue\n\t\t}\n\t}\n}\n", "n_tokens": 185, "primary_symbol": "start", "primary_kind": "function", "primary_span": [74, 88], "def_symbols": ["start"], "symbols": ["start", "gpuCollector", "defines", "collector", "for", "specific", "GPU", "management", "utility", "nvidia", "smi", "rocm", "type", "struct", "name", "string", "cmdArgs", "parse", "func", "byte", "bool", "returns", "true", "valid", "data", "was", "found", "buf", "var", "errNoValidData", "fmt", "Errorf", "Error", "missing", "starts", "and", "manages", "the", "ongoing", "collection", "specified", "err", "collect", "nil", "slog", "Warn", "stopping", "break", "failed", "restarting", "time", "Sleep", "retryWaitTime", "continue"], "doc_head": "// gpuCollector defines a collector for a specific GPU management utility (nvidia-smi or rocm-smi)\ntype gpuCollector struct {\n\tname    string\n\tcmdArgs []string\n\tparse   func([]byte) bool // returns true if valid data was found\n\tbuf     []byte\n}\nvar errNoValidData = fmt.Errorf(\"no valid GPU data found\") // Error for missing data\n// starts and manages the ongoing collection of GPU data for the specified GPU management utility\nfunc (c *gpuCollector) start() {\n\tfor {\n\t\terr := c.collect()\n\t\tif err != nil {\n\t\t\tif err == errNoValidData {\n\t\t\t\tslog.Warn(c.name + \" found no valid GPU data, stopping\")\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tslog.Warn(c.name+\" failed, restarting\", \"err\", err)\n\t\t\ttime.Sleep(retryWaitTime)\n\t\t\tcontinue\n\t\t}\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 89, "end_line": 118, "text": "// collect executes the command, parses output with the assigned parser function\nfunc (c *gpuCollector) collect() error {\n\tcmd := exec.Command(c.name, c.cmdArgs...)\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\n\tscanner := bufio.NewScanner(stdout)\n\tif c.buf == nil {\n\t\tc.buf = make([]byte, 0, cmdBufferSize)\n\t}\n\tscanner.Buffer(c.buf, bufio.MaxScanTokenSize)\n\n\tfor scanner.Scan() {\n\t\thasValidData := c.parse(scanner.Bytes())\n\t\tif !hasValidData {\n\t\t\treturn errNoValidData\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn fmt.Errorf(\"scanner error: %w\", err)\n\t}\n\treturn cmd.Wait()\n}\n", "n_tokens": 178, "primary_symbol": "collect", "primary_kind": "function", "primary_span": [90, 118], "def_symbols": ["collect"], "symbols": ["collect", "executes", "the", "command", "parses", "output", "with", "assigned", "parser", "function", "func", "gpuCollector", "error", "cmd", "exec", "Command", "name", "cmdArgs", "stdout", "err", "StdoutPipe", "nil", "return", "Start", "scanner", "bufio", "NewScanner", "buf", "make", "byte", "cmdBufferSize", "Buffer", "MaxScanTokenSize", "for", "Scan", "hasValidData", "parse", "Bytes", "errNoValidData", "Err", "fmt", "Errorf", "Wait"], "doc_head": "// collect executes the command, parses output with the assigned parser function\nfunc (c *gpuCollector) collect() error {\n\tcmd := exec.Command(c.name, c.cmdArgs...)\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tscanner := bufio.NewScanner(stdout)\n\tif c.buf == nil {\n\t\tc.buf = make([]byte, 0, cmdBufferSize)\n\t}\n\tscanner.Buffer(c.buf, bufio.MaxScanTokenSize)\n\tfor scanner.Scan() {\n\t\thasValidData := c.parse(scanner.Bytes())\n\t\tif !hasValidData {\n\t\t\treturn errNoValidData\n\t\t}\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn fmt.Errorf(\"scanner error: %w\", err)\n\t}\n\treturn cmd.Wait()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 119, "end_line": 163, "text": "// getJetsonParser returns a function to parse the output of tegrastats and update the GPUData map\nfunc (gm *GPUManager) getJetsonParser() func(output []byte) bool {\n\t// use closure to avoid recompiling the regex\n\tramPattern := regexp.MustCompile(`RAM (\\d+)/(\\d+)MB`)\n\tgr3dPattern := regexp.MustCompile(`GR3D_FREQ (\\d+)%`)\n\ttempPattern := regexp.MustCompile(`tj@(\\d+\\.?\\d*)C`)\n\t// Orin Nano / NX do not have GPU specific power monitor\n\t// TODO: Maybe use VDD_IN for Nano / NX and add a total system power chart\n\tpowerPattern := regexp.MustCompile(`(GPU_SOC|CPU_GPU_CV) (\\d+)mW`)\n\n\t// jetson devices have only one gpu so we'll just initialize here\n\tgpuData := &system.GPUData{Name: \"GPU\"}\n\tgm.GpuDataMap[\"0\"] = gpuData\n\n\treturn func(output []byte) bool {\n\t\tgm.Lock()\n\t\tdefer gm.Unlock()\n\t\t// Parse RAM usage\n\t\tramMatches := ramPattern.FindSubmatch(output)\n\t\tif ramMatches != nil {\n\t\t\tgpuData.MemoryUsed, _ = strconv.ParseFloat(string(ramMatches[1]), 64)\n\t\t\tgpuData.MemoryTotal, _ = strconv.ParseFloat(string(ramMatches[2]), 64)\n\t\t}\n\t\t// Parse GR3D (GPU) usage\n\t\tgr3dMatches := gr3dPattern.FindSubmatch(output)\n\t\tif gr3dMatches != nil {\n\t\t\tgr3dUsage, _ := strconv.ParseFloat(string(gr3dMatches[1]), 64)\n\t\t\tgpuData.Usage += gr3dUsage\n\t\t}\n\t\t// Parse temperature\n\t\ttempMatches := tempPattern.FindSubmatch(output)\n\t\tif tempMatches != nil {\n\t\t\tgpuData.Temperature, _ = strconv.ParseFloat(string(tempMatches[1]), 64)\n\t\t}\n\t\t// Parse power usage\n\t\tpowerMatches := powerPattern.FindSubmatch(output)\n\t\tif powerMatches != nil {\n\t\t\tpower, _ := strconv.ParseFloat(string(powerMatches[2]), 64)\n\t\t\tgpuData.Power += power / milliwattsInAWatt\n\t\t}\n\t\tgpuData.Count++\n\t\treturn true\n\t}\n}\n", "n_tokens": 494, "primary_symbol": "getJetsonParser", "primary_kind": "function", "primary_span": [119, 163], "def_symbols": ["getJetsonParser"], "symbols": ["getJetsonParser", "returns", "function", "parse", "the", "output", "tegrastats", "and", "update", "GPUData", "map", "func", "GPUManager", "byte", "bool", "use", "closure", "avoid", "recompiling", "regex", "ramPattern", "regexp", "MustCompile", "RAM", "gr3dPattern", "GR3D_FREQ", "tempPattern", "Orin", "Nano", "not", "have", "GPU", "specific", "power", "monitor", "TODO", "Maybe", "VDD_IN", "for", "add", "total", "system", "chart", "powerPattern", "GPU_SOC", "CPU_GPU_CV", "jetson", "devices", "only", "one", "gpu", "just", "initialize", "here", "gpuData", "Name", "GpuDataMap", "return", "Lock", "defer", "Unlock", "Parse", "usage", "ramMatches", "FindSubmatch", "nil", "MemoryUsed", "strconv", "ParseFloat", "string", "MemoryTotal", "GR3D", "gr3dMatches", "gr3dUsage", "Usage", "temperature", "tempMatches", "Temperature", "powerMatches", "Power", "milliwattsInAWatt", "Count", "true"], "doc_head": "// getJetsonParser returns a function to parse the output of tegrastats and update the GPUData map\nfunc (gm *GPUManager) getJetsonParser() func(output []byte) bool {\n\t// use closure to avoid recompiling the regex\n\tramPattern := regexp.MustCompile(`RAM (\\d+)/(\\d+)MB`)\n\tgr3dPattern := regexp.MustCompile(`GR3D_FREQ (\\d+)%`)\n\ttempPattern := regexp.MustCompile(`tj@(\\d+\\.?\\d*)C`)\n\t// Orin Nano / NX do not have GPU specific power monitor\n\t// TODO: Maybe use VDD_IN for Nano / NX and add a total system power chart\n\tpowerPattern := regexp.MustCompile(`(GPU_SOC|CPU_GPU_CV) (\\d+)mW`)\n\t// jetson devices have only one gpu so we'll just initialize here\n\tgpuData := &system.GPUData{Name: \"GPU\"}\n\tgm.GpuDataMap[\"0\"] = gpuData\n\treturn func(output []byte) bool {\n\t\tgm.Lock()\n\t\tdefer gm.Unlock()\n\t\t// Parse RAM usage\n\t\tramMatches := ramPattern.FindSubmatch(output)\n\t\tif ramMatches != nil {\n\t\t\tgpuData.MemoryUsed, _ = strconv.ParseFloat(string(ramMatches[1]), 64)\n\t\t\tgpuData.MemoryTotal, _ = strconv.ParseFloat(string(ramMatches[2]), 64)\n\t\t}\n\t\t// Parse GR3D (GPU) usage\n\t\tgr3dMatches := gr3dPattern.FindSubmatch(output)\n\t\tif gr3dMatches != nil {\n\t\t\tgr3dUsage, _ := strconv.ParseFloat(string(gr3dMatches[1]), 64)\n\t"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 164, "end_line": 199, "text": "// parseNvidiaData parses the output of nvidia-smi and updates the GPUData map\nfunc (gm *GPUManager) parseNvidiaData(output []byte) bool {\n\tgm.Lock()\n\tdefer gm.Unlock()\n\tscanner := bufio.NewScanner(bytes.NewReader(output))\n\tvar valid bool\n\tfor scanner.Scan() {\n\t\tline := scanner.Text() // Or use scanner.Bytes() for []byte\n\t\tfields := strings.Split(strings.TrimSpace(line), \", \")\n\t\tif len(fields) < 7 {\n\t\t\tcontinue\n\t\t}\n\t\tvalid = true\n\t\tid := fields[0]\n\t\ttemp, _ := strconv.ParseFloat(fields[2], 64)\n\t\tmemoryUsage, _ := strconv.ParseFloat(fields[3], 64)\n\t\ttotalMemory, _ := strconv.ParseFloat(fields[4], 64)\n\t\tusage, _ := strconv.ParseFloat(fields[5], 64)\n\t\tpower, _ := strconv.ParseFloat(fields[6], 64)\n\t\t// add gpu if not exists\n\t\tif _, ok := gm.GpuDataMap[id]; !ok {\n\t\t\tname := strings.TrimPrefix(fields[1], \"NVIDIA \")\n\t\t\tgm.GpuDataMap[id] = &system.GPUData{Name: strings.TrimSuffix(name, \" Laptop GPU\")}\n\t\t}\n\t\t// update gpu data\n\t\tgpu := gm.GpuDataMap[id]\n\t\tgpu.Temperature = temp\n\t\tgpu.MemoryUsed = memoryUsage / mebibytesInAMegabyte\n\t\tgpu.MemoryTotal = totalMemory / mebibytesInAMegabyte\n\t\tgpu.Usage += usage\n\t\tgpu.Power += power\n\t\tgpu.Count++\n\t}\n\treturn valid\n}\n", "n_tokens": 351, "primary_symbol": "parseNvidiaData", "primary_kind": "function", "primary_span": [165, 199], "def_symbols": ["parseNvidiaData"], "symbols": ["parseNvidiaData", "parses", "the", "output", "nvidia", "smi", "and", "updates", "GPUData", "map", "func", "GPUManager", "byte", "bool", "Lock", "defer", "Unlock", "scanner", "bufio", "NewScanner", "bytes", "NewReader", "var", "valid", "for", "Scan", "line", "Text", "use", "Bytes", "fields", "strings", "Split", "TrimSpace", "len", "continue", "true", "temp", "strconv", "ParseFloat", "memoryUsage", "totalMemory", "usage", "power", "add", "gpu", "not", "exists", "GpuDataMap", "name", "TrimPrefix", "NVIDIA", "system", "Name", "TrimSuffix", "Laptop", "GPU", "update", "data", "Temperature", "MemoryUsed", "mebibytesInAMegabyte", "MemoryTotal", "Usage", "Power", "Count", "return"], "doc_head": "// parseNvidiaData parses the output of nvidia-smi and updates the GPUData map\nfunc (gm *GPUManager) parseNvidiaData(output []byte) bool {\n\tgm.Lock()\n\tdefer gm.Unlock()\n\tscanner := bufio.NewScanner(bytes.NewReader(output))\n\tvar valid bool\n\tfor scanner.Scan() {\n\t\tline := scanner.Text() // Or use scanner.Bytes() for []byte\n\t\tfields := strings.Split(strings.TrimSpace(line), \", \")\n\t\tif len(fields) < 7 {\n\t\t\tcontinue\n\t\t}\n\t\tvalid = true\n\t\tid := fields[0]\n\t\ttemp, _ := strconv.ParseFloat(fields[2], 64)\n\t\tmemoryUsage, _ := strconv.ParseFloat(fields[3], 64)\n\t\ttotalMemory, _ := strconv.ParseFloat(fields[4], 64)\n\t\tusage, _ := strconv.ParseFloat(fields[5], 64)\n\t\tpower, _ := strconv.ParseFloat(fields[6], 64)\n\t\t// add gpu if not exists\n\t\tif _, ok := gm.GpuDataMap[id]; !ok {\n\t\t\tname := strings.TrimPrefix(fields[1], \"NVIDIA \")\n\t\t\tgm.GpuDataMap[id] = &system.GPUData{Name: strings.TrimSuffix(name, \" Laptop GPU\")}\n\t\t}\n\t\t// update gpu data\n\t\tgpu := gm.GpuDataMap[id]\n\t\tgpu.Temperature = temp\n\t\tgpu.MemoryUsed = memoryUsage / mebibytesInAMegabyte\n\t\tgpu.MemoryTotal = totalMemory / mebibytesInAMegabyte\n\t\tgpu.Usage += usage\n\t\tgpu.Power += power\n\t\tgpu.Count++\n\t}\n\treturn valid\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 200, "end_line": 232, "text": "// parseAmdData parses the output of rocm-smi and updates the GPUData map\nfunc (gm *GPUManager) parseAmdData(output []byte) bool {\n\tvar rocmSmiInfo map[string]RocmSmiJson\n\tif err := json.Unmarshal(output, &rocmSmiInfo); err != nil || len(rocmSmiInfo) == 0 {\n\t\treturn false\n\t}\n\tgm.Lock()\n\tdefer gm.Unlock()\n\tfor _, v := range rocmSmiInfo {\n\t\tvar power float64\n\t\tif v.PowerPackage != \"\" {\n\t\t\tpower, _ = strconv.ParseFloat(v.PowerPackage, 64)\n\t\t} else {\n\t\t\tpower, _ = strconv.ParseFloat(v.PowerSocket, 64)\n\t\t}\n\t\tmemoryUsage, _ := strconv.ParseFloat(v.MemoryUsed, 64)\n\t\ttotalMemory, _ := strconv.ParseFloat(v.MemoryTotal, 64)\n\t\tusage, _ := strconv.ParseFloat(v.Usage, 64)\n\n\t\tif _, ok := gm.GpuDataMap[v.ID]; !ok {\n\t\t\tgm.GpuDataMap[v.ID] = &system.GPUData{Name: v.Name}\n\t\t}\n\t\tgpu := gm.GpuDataMap[v.ID]\n\t\tgpu.Temperature, _ = strconv.ParseFloat(v.Temperature, 64)\n\t\tgpu.MemoryUsed = bytesToMegabytes(memoryUsage)\n\t\tgpu.MemoryTotal = bytesToMegabytes(totalMemory)\n\t\tgpu.Usage += usage\n\t\tgpu.Power += power\n\t\tgpu.Count++\n\t}\n\treturn true\n}\n", "n_tokens": 329, "primary_symbol": "parseAmdData", "primary_kind": "function", "primary_span": [201, 232], "def_symbols": ["parseAmdData"], "symbols": ["parseAmdData", "parses", "the", "output", "rocm", "smi", "and", "updates", "GPUData", "map", "func", "GPUManager", "byte", "bool", "var", "rocmSmiInfo", "string", "RocmSmiJson", "err", "json", "Unmarshal", "nil", "len", "return", "false", "Lock", "defer", "Unlock", "for", "range", "power", "float64", "PowerPackage", "strconv", "ParseFloat", "else", "PowerSocket", "memoryUsage", "MemoryUsed", "totalMemory", "MemoryTotal", "usage", "Usage", "GpuDataMap", "system", "Name", "gpu", "Temperature", "bytesToMegabytes", "Power", "Count", "true"], "doc_head": "// parseAmdData parses the output of rocm-smi and updates the GPUData map\nfunc (gm *GPUManager) parseAmdData(output []byte) bool {\n\tvar rocmSmiInfo map[string]RocmSmiJson\n\tif err := json.Unmarshal(output, &rocmSmiInfo); err != nil || len(rocmSmiInfo) == 0 {\n\t\treturn false\n\t}\n\tgm.Lock()\n\tdefer gm.Unlock()\n\tfor _, v := range rocmSmiInfo {\n\t\tvar power float64\n\t\tif v.PowerPackage != \"\" {\n\t\t\tpower, _ = strconv.ParseFloat(v.PowerPackage, 64)\n\t\t} else {\n\t\t\tpower, _ = strconv.ParseFloat(v.PowerSocket, 64)\n\t\t}\n\t\tmemoryUsage, _ := strconv.ParseFloat(v.MemoryUsed, 64)\n\t\ttotalMemory, _ := strconv.ParseFloat(v.MemoryTotal, 64)\n\t\tusage, _ := strconv.ParseFloat(v.Usage, 64)\n\t\tif _, ok := gm.GpuDataMap[v.ID]; !ok {\n\t\t\tgm.GpuDataMap[v.ID] = &system.GPUData{Name: v.Name}\n\t\t}\n\t\tgpu := gm.GpuDataMap[v.ID]\n\t\tgpu.Temperature, _ = strconv.ParseFloat(v.Temperature, 64)\n\t\tgpu.MemoryUsed = bytesToMegabytes(memoryUsage)\n\t\tgpu.MemoryTotal = bytesToMegabytes(totalMemory)\n\t\tgpu.Usage += usage\n\t\tgpu.Power += power\n\t\tgpu.Count++\n\t}\n\treturn true\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 233, "end_line": 271, "text": "// sums and resets the current GPU utilization data since the last update\nfunc (gm *GPUManager) GetCurrentData() map[string]system.GPUData {\n\tgm.Lock()\n\tdefer gm.Unlock()\n\n\t// check for GPUs with the same name\n\tnameCounts := make(map[string]int)\n\tfor _, gpu := range gm.GpuDataMap {\n\t\tnameCounts[gpu.Name]++\n\t}\n\n\t// copy / reset the data\n\tgpuData := make(map[string]system.GPUData, len(gm.GpuDataMap))\n\tfor id, gpu := range gm.GpuDataMap {\n\t\tgpuAvg := *gpu\n\n\t\tgpuAvg.Temperature = twoDecimals(gpu.Temperature)\n\t\tgpuAvg.MemoryUsed = twoDecimals(gpu.MemoryUsed)\n\t\tgpuAvg.MemoryTotal = twoDecimals(gpu.MemoryTotal)\n\n\t\t// avoid division by zero\n\t\tif gpu.Count > 0 {\n\t\t\tgpuAvg.Usage = twoDecimals(gpu.Usage / gpu.Count)\n\t\t\tgpuAvg.Power = twoDecimals(gpu.Power / gpu.Count)\n\t\t}\n\n\t\t// reset accumulators in the original\n\t\tgpu.Usage, gpu.Power, gpu.Count = 0, 0, 0\n\n\t\t// append id to the name if there are multiple GPUs with the same name\n\t\tif nameCounts[gpu.Name] > 1 {\n\t\t\tgpuAvg.Name = fmt.Sprintf(\"%s %s\", gpu.Name, id)\n\t\t}\n\t\tgpuData[id] = gpuAvg\n\t}\n\tslog.Debug(\"GPU\", \"data\", gpuData)\n\treturn gpuData\n}\n", "n_tokens": 334, "primary_symbol": "GetCurrentData", "primary_kind": "function", "primary_span": [234, 271], "def_symbols": ["GetCurrentData"], "symbols": ["GetCurrentData", "sums", "and", "resets", "the", "current", "GPU", "utilization", "data", "since", "last", "update", "func", "GPUManager", "map", "string", "system", "GPUData", "Lock", "defer", "Unlock", "check", "for", "GPUs", "with", "same", "name", "nameCounts", "make", "int", "gpu", "range", "GpuDataMap", "Name", "copy", "reset", "gpuData", "len", "gpuAvg", "Temperature", "twoDecimals", "MemoryUsed", "MemoryTotal", "avoid", "division", "zero", "Count", "Usage", "Power", "accumulators", "original", "append", "there", "are", "multiple", "fmt", "Sprintf", "slog", "Debug", "return"], "doc_head": "// sums and resets the current GPU utilization data since the last update\nfunc (gm *GPUManager) GetCurrentData() map[string]system.GPUData {\n\tgm.Lock()\n\tdefer gm.Unlock()\n\t// check for GPUs with the same name\n\tnameCounts := make(map[string]int)\n\tfor _, gpu := range gm.GpuDataMap {\n\t\tnameCounts[gpu.Name]++\n\t}\n\t// copy / reset the data\n\tgpuData := make(map[string]system.GPUData, len(gm.GpuDataMap))\n\tfor id, gpu := range gm.GpuDataMap {\n\t\tgpuAvg := *gpu\n\t\tgpuAvg.Temperature = twoDecimals(gpu.Temperature)\n\t\tgpuAvg.MemoryUsed = twoDecimals(gpu.MemoryUsed)\n\t\tgpuAvg.MemoryTotal = twoDecimals(gpu.MemoryTotal)\n\t\t// avoid division by zero\n\t\tif gpu.Count > 0 {\n\t\t\tgpuAvg.Usage = twoDecimals(gpu.Usage / gpu.Count)\n\t\t\tgpuAvg.Power = twoDecimals(gpu.Power / gpu.Count)\n\t\t}\n\t\t// reset accumulators in the original\n\t\tgpu.Usage, gpu.Power, gpu.Count = 0, 0, 0\n\t\t// append id to the name if there are multiple GPUs with the same name\n\t\tif nameCounts[gpu.Name] > 1 {\n\t\t\tgpuAvg.Name = fmt.Sprintf(\"%s %s\", gpu.Name, id)\n\t\t}\n\t\tgpuData[id] = gpuAvg\n\t}\n\tslog.Debug(\"GPU\", \"data\", gpuData)\n\treturn gpuData\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 272, "end_line": 292, "text": "// detectGPUs checks for the presence of GPU management tools (nvidia-smi, rocm-smi, tegrastats)\n// in the system path. It sets the corresponding flags in the GPUManager struct if any of these\n// tools are found. If none of the tools are found, it returns an error indicating that no GPU\n// management tools are available.\nfunc (gm *GPUManager) detectGPUs() error {\n\tif _, err := exec.LookPath(nvidiaSmiCmd); err == nil {\n\t\tgm.nvidiaSmi = true\n\t}\n\tif _, err := exec.LookPath(rocmSmiCmd); err == nil {\n\t\tgm.rocmSmi = true\n\t}\n\tif _, err := exec.LookPath(tegraStatsCmd); err == nil {\n\t\tgm.tegrastats = true\n\t\tgm.nvidiaSmi = false\n\t}\n\tif gm.nvidiaSmi || gm.rocmSmi || gm.tegrastats {\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"no GPU found - install nvidia-smi, rocm-smi, or tegrastats\")\n}\n", "n_tokens": 237, "primary_symbol": "detectGPUs", "primary_kind": "function", "primary_span": [276, 292], "def_symbols": ["detectGPUs"], "symbols": ["detectGPUs", "checks", "for", "the", "presence", "GPU", "management", "tools", "nvidia", "smi", "rocm", "tegrastats", "system", "path", "sets", "corresponding", "flags", "GPUManager", "struct", "any", "these", "are", "found", "none", "returns", "error", "indicating", "that", "available", "func", "err", "exec", "LookPath", "nvidiaSmiCmd", "nil", "nvidiaSmi", "true", "rocmSmiCmd", "rocmSmi", "tegraStatsCmd", "false", "return", "fmt", "Errorf", "install"], "doc_head": "// detectGPUs checks for the presence of GPU management tools (nvidia-smi, rocm-smi, tegrastats)\n// in the system path. It sets the corresponding flags in the GPUManager struct if any of these\n// tools are found. If none of the tools are found, it returns an error indicating that no GPU\n// management tools are available.\nfunc (gm *GPUManager) detectGPUs() error {\n\tif _, err := exec.LookPath(nvidiaSmiCmd); err == nil {\n\t\tgm.nvidiaSmi = true\n\t}\n\tif _, err := exec.LookPath(rocmSmiCmd); err == nil {\n\t\tgm.rocmSmi = true\n\t}\n\tif _, err := exec.LookPath(tegraStatsCmd); err == nil {\n\t\tgm.tegrastats = true\n\t\tgm.nvidiaSmi = false\n\t}\n\tif gm.nvidiaSmi || gm.rocmSmi || gm.tegrastats {\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"no GPU found - install nvidia-smi, rocm-smi, or tegrastats\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 293, "end_line": 329, "text": "// startCollector starts the appropriate GPU data collector based on the command\nfunc (gm *GPUManager) startCollector(command string) {\n\tcollector := gpuCollector{\n\t\tname: command,\n\t}\n\tswitch command {\n\tcase nvidiaSmiCmd:\n\t\tcollector.cmdArgs = []string{\n\t\t\t\"-l\", nvidiaSmiInterval,\n\t\t\t\"--query-gpu=index,name,temperature.gpu,memory.used,memory.total,utilization.gpu,power.draw\",\n\t\t\t\"--format=csv,noheader,nounits\",\n\t\t}\n\t\tcollector.parse = gm.parseNvidiaData\n\t\tgo collector.start()\n\tcase tegraStatsCmd:\n\t\tcollector.cmdArgs = []string{\"--interval\", tegraStatsInterval}\n\t\tcollector.parse = gm.getJetsonParser()\n\t\tgo collector.start()\n\tcase rocmSmiCmd:\n\t\tcollector.cmdArgs = []string{\"--showid\", \"--showtemp\", \"--showuse\", \"--showpower\", \"--showproductname\", \"--showmeminfo\", \"vram\", \"--json\"}\n\t\tcollector.parse = gm.parseAmdData\n\t\tgo func() {\n\t\t\tfailures := 0\n\t\t\tfor {\n\t\t\t\tif err := collector.collect(); err != nil {\n\t\t\t\t\tfailures++\n\t\t\t\t\tif failures > maxFailureRetries {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tslog.Warn(\"Error collecting AMD GPU data\", \"err\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(rocmSmiInterval)\n\t\t\t}\n\t\t}()\n\t}\n}\n", "n_tokens": 314, "primary_symbol": "startCollector", "primary_kind": "function", "primary_span": [294, 329], "def_symbols": ["startCollector"], "symbols": ["startCollector", "starts", "the", "appropriate", "GPU", "data", "collector", "based", "command", "func", "GPUManager", "string", "gpuCollector", "name", "switch", "case", "nvidiaSmiCmd", "cmdArgs", "nvidiaSmiInterval", "query", "gpu", "index", "temperature", "memory", "used", "total", "utilization", "power", "draw", "format", "csv", "noheader", "nounits", "parse", "parseNvidiaData", "start", "tegraStatsCmd", "interval", "tegraStatsInterval", "getJetsonParser", "rocmSmiCmd", "showid", "showtemp", "showuse", "showpower", "showproductname", "showmeminfo", "vram", "json", "parseAmdData", "failures", "for", "err", "collect", "nil", "maxFailureRetries", "break", "slog", "Warn", "Error", "collecting", "AMD", "time", "Sleep", "rocmSmiInterval"], "doc_head": "// startCollector starts the appropriate GPU data collector based on the command\nfunc (gm *GPUManager) startCollector(command string) {\n\tcollector := gpuCollector{\n\t\tname: command,\n\t}\n\tswitch command {\n\tcase nvidiaSmiCmd:\n\t\tcollector.cmdArgs = []string{\n\t\t\t\"-l\", nvidiaSmiInterval,\n\t\t\t\"--query-gpu=index,name,temperature.gpu,memory.used,memory.total,utilization.gpu,power.draw\",\n\t\t\t\"--format=csv,noheader,nounits\",\n\t\t}\n\t\tcollector.parse = gm.parseNvidiaData\n\t\tgo collector.start()\n\tcase tegraStatsCmd:\n\t\tcollector.cmdArgs = []string{\"--interval\", tegraStatsInterval}\n\t\tcollector.parse = gm.getJetsonParser()\n\t\tgo collector.start()\n\tcase rocmSmiCmd:\n\t\tcollector.cmdArgs = []string{\"--showid\", \"--showtemp\", \"--showuse\", \"--showpower\", \"--showproductname\", \"--showmeminfo\", \"vram\", \"--json\"}\n\t\tcollector.parse = gm.parseAmdData\n\t\tgo func() {\n\t\t\tfailures := 0\n\t\t\tfor {\n\t\t\t\tif err := collector.collect(); err != nil {\n\t\t\t\t\tfailures++\n\t\t\t\t\tif failures > maxFailureRetries {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tslog.Warn(\"Error collecting AMD GPU data\", \"err\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(rocmSmiInterval)\n\t\t\t}\n\t\t}()\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/gpu.go", "rel_path": "agent/gpu.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 330, "end_line": 350, "text": "// NewGPUManager creates and initializes a new GPUManager\nfunc NewGPUManager() (*GPUManager, error) {\n\tvar gm GPUManager\n\tif err := gm.detectGPUs(); err != nil {\n\t\treturn nil, err\n\t}\n\tgm.GpuDataMap = make(map[string]*system.GPUData)\n\n\tif gm.nvidiaSmi {\n\t\tgm.startCollector(nvidiaSmiCmd)\n\t}\n\tif gm.rocmSmi {\n\t\tgm.startCollector(rocmSmiCmd)\n\t}\n\tif gm.tegrastats {\n\t\tgm.startCollector(tegraStatsCmd)\n\t}\n\n\treturn &gm, nil\n}\n", "n_tokens": 131, "primary_symbol": "NewGPUManager", "primary_kind": "function", "primary_span": [331, 350], "def_symbols": ["NewGPUManager"], "symbols": ["NewGPUManager", "creates", "and", "initializes", "new", "GPUManager", "func", "error", "var", "err", "detectGPUs", "nil", "return", "GpuDataMap", "make", "map", "string", "system", "GPUData", "nvidiaSmi", "startCollector", "nvidiaSmiCmd", "rocmSmi", "rocmSmiCmd", "tegrastats", "tegraStatsCmd"], "doc_head": "// NewGPUManager creates and initializes a new GPUManager\nfunc NewGPUManager() (*GPUManager, error) {\n\tvar gm GPUManager\n\tif err := gm.detectGPUs(); err != nil {\n\t\treturn nil, err\n\t}\n\tgm.GpuDataMap = make(map[string]*system.GPUData)\n\tif gm.nvidiaSmi {\n\t\tgm.startCollector(nvidiaSmiCmd)\n\t}\n\tif gm.rocmSmi {\n\t\tgm.startCollector(rocmSmiCmd)\n\t}\n\tif gm.tegrastats {\n\t\tgm.startCollector(tegraStatsCmd)\n\t}\n\treturn &gm, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_test_helpers.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/agent_test_helpers.go", "rel_path": "agent/agent_test_helpers.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 10, "text": "//go:build testing\n// +build testing\n\npackage agent\n\n// TESTING ONLY: GetConnectionManager is a helper function to get the connection manager for testing.\nfunc (a *Agent) GetConnectionManager() *ConnectionManager {\n\treturn a.connectionManager\n}\n", "n_tokens": 53, "primary_symbol": "GetConnectionManager", "primary_kind": "function", "primary_span": [6, 10], "def_symbols": ["GetConnectionManager"], "symbols": ["GetConnectionManager", "build", "testing", "package", "agent", "TESTING", "ONLY", "helper", "function", "get", "the", "connection", "manager", "for", "func", "Agent", "ConnectionManager", "return", "connectionManager"], "doc_head": "//go:build testing\n// +build testing\npackage agent\n// TESTING ONLY: GetConnectionManager is a helper function to get the connection manager for testing.\nfunc (a *Agent) GetConnectionManager() *ConnectionManager {\n\treturn a.connectionManager\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_default.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/sensors_default.go", "rel_path": "agent/sensors_default.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 10, "text": "//go:build !windows\n\npackage agent\n\nimport (\n\t\"github.com/shirou/gopsutil/v4/sensors\"\n)\n\nvar getSensorTemps = sensors.TemperaturesWithContext\n", "n_tokens": 40, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 10], "def_symbols": [], "symbols": ["build", "windows", "package", "agent", "import", "github", "com", "shirou", "gopsutil", "sensors", "var", "getSensorTemps", "TemperaturesWithContext"], "doc_head": "//go:build !windows\npackage agent\nimport (\n\t\"github.com/shirou/gopsutil/v4/sensors\"\n)\nvar getSensorTemps = sensors.TemperaturesWithContext"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/health/health.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/health/health.go", "rel_path": "agent/health/health.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 30, "text": "// Package health provides functions to check and update the health of the agent.\n// It uses a file in the temp directory to store the timestamp of the last connection attempt.\n// If the timestamp is older than 90 seconds, the agent is considered unhealthy.\n// NB: The agent must be started with the Start() method to be considered healthy.\npackage health\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\n// healthFile is the path to the health file\nvar healthFile = filepath.Join(os.TempDir(), \"beszel_health\")\n\n// Check checks if the agent is connected by checking the modification time of the health file\nfunc Check() error {\n\tfileInfo, err := os.Stat(healthFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif time.Since(fileInfo.ModTime()) > 91*time.Second {\n\t\tlog.Println(\"over 90 seconds since last connection\")\n\t\treturn errors.New(\"unhealthy\")\n\t}\n\treturn nil\n}\n", "n_tokens": 202, "primary_symbol": "Check", "primary_kind": "function", "primary_span": [19, 30], "def_symbols": ["Check"], "symbols": ["Check", "Package", "health", "provides", "functions", "check", "and", "update", "the", "agent", "uses", "file", "temp", "directory", "store", "timestamp", "last", "connection", "attempt", "older", "than", "seconds", "considered", "unhealthy", "The", "must", "started", "with", "Start", "method", "healthy", "package", "import", "errors", "log", "path", "filepath", "time", "healthFile", "var", "Join", "TempDir", "beszel_health", "checks", "connected", "checking", "modification", "func", "error", "fileInfo", "err", "Stat", "nil", "return", "Since", "ModTime", "Second", "Println", "over", "since", "New"], "doc_head": "// Package health provides functions to check and update the health of the agent.\n// It uses a file in the temp directory to store the timestamp of the last connection attempt.\n// If the timestamp is older than 90 seconds, the agent is considered unhealthy.\n// NB: The agent must be started with the Start() method to be considered healthy.\npackage health\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n// healthFile is the path to the health file\nvar healthFile = filepath.Join(os.TempDir(), \"beszel_health\")\n// Check checks if the agent is connected by checking the modification time of the health file\nfunc Check() error {\n\tfileInfo, err := os.Stat(healthFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif time.Since(fileInfo.ModTime()) > 91*time.Second {\n\t\tlog.Println(\"over 90 seconds since last connection\")\n\t\treturn errors.New(\"unhealthy\")\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/health/health.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/health/health.go", "rel_path": "agent/health/health.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 31, "end_line": 44, "text": "// Update updates the modification time of the health file\nfunc Update() error {\n\tfile, err := os.Create(healthFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn file.Close()\n}\n\n// CleanUp removes the health file\nfunc CleanUp() error {\n\treturn os.Remove(healthFile)\n}\n", "n_tokens": 64, "primary_symbol": "Update", "primary_kind": "function", "primary_span": [32, 44], "def_symbols": ["Update", "CleanUp"], "symbols": ["Update", "CleanUp", "updates", "the", "modification", "time", "health", "file", "func", "error", "err", "Create", "healthFile", "nil", "return", "Close", "removes", "Remove"], "doc_head": "// Update updates the modification time of the health file\nfunc Update() error {\n\tfile, err := os.Create(healthFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn file.Close()\n}\n// CleanUp removes the health file\nfunc CleanUp() error {\n\treturn os.Remove(healthFile)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/health/health_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/health/health_test.go", "rel_path": "agent/health/health_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 17, "text": "//go:build testing\n// +build testing\n\npackage health\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"testing/synctest\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n", "n_tokens": 51, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 17], "def_symbols": [], "symbols": ["build", "testing", "package", "health", "import", "path", "filepath", "time", "synctest", "github", "com", "stretchr", "testify", "assert", "require"], "doc_head": "//go:build testing\n// +build testing\npackage health\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\t\"testing/synctest\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/health/health_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/health/health_test.go", "rel_path": "agent/health/health_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 18, "end_line": 68, "text": "func TestHealth(t *testing.T) {\n\t// Override healthFile to use a temporary directory for this test.\n\toriginalHealthFile := healthFile\n\ttmpDir := t.TempDir()\n\thealthFile = filepath.Join(tmpDir, \"beszel_health_test\")\n\tdefer func() { healthFile = originalHealthFile }()\n\n\tt.Run(\"check with no health file\", func(t *testing.T) {\n\t\terr := Check()\n\t\trequire.Error(t, err)\n\t\tassert.True(t, os.IsNotExist(err), \"expected a file-not-exist error, but got: %v\", err)\n\t})\n\n\tt.Run(\"update and check\", func(t *testing.T) {\n\t\terr := Update()\n\t\trequire.NoError(t, err, \"Update() failed\")\n\n\t\terr = Check()\n\t\tassert.NoError(t, err, \"Check() failed immediately after Update()\")\n\t})\n\n\t// This test uses synctest to simulate time passing.\n\t// NOTE: This test requires GOEXPERIMENT=synctest to run.\n\tt.Run(\"check with simulated time\", func(t *testing.T) {\n\t\tsynctest.Test(t, func(t *testing.T) {\n\t\t\t// Update the file to set the initial timestamp.\n\t\t\trequire.NoError(t, Update(), \"Update() failed inside synctest\")\n\n\t\t\t// Set the mtime to the current fake time to align the file's timestamp with the simulated clock.\n\t\t\tnow := time.Now()\n\t\t\trequire.NoError(t, os.Chtimes(healthFile, now, now), \"Chtimes failed\")\n\n\t\t\t// Wait a duration less than the threshold.\n\t\t\ttime.Sleep(89 * time.Second)\n\t\t\tsynctest.Wait()\n\n\t\t\t// The check should still pass.\n\t\t\tassert.NoError(t, Check(), \"Check() failed after 89s\")\n\n\t\t\t// Wait for the total duration to exceed the threshold.\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tsynctest.Wait()\n\n\t\t\t// The check should now fail as unhealthy.\n\t\t\terr := Check()\n\t\t\trequire.Error(t, err, \"Check() should have failed after 91s\")\n\t\t\tassert.Equal(t, \"unhealthy\", err.Error(), \"Check() returned wrong error\")\n\t\t})\n\t})\n}\n", "n_tokens": 450, "primary_symbol": "TestHealth", "primary_kind": "function", "primary_span": [18, 68], "def_symbols": ["TestHealth"], "symbols": ["TestHealth", "func", "testing", "Override", "healthFile", "use", "temporary", "directory", "for", "this", "test", "originalHealthFile", "tmpDir", "TempDir", "filepath", "Join", "beszel_health_test", "defer", "Run", "check", "with", "health", "file", "err", "Check", "require", "Error", "assert", "True", "IsNotExist", "expected", "not", "exist", "error", "but", "got", "update", "and", "Update", "NoError", "failed", "immediately", "after", "This", "uses", "synctest", "simulate", "time", "passing", "NOTE", "requires", "GOEXPERIMENT", "run", "simulated", "Test", "the", "set", "initial", "timestamp", "inside", "Set", "mtime", "current", "fake", "align", "clock", "now", "Now", "Chtimes", "Wait", "duration", "less", "than", "threshold", "Sleep", "Second", "The", "should", "still", "pass", "total", "exceed", "fail", "unhealthy", "have", "Equal", "returned", "wrong"], "doc_head": "func TestHealth(t *testing.T) {\n\t// Override healthFile to use a temporary directory for this test.\n\toriginalHealthFile := healthFile\n\ttmpDir := t.TempDir()\n\thealthFile = filepath.Join(tmpDir, \"beszel_health_test\")\n\tdefer func() { healthFile = originalHealthFile }()\n\tt.Run(\"check with no health file\", func(t *testing.T) {\n\t\terr := Check()\n\t\trequire.Error(t, err)\n\t\tassert.True(t, os.IsNotExist(err), \"expected a file-not-exist error, but got: %v\", err)\n\t})\n\tt.Run(\"update and check\", func(t *testing.T) {\n\t\terr := Update()\n\t\trequire.NoError(t, err, \"Update() failed\")\n\t\terr = Check()\n\t\tassert.NoError(t, err, \"Check() failed immediately after Update()\")\n\t})\n\t// This test uses synctest to simulate time passing.\n\t// NOTE: This test requires GOEXPERIMENT=synctest to run.\n\tt.Run(\"check with simulated time\", func(t *testing.T) {\n\t\tsynctest.Test(t, func(t *testing.T) {\n\t\t\t// Update the file to set the initial timestamp.\n\t\t\trequire.NoError(t, Update(), \"Update() failed inside synctest\")\n\t\t\t// Set the mtime to the current fake time to align the file's timestamp with the simulated clock.\n\t\t\tnow := time.Now()\n\t\t\trequire.NoError(t, os.Chtimes(healthFile, now, now), \"Chtimes failed\")\n\t\t\t// Wait a du"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/battery/battery_freebsd.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/battery/battery_freebsd.go", "rel_path": "agent/battery/battery_freebsd.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 14, "text": "//go:build freebsd\n\npackage battery\n\nimport \"errors\"\n\nfunc HasReadableBattery() bool {\n\treturn false\n}\n\nfunc GetBatteryStats() (uint8, uint8, error) {\n\treturn 0, 0, errors.ErrUnsupported\n}\n", "n_tokens": 52, "primary_symbol": "HasReadableBattery", "primary_kind": "function", "primary_span": [7, 14], "def_symbols": ["HasReadableBattery", "GetBatteryStats"], "symbols": ["HasReadableBattery", "GetBatteryStats", "build", "freebsd", "package", "battery", "import", "errors", "func", "bool", "return", "false", "uint8", "error", "ErrUnsupported"], "doc_head": "//go:build freebsd\npackage battery\nimport \"errors\"\nfunc HasReadableBattery() bool {\n\treturn false\n}\nfunc GetBatteryStats() (uint8, uint8, error) {\n\treturn 0, 0, errors.ErrUnsupported\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/battery/battery.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/battery/battery.go", "rel_path": "agent/battery/battery.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 30, "text": "//go:build !freebsd\n\n// Package battery provides functions to check if the system has a battery and to get the battery stats.\npackage battery\n\nimport (\n\t\"errors\"\n\t\"log/slog\"\n\n\t\"github.com/distatus/battery\"\n)\n\nvar systemHasBattery = false\nvar haveCheckedBattery = false\n\n// HasReadableBattery checks if the system has a battery and returns true if it does.\nfunc HasReadableBattery() bool {\n\tif haveCheckedBattery {\n\t\treturn systemHasBattery\n\t}\n\thaveCheckedBattery = true\n\tbat, err := battery.Get(0)\n\tif err == nil && bat != nil {\n\t\tsystemHasBattery = true\n\t} else {\n\t\tslog.Debug(\"No battery found\", \"err\", err)\n\t}\n\treturn systemHasBattery\n}\n", "n_tokens": 161, "primary_symbol": "HasReadableBattery", "primary_kind": "function", "primary_span": [17, 30], "def_symbols": ["HasReadableBattery"], "symbols": ["HasReadableBattery", "build", "freebsd", "Package", "battery", "provides", "functions", "check", "the", "system", "has", "and", "get", "stats", "package", "import", "errors", "log", "slog", "github", "com", "distatus", "var", "systemHasBattery", "false", "haveCheckedBattery", "checks", "returns", "true", "does", "func", "bool", "return", "bat", "err", "Get", "nil", "else", "Debug", "found"], "doc_head": "//go:build !freebsd\n// Package battery provides functions to check if the system has a battery and to get the battery stats.\npackage battery\nimport (\n\t\"errors\"\n\t\"log/slog\"\n\t\"github.com/distatus/battery\"\n)\nvar systemHasBattery = false\nvar haveCheckedBattery = false\n// HasReadableBattery checks if the system has a battery and returns true if it does.\nfunc HasReadableBattery() bool {\n\tif haveCheckedBattery {\n\t\treturn systemHasBattery\n\t}\n\thaveCheckedBattery = true\n\tbat, err := battery.Get(0)\n\tif err == nil && bat != nil {\n\t\tsystemHasBattery = true\n\t} else {\n\t\tslog.Debug(\"No battery found\", \"err\", err)\n\t}\n\treturn systemHasBattery\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/agent/battery/battery.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/agent/battery/battery.go", "rel_path": "agent/battery/battery.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 31, "end_line": 54, "text": "// GetBatteryStats returns the current battery percent and charge state\nfunc GetBatteryStats() (batteryPercent uint8, batteryState uint8, err error) {\n\tif !systemHasBattery {\n\t\treturn batteryPercent, batteryState, errors.ErrUnsupported\n\t}\n\tbatteries, err := battery.GetAll()\n\tif err != nil || len(batteries) == 0 {\n\t\treturn batteryPercent, batteryState, err\n\t}\n\ttotalCapacity := float64(0)\n\ttotalCharge := float64(0)\n\tfor _, bat := range batteries {\n\t\tif bat.Design != 0 {\n\t\t\ttotalCapacity += bat.Design\n\t\t} else {\n\t\t\ttotalCapacity += bat.Full\n\t\t}\n\t\ttotalCharge += bat.Current\n\t}\n\tbatteryPercent = uint8(totalCharge / totalCapacity * 100)\n\tbatteryState = uint8(batteries[0].State.Raw)\n\treturn batteryPercent, batteryState, nil\n}\n", "n_tokens": 190, "primary_symbol": "GetBatteryStats", "primary_kind": "function", "primary_span": [32, 54], "def_symbols": ["GetBatteryStats"], "symbols": ["GetBatteryStats", "returns", "the", "current", "battery", "percent", "and", "charge", "state", "func", "batteryPercent", "uint8", "batteryState", "err", "error", "systemHasBattery", "return", "errors", "ErrUnsupported", "batteries", "GetAll", "nil", "len", "totalCapacity", "float64", "totalCharge", "for", "bat", "range", "Design", "else", "Full", "Current", "State", "Raw"], "doc_head": "// GetBatteryStats returns the current battery percent and charge state\nfunc GetBatteryStats() (batteryPercent uint8, batteryState uint8, err error) {\n\tif !systemHasBattery {\n\t\treturn batteryPercent, batteryState, errors.ErrUnsupported\n\t}\n\tbatteries, err := battery.GetAll()\n\tif err != nil || len(batteries) == 0 {\n\t\treturn batteryPercent, batteryState, err\n\t}\n\ttotalCapacity := float64(0)\n\ttotalCharge := float64(0)\n\tfor _, bat := range batteries {\n\t\tif bat.Design != 0 {\n\t\t\ttotalCapacity += bat.Design\n\t\t} else {\n\t\t\ttotalCapacity += bat.Full\n\t\t}\n\t\ttotalCharge += bat.Current\n\t}\n\tbatteryPercent = uint8(totalCharge / totalCapacity * 100)\n\tbatteryState = uint8(batteries[0].State.Raw)\n\treturn batteryPercent, batteryState, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent.go", "rel_path": "src/cmd/agent/agent.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 24, "text": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/agent\"\n\t\"github.com/henrygd/beszel/agent/health\"\n\t\"github.com/spf13/pflag\"\n\t\"golang.org/x/crypto/ssh\"\n)\n\n// cli options\ntype cmdOptions struct {\n\tkey    string // key is the public key(s) for SSH authentication.\n\tlisten string // listen is the address or port to listen on.\n\t// TODO: add hubURL and token\n\t// hubURL string // hubURL is the URL of the hub to use.\n\t// token  string // token is the token to use for authentication.\n}\n", "n_tokens": 156, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 24], "def_symbols": [], "symbols": ["package", "main", "import", "fmt", "log", "strings", "github", "com", "henrygd", "beszel", "agent", "health", "spf13", "pflag", "golang", "org", "crypto", "ssh", "cli", "options", "type", "cmdOptions", "struct", "key", "string", "the", "public", "for", "SSH", "authentication", "listen", "address", "port", "TODO", "add", "hubURL", "and", "token", "URL", "hub", "use"], "doc_head": "package main\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/agent\"\n\t\"github.com/henrygd/beszel/agent/health\"\n\t\"github.com/spf13/pflag\"\n\t\"golang.org/x/crypto/ssh\"\n)\n// cli options\ntype cmdOptions struct {\n\tkey    string // key is the public key(s) for SSH authentication.\n\tlisten string // listen is the address or port to listen on.\n\t// TODO: add hubURL and token\n\t// hubURL string // hubURL is the URL of the hub to use.\n\t// token  string // token is the token to use for authentication.\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent.go", "rel_path": "src/cmd/agent/agent.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 25, "end_line": 100, "text": "// parse parses the command line flags and populates the config struct.\n// It returns true if a subcommand was handled and the program should exit.\nfunc (opts *cmdOptions) parse() bool {\n\tsubcommand := \"\"\n\tif len(os.Args) > 1 {\n\t\tsubcommand = os.Args[1]\n\t}\n\n\t// Subcommands that don't require any pflag parsing\n\tswitch subcommand {\n\tcase \"-v\", \"version\":\n\t\tfmt.Println(beszel.AppName+\"-agent\", beszel.Version)\n\t\treturn true\n\tcase \"health\":\n\t\terr := health.Check()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Print(\"ok\")\n\t\treturn true\n\t}\n\n\t// pflag.CommandLine.ParseErrorsWhitelist.UnknownFlags = true\n\tpflag.StringVarP(&opts.key, \"key\", \"k\", \"\", \"Public key(s) for SSH authentication\")\n\tpflag.StringVarP(&opts.listen, \"listen\", \"l\", \"\", \"Address or port to listen on\")\n\t// pflag.StringVarP(&opts.hubURL, \"hub-url\", \"u\", \"\", \"URL of the hub to use\")\n\t// pflag.StringVarP(&opts.token, \"token\", \"t\", \"\", \"Token to use for authentication\")\n\tchinaMirrors := pflag.BoolP(\"china-mirrors\", \"c\", false, \"Use mirror for update (gh.beszel.dev) instead of GitHub\")\n\thelp := pflag.BoolP(\"help\", \"h\", false, \"Show this help message\")\n\n\t// Convert old single-dash long flags to double-dash for backward compatibility\n\tflagsToConvert := []string{\"key\", \"listen\"}\n\tfor i, arg := range os.Args {\n\t\tfor _, flag := range flagsToConvert {\n\t\t\tsingleDash := \"-\" + flag\n\t\t\tdoubleDash := \"--\" + flag\n\t\t\tif arg == singleDash {\n\t\t\t\tos.Args[i] = doubleDash\n\t\t\t\tbreak\n\t\t\t} else if strings.HasPrefix(arg, singleDash+\"=\") {\n\t\t\t\tos.Args[i] = doubleDash + arg[len(singleDash):]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tpflag.Usage = func() {\n\t\tbuilder := strings.Builder{}\n\t\tbuilder.WriteString(\"Usage: \")\n\t\tbuilder.WriteString(os.Args[0])\n\t\tbuilder.WriteString(\" [command] [flags]\\n\")\n\t\tbuilder.WriteString(\"\\nCommands:\\n\")\n\t\tbuilder.WriteString(\"  health    Check if the agent is running\\n\")\n\t\t// builder.WriteString(\"  help      Display this help message\\n\")\n\t\tbuilder.WriteString(\"  update    Update to the latest version\\n\")\n\t\tbuilder.WriteString(\"\\nFlags:\\n\")\n\t\tfmt.Print(builder.String())\n\t\tpflag.PrintDefaults()\n\t}\n\n\t// Parse all arguments with pflag\n\tpflag.Parse()\n\n\t// Must run after pflag.Parse()\n\tswitch {\n\tcase *help || subcommand == \"help\":\n\t\tpflag.Usage()\n\t\treturn true\n\tcase subcommand == \"update\":\n\t\tagent.Update(*chinaMirrors)\n\t\treturn true\n\t}\n\n\treturn false\n}\n", "n_tokens": 626, "primary_symbol": "parse", "primary_kind": "function", "primary_span": [27, 100], "def_symbols": ["parse"], "symbols": ["parse", "parses", "the", "command", "line", "flags", "and", "populates", "config", "struct", "returns", "true", "subcommand", "was", "handled", "program", "should", "exit", "func", "opts", "cmdOptions", "bool", "len", "Args", "Subcommands", "that", "don", "require", "any", "pflag", "parsing", "switch", "case", "version", "fmt", "Println", "beszel", "AppName", "agent", "Version", "return", "health", "err", "Check", "nil", "log", "Fatal", "Print", "CommandLine", "ParseErrorsWhitelist", "UnknownFlags", "StringVarP", "key", "Public", "for", "SSH", "authentication", "listen", "Address", "port", "hubURL", "hub", "url", "URL", "use", "token", "Token", "chinaMirrors", "BoolP", "china", "mirrors", "false", "Use", "mirror", "update", "dev", "instead", "GitHub", "help", "Show", "this", "message", "Convert", "old", "single", "dash", "long", "double", "backward", "compatibility", "flagsToConvert", "string", "arg", "range", "flag", "singleDash", "doubleDash", "break", "else", "strings", "HasPrefix", "Usage", "builder", "Builder", "WriteString", "nCommands", "running", "Display", "Update", "latest", "nFlags", "String", "PrintDefaults", "Parse", "all", "arguments", "with", "Must", "run", "after"], "doc_head": "// parse parses the command line flags and populates the config struct.\n// It returns true if a subcommand was handled and the program should exit.\nfunc (opts *cmdOptions) parse() bool {\n\tsubcommand := \"\"\n\tif len(os.Args) > 1 {\n\t\tsubcommand = os.Args[1]\n\t}\n\t// Subcommands that don't require any pflag parsing\n\tswitch subcommand {\n\tcase \"-v\", \"version\":\n\t\tfmt.Println(beszel.AppName+\"-agent\", beszel.Version)\n\t\treturn true\n\tcase \"health\":\n\t\terr := health.Check()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Print(\"ok\")\n\t\treturn true\n\t}\n\t// pflag.CommandLine.ParseErrorsWhitelist.UnknownFlags = true\n\tpflag.StringVarP(&opts.key, \"key\", \"k\", \"\", \"Public key(s) for SSH authentication\")\n\tpflag.StringVarP(&opts.listen, \"listen\", \"l\", \"\", \"Address or port to listen on\")\n\t// pflag.StringVarP(&opts.hubURL, \"hub-url\", \"u\", \"\", \"URL of the hub to use\")\n\t// pflag.StringVarP(&opts.token, \"token\", \"t\", \"\", \"Token to use for authentication\")\n\tchinaMirrors := pflag.BoolP(\"china-mirrors\", \"c\", false, \"Use mirror for update (gh.beszel.dev) instead of GitHub\")\n\thelp := pflag.BoolP(\"help\", \"h\", false, \"Show this help message\")\n\t// Convert old single-dash long flags to double-dash for backward compatibility"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent.go", "rel_path": "src/cmd/agent/agent.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 101, "end_line": 125, "text": "// loadPublicKeys loads the public keys from the command line flag, environment variable, or key file.\nfunc (opts *cmdOptions) loadPublicKeys() ([]ssh.PublicKey, error) {\n\t// Try command line flag first\n\tif opts.key != \"\" {\n\t\treturn agent.ParseKeys(opts.key)\n\t}\n\n\t// Try environment variable\n\tif key, ok := agent.GetEnv(\"KEY\"); ok && key != \"\" {\n\t\treturn agent.ParseKeys(key)\n\t}\n\n\t// Try key file\n\tkeyFile, ok := agent.GetEnv(\"KEY_FILE\")\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no key provided: must set -key flag, KEY env var, or KEY_FILE env var. Use 'beszel-agent help' for usage\")\n\t}\n\n\tpubKey, err := os.ReadFile(keyFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read key file: %w\", err)\n\t}\n\treturn agent.ParseKeys(string(pubKey))\n}\n", "n_tokens": 201, "primary_symbol": "loadPublicKeys", "primary_kind": "function", "primary_span": [102, 125], "def_symbols": ["loadPublicKeys"], "symbols": ["loadPublicKeys", "loads", "the", "public", "keys", "from", "command", "line", "flag", "environment", "variable", "key", "file", "func", "opts", "cmdOptions", "ssh", "PublicKey", "error", "Try", "first", "return", "agent", "ParseKeys", "GetEnv", "KEY", "keyFile", "KEY_FILE", "nil", "fmt", "Errorf", "provided", "must", "set", "env", "var", "Use", "beszel", "help", "for", "usage", "pubKey", "err", "ReadFile", "failed", "read", "string"], "doc_head": "// loadPublicKeys loads the public keys from the command line flag, environment variable, or key file.\nfunc (opts *cmdOptions) loadPublicKeys() ([]ssh.PublicKey, error) {\n\t// Try command line flag first\n\tif opts.key != \"\" {\n\t\treturn agent.ParseKeys(opts.key)\n\t}\n\t// Try environment variable\n\tif key, ok := agent.GetEnv(\"KEY\"); ok && key != \"\" {\n\t\treturn agent.ParseKeys(key)\n\t}\n\t// Try key file\n\tkeyFile, ok := agent.GetEnv(\"KEY_FILE\")\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no key provided: must set -key flag, KEY env var, or KEY_FILE env var. Use 'beszel-agent help' for usage\")\n\t}\n\tpubKey, err := os.ReadFile(keyFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read key file: %w\", err)\n\t}\n\treturn agent.ParseKeys(string(pubKey))\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent.go", "rel_path": "src/cmd/agent/agent.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 126, "end_line": 158, "text": "func (opts *cmdOptions) getAddress() string {\n\treturn agent.GetAddress(opts.listen)\n}\n\nfunc main() {\n\tvar opts cmdOptions\n\tsubcommandHandled := opts.parse()\n\n\tif subcommandHandled {\n\t\treturn\n\t}\n\n\tvar serverConfig agent.ServerOptions\n\tvar err error\n\tserverConfig.Keys, err = opts.loadPublicKeys()\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to load public keys:\", err)\n\t}\n\n\taddr := opts.getAddress()\n\tserverConfig.Addr = addr\n\tserverConfig.Network = agent.GetNetwork(addr)\n\n\ta, err := agent.NewAgent()\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to create agent: \", err)\n\t}\n\n\tif err := a.Start(serverConfig); err != nil {\n\t\tlog.Fatal(\"Failed to start server: \", err)\n\t}\n}\n", "n_tokens": 160, "primary_symbol": "getAddress", "primary_kind": "function", "primary_span": [126, 158], "def_symbols": ["getAddress", "main"], "symbols": ["getAddress", "main", "func", "opts", "cmdOptions", "string", "return", "agent", "GetAddress", "listen", "var", "subcommandHandled", "parse", "serverConfig", "ServerOptions", "err", "error", "Keys", "loadPublicKeys", "nil", "log", "Fatal", "Failed", "load", "public", "keys", "addr", "Addr", "Network", "GetNetwork", "NewAgent", "create", "Start", "start", "server"], "doc_head": "func (opts *cmdOptions) getAddress() string {\n\treturn agent.GetAddress(opts.listen)\n}\nfunc main() {\n\tvar opts cmdOptions\n\tsubcommandHandled := opts.parse()\n\tif subcommandHandled {\n\t\treturn\n\t}\n\tvar serverConfig agent.ServerOptions\n\tvar err error\n\tserverConfig.Keys, err = opts.loadPublicKeys()\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to load public keys:\", err)\n\t}\n\taddr := opts.getAddress()\n\tserverConfig.Addr = addr\n\tserverConfig.Network = agent.GetNetwork(addr)\n\ta, err := agent.NewAgent()\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to create agent: \", err)\n\t}\n\tif err := a.Start(serverConfig); err != nil {\n\t\tlog.Fatal(\"Failed to start server: \", err)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go", "rel_path": "src/cmd/agent/agent_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 17, "text": "package main\n\nimport (\n\t\"crypto/ed25519\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/henrygd/beszel/agent\"\n\n\t\"github.com/spf13/pflag\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc TestGetAddress(t *testing.T) {", "n_tokens": 79, "primary_symbol": "TestGetAddress", "primary_kind": "function", "primary_span": [17, 17], "def_symbols": ["TestGetAddress"], "symbols": ["TestGetAddress", "package", "main", "import", "crypto", "ed25519", "path", "filepath", "testing", "github", "com", "henrygd", "beszel", "agent", "spf13", "pflag", "stretchr", "testify", "assert", "require", "golang", "org", "ssh", "func"], "doc_head": "package main\nimport (\n\t\"crypto/ed25519\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"github.com/henrygd/beszel/agent\"\n\t\"github.com/spf13/pflag\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)\nfunc TestGetAddress(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go", "rel_path": "src/cmd/agent/agent_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 18, "end_line": 94, "text": "\ttests := []struct {\n\t\tname     string\n\t\topts     cmdOptions\n\t\tenvVars  map[string]string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"default port when no config\",\n\t\t\topts:     cmdOptions{},\n\t\t\texpected: \":45876\",\n\t\t},\n\t\t{\n\t\t\tname: \"use address from flag\",\n\t\t\topts: cmdOptions{\n\t\t\t\tlisten: \"8080\",\n\t\t\t},\n\t\t\texpected: \":8080\",\n\t\t},\n\t\t{\n\t\t\tname: \"use unix socket from flag\",\n\t\t\topts: cmdOptions{\n\t\t\t\tlisten: \"/tmp/beszel.sock\",\n\t\t\t},\n\t\t\texpected: \"/tmp/beszel.sock\",\n\t\t},\n\t\t{\n\t\t\tname: \"use LISTEN env var\",\n\t\t\topts: cmdOptions{},\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"LISTEN\": \"1.2.3.4:9090\",\n\t\t\t},\n\t\t\texpected: \"1.2.3.4:9090\",\n\t\t},\n\t\t{\n\t\t\tname: \"use legacy PORT env var\",\n\t\t\topts: cmdOptions{},\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"PORT\": \"7070\",\n\t\t\t},\n\t\t\texpected: \":7070\",\n\t\t},\n\t\t{\n\t\t\tname: \"use unix socket from env var\",\n\t\t\topts: cmdOptions{\n\t\t\t\tlisten: \"\",\n\t\t\t},\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"LISTEN\": \"/tmp/beszel.sock\",\n\t\t\t},\n\t\t\texpected: \"/tmp/beszel.sock\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag takes precedence over env vars\",\n\t\t\topts: cmdOptions{\n\t\t\t\tlisten: \":8080\",\n\t\t\t},\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"LISTEN\": \":9090\",\n\t\t\t\t\"PORT\":   \"7070\",\n\t\t\t},\n\t\t\texpected: \":8080\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Setup environment\n\t\t\tfor k, v := range tt.envVars {\n\t\t\t\tt.Setenv(k, v)\n\t\t\t}\n\n\t\t\taddr := tt.opts.getAddress()\n\t\t\tassert.Equal(t, tt.expected, addr)\n\t\t})\n\t}\n}\n", "n_tokens": 471, "primary_symbol": "", "primary_kind": "", "primary_span": [18, 94], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "opts", "cmdOptions", "envVars", "map", "expected", "default", "port", "when", "config", "use", "address", "from", "flag", "listen", "unix", "socket", "tmp", "beszel", "sock", "LISTEN", "env", "var", "legacy", "PORT", "takes", "precedence", "over", "vars", "for", "range", "Run", "func", "testing", "Setup", "environment", "Setenv", "addr", "getAddress", "assert", "Equal"], "doc_head": "\ttests := []struct {\n\t\tname     string\n\t\topts     cmdOptions\n\t\tenvVars  map[string]string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"default port when no config\",\n\t\t\topts:     cmdOptions{},\n\t\t\texpected: \":45876\",\n\t\t},\n\t\t{\n\t\t\tname: \"use address from flag\",\n\t\t\topts: cmdOptions{\n\t\t\t\tlisten: \"8080\",\n\t\t\t},\n\t\t\texpected: \":8080\",\n\t\t},\n\t\t{\n\t\t\tname: \"use unix socket from flag\",\n\t\t\topts: cmdOptions{\n\t\t\t\tlisten: \"/tmp/beszel.sock\",\n\t\t\t},\n\t\t\texpected: \"/tmp/beszel.sock\",\n\t\t},\n\t\t{\n\t\t\tname: \"use LISTEN env var\",\n\t\t\topts: cmdOptions{},\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"LISTEN\": \"1.2.3.4:9090\",\n\t\t\t},\n\t\t\texpected: \"1.2.3.4:9090\",\n\t\t},\n\t\t{\n\t\t\tname: \"use legacy PORT env var\",\n\t\t\topts: cmdOptions{},\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"PORT\": \"7070\",\n\t\t\t},\n\t\t\texpected: \":7070\",\n\t\t},\n\t\t{\n\t\t\tname: \"use unix socket from env var\",\n\t\t\topts: cmdOptions{\n\t\t\t\tlisten: \"\",\n\t\t\t},\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"LISTEN\": \"/tmp/beszel.sock\",\n\t\t\t},\n\t\t\texpected: \"/tmp/beszel.sock\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go", "rel_path": "src/cmd/agent/agent_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 95, "end_line": 102, "text": "func TestLoadPublicKeys(t *testing.T) {\n\t// Generate a test key\n\t_, priv, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tsigner, err := ssh.NewSignerFromKey(priv)\n\trequire.NoError(t, err)\n\tpubKey := ssh.MarshalAuthorizedKey(signer.PublicKey())\n", "n_tokens": 68, "primary_symbol": "TestLoadPublicKeys", "primary_kind": "function", "primary_span": [95, 102], "def_symbols": ["TestLoadPublicKeys"], "symbols": ["TestLoadPublicKeys", "func", "testing", "Generate", "test", "key", "priv", "err", "ed25519", "GenerateKey", "nil", "require", "NoError", "signer", "ssh", "NewSignerFromKey", "pubKey", "MarshalAuthorizedKey", "PublicKey"], "doc_head": "func TestLoadPublicKeys(t *testing.T) {\n\t// Generate a test key\n\t_, priv, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tsigner, err := ssh.NewSignerFromKey(priv)\n\trequire.NoError(t, err)\n\tpubKey := ssh.MarshalAuthorizedKey(signer.PublicKey())"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go", "rel_path": "src/cmd/agent/agent_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 103, "end_line": 189, "text": "\ttests := []struct {\n\t\tname        string\n\t\topts        cmdOptions\n\t\tenvVars     map[string]string\n\t\tsetupFiles  map[string][]byte\n\t\twantErr     bool\n\t\terrContains string\n\t}{\n\t\t{\n\t\t\tname: \"load key from flag\",\n\t\t\topts: cmdOptions{\n\t\t\t\tkey: string(pubKey),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"load key from env var\",\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"KEY\": string(pubKey),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"load key from file\",\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"KEY_FILE\": \"testkey.pub\",\n\t\t\t},\n\t\t\tsetupFiles: map[string][]byte{\n\t\t\t\t\"testkey.pub\": pubKey,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"error when no key provided\",\n\t\t\twantErr:     true,\n\t\t\terrContains: \"no key provided\",\n\t\t},\n\t\t{\n\t\t\tname: \"error on invalid key file\",\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"KEY_FILE\": \"nonexistent.pub\",\n\t\t\t},\n\t\t\twantErr:     true,\n\t\t\terrContains: \"failed to read key file\",\n\t\t},\n\t\t{\n\t\t\tname: \"error on invalid key data\",\n\t\t\topts: cmdOptions{\n\t\t\t\tkey: \"invalid-key-data\",\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Create a temporary directory for test files\n\t\t\tif len(tt.setupFiles) > 0 {\n\t\t\t\ttmpDir := t.TempDir()\n\t\t\t\tfor name, content := range tt.setupFiles {\n\t\t\t\t\tpath := filepath.Join(tmpDir, name)\n\t\t\t\t\terr := os.WriteFile(path, content, 0600)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tif tt.envVars != nil {\n\t\t\t\t\t\ttt.envVars[\"KEY_FILE\"] = path\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set up environment\n\t\t\tfor k, v := range tt.envVars {\n\t\t\t\tt.Setenv(k, v)\n\t\t\t}\n\n\t\t\tkeys, err := tt.opts.loadPublicKeys()\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tif tt.errContains != \"\" {\n\t\t\t\t\tassert.Contains(t, err.Error(), tt.errContains)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Len(t, keys, 1)\n\t\t\tassert.Equal(t, signer.PublicKey().Type(), keys[0].Type())\n\t\t})\n\t}\n}\n", "n_tokens": 545, "primary_symbol": "", "primary_kind": "", "primary_span": [103, 189], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "opts", "cmdOptions", "envVars", "map", "setupFiles", "byte", "wantErr", "bool", "errContains", "load", "key", "from", "flag", "pubKey", "env", "var", "KEY", "file", "KEY_FILE", "testkey", "pub", "error", "when", "provided", "true", "invalid", "nonexistent", "failed", "read", "data", "for", "range", "Run", "func", "testing", "Create", "temporary", "directory", "test", "files", "len", "tmpDir", "TempDir", "content", "path", "filepath", "Join", "err", "WriteFile", "require", "NoError", "nil", "Set", "environment", "Setenv", "keys", "loadPublicKeys", "assert", "Error", "Contains", "return", "Len", "Equal", "signer", "PublicKey", "Type"], "doc_head": "\ttests := []struct {\n\t\tname        string\n\t\topts        cmdOptions\n\t\tenvVars     map[string]string\n\t\tsetupFiles  map[string][]byte\n\t\twantErr     bool\n\t\terrContains string\n\t}{\n\t\t{\n\t\t\tname: \"load key from flag\",\n\t\t\topts: cmdOptions{\n\t\t\t\tkey: string(pubKey),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"load key from env var\",\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"KEY\": string(pubKey),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"load key from file\",\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"KEY_FILE\": \"testkey.pub\",\n\t\t\t},\n\t\t\tsetupFiles: map[string][]byte{\n\t\t\t\t\"testkey.pub\": pubKey,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"error when no key provided\",\n\t\t\twantErr:     true,\n\t\t\terrContains: \"no key provided\",\n\t\t},\n\t\t{\n\t\t\tname: \"error on invalid key file\",\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"KEY_FILE\": \"nonexistent.pub\",\n\t\t\t},\n\t\t\twantErr:     true,\n\t\t\terrContains: \"failed to read key file\",\n\t\t},\n\t\t{\n\t\t\tname: \"error on invalid key data\",\n\t\t\topts: cmdOptions{\n\t\t\t\tkey: \"invalid-key-data\",\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go", "rel_path": "src/cmd/agent/agent_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 190, "end_line": 190, "text": "func TestGetNetwork(t *testing.T) {", "n_tokens": 10, "primary_symbol": "TestGetNetwork", "primary_kind": "function", "primary_span": [190, 190], "def_symbols": ["TestGetNetwork"], "symbols": ["TestGetNetwork", "func", "testing"], "doc_head": "func TestGetNetwork(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go", "rel_path": "src/cmd/agent/agent_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 191, "end_line": 243, "text": "\ttests := []struct {\n\t\tname     string\n\t\topts     cmdOptions\n\t\tenvVars  map[string]string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"NETWORK env var\",\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"NETWORK\": \"tcp4\",\n\t\t\t},\n\t\t\texpected: \"tcp4\",\n\t\t},\n\t\t{\n\t\t\tname:     \"only port\",\n\t\t\topts:     cmdOptions{listen: \"8080\"},\n\t\t\texpected: \"tcp\",\n\t\t},\n\t\t{\n\t\t\tname:     \"ipv4 address\",\n\t\t\topts:     cmdOptions{listen: \"1.2.3.4:8080\"},\n\t\t\texpected: \"tcp\",\n\t\t},\n\t\t{\n\t\t\tname:     \"ipv6 address\",\n\t\t\topts:     cmdOptions{listen: \"[2001:db8::1]:8080\"},\n\t\t\texpected: \"tcp\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unix network\",\n\t\t\topts:     cmdOptions{listen: \"/tmp/beszel.sock\"},\n\t\t\texpected: \"unix\",\n\t\t},\n\t\t{\n\t\t\tname:     \"env var network\",\n\t\t\topts:     cmdOptions{listen: \":8080\"},\n\t\t\tenvVars:  map[string]string{\"NETWORK\": \"tcp4\"},\n\t\t\texpected: \"tcp4\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Setup environment\n\t\t\tfor k, v := range tt.envVars {\n\t\t\t\tt.Setenv(k, v)\n\t\t\t}\n\t\t\tnetwork := agent.GetNetwork(tt.opts.listen)\n\t\t\tassert.Equal(t, tt.expected, network)\n\t\t})\n\t}\n}\n", "n_tokens": 351, "primary_symbol": "", "primary_kind": "", "primary_span": [191, 243], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "opts", "cmdOptions", "envVars", "map", "expected", "NETWORK", "env", "var", "tcp4", "only", "port", "listen", "tcp", "ipv4", "address", "ipv6", "db8", "unix", "network", "tmp", "beszel", "sock", "for", "range", "Run", "func", "testing", "Setup", "environment", "Setenv", "agent", "GetNetwork", "assert", "Equal"], "doc_head": "\ttests := []struct {\n\t\tname     string\n\t\topts     cmdOptions\n\t\tenvVars  map[string]string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"NETWORK env var\",\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"NETWORK\": \"tcp4\",\n\t\t\t},\n\t\t\texpected: \"tcp4\",\n\t\t},\n\t\t{\n\t\t\tname:     \"only port\",\n\t\t\topts:     cmdOptions{listen: \"8080\"},\n\t\t\texpected: \"tcp\",\n\t\t},\n\t\t{\n\t\t\tname:     \"ipv4 address\",\n\t\t\topts:     cmdOptions{listen: \"1.2.3.4:8080\"},\n\t\t\texpected: \"tcp\",\n\t\t},\n\t\t{\n\t\t\tname:     \"ipv6 address\",\n\t\t\topts:     cmdOptions{listen: \"[2001:db8::1]:8080\"},\n\t\t\texpected: \"tcp\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unix network\",\n\t\t\topts:     cmdOptions{listen: \"/tmp/beszel.sock\"},\n\t\t\texpected: \"unix\",\n\t\t},\n\t\t{\n\t\t\tname:     \"env var network\",\n\t\t\topts:     cmdOptions{listen: \":8080\"},\n\t\t\tenvVars:  map[string]string{\"NETWORK\": \"tcp4\"},\n\t\t\texpected: \"tcp4\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Setup environment\n\t\t\tfor k, v := range tt.envVars {\n\t\t\t\tt.Setenv(k, v)\n\t\t\t}\n\t\t\tnetwork := agent.GetNetwork(tt.opts.listen)\n\t\t\tassert.Equal(t, tt.expected, network)\n\t\t})\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go", "rel_path": "src/cmd/agent/agent_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 244, "end_line": 251, "text": "func TestParseFlags(t *testing.T) {\n\t// Save original command line arguments and restore after test\n\toldArgs := os.Args\n\tdefer func() {\n\t\tos.Args = oldArgs\n\t\tpflag.CommandLine = pflag.NewFlagSet(os.Args[0], pflag.ExitOnError)\n\t}()\n", "n_tokens": 62, "primary_symbol": "TestParseFlags", "primary_kind": "function", "primary_span": [244, 251], "def_symbols": ["TestParseFlags"], "symbols": ["TestParseFlags", "func", "testing", "Save", "original", "command", "line", "arguments", "and", "restore", "after", "test", "oldArgs", "Args", "defer", "pflag", "CommandLine", "NewFlagSet", "ExitOnError"], "doc_head": "func TestParseFlags(t *testing.T) {\n\t// Save original command line arguments and restore after test\n\toldArgs := os.Args\n\tdefer func() {\n\t\tos.Args = oldArgs\n\t\tpflag.CommandLine = pflag.NewFlagSet(os.Args[0], pflag.ExitOnError)\n\t}()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/agent/agent_test.go", "rel_path": "src/cmd/agent/agent_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 252, "end_line": 337, "text": "\ttests := []struct {\n\t\tname     string\n\t\targs     []string\n\t\texpected cmdOptions\n\t}{\n\t\t{\n\t\t\tname: \"no flags\",\n\t\t\targs: []string{\"cmd\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"\",\n\t\t\t\tlisten: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"key flag only\",\n\t\t\targs: []string{\"cmd\", \"-key\", \"testkey\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"testkey\",\n\t\t\t\tlisten: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"key flag double dash\",\n\t\t\targs: []string{\"cmd\", \"--key\", \"testkey\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"testkey\",\n\t\t\t\tlisten: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"key flag short\",\n\t\t\targs: []string{\"cmd\", \"-k\", \"testkey\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"testkey\",\n\t\t\t\tlisten: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"addr flag only\",\n\t\t\targs: []string{\"cmd\", \"-listen\", \":8080\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"\",\n\t\t\t\tlisten: \":8080\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"addr flag double dash\",\n\t\t\targs: []string{\"cmd\", \"--listen\", \":8080\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"\",\n\t\t\t\tlisten: \":8080\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"addr flag short\",\n\t\t\targs: []string{\"cmd\", \"-l\", \":8080\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"\",\n\t\t\t\tlisten: \":8080\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"both flags\",\n\t\t\targs: []string{\"cmd\", \"-key\", \"testkey\", \"-listen\", \":8080\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"testkey\",\n\t\t\t\tlisten: \":8080\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Reset flags for each test\n\t\t\tpflag.CommandLine = pflag.NewFlagSet(tt.args[0], pflag.ExitOnError)\n\t\t\tos.Args = tt.args\n\n\t\t\tvar opts cmdOptions\n\t\t\topts.parse()\n\t\t\tpflag.Parse()\n\n\t\t\tassert.Equal(t, tt.expected, opts)\n\t\t})\n\t}\n}\n", "n_tokens": 521, "primary_symbol": "", "primary_kind": "", "primary_span": [252, 337], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "args", "expected", "cmdOptions", "flags", "cmd", "key", "listen", "flag", "only", "testkey", "double", "dash", "short", "addr", "both", "for", "range", "Run", "func", "testing", "Reset", "each", "test", "pflag", "CommandLine", "NewFlagSet", "ExitOnError", "Args", "var", "opts", "parse", "Parse", "assert", "Equal"], "doc_head": "\ttests := []struct {\n\t\tname     string\n\t\targs     []string\n\t\texpected cmdOptions\n\t}{\n\t\t{\n\t\t\tname: \"no flags\",\n\t\t\targs: []string{\"cmd\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"\",\n\t\t\t\tlisten: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"key flag only\",\n\t\t\targs: []string{\"cmd\", \"-key\", \"testkey\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"testkey\",\n\t\t\t\tlisten: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"key flag double dash\",\n\t\t\targs: []string{\"cmd\", \"--key\", \"testkey\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"testkey\",\n\t\t\t\tlisten: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"key flag short\",\n\t\t\targs: []string{\"cmd\", \"-k\", \"testkey\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"testkey\",\n\t\t\t\tlisten: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"addr flag only\",\n\t\t\targs: []string{\"cmd\", \"-listen\", \":8080\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"\",\n\t\t\t\tlisten: \":8080\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"addr flag double dash\",\n\t\t\targs: []string{\"cmd\", \"--listen\", \":8080\"},\n\t\t\texpected: cmdOptions{\n\t\t\t\tkey:    \"\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/hub/hub.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/hub/hub.go", "rel_path": "src/cmd/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 18, "text": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/hub\"\n\t_ \"github.com/henrygd/beszel/src/migrations\"\n\n\t\"github.com/pocketbase/pocketbase\"\n\t\"github.com/pocketbase/pocketbase/plugins/migratecmd\"\n\t\"github.com/spf13/cobra\"\n)\n", "n_tokens": 96, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 18], "def_symbols": [], "symbols": ["package", "main", "import", "fmt", "log", "net", "http", "time", "github", "com", "henrygd", "beszel", "src", "hub", "migrations", "pocketbase", "plugins", "migratecmd", "spf13", "cobra"], "doc_head": "package main\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/hub\"\n\t_ \"github.com/henrygd/beszel/src/migrations\"\n\t\"github.com/pocketbase/pocketbase\"\n\t\"github.com/pocketbase/pocketbase/plugins/migratecmd\"\n\t\"github.com/spf13/cobra\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/hub/hub.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/hub/hub.go", "rel_path": "src/cmd/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 19, "end_line": 36, "text": "func main() {\n\t// handle health check first to prevent unneeded execution\n\tif len(os.Args) > 3 && os.Args[1] == \"health\" {\n\t\turl := os.Args[3]\n\t\tif err := checkHealth(url); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Print(\"ok\")\n\t\treturn\n\t}\n\n\tbaseApp := getBaseApp()\n\th := hub.NewHub(baseApp)\n\tif err := h.StartHub(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n", "n_tokens": 108, "primary_symbol": "main", "primary_kind": "function", "primary_span": [19, 36], "def_symbols": ["main"], "symbols": ["main", "func", "handle", "health", "check", "first", "prevent", "unneeded", "execution", "len", "Args", "url", "err", "checkHealth", "nil", "log", "Fatal", "fmt", "Print", "return", "baseApp", "getBaseApp", "hub", "NewHub", "StartHub"], "doc_head": "func main() {\n\t// handle health check first to prevent unneeded execution\n\tif len(os.Args) > 3 && os.Args[1] == \"health\" {\n\t\turl := os.Args[3]\n\t\tif err := checkHealth(url); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Print(\"ok\")\n\t\treturn\n\t}\n\tbaseApp := getBaseApp()\n\th := hub.NewHub(baseApp)\n\tif err := h.StartHub(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/hub/hub.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/hub/hub.go", "rel_path": "src/cmd/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 37, "end_line": 67, "text": "// getBaseApp creates a new PocketBase app with the default config\nfunc getBaseApp() *pocketbase.PocketBase {\n\tisDev := os.Getenv(\"ENV\") == \"dev\"\n\n\tbaseApp := pocketbase.NewWithConfig(pocketbase.Config{\n\t\tDefaultDataDir: beszel.AppName + \"_data\",\n\t\tDefaultDev:     isDev,\n\t})\n\tbaseApp.RootCmd.Version = beszel.Version\n\tbaseApp.RootCmd.Use = beszel.AppName\n\tbaseApp.RootCmd.Short = \"\"\n\t// add update command\n\tupdateCmd := &cobra.Command{\n\t\tUse:   \"update\",\n\t\tShort: \"Update \" + beszel.AppName + \" to the latest version\",\n\t\tRun:   hub.Update,\n\t}\n\tupdateCmd.Flags().Bool(\"china-mirrors\", false, \"Use mirror (gh.beszel.dev) instead of GitHub\")\n\tbaseApp.RootCmd.AddCommand(updateCmd)\n\t// add health command\n\tbaseApp.RootCmd.AddCommand(newHealthCmd())\n\n\t// enable auto creation of migration files when making collection changes in the Admin UI\n\tmigratecmd.MustRegister(baseApp, baseApp.RootCmd, migratecmd.Config{\n\t\tAutomigrate: isDev,\n\t\tDir:         \"../../migrations\",\n\t})\n\n\treturn baseApp\n}\n", "n_tokens": 262, "primary_symbol": "getBaseApp", "primary_kind": "function", "primary_span": [38, 67], "def_symbols": ["getBaseApp"], "symbols": ["getBaseApp", "creates", "new", "PocketBase", "app", "with", "the", "default", "config", "func", "pocketbase", "isDev", "Getenv", "ENV", "dev", "baseApp", "NewWithConfig", "Config", "DefaultDataDir", "beszel", "AppName", "_data", "DefaultDev", "RootCmd", "Version", "Use", "Short", "add", "update", "command", "updateCmd", "cobra", "Command", "Update", "latest", "version", "Run", "hub", "Flags", "Bool", "china", "mirrors", "false", "mirror", "instead", "GitHub", "AddCommand", "health", "newHealthCmd", "enable", "auto", "creation", "migration", "files", "when", "making", "collection", "changes", "Admin", "migratecmd", "MustRegister", "Automigrate", "Dir", "migrations", "return"], "doc_head": "// getBaseApp creates a new PocketBase app with the default config\nfunc getBaseApp() *pocketbase.PocketBase {\n\tisDev := os.Getenv(\"ENV\") == \"dev\"\n\tbaseApp := pocketbase.NewWithConfig(pocketbase.Config{\n\t\tDefaultDataDir: beszel.AppName + \"_data\",\n\t\tDefaultDev:     isDev,\n\t})\n\tbaseApp.RootCmd.Version = beszel.Version\n\tbaseApp.RootCmd.Use = beszel.AppName\n\tbaseApp.RootCmd.Short = \"\"\n\t// add update command\n\tupdateCmd := &cobra.Command{\n\t\tUse:   \"update\",\n\t\tShort: \"Update \" + beszel.AppName + \" to the latest version\",\n\t\tRun:   hub.Update,\n\t}\n\tupdateCmd.Flags().Bool(\"china-mirrors\", false, \"Use mirror (gh.beszel.dev) instead of GitHub\")\n\tbaseApp.RootCmd.AddCommand(updateCmd)\n\t// add health command\n\tbaseApp.RootCmd.AddCommand(newHealthCmd())\n\t// enable auto creation of migration files when making collection changes in the Admin UI\n\tmigratecmd.MustRegister(baseApp, baseApp.RootCmd, migratecmd.Config{\n\t\tAutomigrate: isDev,\n\t\tDir:         \"../../migrations\",\n\t})\n\treturn baseApp\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/hub/hub.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/hub/hub.go", "rel_path": "src/cmd/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 68, "end_line": 85, "text": "func newHealthCmd() *cobra.Command {\n\tvar baseURL string\n\n\thealthCmd := &cobra.Command{\n\t\tUse:   \"health\",\n\t\tShort: \"Check health of running hub\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tif err := checkHealth(baseURL); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tos.Exit(0)\n\t\t},\n\t}\n\thealthCmd.Flags().StringVar(&baseURL, \"url\", \"\", \"base URL\")\n\thealthCmd.MarkFlagRequired(\"url\")\n\treturn healthCmd\n}\n", "n_tokens": 118, "primary_symbol": "newHealthCmd", "primary_kind": "function", "primary_span": [68, 85], "def_symbols": ["newHealthCmd"], "symbols": ["newHealthCmd", "func", "cobra", "Command", "var", "baseURL", "string", "healthCmd", "Use", "health", "Short", "Check", "running", "hub", "Run", "cmd", "args", "err", "checkHealth", "nil", "log", "Fatal", "Exit", "Flags", "StringVar", "url", "base", "URL", "MarkFlagRequired", "return"], "doc_head": "func newHealthCmd() *cobra.Command {\n\tvar baseURL string\n\thealthCmd := &cobra.Command{\n\t\tUse:   \"health\",\n\t\tShort: \"Check health of running hub\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tif err := checkHealth(baseURL); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tos.Exit(0)\n\t\t},\n\t}\n\thealthCmd.Flags().StringVar(&baseURL, \"url\", \"\", \"base URL\")\n\thealthCmd.MarkFlagRequired(\"url\")\n\treturn healthCmd\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/hub/hub.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/cmd/hub/hub.go", "rel_path": "src/cmd/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 86, "end_line": 103, "text": "// checkHealth checks the health of the hub.\nfunc checkHealth(baseURL string) error {\n\tclient := &http.Client{\n\t\tTimeout: time.Second * 3,\n\t}\n\thealthURL := baseURL + \"/api/health\"\n\tresp, err := client.Get(healthURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\treturn fmt.Errorf(\"%s returned status %d\", healthURL, resp.StatusCode)\n\t}\n\treturn nil\n}\n", "n_tokens": 104, "primary_symbol": "checkHealth", "primary_kind": "function", "primary_span": [87, 103], "def_symbols": ["checkHealth"], "symbols": ["checkHealth", "checks", "the", "health", "hub", "func", "baseURL", "string", "error", "client", "http", "Client", "Timeout", "time", "Second", "healthURL", "api", "resp", "err", "Get", "nil", "return", "defer", "Body", "Close", "StatusCode", "fmt", "Errorf", "returned", "status"], "doc_head": "// checkHealth checks the health of the hub.\nfunc checkHealth(baseURL string) error {\n\tclient := &http.Client{\n\t\tTimeout: time.Second * 3,\n\t}\n\thealthURL := baseURL + \"/api/health\"\n\tresp, err := client.Get(healthURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn fmt.Errorf(\"%s returned status %d\", healthURL, resp.StatusCode)\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/migrations/0_collections_snapshot_0_12_0_7.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/migrations/0_collections_snapshot_0_12_0_7.go", "rel_path": "src/migrations/0_collections_snapshot_0_12_0_7.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 8, "text": "package migrations\n\nimport (\n\t\"github.com/google/uuid\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\tm \"github.com/pocketbase/pocketbase/migrations\"\n)\n", "n_tokens": 37, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 8], "def_symbols": [], "symbols": ["package", "migrations", "import", "github", "com", "google", "uuid", "pocketbase", "core"], "doc_head": "package migrations\nimport (\n\t\"github.com/google/uuid\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\tm \"github.com/pocketbase/pocketbase/migrations\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/migrations/0_collections_snapshot_0_12_0_7.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/migrations/0_collections_snapshot_0_12_0_7.go", "rel_path": "src/migrations/0_collections_snapshot_0_12_0_7.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 9, "end_line": 901, "text": "func init() {\n\tm.Register(func(app core.App) error {\n\t\t// update collections\n\t\tjsonData := `[\n\t{\n\t\t\"id\": \"elngm8x1l60zi2v\",\n\t\t\"listRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"viewRule\": \"\",\n\t\t\"createRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"updateRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"deleteRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"name\": \"alerts\",\n\t\t\"type\": \"base\",\n\t\t\"fields\": [\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"[a-z0-9]{15}\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"text3208210256\",\n\t\t\t\t\"max\": 15,\n\t\t\t\t\"min\": 15,\n\t\t\t\t\"name\": \"id\",\n\t\t\t\t\"pattern\": \"^[a-z0-9]+$\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": true,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"cascadeDelete\": true,\n\t\t\t\t\"collectionId\": \"_pb_users_auth_\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"hn5ly3vi\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"minSelect\": 0,\n\t\t\t\t\"name\": \"user\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"relation\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"cascadeDelete\": true,\n\t\t\t\t\"collectionId\": \"2hz5ncl8tizk5nx\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"g5sl3jdg\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"minSelect\": 0,\n\t\t\t\t\"name\": \"system\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"relation\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"zj3ingrv\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"name\": \"name\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"select\",\n\t\t\t\t\"values\": [\n\t\t\t\t\t\"Status\",\n\t\t\t\t\t\"CPU\",\n\t\t\t\t\t\"Memory\",\n\t\t\t\t\t\"Disk\",\n\t\t\t\t\t\"Temperature\",\n\t\t\t\t\t\"Bandwidth\",\n\t\t\t\t\t\"LoadAvg1\",\n\t\t\t\t\t\"LoadAvg5\",\n\t\t\t\t\t\"LoadAvg15\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"o2ablxvn\",\n\t\t\t\t\"max\": null,\n\t\t\t\t\"min\": null,\n\t\t\t\t\"name\": \"value\",\n\t\t\t\t\"onlyInt\": false,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"number\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"fstdehcq\",\n\t\t\t\t\"max\": 60,\n\t\t\t\t\"min\": null,\n\t\t\t\t\"name\": \"min\",\n\t\t\t\t\"onlyInt\": true,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"number\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"6hgdf6hs\",\n\t\t\t\t\"name\": \"triggered\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"bool\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate2990389176\",\n\t\t\t\t\"name\": \"created\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": false,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate3332085495\",\n\t\t\t\t\"name\": \"updated\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": true,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t}\n\t\t],\n\t\t\"indexes\": [\n\t\t\t\"CREATE UNIQUE INDEX ` + \"`\" + `idx_MnhEt21L5r` + \"`\" + ` ON ` + \"`\" + `alerts` + \"`\" + ` (\\n  ` + \"`\" + `user` + \"`\" + `,\\n  ` + \"`\" + `system` + \"`\" + `,\\n  ` + \"`\" + `name` + \"`\" + `\\n)\"\n\t\t],\n\t\t\"system\": false\n\t},\n\t{\n\t\t\"id\": \"pbc_1697146157\",\n\t\t\"listRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"viewRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"createRule\": null,\n\t\t\"updateRule\": null,\n\t\t\"deleteRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"name\": \"alerts_history\",\n\t\t\"type\": \"base\",\n\t\t\"fields\": [\n\t\t\t{\n\t\t\t\t\t\"autogeneratePattern\": \"[a-z0-9]{15}\",\n\t\t\t\t\t\"hidden\": false,\n\t\t\t\t\t\"id\": \"text3208210256\",\n\t\t\t\t\t\"max\": 15,\n\t\t\t\t\t\"min\": 15,\n\t\t\t\t\t\"name\": \"id\",\n\t\t\t\t\t\"pattern\": \"^[a-z0-9]+$\",\n\t\t\t\t\t\"presentable\": false,\n\t\t\t\t\t\"primaryKey\": true,\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"system\": true,\n\t\t\t\t\t\"type\": \"text\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"cascadeDelete\": true,\n\t\t\t\t\t\"collectionId\": \"_pb_users_auth_\",\n\t\t\t\t\t\"hidden\": false,\n\t\t\t\t\t\"id\": \"relation2375276105\",\n\t\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\t\"minSelect\": 0,\n\t\t\t\t\t\"name\": \"user\",\n\t\t\t\t\t\"presentable\": false,\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"type\": \"relation\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"cascadeDelete\": true,\n\t\t\t\t\t\"collectionId\": \"2hz5ncl8tizk5nx\",\n\t\t\t\t\t\"hidden\": false,\n\t\t\t\t\t\"id\": \"relation3377271179\",\n\t\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\t\"minSelect\": 0,\n\t\t\t\t\t\"name\": \"system\",\n\t\t\t\t\t\"presentable\": false,\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"type\": \"relation\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"autogeneratePattern\": \"\",\n\t\t\t\t\t\"hidden\": false,\n\t\t\t\t\t\"id\": \"text2466471794\",\n\t\t\t\t\t\"max\": 0,\n\t\t\t\t\t\"min\": 0,\n\t\t\t\t\t\"name\": \"alert_id\",\n\t\t\t\t\t\"pattern\": \"\",\n\t\t\t\t\t\"presentable\": false,\n\t\t\t\t\t\"primaryKey\": false,\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"type\": \"text\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"autogeneratePattern\": \"\",\n\t\t\t\t\t\"hidden\": false,\n\t\t\t\t\t\"id\": \"text1579384326\",\n\t\t\t\t\t\"max\": 0,\n\t\t\t\t\t\"min\": 0,\n\t\t\t\t\t\"name\": \"name\",\n\t\t\t\t\t\"pattern\": \"\",\n\t\t\t\t\t\"presentable\": false,\n\t\t\t\t\t\"primaryKey\": false,\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"type\": \"text\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"hidden\": false,\n\t\t\t\t\t\"id\": \"number494360628\",\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"name\": \"value\",\n\t\t\t\t\t\"onlyInt\": false,\n\t\t\t\t\t\"presentable\": false,\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"type\": \"number\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"hidden\": false,\n\t\t\t\t\t\"id\": \"autodate2990389176\",\n\t\t\t\t\t\"name\": \"created\",\n\t\t\t\t\t\"onCreate\": true,\n\t\t\t\t\t\"onUpdate\": false,\n\t\t\t\t\t\"presentable\": false,\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"type\": \"autodate\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"hidden\": false,\n\t\t\t\t\t\"id\": \"date2276568630\",\n\t\t\t\t\t\"max\": \"\",\n\t\t\t\t\t\"min\": \"\",\n\t\t\t\t\t\"name\": \"resolved\",\n\t\t\t\t\t\"presentable\": false,\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"type\": \"date\"\n\t\t\t\t}\n\t\t],\n\t\t\"indexes\": [\n\t\t\t\"CREATE INDEX ` + \"`\" + `idx_YdGnup5aqB` + \"`\" + ` ON ` + \"`\" + `alerts_history` + \"`\" + ` (` + \"`\" + `user` + \"`\" + `)\",\n\t\t\t\"CREATE INDEX ` + \"`\" + `idx_taLet9VdME` + \"`\" + ` ON ` + \"`\" + `alerts_history` + \"`\" + ` (` + \"`\" + `created` + \"`\" + `)\"\n\t\t],\n\t\t\"system\": false\n\t},\n\t{\n\t\t\"id\": \"juohu4jipgc13v7\",\n\t\t\"listRule\": \"@request.auth.id != \\\"\\\"\",\n\t\t\"viewRule\": null,\n\t\t\"createRule\": null,\n\t\t\"updateRule\": null,\n\t\t\"deleteRule\": null,\n\t\t\"name\": \"container_stats\",\n\t\t\"type\": \"base\",\n\t\t\"fields\": [\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"[a-z0-9]{15}\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"text3208210256\",\n\t\t\t\t\"max\": 15,\n\t\t\t\t\"min\": 15,\n\t\t\t\t\"name\": \"id\",\n\t\t\t\t\"pattern\": \"^[a-z0-9]+$\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": true,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"cascadeDelete\": true,\n\t\t\t\t\"collectionId\": \"2hz5ncl8tizk5nx\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"hutcu6ps\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"minSelect\": 0,\n\t\t\t\t\"name\": \"system\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"relation\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"r39hhnil\",\n\t\t\t\t\"maxSize\": 2000000,\n\t\t\t\t\"name\": \"stats\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"json\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"vo7iuj96\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"name\": \"type\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"select\",\n\t\t\t\t\"values\": [\n\t\t\t\t\t\"1m\",\n\t\t\t\t\t\"10m\",\n\t\t\t\t\t\"20m\",\n\t\t\t\t\t\"120m\",\n\t\t\t\t\t\"480m\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate2990389176\",\n\t\t\t\t\"name\": \"created\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": false,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate3332085495\",\n\t\t\t\t\"name\": \"updated\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": true,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t}\n\t\t],\n\t\t\"indexes\": [\n\t\t\t\"CREATE INDEX ` + \"`\" + `idx_d87OiXGZD8` + \"`\" + ` ON ` + \"`\" + `container_stats` + \"`\" + ` (\\n  ` + \"`\" + `system` + \"`\" + `,\\n  ` + \"`\" + `type` + \"`\" + `,\\n  ` + \"`\" + `created` + \"`\" + `\\n)\"\n\t\t],\n\t\t\"system\": false\n\t},\n\t{\n\t\t\"id\": \"pbc_3663931638\",\n\t\t\"listRule\": \"@request.auth.id != \\\"\\\" && system.users.id ?= @request.auth.id\",\n\t\t\"viewRule\": \"@request.auth.id != \\\"\\\" && system.users.id ?= @request.auth.id\",\n\t\t\"createRule\": \"@request.auth.id != \\\"\\\" && system.users.id ?= @request.auth.id && @request.auth.role != \\\"readonly\\\"\",\n\t\t\"updateRule\": \"@request.auth.id != \\\"\\\" && system.users.id ?= @request.auth.id && @request.auth.role != \\\"readonly\\\"\",\n\t\t\"deleteRule\": null,\n\t\t\"name\": \"fingerprints\",\n\t\t\"type\": \"base\",\n\t\t\"fields\": [\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"[a-z0-9]{9}\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"text3208210256\",\n\t\t\t\t\"max\": 15,\n\t\t\t\t\"min\": 9,\n\t\t\t\t\"name\": \"id\",\n\t\t\t\t\"pattern\": \"^[a-z0-9]+$\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": true,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"cascadeDelete\": true,\n\t\t\t\t\"collectionId\": \"2hz5ncl8tizk5nx\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"relation3377271179\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"minSelect\": 0,\n\t\t\t\t\"name\": \"system\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"relation\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"[a-zA-Z9-9]{20}\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"text1597481275\",\n\t\t\t\t\"max\": 255,\n\t\t\t\t\"min\": 9,\n\t\t\t\t\"name\": \"token\",\n\t\t\t\t\"pattern\": \"\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"text4228609354\",\n\t\t\t\t\"max\": 255,\n\t\t\t\t\"min\": 9,\n\t\t\t\t\"name\": \"fingerprint\",\n\t\t\t\t\"pattern\": \"\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate3332085495\",\n\t\t\t\t\"name\": \"updated\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": true,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t}\n\t\t],\n\t\t\"indexes\": [\n\t\t\t\"CREATE INDEX ` + \"`\" + `idx_p9qZlu26po` + \"`\" + ` ON ` + \"`\" + `fingerprints` + \"`\" + ` (` + \"`\" + `token` + \"`\" + `)\",\n\t\t\t\"CREATE UNIQUE INDEX ` + \"`\" + `idx_ngboulGMYw` + \"`\" + ` ON ` + \"`\" + `fingerprints` + \"`\" + ` (` + \"`\" + `system` + \"`\" + `)\"\n\t\t],\n\t\t\"system\": false\n\t},\n\t{\n\t\t\"id\": \"ej9oowivz8b2mht\",\n\t\t\"listRule\": \"@request.auth.id != \\\"\\\"\",\n\t\t\"viewRule\": null,\n\t\t\"createRule\": null,\n\t\t\"updateRule\": null,\n\t\t\"deleteRule\": null,\n\t\t\"name\": \"system_stats\",\n\t\t\"type\": \"base\",\n\t\t\"fields\": [\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"[a-z0-9]{15}\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"text3208210256\",\n\t\t\t\t\"max\": 15,\n\t\t\t\t\"min\": 15,\n\t\t\t\t\"name\": \"id\",\n\t\t\t\t\"pattern\": \"^[a-z0-9]+$\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": true,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"cascadeDelete\": true,\n\t\t\t\t\"collectionId\": \"2hz5ncl8tizk5nx\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"h9sg148r\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"minSelect\": 0,\n\t\t\t\t\"name\": \"system\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"relation\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"azftn0be\",\n\t\t\t\t\"maxSize\": 2000000,\n\t\t\t\t\"name\": \"stats\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"json\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"m1ekhli3\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"name\": \"type\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"select\",\n\t\t\t\t\"values\": [\n\t\t\t\t\t\"1m\",\n\t\t\t\t\t\"10m\",\n\t\t\t\t\t\"20m\",\n\t\t\t\t\t\"120m\",\n\t\t\t\t\t\"480m\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate2990389176\",\n\t\t\t\t\"name\": \"created\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": false,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate3332085495\",\n\t\t\t\t\"name\": \"updated\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": true,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t}\n\t\t],\n\t\t\"indexes\": [\n\t\t\t\"CREATE INDEX ` + \"`\" + `idx_GxIee0j` + \"`\" + ` ON ` + \"`\" + `system_stats` + \"`\" + ` (\\n  ` + \"`\" + `system` + \"`\" + `,\\n  ` + \"`\" + `type` + \"`\" + `,\\n  ` + \"`\" + `created` + \"`\" + `\\n)\"\n\t\t],\n\t\t\"system\": false\n\t},\n\t{\n\t\t\"id\": \"4afacsdnlu8q8r2\",\n\t\t\"listRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"viewRule\": null,\n\t\t\"createRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"updateRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"deleteRule\": null,\n\t\t\"name\": \"user_settings\",\n\t\t\"type\": \"base\",\n\t\t\"fields\": [\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"[a-z0-9]{15}\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"text3208210256\",\n\t\t\t\t\"max\": 15,\n\t\t\t\t\"min\": 15,\n\t\t\t\t\"name\": \"id\",\n\t\t\t\t\"pattern\": \"^[a-z0-9]+$\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": true,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"cascadeDelete\": true,\n\t\t\t\t\"collectionId\": \"_pb_users_auth_\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"d5vztyxa\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"minSelect\": 0,\n\t\t\t\t\"name\": \"user\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"relation\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"xcx4qgqq\",\n\t\t\t\t\"maxSize\": 2000000,\n\t\t\t\t\"name\": \"settings\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"json\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate2990389176\",\n\t\t\t\t\"name\": \"created\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": false,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate3332085495\",\n\t\t\t\t\"name\": \"updated\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": true,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t}\n\t\t],\n\t\t\"indexes\": [\n\t\t\t\"CREATE UNIQUE INDEX ` + \"`\" + `idx_30Lwgf2` + \"`\" + ` ON ` + \"`\" + `user_settings` + \"`\" + ` (` + \"`\" + `user` + \"`\" + `)\"\n\t\t],\n\t\t\"system\": false\n\t},\n\t{\n\t\t\"id\": \"2hz5ncl8tizk5nx\",\n\t\t\"listRule\": \"@request.auth.id != \\\"\\\" && users.id ?= @request.auth.id\",\n\t\t\"viewRule\": \"@request.auth.id != \\\"\\\" && users.id ?= @request.auth.id\",\n\t\t\"createRule\": \"@request.auth.id != \\\"\\\" && users.id ?= @request.auth.id && @request.auth.role != \\\"readonly\\\"\",\n\t\t\"updateRule\": \"@request.auth.id != \\\"\\\" && users.id ?= @request.auth.id && @request.auth.role != \\\"readonly\\\"\",\n\t\t\"deleteRule\": \"@request.auth.id != \\\"\\\" && users.id ?= @request.auth.id && @request.auth.role != \\\"readonly\\\"\",\n\t\t\"name\": \"systems\",\n\t\t\"type\": \"base\",\n\t\t\"fields\": [\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"[a-z0-9]{15}\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"text3208210256\",\n\t\t\t\t\"max\": 15,\n\t\t\t\t\"min\": 15,\n\t\t\t\t\"name\": \"id\",\n\t\t\t\t\"pattern\": \"^[a-z0-9]+$\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": true,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"7xloxkwk\",\n\t\t\t\t\"max\": 0,\n\t\t\t\t\"min\": 0,\n\t\t\t\t\"name\": \"name\",\n\t\t\t\t\"pattern\": \"\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"waj7seaf\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"name\": \"status\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"select\",\n\t\t\t\t\"values\": [\n\t\t\t\t\t\"up\",\n\t\t\t\t\t\"down\",\n\t\t\t\t\t\"paused\",\n\t\t\t\t\t\"pending\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"ve781smf\",\n\t\t\t\t\"max\": 0,\n\t\t\t\t\"min\": 0,\n\t\t\t\t\"name\": \"host\",\n\t\t\t\t\"pattern\": \"\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"pij0k2jk\",\n\t\t\t\t\"max\": 0,\n\t\t\t\t\"min\": 0,\n\t\t\t\t\"name\": \"port\",\n\t\t\t\t\"pattern\": \"\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"qoq64ntl\",\n\t\t\t\t\"maxSize\": 2000000,\n\t\t\t\t\"name\": \"info\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"json\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"cascadeDelete\": true,\n\t\t\t\t\"collectionId\": \"_pb_users_auth_\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"jcarjnjj\",\n\t\t\t\t\"maxSelect\": 2147483647,\n\t\t\t\t\"minSelect\": 0,\n\t\t\t\t\"name\": \"users\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"relation\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate2990389176\",\n\t\t\t\t\"name\": \"created\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": false,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate3332085495\",\n\t\t\t\t\"name\": \"updated\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": true,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t}\n\t\t],\n\t\t\"indexes\": [],\n\t\t\"system\": false\n\t},\n\t{\n\t\t\"id\": \"_pb_users_auth_\",\n\t\t\"listRule\": \"id = @request.auth.id\",\n\t\t\"viewRule\": \"id = @request.auth.id\",\n\t\t\"createRule\": null,\n\t\t\"updateRule\": null,\n\t\t\"deleteRule\": null,\n\t\t\"name\": \"users\",\n\t\t\"type\": \"auth\",\n\t\t\"fields\": [\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"[a-z0-9]{15}\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"text3208210256\",\n\t\t\t\t\"max\": 15,\n\t\t\t\t\"min\": 15,\n\t\t\t\t\"name\": \"id\",\n\t\t\t\t\"pattern\": \"^[a-z0-9]+$\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": true,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"cost\": 10,\n\t\t\t\t\"hidden\": true,\n\t\t\t\t\"id\": \"password901924565\",\n\t\t\t\t\"max\": 0,\n\t\t\t\t\"min\": 8,\n\t\t\t\t\"name\": \"password\",\n\t\t\t\t\"pattern\": \"\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"password\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"[a-zA-Z0-9_]{50}\",\n\t\t\t\t\"hidden\": true,\n\t\t\t\t\"id\": \"text2504183744\",\n\t\t\t\t\"max\": 60,\n\t\t\t\t\"min\": 30,\n\t\t\t\t\"name\": \"tokenKey\",\n\t\t\t\t\"pattern\": \"\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"exceptDomains\": null,\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"email3885137012\",\n\t\t\t\t\"name\": \"email\",\n\t\t\t\t\"onlyDomains\": null,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"email\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"bool1547992806\",\n\t\t\t\t\"name\": \"emailVisibility\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"bool\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"bool256245529\",\n\t\t\t\t\"name\": \"verified\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"bool\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"users[0-9]{6}\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"text4166911607\",\n\t\t\t\t\"max\": 150,\n\t\t\t\t\"min\": 3,\n\t\t\t\t\"name\": \"username\",\n\t\t\t\t\"pattern\": \"^[\\\\w][\\\\w\\\\.\\\\-]*$\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"qkbp58ae\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"name\": \"role\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"select\",\n\t\t\t\t\"values\": [\n\t\t\t\t\t\"user\",\n\t\t\t\t\t\"admin\",\n\t\t\t\t\t\"readonly\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate2990389176\",\n\t\t\t\t\"name\": \"created\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": false,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"autodate3332085495\",\n\t\t\t\t\"name\": \"updated\",\n\t\t\t\t\"onCreate\": true,\n\t\t\t\t\"onUpdate\": true,\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"autodate\"\n\t\t\t}\n\t\t],\n\t\t\"indexes\": [\n\t\t\t\"CREATE UNIQUE INDEX ` + \"`\" + `__pb_users_auth__username_idx` + \"`\" + ` ON ` + \"`\" + `users` + \"`\" + ` (username COLLATE NOCASE)\",\n\t\t\t\"CREATE UNIQUE INDEX ` + \"`\" + `__pb_users_auth__email_idx` + \"`\" + ` ON ` + \"`\" + `users` + \"`\" + ` (` + \"`\" + `email` + \"`\" + `) WHERE ` + \"`\" + `email` + \"`\" + ` != ''\",\n\t\t\t\"CREATE UNIQUE INDEX ` + \"`\" + `__pb_users_auth__tokenKey_idx` + \"`\" + ` ON ` + \"`\" + `users` + \"`\" + ` (` + \"`\" + `tokenKey` + \"`\" + `)\"\n\t\t],\n\t\t\"system\": false,\n\t\t\"authRule\": \"verified=true\",\n\t\t\"manageRule\": null\n\t}\n]`\n\n\t\terr := app.ImportCollectionsByMarshaledJSON([]byte(jsonData), false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Get all systems that don't have fingerprint records\n\t\tvar systemIds []string\n\t\terr = app.DB().NewQuery(`\n\t\t\tSELECT s.id FROM systems s\n\t\t\tLEFT JOIN fingerprints f ON s.id = f.system\n\t\t\tWHERE f.system IS NULL\n\t\t`).Column(&systemIds)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create fingerprint records with unique UUID tokens for each system\n\t\tfor _, systemId := range systemIds {\n\t\t\ttoken := uuid.New().String()\n\t\t\t_, err = app.DB().NewQuery(`\n\t\t\t\tINSERT INTO fingerprints (system, token)\n\t\t\t\tVALUES ({:system}, {:token})\n\t\t\t`).Bind(map[string]any{\n\t\t\t\t\"system\": systemId,\n\t\t\t\t\"token\":  token,\n\t\t\t}).Execute()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, func(app core.App) error {\n\t\treturn nil\n\t})\n}\n", "n_tokens": 7353, "primary_symbol": "init", "primary_kind": "function", "primary_span": [9, 901], "def_symbols": ["init"], "symbols": ["init", "func", "Register", "app", "core", "App", "error", "update", "collections", "jsonData", "elngm8x1l60zi2v", "listRule", "request", "auth", "user", "viewRule", "createRule", "updateRule", "deleteRule", "name", "alerts", "type", "base", "fields", "autogeneratePattern", "hidden", "false", "text3208210256", "max", "min", "pattern", "presentable", "primaryKey", "true", "required", "system", "text", "cascadeDelete", "collectionId", "_pb_users_auth_", "hn5ly3vi", "maxSelect", "minSelect", "relation", "g5sl3jdg", "zj3ingrv", "select", "values", "Status", "CPU", "Memory", "Disk", "Temperature", "Bandwidth", "LoadAvg1", "LoadAvg5", "LoadAvg15", "o2ablxvn", "null", "value", "onlyInt", "number", "fstdehcq", "triggered", "bool", "autodate2990389176", "created", "onCreate", "onUpdate", "autodate", "autodate3332085495", "updated", "indexes", "CREATE", "UNIQUE", "INDEX", "idx_MnhEt21L5r", "pbc_1697146157", "alerts_history", "relation2375276105", "relation3377271179", "text2466471794", "alert_id", "text1579384326", "number494360628", "date2276568630", "resolved", "date", "idx_YdGnup5aqB", "idx_taLet9VdME", "juohu4jipgc13v7", "container_stats", "hutcu6ps", "r39hhnil", "maxSize", "stats", "json", "vo7iuj96", "idx_d87OiXGZD8", "pbc_3663931638", "users", "role", "readonly", "fingerprints", "text1597481275", "token", "text4228609354", "fingerprint", "idx_p9qZlu26po", "idx_ngboulGMYw", "ej9oowivz8b2mht", "system_stats", "h9sg148r", "azftn0be", "m1ekhli3", "idx_GxIee0j", "user_settings", "d5vztyxa", "xcx4qgqq", "settings", "idx_30Lwgf2", "systems", "waj7seaf", "status", "down", "paused", "pending", "ve781smf", "host", "pij0k2jk", "port", "qoq64ntl", "info", "jcarjnjj", "cost", "password901924565", "password", "text2504183744", "tokenKey", "exceptDomains", "email3885137012", "email", "onlyDomains", "bool1547992806", "emailVisibility", "bool256245529", "verified", "text4166911607", "username", "qkbp58ae", "admin", "__pb_users_auth__username_idx", "COLLATE", "NOCASE", "__pb_users_auth__email_idx", "WHERE", "__pb_users_auth__tokenKey_idx", "authRule", "manageRule", "err", "ImportCollectionsByMarshaledJSON", "byte", "nil", "return", "Get", "all", "that", "don", "have", "records", "var", "systemIds", "string", "NewQuery", "SELECT", "FROM", "LEFT", "JOIN", "NULL", "Column", "Create", "with", "unique", "UUID", "tokens", "for", "each", "systemId", "range", "uuid", "New", "String", "INSERT", "INTO", "VALUES", "Bind", "map", "any", "Execute"], "doc_head": "func init() {\n\tm.Register(func(app core.App) error {\n\t\t// update collections\n\t\tjsonData := `[\n\t{\n\t\t\"id\": \"elngm8x1l60zi2v\",\n\t\t\"listRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"viewRule\": \"\",\n\t\t\"createRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"updateRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"deleteRule\": \"@request.auth.id != \\\"\\\" && user.id = @request.auth.id\",\n\t\t\"name\": \"alerts\",\n\t\t\"type\": \"base\",\n\t\t\"fields\": [\n\t\t\t{\n\t\t\t\t\"autogeneratePattern\": \"[a-z0-9]{15}\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"text3208210256\",\n\t\t\t\t\"max\": 15,\n\t\t\t\t\"min\": 15,\n\t\t\t\t\"name\": \"id\",\n\t\t\t\t\"pattern\": \"^[a-z0-9]+$\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"primaryKey\": true,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": true,\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"cascadeDelete\": true,\n\t\t\t\t\"collectionId\": \"_pb_users_auth_\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"hn5ly3vi\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"minSelect\": 0,\n\t\t\t\t\"name\": \"user\",\n\t\t\t\t\"presentable\": false,\n\t\t\t\t\"required\": true,\n\t\t\t\t\"system\": false,\n\t\t\t\t\"type\": \"relation\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"cascadeDelete\": true,\n\t\t\t\t\"collectionId\": \"2hz5ncl8tizk5nx\",\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"id\": \"g5sl3jdg\",\n\t\t\t\t\"maxSelect\": 1,\n\t\t\t\t\"minSelect"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/migrations/initial-settings.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/migrations/initial-settings.go", "rel_path": "src/migrations/initial-settings.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 13, "text": "package migrations\n\nimport (\n\t\"os\"\n\n\t\"github.com/pocketbase/pocketbase/core\"\n\tm \"github.com/pocketbase/pocketbase/migrations\"\n)\n\nconst (\n\tTempAdminEmail = \"_@b.b\"\n)\n", "n_tokens": 46, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 13], "def_symbols": [], "symbols": ["package", "migrations", "import", "github", "com", "pocketbase", "core", "const", "TempAdminEmail"], "doc_head": "package migrations\nimport (\n\t\"os\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\tm \"github.com/pocketbase/pocketbase/migrations\"\n)\nconst (\n\tTempAdminEmail = \"_@b.b\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/migrations/initial-settings.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/migrations/initial-settings.go", "rel_path": "src/migrations/initial-settings.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 14, "end_line": 63, "text": "func init() {\n\tm.Register(func(app core.App) error {\n\t\t// initial settings\n\t\tsettings := app.Settings()\n\t\tsettings.Meta.AppName = \"Beszel\"\n\t\tsettings.Meta.HideControls = true\n\t\tsettings.Logs.MinLevel = 4\n\t\tif err := app.Save(settings); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// create superuser\n\t\tsuperuserCollection, _ := app.FindCollectionByNameOrId(core.CollectionNameSuperusers)\n\t\tsuperUser := core.NewRecord(superuserCollection)\n\n\t\t// set email\n\t\temail, _ := GetEnv(\"USER_EMAIL\")\n\t\tpassword, _ := GetEnv(\"USER_PASSWORD\")\n\t\tdidProvideUserDetails := email != \"\" && password != \"\"\n\n\t\t// set superuser email\n\t\tif email == \"\" {\n\t\t\temail = TempAdminEmail\n\t\t}\n\t\tsuperUser.SetEmail(email)\n\n\t\t// set superuser password\n\t\tif password != \"\" {\n\t\t\tsuperUser.SetPassword(password)\n\t\t} else {\n\t\t\tsuperUser.SetRandomPassword()\n\t\t}\n\n\t\t// if user details are provided, we create a regular user as well\n\t\tif didProvideUserDetails {\n\t\t\tusersCollection, _ := app.FindCollectionByNameOrId(\"users\")\n\t\t\tuser := core.NewRecord(usersCollection)\n\t\t\tuser.SetEmail(email)\n\t\t\tuser.SetPassword(password)\n\t\t\tuser.SetVerified(true)\n\t\t\terr := app.Save(user)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn app.Save(superUser)\n\t}, nil)\n}\n", "n_tokens": 319, "primary_symbol": "init", "primary_kind": "function", "primary_span": [14, 63], "def_symbols": ["init"], "symbols": ["init", "func", "Register", "app", "core", "App", "error", "initial", "settings", "Settings", "Meta", "AppName", "Beszel", "HideControls", "true", "Logs", "MinLevel", "err", "Save", "nil", "return", "create", "superuser", "superuserCollection", "FindCollectionByNameOrId", "CollectionNameSuperusers", "superUser", "NewRecord", "set", "email", "GetEnv", "USER_EMAIL", "password", "USER_PASSWORD", "didProvideUserDetails", "TempAdminEmail", "SetEmail", "SetPassword", "else", "SetRandomPassword", "user", "details", "are", "provided", "regular", "well", "usersCollection", "users", "SetVerified"], "doc_head": "func init() {\n\tm.Register(func(app core.App) error {\n\t\t// initial settings\n\t\tsettings := app.Settings()\n\t\tsettings.Meta.AppName = \"Beszel\"\n\t\tsettings.Meta.HideControls = true\n\t\tsettings.Logs.MinLevel = 4\n\t\tif err := app.Save(settings); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// create superuser\n\t\tsuperuserCollection, _ := app.FindCollectionByNameOrId(core.CollectionNameSuperusers)\n\t\tsuperUser := core.NewRecord(superuserCollection)\n\t\t// set email\n\t\temail, _ := GetEnv(\"USER_EMAIL\")\n\t\tpassword, _ := GetEnv(\"USER_PASSWORD\")\n\t\tdidProvideUserDetails := email != \"\" && password != \"\"\n\t\t// set superuser email\n\t\tif email == \"\" {\n\t\t\temail = TempAdminEmail\n\t\t}\n\t\tsuperUser.SetEmail(email)\n\t\t// set superuser password\n\t\tif password != \"\" {\n\t\t\tsuperUser.SetPassword(password)\n\t\t} else {\n\t\t\tsuperUser.SetRandomPassword()\n\t\t}\n\t\t// if user details are provided, we create a regular user as well\n\t\tif didProvideUserDetails {\n\t\t\tusersCollection, _ := app.FindCollectionByNameOrId(\"users\")\n\t\t\tuser := core.NewRecord(usersCollection)\n\t\t\tuser.SetEmail(email)\n\t\t\tuser.SetPassword(password)\n\t\t\tuser.SetVerified(true)\n\t\t\terr := app.Save(user)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn app.Save(superUser)\n\t}, nil)\n"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/migrations/initial-settings.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/migrations/initial-settings.go", "rel_path": "src/migrations/initial-settings.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 64, "end_line": 72, "text": "// GetEnv retrieves an environment variable with a \"BESZEL_HUB_\" prefix, or falls back to the unprefixed key.\nfunc GetEnv(key string) (value string, exists bool) {\n\tif value, exists = os.LookupEnv(\"BESZEL_HUB_\" + key); exists {\n\t\treturn value, exists\n\t}\n\t// Fallback to the old unprefixed key\n\treturn os.LookupEnv(key)\n}\n", "n_tokens": 91, "primary_symbol": "GetEnv", "primary_kind": "function", "primary_span": [65, 72], "def_symbols": ["GetEnv"], "symbols": ["GetEnv", "retrieves", "environment", "variable", "with", "BESZEL_HUB_", "prefix", "falls", "back", "the", "unprefixed", "key", "func", "string", "value", "exists", "bool", "LookupEnv", "return", "Fallback", "old"], "doc_head": "// GetEnv retrieves an environment variable with a \"BESZEL_HUB_\" prefix, or falls back to the unprefixed key.\nfunc GetEnv(key string) (value string, exists bool) {\n\tif value, exists = os.LookupEnv(\"BESZEL_HUB_\" + key); exists {\n\t\treturn value, exists\n\t}\n\t// Fallback to the old unprefixed key\n\treturn os.LookupEnv(key)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go", "rel_path": "src/records/records.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 37, "text": "// Package records handles creating longer records and deleting old records.\npackage records\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/entities/container\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n\ntype RecordManager struct {\n\tapp core.App\n}\n\ntype LongerRecordData struct {\n\tshorterType        string\n\tlongerType         string\n\tlongerTimeDuration time.Duration\n\tminShorterRecords  int\n}\n\ntype RecordIds []struct {\n\tId string `db:\"id\"`\n}\n\nfunc NewRecordManager(app core.App) *RecordManager {\n\treturn &RecordManager{app}\n}\n", "n_tokens": 162, "primary_symbol": "NewRecordManager", "primary_kind": "function", "primary_span": [34, 37], "def_symbols": ["NewRecordManager"], "symbols": ["NewRecordManager", "Package", "records", "handles", "creating", "longer", "and", "deleting", "old", "package", "import", "encoding", "json", "fmt", "log", "math", "strings", "time", "github", "com", "henrygd", "beszel", "src", "entities", "container", "system", "pocketbase", "dbx", "core", "type", "RecordManager", "struct", "app", "App", "LongerRecordData", "shorterType", "string", "longerType", "longerTimeDuration", "Duration", "minShorterRecords", "int", "RecordIds", "func", "return"], "doc_head": "// Package records handles creating longer records and deleting old records.\npackage records\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"strings\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/entities/container\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\ntype RecordManager struct {\n\tapp core.App\n}\ntype LongerRecordData struct {\n\tshorterType        string\n\tlongerType         string\n\tlongerTimeDuration time.Duration\n\tminShorterRecords  int\n}\ntype RecordIds []struct {\n\tId string `db:\"id\"`\n}\nfunc NewRecordManager(app core.App) *RecordManager {\n\treturn &RecordManager{app}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go", "rel_path": "src/records/records.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 38, "end_line": 51, "text": "type StatsRecord struct {\n\tStats []byte `db:\"stats\"`\n}\n\n// global variables for reusing allocations\nvar (\n\tstatsRecord    StatsRecord\n\tcontainerStats []container.Stats\n\tsumStats       system.Stats\n\ttempStats      system.Stats\n\tqueryParams    = make(dbx.Params, 1)\n\tcontainerSums  = make(map[string]*container.Stats)\n)\n", "n_tokens": 78, "primary_symbol": "", "primary_kind": "", "primary_span": [38, 51], "def_symbols": [], "symbols": ["type", "StatsRecord", "struct", "Stats", "byte", "stats", "global", "variables", "for", "reusing", "allocations", "var", "statsRecord", "containerStats", "container", "sumStats", "system", "tempStats", "queryParams", "make", "dbx", "Params", "containerSums", "map", "string"], "doc_head": "type StatsRecord struct {\n\tStats []byte `db:\"stats\"`\n}\n// global variables for reusing allocations\nvar (\n\tstatsRecord    StatsRecord\n\tcontainerStats []container.Stats\n\tsumStats       system.Stats\n\ttempStats      system.Stats\n\tqueryParams    = make(dbx.Params, 1)\n\tcontainerSums  = make(map[string]*container.Stats)\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go", "rel_path": "src/records/records.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 52, "end_line": 170, "text": "// Create longer records by averaging shorter records\nfunc (rm *RecordManager) CreateLongerRecords() {\n\t// start := time.Now()\n\tlongerRecordData := []LongerRecordData{\n\t\t{\n\t\t\tshorterType: \"1m\",\n\t\t\t// change to 9 from 10 to allow edge case timing or short pauses\n\t\t\tminShorterRecords:  9,\n\t\t\tlongerType:         \"10m\",\n\t\t\tlongerTimeDuration: -10 * time.Minute,\n\t\t},\n\t\t{\n\t\t\tshorterType:        \"10m\",\n\t\t\tminShorterRecords:  2,\n\t\t\tlongerType:         \"20m\",\n\t\t\tlongerTimeDuration: -20 * time.Minute,\n\t\t},\n\t\t{\n\t\t\tshorterType:        \"20m\",\n\t\t\tminShorterRecords:  6,\n\t\t\tlongerType:         \"120m\",\n\t\t\tlongerTimeDuration: -120 * time.Minute,\n\t\t},\n\t\t{\n\t\t\tshorterType:        \"120m\",\n\t\t\tminShorterRecords:  4,\n\t\t\tlongerType:         \"480m\",\n\t\t\tlongerTimeDuration: -480 * time.Minute,\n\t\t},\n\t}\n\t// wrap the operations in a transaction\n\trm.app.RunInTransaction(func(txApp core.App) error {\n\t\tvar err error\n\t\tcollections := [2]*core.Collection{}\n\t\tcollections[0], err = txApp.FindCachedCollectionByNameOrId(\"system_stats\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcollections[1], err = txApp.FindCachedCollectionByNameOrId(\"container_stats\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar systems RecordIds\n\t\tdb := txApp.DB()\n\n\t\tdb.NewQuery(\"SELECT id FROM systems WHERE status='up'\").All(&systems)\n\n\t\t// loop through all active systems, time periods, and collections\n\t\tfor _, system := range systems {\n\t\t\t// log.Println(\"processing system\", system.GetString(\"name\"))\n\t\t\tfor i := range longerRecordData {\n\t\t\t\trecordData := longerRecordData[i]\n\t\t\t\t// log.Println(\"processing longer record type\", recordData.longerType)\n\t\t\t\t// add one minute padding for longer records because they are created slightly later than the job start time\n\t\t\t\tlongerRecordPeriod := time.Now().UTC().Add(recordData.longerTimeDuration + time.Minute)\n\t\t\t\t// shorter records are created independently of longer records, so we shouldn't need to add padding\n\t\t\t\tshorterRecordPeriod := time.Now().UTC().Add(recordData.longerTimeDuration)\n\t\t\t\t// loop through both collections\n\t\t\t\tfor _, collection := range collections {\n\t\t\t\t\t// check creation time of last longer record if not 10m, since 10m is created every run\n\t\t\t\t\tif recordData.longerType != \"10m\" {\n\t\t\t\t\t\tcount, err := txApp.CountRecords(\n\t\t\t\t\t\t\tcollection.Id,\n\t\t\t\t\t\t\tdbx.NewExp(\n\t\t\t\t\t\t\t\t\"system = {:system} AND type = {:type} AND created > {:created}\",\n\t\t\t\t\t\t\t\tdbx.Params{\"type\": recordData.longerType, \"system\": system.Id, \"created\": longerRecordPeriod},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t// continue if longer record exists\n\t\t\t\t\t\tif err != nil || count > 0 {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// get shorter records from the past x minutes\n\t\t\t\t\tvar recordIds RecordIds\n\n\t\t\t\t\terr := txApp.DB().\n\t\t\t\t\t\tSelect(\"id\").\n\t\t\t\t\t\tFrom(collection.Name).\n\t\t\t\t\t\tAndWhere(dbx.NewExp(\n\t\t\t\t\t\t\t\"system={:system} AND type={:type} AND created > {:created}\",\n\t\t\t\t\t\t\tdbx.Params{\n\t\t\t\t\t\t\t\t\"type\":    recordData.shorterType,\n\t\t\t\t\t\t\t\t\"system\":  system.Id,\n\t\t\t\t\t\t\t\t\"created\": shorterRecordPeriod,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)).\n\t\t\t\t\t\tAll(&recordIds)\n\n\t\t\t\t\t// continue if not enough shorter records\n\t\t\t\t\tif err != nil || len(recordIds) < recordData.minShorterRecords {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// average the shorter records and create longer record\n\t\t\t\t\tlongerRecord := core.NewRecord(collection)\n\t\t\t\t\tlongerRecord.Set(\"system\", system.Id)\n\t\t\t\t\tlongerRecord.Set(\"type\", recordData.longerType)\n\t\t\t\t\tswitch collection.Name {\n\t\t\t\t\tcase \"system_stats\":\n\t\t\t\t\t\tlongerRecord.Set(\"stats\", rm.AverageSystemStats(db, recordIds))\n\t\t\t\t\tcase \"container_stats\":\n\n\t\t\t\t\t\tlongerRecord.Set(\"stats\", rm.AverageContainerStats(db, recordIds))\n\t\t\t\t\t}\n\t\t\t\t\tif err := txApp.SaveNoValidate(longerRecord); err != nil {\n\t\t\t\t\t\tlog.Println(\"failed to save longer record\", \"err\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tstatsRecord.Stats = statsRecord.Stats[:0]\n\n\t// log.Println(\"finished creating longer records\", \"time (ms)\", time.Since(start).Milliseconds())\n}\n", "n_tokens": 1034, "primary_symbol": "CreateLongerRecords", "primary_kind": "function", "primary_span": [53, 170], "def_symbols": ["CreateLongerRecords"], "symbols": ["CreateLongerRecords", "Create", "longer", "records", "averaging", "shorter", "func", "RecordManager", "start", "time", "Now", "longerRecordData", "LongerRecordData", "shorterType", "change", "from", "allow", "edge", "case", "timing", "short", "pauses", "minShorterRecords", "longerType", "longerTimeDuration", "Minute", "wrap", "the", "operations", "transaction", "app", "RunInTransaction", "txApp", "core", "App", "error", "var", "err", "collections", "Collection", "FindCachedCollectionByNameOrId", "system_stats", "nil", "return", "container_stats", "systems", "RecordIds", "NewQuery", "SELECT", "FROM", "WHERE", "status", "All", "loop", "through", "all", "active", "periods", "and", "for", "system", "range", "log", "Println", "processing", "GetString", "name", "recordData", "record", "type", "add", "one", "minute", "padding", "because", "they", "are", "created", "slightly", "later", "than", "job", "longerRecordPeriod", "UTC", "Add", "independently", "shouldn", "need", "shorterRecordPeriod", "both", "collection", "check", "creation", "last", "not", "since", "every", "run", "count", "CountRecords", "dbx", "NewExp", "AND", "Params", "continue", "exists", "get", "past", "minutes", "recordIds", "Select", "From", "Name", "AndWhere", "enough", "len", "average", "create", "longerRecord", "NewRecord", "Set", "switch", "stats", "AverageSystemStats", "AverageContainerStats", "SaveNoValidate", "failed", "save", "statsRecord", "Stats", "finished", "creating", "Since", "Milliseconds"], "doc_head": "// Create longer records by averaging shorter records\nfunc (rm *RecordManager) CreateLongerRecords() {\n\t// start := time.Now()\n\tlongerRecordData := []LongerRecordData{\n\t\t{\n\t\t\tshorterType: \"1m\",\n\t\t\t// change to 9 from 10 to allow edge case timing or short pauses\n\t\t\tminShorterRecords:  9,\n\t\t\tlongerType:         \"10m\",\n\t\t\tlongerTimeDuration: -10 * time.Minute,\n\t\t},\n\t\t{\n\t\t\tshorterType:        \"10m\",\n\t\t\tminShorterRecords:  2,\n\t\t\tlongerType:         \"20m\",\n\t\t\tlongerTimeDuration: -20 * time.Minute,\n\t\t},\n\t\t{\n\t\t\tshorterType:        \"20m\",\n\t\t\tminShorterRecords:  6,\n\t\t\tlongerType:         \"120m\",\n\t\t\tlongerTimeDuration: -120 * time.Minute,\n\t\t},\n\t\t{\n\t\t\tshorterType:        \"120m\",\n\t\t\tminShorterRecords:  4,\n\t\t\tlongerType:         \"480m\",\n\t\t\tlongerTimeDuration: -480 * time.Minute,\n\t\t},\n\t}\n\t// wrap the operations in a transaction\n\trm.app.RunInTransaction(func(txApp core.App) error {\n\t\tvar err error\n\t\tcollections := [2]*core.Collection{}\n\t\tcollections[0], err = txApp.FindCachedCollectionByNameOrId(\"system_stats\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcollections[1], err = txApp.FindCachedCollectionByNameOrId(\"container_stats\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar systems RecordIds\n\t\tdb := txApp"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go", "rel_path": "src/records/records.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 171, "end_line": 337, "text": "// Calculate the average stats of a list of system_stats records without reflect\nfunc (rm *RecordManager) AverageSystemStats(db dbx.Builder, records RecordIds) *system.Stats {\n\t// Clear/reset global structs for reuse\n\tsumStats = system.Stats{}\n\ttempStats = system.Stats{}\n\tsum := &sumStats\n\tstats := &tempStats\n\t// necessary because uint8 is not big enough for the sum\n\tbatterySum := 0\n\n\tcount := float64(len(records))\n\ttempCount := float64(0)\n\n\t// Accumulate totals\n\tfor _, record := range records {\n\t\tid := record.Id\n\t\t// clear global statsRecord for reuse\n\t\tstatsRecord.Stats = statsRecord.Stats[:0]\n\n\t\tqueryParams[\"id\"] = id\n\t\tdb.NewQuery(\"SELECT stats FROM system_stats WHERE id = {:id}\").Bind(queryParams).One(&statsRecord)\n\t\tif err := json.Unmarshal(statsRecord.Stats, stats); err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tsum.Cpu += stats.Cpu\n\t\tsum.Mem += stats.Mem\n\t\tsum.MemUsed += stats.MemUsed\n\t\tsum.MemPct += stats.MemPct\n\t\tsum.MemBuffCache += stats.MemBuffCache\n\t\tsum.MemZfsArc += stats.MemZfsArc\n\t\tsum.Swap += stats.Swap\n\t\tsum.SwapUsed += stats.SwapUsed\n\t\tsum.DiskTotal += stats.DiskTotal\n\t\tsum.DiskUsed += stats.DiskUsed\n\t\tsum.DiskPct += stats.DiskPct\n\t\tsum.DiskReadPs += stats.DiskReadPs\n\t\tsum.DiskWritePs += stats.DiskWritePs\n\t\tsum.NetworkSent += stats.NetworkSent\n\t\tsum.NetworkRecv += stats.NetworkRecv\n\t\tsum.LoadAvg[0] += stats.LoadAvg[0]\n\t\tsum.LoadAvg[1] += stats.LoadAvg[1]\n\t\tsum.LoadAvg[2] += stats.LoadAvg[2]\n\t\tsum.Bandwidth[0] += stats.Bandwidth[0]\n\t\tsum.Bandwidth[1] += stats.Bandwidth[1]\n\t\tbatterySum += int(stats.Battery[0])\n\t\tsum.Battery[1] = stats.Battery[1]\n\t\t// Set peak values\n\t\tsum.MaxCpu = max(sum.MaxCpu, stats.MaxCpu, stats.Cpu)\n\t\tsum.MaxMem = max(sum.MaxMem, stats.MaxMem, stats.MemUsed)\n\t\tsum.MaxNetworkSent = max(sum.MaxNetworkSent, stats.MaxNetworkSent, stats.NetworkSent)\n\t\tsum.MaxNetworkRecv = max(sum.MaxNetworkRecv, stats.MaxNetworkRecv, stats.NetworkRecv)\n\t\tsum.MaxDiskReadPs = max(sum.MaxDiskReadPs, stats.MaxDiskReadPs, stats.DiskReadPs)\n\t\tsum.MaxDiskWritePs = max(sum.MaxDiskWritePs, stats.MaxDiskWritePs, stats.DiskWritePs)\n\t\tsum.MaxBandwidth[0] = max(sum.MaxBandwidth[0], stats.MaxBandwidth[0], stats.Bandwidth[0])\n\t\tsum.MaxBandwidth[1] = max(sum.MaxBandwidth[1], stats.MaxBandwidth[1], stats.Bandwidth[1])\n\n\t\t// Accumulate temperatures\n\t\tif stats.Temperatures != nil {\n\t\t\tif sum.Temperatures == nil {\n\t\t\t\tsum.Temperatures = make(map[string]float64, len(stats.Temperatures))\n\t\t\t}\n\t\t\ttempCount++\n\t\t\tfor key, value := range stats.Temperatures {\n\t\t\t\tsum.Temperatures[key] += value\n\t\t\t}\n\t\t}\n\n\t\t// Accumulate extra filesystem stats\n\t\tif stats.ExtraFs != nil {\n\t\t\tif sum.ExtraFs == nil {\n\t\t\t\tsum.ExtraFs = make(map[string]*system.FsStats, len(stats.ExtraFs))\n\t\t\t}\n\t\t\tfor key, value := range stats.ExtraFs {\n\t\t\t\tif _, ok := sum.ExtraFs[key]; !ok {\n\t\t\t\t\tsum.ExtraFs[key] = &system.FsStats{}\n\t\t\t\t}\n\t\t\t\tfs := sum.ExtraFs[key]\n\t\t\t\tfs.DiskTotal += value.DiskTotal\n\t\t\t\tfs.DiskUsed += value.DiskUsed\n\t\t\t\tfs.DiskWritePs += value.DiskWritePs\n\t\t\t\tfs.DiskReadPs += value.DiskReadPs\n\t\t\t\tfs.MaxDiskReadPS = max(fs.MaxDiskReadPS, value.MaxDiskReadPS, value.DiskReadPs)\n\t\t\t\tfs.MaxDiskWritePS = max(fs.MaxDiskWritePS, value.MaxDiskWritePS, value.DiskWritePs)\n\t\t\t}\n\t\t}\n\n\t\t// Accumulate GPU data\n\t\tif stats.GPUData != nil {\n\t\t\tif sum.GPUData == nil {\n\t\t\t\tsum.GPUData = make(map[string]system.GPUData, len(stats.GPUData))\n\t\t\t}\n\t\t\tfor id, value := range stats.GPUData {\n\t\t\t\tgpu, ok := sum.GPUData[id]\n\t\t\t\tif !ok {\n\t\t\t\t\tgpu = system.GPUData{Name: value.Name}\n\t\t\t\t}\n\t\t\t\tgpu.Temperature += value.Temperature\n\t\t\t\tgpu.MemoryUsed += value.MemoryUsed\n\t\t\t\tgpu.MemoryTotal += value.MemoryTotal\n\t\t\t\tgpu.Usage += value.Usage\n\t\t\t\tgpu.Power += value.Power\n\t\t\t\tgpu.Count += value.Count\n\t\t\t\tsum.GPUData[id] = gpu\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compute averages in place\n\tif count > 0 {\n\t\tsum.Cpu = twoDecimals(sum.Cpu / count)\n\t\tsum.Mem = twoDecimals(sum.Mem / count)\n\t\tsum.MemUsed = twoDecimals(sum.MemUsed / count)\n\t\tsum.MemPct = twoDecimals(sum.MemPct / count)\n\t\tsum.MemBuffCache = twoDecimals(sum.MemBuffCache / count)\n\t\tsum.MemZfsArc = twoDecimals(sum.MemZfsArc / count)\n\t\tsum.Swap = twoDecimals(sum.Swap / count)\n\t\tsum.SwapUsed = twoDecimals(sum.SwapUsed / count)\n\t\tsum.DiskTotal = twoDecimals(sum.DiskTotal / count)\n\t\tsum.DiskUsed = twoDecimals(sum.DiskUsed / count)\n\t\tsum.DiskPct = twoDecimals(sum.DiskPct / count)\n\t\tsum.DiskReadPs = twoDecimals(sum.DiskReadPs / count)\n\t\tsum.DiskWritePs = twoDecimals(sum.DiskWritePs / count)\n\t\tsum.NetworkSent = twoDecimals(sum.NetworkSent / count)\n\t\tsum.NetworkRecv = twoDecimals(sum.NetworkRecv / count)\n\t\tsum.LoadAvg[0] = twoDecimals(sum.LoadAvg[0] / count)\n\t\tsum.LoadAvg[1] = twoDecimals(sum.LoadAvg[1] / count)\n\t\tsum.LoadAvg[2] = twoDecimals(sum.LoadAvg[2] / count)\n\t\tsum.Bandwidth[0] = sum.Bandwidth[0] / uint64(count)\n\t\tsum.Bandwidth[1] = sum.Bandwidth[1] / uint64(count)\n\t\tsum.Battery[0] = uint8(batterySum / int(count))\n\t\t// Average temperatures\n\t\tif sum.Temperatures != nil && tempCount > 0 {\n\t\t\tfor key := range sum.Temperatures {\n\t\t\t\tsum.Temperatures[key] = twoDecimals(sum.Temperatures[key] / tempCount)\n\t\t\t}\n\t\t}\n\n\t\t// Average extra filesystem stats\n\t\tif sum.ExtraFs != nil {\n\t\t\tfor key := range sum.ExtraFs {\n\t\t\t\tfs := sum.ExtraFs[key]\n\t\t\t\tfs.DiskTotal = twoDecimals(fs.DiskTotal / count)\n\t\t\t\tfs.DiskUsed = twoDecimals(fs.DiskUsed / count)\n\t\t\t\tfs.DiskWritePs = twoDecimals(fs.DiskWritePs / count)\n\t\t\t\tfs.DiskReadPs = twoDecimals(fs.DiskReadPs / count)\n\t\t\t}\n\t\t}\n\n\t\t// Average GPU data\n\t\tif sum.GPUData != nil {\n\t\t\tfor id := range sum.GPUData {\n\t\t\t\tgpu := sum.GPUData[id]\n\t\t\t\tgpu.Temperature = twoDecimals(gpu.Temperature / count)\n\t\t\t\tgpu.MemoryUsed = twoDecimals(gpu.MemoryUsed / count)\n\t\t\t\tgpu.MemoryTotal = twoDecimals(gpu.MemoryTotal / count)\n\t\t\t\tgpu.Usage = twoDecimals(gpu.Usage / count)\n\t\t\t\tgpu.Power = twoDecimals(gpu.Power / count)\n\t\t\t\tgpu.Count = twoDecimals(gpu.Count / count)\n\t\t\t\tsum.GPUData[id] = gpu\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n", "n_tokens": 1839, "primary_symbol": "AverageSystemStats", "primary_kind": "function", "primary_span": [172, 337], "def_symbols": ["AverageSystemStats"], "symbols": ["AverageSystemStats", "Calculate", "the", "average", "stats", "list", "system_stats", "records", "without", "reflect", "func", "RecordManager", "dbx", "Builder", "RecordIds", "system", "Stats", "Clear", "reset", "global", "structs", "for", "reuse", "sumStats", "tempStats", "sum", "necessary", "because", "uint8", "not", "big", "enough", "batterySum", "count", "float64", "len", "tempCount", "Accumulate", "totals", "record", "range", "clear", "statsRecord", "queryParams", "NewQuery", "SELECT", "FROM", "WHERE", "Bind", "One", "err", "json", "Unmarshal", "nil", "continue", "Cpu", "Mem", "MemUsed", "MemPct", "MemBuffCache", "MemZfsArc", "Swap", "SwapUsed", "DiskTotal", "DiskUsed", "DiskPct", "DiskReadPs", "DiskWritePs", "NetworkSent", "NetworkRecv", "LoadAvg", "Bandwidth", "int", "Battery", "Set", "peak", "values", "MaxCpu", "max", "MaxMem", "MaxNetworkSent", "MaxNetworkRecv", "MaxDiskReadPs", "MaxDiskWritePs", "MaxBandwidth", "temperatures", "Temperatures", "make", "map", "string", "key", "value", "extra", "filesystem", "ExtraFs", "FsStats", "MaxDiskReadPS", "MaxDiskWritePS", "GPU", "data", "GPUData", "gpu", "Name", "Temperature", "MemoryUsed", "MemoryTotal", "Usage", "Power", "Count", "Compute", "averages", "place", "twoDecimals", "uint64", "Average", "return"], "doc_head": "// Calculate the average stats of a list of system_stats records without reflect\nfunc (rm *RecordManager) AverageSystemStats(db dbx.Builder, records RecordIds) *system.Stats {\n\t// Clear/reset global structs for reuse\n\tsumStats = system.Stats{}\n\ttempStats = system.Stats{}\n\tsum := &sumStats\n\tstats := &tempStats\n\t// necessary because uint8 is not big enough for the sum\n\tbatterySum := 0\n\tcount := float64(len(records))\n\ttempCount := float64(0)\n\t// Accumulate totals\n\tfor _, record := range records {\n\t\tid := record.Id\n\t\t// clear global statsRecord for reuse\n\t\tstatsRecord.Stats = statsRecord.Stats[:0]\n\t\tqueryParams[\"id\"] = id\n\t\tdb.NewQuery(\"SELECT stats FROM system_stats WHERE id = {:id}\").Bind(queryParams).One(&statsRecord)\n\t\tif err := json.Unmarshal(statsRecord.Stats, stats); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tsum.Cpu += stats.Cpu\n\t\tsum.Mem += stats.Mem\n\t\tsum.MemUsed += stats.MemUsed\n\t\tsum.MemPct += stats.MemPct\n\t\tsum.MemBuffCache += stats.MemBuffCache\n\t\tsum.MemZfsArc += stats.MemZfsArc\n\t\tsum.Swap += stats.Swap\n\t\tsum.SwapUsed += stats.SwapUsed\n\t\tsum.DiskTotal += stats.DiskTotal\n\t\tsum.DiskUsed += stats.DiskUsed\n\t\tsum.DiskPct += stats.DiskPct\n\t\tsum.DiskReadPs += stats.DiskReadPs\n\t\tsum.DiskWrit"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go", "rel_path": "src/records/records.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 338, "end_line": 383, "text": "// Calculate the average stats of a list of container_stats records\nfunc (rm *RecordManager) AverageContainerStats(db dbx.Builder, records RecordIds) []container.Stats {\n\t// Clear global map for reuse\n\tfor k := range containerSums {\n\t\tdelete(containerSums, k)\n\t}\n\tsums := containerSums\n\tcount := float64(len(records))\n\n\tfor i := range records {\n\t\tid := records[i].Id\n\t\t// clear global statsRecord and containerStats for reuse\n\t\tstatsRecord.Stats = statsRecord.Stats[:0]\n\t\tcontainerStats = containerStats[:0]\n\n\t\tqueryParams[\"id\"] = id\n\t\tdb.NewQuery(\"SELECT stats FROM container_stats WHERE id = {:id}\").Bind(queryParams).One(&statsRecord)\n\n\t\tif err := json.Unmarshal(statsRecord.Stats, &containerStats); err != nil {\n\t\t\treturn []container.Stats{}\n\t\t}\n\t\tfor i := range containerStats {\n\t\t\tstat := containerStats[i]\n\t\t\tif _, ok := sums[stat.Name]; !ok {\n\t\t\t\tsums[stat.Name] = &container.Stats{Name: stat.Name}\n\t\t\t}\n\t\t\tsums[stat.Name].Cpu += stat.Cpu\n\t\t\tsums[stat.Name].Mem += stat.Mem\n\t\t\tsums[stat.Name].NetworkSent += stat.NetworkSent\n\t\t\tsums[stat.Name].NetworkRecv += stat.NetworkRecv\n\t\t}\n\t}\n\n\tresult := make([]container.Stats, 0, len(sums))\n\tfor _, value := range sums {\n\t\tresult = append(result, container.Stats{\n\t\t\tName:        value.Name,\n\t\t\tCpu:         twoDecimals(value.Cpu / count),\n\t\t\tMem:         twoDecimals(value.Mem / count),\n\t\t\tNetworkSent: twoDecimals(value.NetworkSent / count),\n\t\t\tNetworkRecv: twoDecimals(value.NetworkRecv / count),\n\t\t})\n\t}\n\treturn result\n}\n", "n_tokens": 402, "primary_symbol": "AverageContainerStats", "primary_kind": "function", "primary_span": [339, 383], "def_symbols": ["AverageContainerStats"], "symbols": ["AverageContainerStats", "Calculate", "the", "average", "stats", "list", "container_stats", "records", "func", "RecordManager", "dbx", "Builder", "RecordIds", "container", "Stats", "Clear", "global", "map", "for", "reuse", "range", "containerSums", "delete", "sums", "count", "float64", "len", "clear", "statsRecord", "and", "containerStats", "queryParams", "NewQuery", "SELECT", "FROM", "WHERE", "Bind", "One", "err", "json", "Unmarshal", "nil", "return", "stat", "Name", "Cpu", "Mem", "NetworkSent", "NetworkRecv", "result", "make", "value", "append", "twoDecimals"], "doc_head": "// Calculate the average stats of a list of container_stats records\nfunc (rm *RecordManager) AverageContainerStats(db dbx.Builder, records RecordIds) []container.Stats {\n\t// Clear global map for reuse\n\tfor k := range containerSums {\n\t\tdelete(containerSums, k)\n\t}\n\tsums := containerSums\n\tcount := float64(len(records))\n\tfor i := range records {\n\t\tid := records[i].Id\n\t\t// clear global statsRecord and containerStats for reuse\n\t\tstatsRecord.Stats = statsRecord.Stats[:0]\n\t\tcontainerStats = containerStats[:0]\n\t\tqueryParams[\"id\"] = id\n\t\tdb.NewQuery(\"SELECT stats FROM container_stats WHERE id = {:id}\").Bind(queryParams).One(&statsRecord)\n\t\tif err := json.Unmarshal(statsRecord.Stats, &containerStats); err != nil {\n\t\t\treturn []container.Stats{}\n\t\t}\n\t\tfor i := range containerStats {\n\t\t\tstat := containerStats[i]\n\t\t\tif _, ok := sums[stat.Name]; !ok {\n\t\t\t\tsums[stat.Name] = &container.Stats{Name: stat.Name}\n\t\t\t}\n\t\t\tsums[stat.Name].Cpu += stat.Cpu\n\t\t\tsums[stat.Name].Mem += stat.Mem\n\t\t\tsums[stat.Name].NetworkSent += stat.NetworkSent\n\t\t\tsums[stat.Name].NetworkRecv += stat.NetworkRecv\n\t\t}\n\t}\n\tresult := make([]container.Stats, 0, len(sums))\n\tfor _, value := range sums {\n\t\tresult = append(result, contain"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go", "rel_path": "src/records/records.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 384, "end_line": 401, "text": "// Delete old records\nfunc (rm *RecordManager) DeleteOldRecords() {\n\trm.app.RunInTransaction(func(txApp core.App) error {\n\t\terr := deleteOldSystemStats(txApp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = deleteOldAlertsHistory(txApp, 200, 250)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// Delete old alerts history records\nfunc deleteOldAlertsHistory(app core.App, countToKeep, countBeforeDeletion int) error {\n\tdb := app.DB()", "n_tokens": 124, "primary_symbol": "DeleteOldRecords", "primary_kind": "function", "primary_span": [385, 401], "def_symbols": ["DeleteOldRecords", "deleteOldAlertsHistory"], "symbols": ["DeleteOldRecords", "deleteOldAlertsHistory", "Delete", "old", "records", "func", "RecordManager", "app", "RunInTransaction", "txApp", "core", "App", "error", "err", "deleteOldSystemStats", "nil", "return", "alerts", "history", "countToKeep", "countBeforeDeletion", "int"], "doc_head": "// Delete old records\nfunc (rm *RecordManager) DeleteOldRecords() {\n\trm.app.RunInTransaction(func(txApp core.App) error {\n\t\terr := deleteOldSystemStats(txApp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = deleteOldAlertsHistory(txApp, 200, 250)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n// Delete old alerts history records\nfunc deleteOldAlertsHistory(app core.App, countToKeep, countBeforeDeletion int) error {\n\tdb := app.DB()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go", "rel_path": "src/records/records.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 402, "end_line": 417, "text": "\tvar users []struct {\n\t\tId string `db:\"user\"`\n\t}\n\terr := db.NewQuery(\"SELECT user, COUNT(*) as count FROM alerts_history GROUP BY user HAVING count > {:countBeforeDeletion}\").Bind(dbx.Params{\"countBeforeDeletion\": countBeforeDeletion}).All(&users)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, user := range users {\n\t\t_, err = db.NewQuery(\"DELETE FROM alerts_history WHERE user = {:user} AND id NOT IN (SELECT id FROM alerts_history WHERE user = {:user} ORDER BY created DESC LIMIT {:countToKeep})\").Bind(dbx.Params{\"user\": user.Id, \"countToKeep\": countToKeep}).Execute()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n", "n_tokens": 168, "primary_symbol": "", "primary_kind": "", "primary_span": [402, 417], "def_symbols": [], "symbols": ["var", "users", "struct", "string", "user", "err", "NewQuery", "SELECT", "COUNT", "count", "FROM", "alerts_history", "GROUP", "HAVING", "countBeforeDeletion", "Bind", "dbx", "Params", "All", "nil", "return", "for", "range", "DELETE", "WHERE", "AND", "NOT", "ORDER", "created", "DESC", "LIMIT", "countToKeep", "Execute"], "doc_head": "\tvar users []struct {\n\t\tId string `db:\"user\"`\n\t}\n\terr := db.NewQuery(\"SELECT user, COUNT(*) as count FROM alerts_history GROUP BY user HAVING count > {:countBeforeDeletion}\").Bind(dbx.Params{\"countBeforeDeletion\": countBeforeDeletion}).All(&users)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, user := range users {\n\t\t_, err = db.NewQuery(\"DELETE FROM alerts_history WHERE user = {:user} AND id NOT IN (SELECT id FROM alerts_history WHERE user = {:user} ORDER BY created DESC LIMIT {:countToKeep})\").Bind(dbx.Params{\"user\": user.Id, \"countToKeep\": countToKeep}).Execute()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go", "rel_path": "src/records/records.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 418, "end_line": 422, "text": "// Deletes system_stats records older than what is displayed in the UI\nfunc deleteOldSystemStats(app core.App) error {\n\t// Collections to process\n\tcollections := [2]string{\"system_stats\", \"container_stats\"}\n", "n_tokens": 45, "primary_symbol": "deleteOldSystemStats", "primary_kind": "function", "primary_span": [419, 422], "def_symbols": ["deleteOldSystemStats"], "symbols": ["deleteOldSystemStats", "Deletes", "system_stats", "records", "older", "than", "what", "displayed", "the", "func", "app", "core", "App", "error", "Collections", "process", "collections", "string", "container_stats"], "doc_head": "// Deletes system_stats records older than what is displayed in the UI\nfunc deleteOldSystemStats(app core.App) error {\n\t// Collections to process\n\tcollections := [2]string{\"system_stats\", \"container_stats\"}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go", "rel_path": "src/records/records.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 423, "end_line": 459, "text": "\t// Record types and their retention periods\n\ttype RecordDeletionData struct {\n\t\trecordType string\n\t\tretention  time.Duration\n\t}\n\trecordData := []RecordDeletionData{\n\t\t{recordType: \"1m\", retention: time.Hour},             // 1 hour\n\t\t{recordType: \"10m\", retention: 12 * time.Hour},       // 12 hours\n\t\t{recordType: \"20m\", retention: 24 * time.Hour},       // 1 day\n\t\t{recordType: \"120m\", retention: 7 * 24 * time.Hour},  // 7 days\n\t\t{recordType: \"480m\", retention: 30 * 24 * time.Hour}, // 30 days\n\t}\n\n\tnow := time.Now().UTC()\n\n\tfor _, collection := range collections {\n\t\t// Build the WHERE clause\n\t\tvar conditionParts []string\n\t\tvar params dbx.Params = make(map[string]any)\n\t\tfor i := range recordData {\n\t\t\trd := recordData[i]\n\t\t\t// Create parameterized condition for this record type\n\t\t\tdateParam := fmt.Sprintf(\"date%d\", i)\n\t\t\tconditionParts = append(conditionParts, fmt.Sprintf(\"(type = '%s' AND created < {:%s})\", rd.recordType, dateParam))\n\t\t\tparams[dateParam] = now.Add(-rd.retention)\n\t\t}\n\t\t// Combine conditions with OR\n\t\tconditionStr := strings.Join(conditionParts, \" OR \")\n\t\t// Construct and execute the full raw query\n\t\trawQuery := fmt.Sprintf(\"DELETE FROM %s WHERE %s\", collection, conditionStr)\n\t\tif _, err := app.DB().NewQuery(rawQuery).Bind(params).Execute(); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to delete from %s: %v\", collection, err)\n\t\t}\n\t}\n\treturn nil\n}\n", "n_tokens": 393, "primary_symbol": "", "primary_kind": "", "primary_span": [423, 459], "def_symbols": [], "symbols": ["Record", "types", "and", "their", "retention", "periods", "type", "RecordDeletionData", "struct", "recordType", "string", "time", "Duration", "recordData", "Hour", "hour", "hours", "day", "days", "now", "Now", "UTC", "for", "collection", "range", "collections", "Build", "the", "WHERE", "clause", "var", "conditionParts", "params", "dbx", "Params", "make", "map", "any", "Create", "parameterized", "condition", "this", "record", "dateParam", "fmt", "Sprintf", "date", "append", "AND", "created", "Add", "Combine", "conditions", "with", "conditionStr", "strings", "Join", "Construct", "execute", "full", "raw", "query", "rawQuery", "DELETE", "FROM", "err", "app", "NewQuery", "Bind", "Execute", "nil", "return", "Errorf", "failed", "delete", "from"], "doc_head": "\t// Record types and their retention periods\n\ttype RecordDeletionData struct {\n\t\trecordType string\n\t\tretention  time.Duration\n\t}\n\trecordData := []RecordDeletionData{\n\t\t{recordType: \"1m\", retention: time.Hour},             // 1 hour\n\t\t{recordType: \"10m\", retention: 12 * time.Hour},       // 12 hours\n\t\t{recordType: \"20m\", retention: 24 * time.Hour},       // 1 day\n\t\t{recordType: \"120m\", retention: 7 * 24 * time.Hour},  // 7 days\n\t\t{recordType: \"480m\", retention: 30 * 24 * time.Hour}, // 30 days\n\t}\n\tnow := time.Now().UTC()\n\tfor _, collection := range collections {\n\t\t// Build the WHERE clause\n\t\tvar conditionParts []string\n\t\tvar params dbx.Params = make(map[string]any)\n\t\tfor i := range recordData {\n\t\t\trd := recordData[i]\n\t\t\t// Create parameterized condition for this record type\n\t\t\tdateParam := fmt.Sprintf(\"date%d\", i)\n\t\t\tconditionParts = append(conditionParts, fmt.Sprintf(\"(type = '%s' AND created < {:%s})\", rd.recordType, dateParam))\n\t\t\tparams[dateParam] = now.Add(-rd.retention)\n\t\t}\n\t\t// Combine conditions with OR\n\t\tconditionStr := strings.Join(conditionParts, \" OR \")\n\t\t// Construct and execute the full raw query\n\t\trawQuery := fmt.Sprintf(\"DELETE FROM %s WHERE %s\", collection, conditio"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records.go", "rel_path": "src/records/records.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 460, "end_line": 464, "text": "/* Round float to two decimals */\nfunc twoDecimals(value float64) float64 {\n\treturn math.Round(value*100) / 100\n}\n", "n_tokens": 30, "primary_symbol": "twoDecimals", "primary_kind": "function", "primary_span": [461, 464], "def_symbols": ["twoDecimals"], "symbols": ["twoDecimals", "Round", "float", "two", "decimals", "func", "value", "float64", "return", "math"], "doc_head": "/* Round float to two decimals */\nfunc twoDecimals(value float64) float64 {\n\treturn math.Round(value*100) / 100\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test_helpers.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test_helpers.go", "rel_path": "src/records/records_test_helpers.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 24, "text": "//go:build testing\n// +build testing\n\npackage records\n\nimport (\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n\n// TestDeleteOldSystemStats exposes deleteOldSystemStats for testing\nfunc TestDeleteOldSystemStats(app core.App) error {\n\treturn deleteOldSystemStats(app)\n}\n\n// TestDeleteOldAlertsHistory exposes deleteOldAlertsHistory for testing\nfunc TestDeleteOldAlertsHistory(app core.App, countToKeep, countBeforeDeletion int) error {\n\treturn deleteOldAlertsHistory(app, countToKeep, countBeforeDeletion)\n}\n\n// TestTwoDecimals exposes twoDecimals for testing\nfunc TestTwoDecimals(value float64) float64 {\n\treturn twoDecimals(value)\n}\n", "n_tokens": 150, "primary_symbol": "TestDeleteOldSystemStats", "primary_kind": "function", "primary_span": [11, 24], "def_symbols": ["TestDeleteOldSystemStats", "TestDeleteOldAlertsHistory", "TestTwoDecimals"], "symbols": ["TestDeleteOldSystemStats", "TestDeleteOldAlertsHistory", "TestTwoDecimals", "build", "testing", "package", "records", "import", "github", "com", "pocketbase", "core", "exposes", "deleteOldSystemStats", "for", "func", "app", "App", "error", "return", "deleteOldAlertsHistory", "countToKeep", "countBeforeDeletion", "int", "twoDecimals", "value", "float64"], "doc_head": "//go:build testing\n// +build testing\npackage records\nimport (\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n// TestDeleteOldSystemStats exposes deleteOldSystemStats for testing\nfunc TestDeleteOldSystemStats(app core.App) error {\n\treturn deleteOldSystemStats(app)\n}\n// TestDeleteOldAlertsHistory exposes deleteOldAlertsHistory for testing\nfunc TestDeleteOldAlertsHistory(app core.App, countToKeep, countBeforeDeletion int) error {\n\treturn deleteOldAlertsHistory(app, countToKeep, countBeforeDeletion)\n}\n// TestTwoDecimals exposes twoDecimals for testing\nfunc TestTwoDecimals(value float64) float64 {\n\treturn twoDecimals(value)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go", "rel_path": "src/records/records_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 20, "text": "//go:build testing\n// +build testing\n\npackage records_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/records\"\n\t\"github.com/henrygd/beszel/src/tests\"\n\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tools/types\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n", "n_tokens": 101, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 20], "def_symbols": [], "symbols": ["build", "testing", "package", "records_test", "import", "fmt", "time", "github", "com", "henrygd", "beszel", "src", "records", "tests", "pocketbase", "dbx", "core", "tools", "types", "stretchr", "testify", "assert", "require"], "doc_head": "//go:build testing\n// +build testing\npackage records_test\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/records\"\n\t\"github.com/henrygd/beszel/src/tests\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tools/types\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go", "rel_path": "src/records/records_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 21, "end_line": 105, "text": "// TestDeleteOldRecords tests the main DeleteOldRecords function\nfunc TestDeleteOldRecords(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer hub.Cleanup()\n\n\trm := records.NewRecordManager(hub)\n\n\t// Create test user for alerts history\n\tuser, err := tests.CreateUser(hub, \"test@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\n\t// Create test system\n\tsystem, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"up\",\n\t\t\"users\":  []string{user.Id},\n\t})\n\trequire.NoError(t, err)\n\n\tnow := time.Now()\n\n\t// Create old system_stats records that should be deleted\n\tvar record *core.Record\n\trecord, err = tests.CreateRecord(hub, \"system_stats\", map[string]any{\n\t\t\"system\": system.Id,\n\t\t\"type\":   \"1m\",\n\t\t\"stats\":  `{\"cpu\": 50.0, \"mem\": 1024}`,\n\t})\n\trequire.NoError(t, err)\n\t// created is autodate field, so we need to set it manually\n\trecord.SetRaw(\"created\", now.UTC().Add(-2*time.Hour).Format(types.DefaultDateLayout))\n\terr = hub.SaveNoValidate(record)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, record)\n\trequire.InDelta(t, record.GetDateTime(\"created\").Time().UTC().Unix(), now.UTC().Add(-2*time.Hour).Unix(), 1)\n\trequire.Equal(t, record.Get(\"system\"), system.Id)\n\trequire.Equal(t, record.Get(\"type\"), \"1m\")\n\n\t// Create recent system_stats record that should be kept\n\t_, err = tests.CreateRecord(hub, \"system_stats\", map[string]any{\n\t\t\"system\":  system.Id,\n\t\t\"type\":    \"1m\",\n\t\t\"stats\":   `{\"cpu\": 30.0, \"mem\": 512}`,\n\t\t\"created\": now.Add(-30 * time.Minute), // 30 minutes old, should be kept\n\t})\n\trequire.NoError(t, err)\n\n\t// Create many alerts history records to trigger deletion\n\tfor i := range 260 { // More than countBeforeDeletion (250)\n\t\t_, err = tests.CreateRecord(hub, \"alerts_history\", map[string]any{\n\t\t\t\"user\":    user.Id,\n\t\t\t\"name\":    \"CPU\",\n\t\t\t\"value\":   i + 1,\n\t\t\t\"system\":  system.Id,\n\t\t\t\"created\": now.Add(-time.Duration(i) * time.Minute),\n\t\t})\n\t\trequire.NoError(t, err)\n\t}\n\n\t// Count records before deletion\n\tsystemStatsCountBefore, err := hub.CountRecords(\"system_stats\")\n\trequire.NoError(t, err)\n\talertsCountBefore, err := hub.CountRecords(\"alerts_history\")\n\trequire.NoError(t, err)\n\n\t// Run deletion\n\trm.DeleteOldRecords()\n\n\t// Count records after deletion\n\tsystemStatsCountAfter, err := hub.CountRecords(\"system_stats\")\n\trequire.NoError(t, err)\n\talertsCountAfter, err := hub.CountRecords(\"alerts_history\")\n\trequire.NoError(t, err)\n\n\t// Verify old system stats were deleted\n\tassert.Less(t, systemStatsCountAfter, systemStatsCountBefore, \"Old system stats should be deleted\")\n\n\t// Verify alerts history was trimmed\n\tassert.Less(t, alertsCountAfter, alertsCountBefore, \"Excessive alerts history should be deleted\")\n\tassert.Equal(t, alertsCountAfter, int64(200), \"Alerts count should be equal to countToKeep (200)\")\n}\n", "n_tokens": 780, "primary_symbol": "TestDeleteOldRecords", "primary_kind": "function", "primary_span": [22, 105], "def_symbols": ["TestDeleteOldRecords"], "symbols": ["TestDeleteOldRecords", "tests", "the", "main", "DeleteOldRecords", "function", "func", "testing", "hub", "err", "NewTestHub", "TempDir", "require", "NoError", "defer", "Cleanup", "records", "NewRecordManager", "Create", "test", "user", "for", "alerts", "history", "CreateUser", "example", "com", "testtesttest", "system", "CreateRecord", "systems", "map", "string", "any", "name", "host", "localhost", "port", "status", "users", "now", "time", "Now", "old", "system_stats", "that", "should", "deleted", "var", "record", "core", "Record", "type", "stats", "cpu", "mem", "created", "autodate", "field", "need", "set", "manually", "SetRaw", "UTC", "Add", "Hour", "Format", "types", "DefaultDateLayout", "SaveNoValidate", "NotNil", "InDelta", "GetDateTime", "Time", "Unix", "Equal", "Get", "recent", "kept", "Minute", "minutes", "many", "trigger", "deletion", "range", "More", "than", "countBeforeDeletion", "alerts_history", "CPU", "value", "Duration", "Count", "before", "systemStatsCountBefore", "CountRecords", "alertsCountBefore", "Run", "after", "systemStatsCountAfter", "alertsCountAfter", "Verify", "were", "assert", "Less", "Old", "was", "trimmed", "Excessive", "int64", "Alerts", "count", "equal", "countToKeep"], "doc_head": "// TestDeleteOldRecords tests the main DeleteOldRecords function\nfunc TestDeleteOldRecords(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer hub.Cleanup()\n\trm := records.NewRecordManager(hub)\n\t// Create test user for alerts history\n\tuser, err := tests.CreateUser(hub, \"test@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\t// Create test system\n\tsystem, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"up\",\n\t\t\"users\":  []string{user.Id},\n\t})\n\trequire.NoError(t, err)\n\tnow := time.Now()\n\t// Create old system_stats records that should be deleted\n\tvar record *core.Record\n\trecord, err = tests.CreateRecord(hub, \"system_stats\", map[string]any{\n\t\t\"system\": system.Id,\n\t\t\"type\":   \"1m\",\n\t\t\"stats\":  `{\"cpu\": 50.0, \"mem\": 1024}`,\n\t})\n\trequire.NoError(t, err)\n\t// created is autodate field, so we need to set it manually\n\trecord.SetRaw(\"created\", now.UTC().Add(-2*time.Hour).Format(types.DefaultDateLayout))\n\terr = hub.SaveNoValidate(record)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, record)\n\trequire.InDelta(t, record.GetDateTime(\"created\").Time().UTC().Unix()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go", "rel_path": "src/records/records_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 106, "end_line": 126, "text": "// TestDeleteOldSystemStats tests the deleteOldSystemStats function\nfunc TestDeleteOldSystemStats(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer hub.Cleanup()\n\n\t// Create test system\n\tuser, err := tests.CreateUser(hub, \"test@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\n\tsystem, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"up\",\n\t\t\"users\":  []string{user.Id},\n\t})\n\trequire.NoError(t, err)\n\n\tnow := time.Now().UTC()\n", "n_tokens": 163, "primary_symbol": "TestDeleteOldSystemStats", "primary_kind": "function", "primary_span": [107, 126], "def_symbols": ["TestDeleteOldSystemStats"], "symbols": ["TestDeleteOldSystemStats", "tests", "the", "deleteOldSystemStats", "function", "func", "testing", "hub", "err", "NewTestHub", "TempDir", "require", "NoError", "defer", "Cleanup", "Create", "test", "system", "user", "CreateUser", "example", "com", "testtesttest", "CreateRecord", "systems", "map", "string", "any", "name", "host", "localhost", "port", "status", "users", "now", "time", "Now", "UTC"], "doc_head": "// TestDeleteOldSystemStats tests the deleteOldSystemStats function\nfunc TestDeleteOldSystemStats(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer hub.Cleanup()\n\t// Create test system\n\tuser, err := tests.CreateUser(hub, \"test@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\tsystem, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"up\",\n\t\t\"users\":  []string{user.Id},\n\t})\n\trequire.NoError(t, err)\n\tnow := time.Now().UTC()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go", "rel_path": "src/records/records_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 127, "end_line": 197, "text": "\t// Test data for different record types and their retention periods\n\ttestCases := []struct {\n\t\trecordType   string\n\t\tretention    time.Duration\n\t\tshouldBeKept bool\n\t\tageFromNow   time.Duration\n\t\tdescription  string\n\t}{\n\t\t{\"1m\", time.Hour, true, 30 * time.Minute, \"1m record within 1 hour should be kept\"},\n\t\t{\"1m\", time.Hour, false, 2 * time.Hour, \"1m record older than 1 hour should be deleted\"},\n\t\t{\"10m\", 12 * time.Hour, true, 6 * time.Hour, \"10m record within 12 hours should be kept\"},\n\t\t{\"10m\", 12 * time.Hour, false, 24 * time.Hour, \"10m record older than 12 hours should be deleted\"},\n\t\t{\"20m\", 24 * time.Hour, true, 12 * time.Hour, \"20m record within 24 hours should be kept\"},\n\t\t{\"20m\", 24 * time.Hour, false, 48 * time.Hour, \"20m record older than 24 hours should be deleted\"},\n\t\t{\"120m\", 7 * 24 * time.Hour, true, 3 * 24 * time.Hour, \"120m record within 7 days should be kept\"},\n\t\t{\"120m\", 7 * 24 * time.Hour, false, 10 * 24 * time.Hour, \"120m record older than 7 days should be deleted\"},\n\t\t{\"480m\", 30 * 24 * time.Hour, true, 15 * 24 * time.Hour, \"480m record within 30 days should be kept\"},\n\t\t{\"480m\", 30 * 24 * time.Hour, false, 45 * 24 * time.Hour, \"480m record older than 30 days should be deleted\"},\n\t}\n\n\t// Create test records for both system_stats and container_stats\n\tcollections := []string{\"system_stats\", \"container_stats\"}\n\trecordIds := make(map[string][]string)\n\n\tfor _, collection := range collections {\n\t\trecordIds[collection] = make([]string, 0)\n\n\t\tfor i, tc := range testCases {\n\t\t\trecordTime := now.Add(-tc.ageFromNow)\n\n\t\t\tvar stats string\n\t\t\tif collection == \"system_stats\" {\n\t\t\t\tstats = fmt.Sprintf(`{\"cpu\": %d.0, \"mem\": %d}`, i*10, i*100)\n\t\t\t} else {\n\t\t\t\tstats = fmt.Sprintf(`[{\"name\": \"container%d\", \"cpu\": %d.0, \"mem\": %d}]`, i, i*5, i*50)\n\t\t\t}\n\n\t\t\trecord, err := tests.CreateRecord(hub, collection, map[string]any{\n\t\t\t\t\"system\": system.Id,\n\t\t\t\t\"type\":   tc.recordType,\n\t\t\t\t\"stats\":  stats,\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\t\t\trecord.SetRaw(\"created\", recordTime.Format(types.DefaultDateLayout))\n\t\t\terr = hub.SaveNoValidate(record)\n\t\t\trequire.NoError(t, err)\n\t\t\trecordIds[collection] = append(recordIds[collection], record.Id)\n\t\t}\n\t}\n\n\t// Run deletion\n\terr = records.TestDeleteOldSystemStats(hub)\n\trequire.NoError(t, err)\n\n\t// Verify results\n\tfor _, collection := range collections {\n\t\tfor i, tc := range testCases {\n\t\t\trecordId := recordIds[collection][i]\n\n\t\t\t// Try to find the record\n\t\t\t_, err := hub.FindRecordById(collection, recordId)\n\n\t\t\tif tc.shouldBeKept {\n\t\t\t\tassert.NoError(t, err, \"Record should exist: %s\", tc.description)\n\t\t\t} else {\n\t\t\t\tassert.Error(t, err, \"Record should be deleted: %s\", tc.description)\n\t\t\t}\n\t\t}\n\t}\n}\n", "n_tokens": 809, "primary_symbol": "", "primary_kind": "", "primary_span": [127, 197], "def_symbols": [], "symbols": ["Test", "data", "for", "different", "record", "types", "and", "their", "retention", "periods", "testCases", "struct", "recordType", "string", "time", "Duration", "shouldBeKept", "bool", "ageFromNow", "description", "Hour", "true", "Minute", "within", "hour", "should", "kept", "false", "older", "than", "deleted", "hours", "days", "Create", "test", "records", "both", "system_stats", "container_stats", "collections", "recordIds", "make", "map", "collection", "range", "recordTime", "now", "Add", "var", "stats", "fmt", "Sprintf", "cpu", "mem", "else", "name", "container", "err", "tests", "CreateRecord", "hub", "any", "system", "type", "require", "NoError", "SetRaw", "created", "Format", "DefaultDateLayout", "SaveNoValidate", "append", "Run", "deletion", "TestDeleteOldSystemStats", "Verify", "results", "recordId", "Try", "find", "the", "FindRecordById", "assert", "Record", "exist", "Error"], "doc_head": "\t// Test data for different record types and their retention periods\n\ttestCases := []struct {\n\t\trecordType   string\n\t\tretention    time.Duration\n\t\tshouldBeKept bool\n\t\tageFromNow   time.Duration\n\t\tdescription  string\n\t}{\n\t\t{\"1m\", time.Hour, true, 30 * time.Minute, \"1m record within 1 hour should be kept\"},\n\t\t{\"1m\", time.Hour, false, 2 * time.Hour, \"1m record older than 1 hour should be deleted\"},\n\t\t{\"10m\", 12 * time.Hour, true, 6 * time.Hour, \"10m record within 12 hours should be kept\"},\n\t\t{\"10m\", 12 * time.Hour, false, 24 * time.Hour, \"10m record older than 12 hours should be deleted\"},\n\t\t{\"20m\", 24 * time.Hour, true, 12 * time.Hour, \"20m record within 24 hours should be kept\"},\n\t\t{\"20m\", 24 * time.Hour, false, 48 * time.Hour, \"20m record older than 24 hours should be deleted\"},\n\t\t{\"120m\", 7 * 24 * time.Hour, true, 3 * 24 * time.Hour, \"120m record within 7 days should be kept\"},\n\t\t{\"120m\", 7 * 24 * time.Hour, false, 10 * 24 * time.Hour, \"120m record older than 7 days should be deleted\"},\n\t\t{\"480m\", 30 * 24 * time.Hour, true, 15 * 24 * time.Hour, \"480m record within 30 days should be kept\"},\n\t\t{\"480m\", 30 * 24 * time.Hour, false, 45 * 24 * time.Hour, \"480m record older than 30 days "}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go", "rel_path": "src/records/records_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 198, "end_line": 220, "text": "// TestDeleteOldAlertsHistory tests the deleteOldAlertsHistory function\nfunc TestDeleteOldAlertsHistory(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer hub.Cleanup()\n\n\t// Create test users\n\tuser1, err := tests.CreateUser(hub, \"user1@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\n\tuser2, err := tests.CreateUser(hub, \"user2@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\n\tsystem, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"up\",\n\t\t\"users\":  []string{user1.Id, user2.Id},\n\t})\n\trequire.NoError(t, err)\n\tnow := time.Now().UTC()\n", "n_tokens": 201, "primary_symbol": "TestDeleteOldAlertsHistory", "primary_kind": "function", "primary_span": [199, 220], "def_symbols": ["TestDeleteOldAlertsHistory"], "symbols": ["TestDeleteOldAlertsHistory", "tests", "the", "deleteOldAlertsHistory", "function", "func", "testing", "hub", "err", "NewTestHub", "TempDir", "require", "NoError", "defer", "Cleanup", "Create", "test", "users", "user1", "CreateUser", "example", "com", "testtesttest", "user2", "system", "CreateRecord", "systems", "map", "string", "any", "name", "host", "localhost", "port", "status", "now", "time", "Now", "UTC"], "doc_head": "// TestDeleteOldAlertsHistory tests the deleteOldAlertsHistory function\nfunc TestDeleteOldAlertsHistory(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer hub.Cleanup()\n\t// Create test users\n\tuser1, err := tests.CreateUser(hub, \"user1@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\tuser2, err := tests.CreateUser(hub, \"user2@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\tsystem, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"up\",\n\t\t\"users\":  []string{user1.Id, user2.Id},\n\t})\n\trequire.NoError(t, err)\n\tnow := time.Now().UTC()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go", "rel_path": "src/records/records_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 221, "end_line": 303, "text": "\ttestCases := []struct {\n\t\tname                  string\n\t\tuser                  *core.Record\n\t\talertCount            int\n\t\tcountToKeep           int\n\t\tcountBeforeDeletion   int\n\t\texpectedAfterDeletion int\n\t\tdescription           string\n\t}{\n\t\t{\n\t\t\tname:                  \"User with few alerts (below threshold)\",\n\t\t\tuser:                  user1,\n\t\t\talertCount:            100,\n\t\t\tcountToKeep:           50,\n\t\t\tcountBeforeDeletion:   150,\n\t\t\texpectedAfterDeletion: 100, // No deletion because below threshold\n\t\t\tdescription:           \"User with alerts below countBeforeDeletion should not have any deleted\",\n\t\t},\n\t\t{\n\t\t\tname:                  \"User with many alerts (above threshold)\",\n\t\t\tuser:                  user2,\n\t\t\talertCount:            300,\n\t\t\tcountToKeep:           100,\n\t\t\tcountBeforeDeletion:   200,\n\t\t\texpectedAfterDeletion: 100, // Should be trimmed to countToKeep\n\t\t\tdescription:           \"User with alerts above countBeforeDeletion should be trimmed to countToKeep\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Create alerts for this user\n\t\t\tfor i := 0; i < tc.alertCount; i++ {\n\t\t\t\t_, err := tests.CreateRecord(hub, \"alerts_history\", map[string]any{\n\t\t\t\t\t\"user\":    tc.user.Id,\n\t\t\t\t\t\"name\":    \"CPU\",\n\t\t\t\t\t\"value\":   i + 1,\n\t\t\t\t\t\"system\":  system.Id,\n\t\t\t\t\t\"created\": now.Add(-time.Duration(i) * time.Minute),\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\n\t\t\t// Count before deletion\n\t\t\tcountBefore, err := hub.CountRecords(\"alerts_history\",\n\t\t\t\tdbx.NewExp(\"user = {:user}\", dbx.Params{\"user\": tc.user.Id}))\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, int64(tc.alertCount), countBefore, \"Initial count should match\")\n\n\t\t\t// Run deletion\n\t\t\terr = records.TestDeleteOldAlertsHistory(hub, tc.countToKeep, tc.countBeforeDeletion)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Count after deletion\n\t\t\tcountAfter, err := hub.CountRecords(\"alerts_history\",\n\t\t\t\tdbx.NewExp(\"user = {:user}\", dbx.Params{\"user\": tc.user.Id}))\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, int64(tc.expectedAfterDeletion), countAfter, tc.description)\n\n\t\t\t// If deletion occurred, verify the most recent records were kept\n\t\t\tif tc.expectedAfterDeletion < tc.alertCount {\n\t\t\t\trecords, err := hub.FindRecordsByFilter(\"alerts_history\",\n\t\t\t\t\t\"user = {:user}\",\n\t\t\t\t\t\"-created\", // Order by created DESC\n\t\t\t\t\ttc.countToKeep,\n\t\t\t\t\t0,\n\t\t\t\t\tmap[string]any{\"user\": tc.user.Id})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Len(t, records, tc.expectedAfterDeletion, \"Should have exactly countToKeep records\")\n\n\t\t\t\t// Verify records are in descending order by created time\n\t\t\t\tfor i := 1; i < len(records); i++ {\n\t\t\t\t\tprev := records[i-1].GetDateTime(\"created\").Time()\n\t\t\t\t\tcurr := records[i].GetDateTime(\"created\").Time()\n\t\t\t\t\tassert.True(t, prev.After(curr) || prev.Equal(curr),\n\t\t\t\t\t\t\"Records should be ordered by created time (newest first)\")\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 746, "primary_symbol": "", "primary_kind": "", "primary_span": [221, 303], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "user", "core", "Record", "alertCount", "int", "countToKeep", "countBeforeDeletion", "expectedAfterDeletion", "description", "User", "with", "few", "alerts", "below", "threshold", "user1", "deletion", "because", "should", "not", "have", "any", "deleted", "many", "above", "user2", "Should", "trimmed", "for", "range", "Run", "func", "testing", "Create", "this", "err", "tests", "CreateRecord", "hub", "alerts_history", "map", "CPU", "value", "system", "created", "now", "Add", "time", "Duration", "Minute", "require", "NoError", "Count", "before", "countBefore", "CountRecords", "dbx", "NewExp", "Params", "assert", "Equal", "int64", "Initial", "count", "match", "records", "TestDeleteOldAlertsHistory", "after", "countAfter", "occurred", "verify", "the", "most", "recent", "were", "kept", "FindRecordsByFilter", "Order", "DESC", "Len", "exactly", "Verify", "are", "descending", "order", "len", "prev", "GetDateTime", "Time", "curr", "True", "After", "Records", "ordered", "newest", "first"], "doc_head": "\ttestCases := []struct {\n\t\tname                  string\n\t\tuser                  *core.Record\n\t\talertCount            int\n\t\tcountToKeep           int\n\t\tcountBeforeDeletion   int\n\t\texpectedAfterDeletion int\n\t\tdescription           string\n\t}{\n\t\t{\n\t\t\tname:                  \"User with few alerts (below threshold)\",\n\t\t\tuser:                  user1,\n\t\t\talertCount:            100,\n\t\t\tcountToKeep:           50,\n\t\t\tcountBeforeDeletion:   150,\n\t\t\texpectedAfterDeletion: 100, // No deletion because below threshold\n\t\t\tdescription:           \"User with alerts below countBeforeDeletion should not have any deleted\",\n\t\t},\n\t\t{\n\t\t\tname:                  \"User with many alerts (above threshold)\",\n\t\t\tuser:                  user2,\n\t\t\talertCount:            300,\n\t\t\tcountToKeep:           100,\n\t\t\tcountBeforeDeletion:   200,\n\t\t\texpectedAfterDeletion: 100, // Should be trimmed to countToKeep\n\t\t\tdescription:           \"User with alerts above countBeforeDeletion should be trimmed to countToKeep\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Create alerts for this user\n\t\t\tfor i := 0; i < tc.alertCount; i++ {\n\t\t\t\t_, err := tests.CreateRecord(hub, \"alerts_history\", map[strin"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go", "rel_path": "src/records/records_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 304, "end_line": 353, "text": "// TestDeleteOldAlertsHistoryEdgeCases tests edge cases for alerts history deletion\nfunc TestDeleteOldAlertsHistoryEdgeCases(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer hub.Cleanup()\n\n\tt.Run(\"No users with excessive alerts\", func(t *testing.T) {\n\t\t// Create user with few alerts\n\t\tuser, err := tests.CreateUser(hub, \"few@example.com\", \"testtesttest\")\n\t\trequire.NoError(t, err)\n\n\t\tsystem, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":   \"test-system\",\n\t\t\t\"host\":   \"localhost\",\n\t\t\t\"port\":   \"45876\",\n\t\t\t\"status\": \"up\",\n\t\t\t\"users\":  []string{user.Id},\n\t\t})\n\n\t\t// Create only 5 alerts (well below threshold)\n\t\tfor i := range 5 {\n\t\t\t_, err := tests.CreateRecord(hub, \"alerts_history\", map[string]any{\n\t\t\t\t\"user\":   user.Id,\n\t\t\t\t\"name\":   \"CPU\",\n\t\t\t\t\"value\":  i + 1,\n\t\t\t\t\"system\": system.Id,\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\t\t}\n\n\t\t// Should not error and should not delete anything\n\t\terr = records.TestDeleteOldAlertsHistory(hub, 10, 20)\n\t\trequire.NoError(t, err)\n\n\t\tcount, err := hub.CountRecords(\"alerts_history\")\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, int64(5), count, \"All alerts should remain\")\n\t})\n\n\tt.Run(\"Empty alerts_history table\", func(t *testing.T) {\n\t\t// Clear any existing alerts\n\t\t_, err := hub.DB().NewQuery(\"DELETE FROM alerts_history\").Execute()\n\t\trequire.NoError(t, err)\n\n\t\t// Should not error with empty table\n\t\terr = records.TestDeleteOldAlertsHistory(hub, 10, 20)\n\t\trequire.NoError(t, err)\n\t})\n}\n", "n_tokens": 431, "primary_symbol": "TestDeleteOldAlertsHistoryEdgeCases", "primary_kind": "function", "primary_span": [305, 353], "def_symbols": ["TestDeleteOldAlertsHistoryEdgeCases"], "symbols": ["TestDeleteOldAlertsHistoryEdgeCases", "tests", "edge", "cases", "for", "alerts", "history", "deletion", "func", "testing", "hub", "err", "NewTestHub", "TempDir", "require", "NoError", "defer", "Cleanup", "Run", "users", "with", "excessive", "Create", "user", "few", "CreateUser", "example", "com", "testtesttest", "system", "CreateRecord", "systems", "map", "string", "any", "name", "test", "host", "localhost", "port", "status", "only", "well", "below", "threshold", "range", "alerts_history", "CPU", "value", "Should", "not", "error", "and", "should", "delete", "anything", "records", "TestDeleteOldAlertsHistory", "count", "CountRecords", "assert", "Equal", "int64", "All", "remain", "Empty", "table", "Clear", "existing", "NewQuery", "DELETE", "FROM", "Execute", "empty"], "doc_head": "// TestDeleteOldAlertsHistoryEdgeCases tests edge cases for alerts history deletion\nfunc TestDeleteOldAlertsHistoryEdgeCases(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer hub.Cleanup()\n\tt.Run(\"No users with excessive alerts\", func(t *testing.T) {\n\t\t// Create user with few alerts\n\t\tuser, err := tests.CreateUser(hub, \"few@example.com\", \"testtesttest\")\n\t\trequire.NoError(t, err)\n\t\tsystem, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":   \"test-system\",\n\t\t\t\"host\":   \"localhost\",\n\t\t\t\"port\":   \"45876\",\n\t\t\t\"status\": \"up\",\n\t\t\t\"users\":  []string{user.Id},\n\t\t})\n\t\t// Create only 5 alerts (well below threshold)\n\t\tfor i := range 5 {\n\t\t\t_, err := tests.CreateRecord(hub, \"alerts_history\", map[string]any{\n\t\t\t\t\"user\":   user.Id,\n\t\t\t\t\"name\":   \"CPU\",\n\t\t\t\t\"value\":  i + 1,\n\t\t\t\t\"system\": system.Id,\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\t\t}\n\t\t// Should not error and should not delete anything\n\t\terr = records.TestDeleteOldAlertsHistory(hub, 10, 20)\n\t\trequire.NoError(t, err)\n\t\tcount, err := hub.CountRecords(\"alerts_history\")\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, int64(5), count, \"All alerts should remain\")\n\t})\n\tt.Run(\"Empty alerts_history t"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go", "rel_path": "src/records/records_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 354, "end_line": 365, "text": "// TestRecordManagerCreation tests RecordManager creation\nfunc TestRecordManagerCreation(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer hub.Cleanup()\n\n\trm := records.NewRecordManager(hub)\n\tassert.NotNil(t, rm, \"RecordManager should not be nil\")\n}\n\n// TestTwoDecimals tests the twoDecimals helper function\nfunc TestTwoDecimals(t *testing.T) {", "n_tokens": 93, "primary_symbol": "TestRecordManagerCreation", "primary_kind": "function", "primary_span": [355, 365], "def_symbols": ["TestRecordManagerCreation", "TestTwoDecimals"], "symbols": ["TestRecordManagerCreation", "TestTwoDecimals", "tests", "RecordManager", "creation", "func", "testing", "hub", "err", "NewTestHub", "TempDir", "require", "NoError", "defer", "Cleanup", "records", "NewRecordManager", "assert", "NotNil", "should", "not", "nil", "the", "twoDecimals", "helper", "function"], "doc_head": "// TestRecordManagerCreation tests RecordManager creation\nfunc TestRecordManagerCreation(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer hub.Cleanup()\n\trm := records.NewRecordManager(hub)\n\tassert.NotNil(t, rm, \"RecordManager should not be nil\")\n}\n// TestTwoDecimals tests the twoDecimals helper function\nfunc TestTwoDecimals(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/records/records_test.go", "rel_path": "src/records/records_test.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 366, "end_line": 383, "text": "\ttestCases := []struct {\n\t\tinput    float64\n\t\texpected float64\n\t}{\n\t\t{1.234567, 1.23},\n\t\t{1.235, 1.24}, // Should round up\n\t\t{1.0, 1.0},\n\t\t{0.0, 0.0},\n\t\t{-1.234567, -1.23},\n\t\t{-1.235, -1.23}, // Negative rounding\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := records.TestTwoDecimals(tc.input)\n\t\tassert.InDelta(t, tc.expected, result, 0.02, \"twoDecimals(%f) should equal %f\", tc.input, tc.expected)\n\t}\n}\n", "n_tokens": 160, "primary_symbol": "", "primary_kind": "", "primary_span": [366, 383], "def_symbols": [], "symbols": ["testCases", "struct", "input", "float64", "expected", "Should", "round", "Negative", "rounding", "for", "range", "result", "records", "TestTwoDecimals", "assert", "InDelta", "twoDecimals", "should", "equal"], "doc_head": "\ttestCases := []struct {\n\t\tinput    float64\n\t\texpected float64\n\t}{\n\t\t{1.234567, 1.23},\n\t\t{1.235, 1.24}, // Should round up\n\t\t{1.0, 1.0},\n\t\t{0.0, 0.0},\n\t\t{-1.234567, -1.23},\n\t\t{-1.235, -1.23}, // Negative rounding\n\t}\n\tfor _, tc := range testCases {\n\t\tresult := records.TestTwoDecimals(tc.input)\n\t\tassert.InDelta(t, tc.expected, result, 0.02, \"twoDecimals(%f) should equal %f\", tc.input, tc.expected)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go", "rel_path": "src/tests/hub.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 26, "text": "//go:build testing\n// +build testing\n\n// Package tests provides helpers for testing the application.\npackage tests\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/henrygd/beszel/src/hub\"\n\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tests\"\n\t\"github.com/stretchr/testify/assert\"\n\n\t_ \"github.com/pocketbase/pocketbase/migrations\"\n)\n\n// TestHub is a wrapper hub instance used for testing.\ntype TestHub struct {\n\tcore.App\n\t*tests.TestApp\n\t*hub.Hub\n}\n", "n_tokens": 123, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 26], "def_symbols": [], "symbols": ["build", "testing", "Package", "tests", "provides", "helpers", "for", "the", "application", "package", "import", "fmt", "github", "com", "henrygd", "beszel", "src", "hub", "pocketbase", "core", "stretchr", "testify", "assert", "migrations", "TestHub", "wrapper", "instance", "used", "type", "struct", "App", "TestApp", "Hub"], "doc_head": "//go:build testing\n// +build testing\n// Package tests provides helpers for testing the application.\npackage tests\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"github.com/henrygd/beszel/src/hub\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tests\"\n\t\"github.com/stretchr/testify/assert\"\n\t_ \"github.com/pocketbase/pocketbase/migrations\"\n)\n// TestHub is a wrapper hub instance used for testing.\ntype TestHub struct {\n\tcore.App\n\t*tests.TestApp\n\t*hub.Hub\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go", "rel_path": "src/tests/hub.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 27, "end_line": 41, "text": "// NewTestHub creates and initializes a test application instance.\n//\n// It is the caller's responsibility to call app.Cleanup() when the app is no longer needed.\nfunc NewTestHub(optTestDataDir ...string) (*TestHub, error) {\n\tvar testDataDir string\n\tif len(optTestDataDir) > 0 {\n\t\ttestDataDir = optTestDataDir[0]\n\t}\n\n\treturn NewTestHubWithConfig(core.BaseAppConfig{\n\t\tDataDir:       testDataDir,\n\t\tEncryptionEnv: \"pb_test_env\",\n\t})\n}\n", "n_tokens": 111, "primary_symbol": "NewTestHub", "primary_kind": "function", "primary_span": [30, 41], "def_symbols": ["NewTestHub"], "symbols": ["NewTestHub", "creates", "and", "initializes", "test", "application", "instance", "the", "caller", "responsibility", "call", "app", "Cleanup", "when", "longer", "needed", "func", "optTestDataDir", "string", "TestHub", "error", "var", "testDataDir", "len", "return", "NewTestHubWithConfig", "core", "BaseAppConfig", "DataDir", "EncryptionEnv", "pb_test_env"], "doc_head": "// NewTestHub creates and initializes a test application instance.\n//\n// It is the caller's responsibility to call app.Cleanup() when the app is no longer needed.\nfunc NewTestHub(optTestDataDir ...string) (*TestHub, error) {\n\tvar testDataDir string\n\tif len(optTestDataDir) > 0 {\n\t\ttestDataDir = optTestDataDir[0]\n\t}\n\treturn NewTestHubWithConfig(core.BaseAppConfig{\n\t\tDataDir:       testDataDir,\n\t\tEncryptionEnv: \"pb_test_env\",\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go", "rel_path": "src/tests/hub.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 42, "end_line": 66, "text": "// NewTestHubWithConfig creates and initializes a test application instance\n// from the provided config.\n//\n// If config.DataDir is not set it fallbacks to the default internal test data directory.\n//\n// config.DataDir is cloned for each new test application instance.\n//\n// It is the caller's responsibility to call app.Cleanup() when the app is no longer needed.\nfunc NewTestHubWithConfig(config core.BaseAppConfig) (*TestHub, error) {\n\ttestApp, err := tests.NewTestAppWithConfig(config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thub := hub.NewHub(testApp)\n\n\tt := &TestHub{\n\t\tApp:     testApp,\n\t\tTestApp: testApp,\n\t\tHub:     hub,\n\t}\n\n\treturn t, nil\n}\n", "n_tokens": 165, "primary_symbol": "NewTestHubWithConfig", "primary_kind": "function", "primary_span": [50, 66], "def_symbols": ["NewTestHubWithConfig"], "symbols": ["NewTestHubWithConfig", "creates", "and", "initializes", "test", "application", "instance", "from", "the", "provided", "config", "DataDir", "not", "set", "fallbacks", "default", "internal", "data", "directory", "cloned", "for", "each", "new", "caller", "responsibility", "call", "app", "Cleanup", "when", "longer", "needed", "func", "core", "BaseAppConfig", "TestHub", "error", "testApp", "err", "tests", "NewTestAppWithConfig", "nil", "return", "hub", "NewHub", "App", "TestApp", "Hub"], "doc_head": "// NewTestHubWithConfig creates and initializes a test application instance\n// from the provided config.\n//\n// If config.DataDir is not set it fallbacks to the default internal test data directory.\n//\n// config.DataDir is cloned for each new test application instance.\n//\n// It is the caller's responsibility to call app.Cleanup() when the app is no longer needed.\nfunc NewTestHubWithConfig(config core.BaseAppConfig) (*TestHub, error) {\n\ttestApp, err := tests.NewTestAppWithConfig(config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thub := hub.NewHub(testApp)\n\tt := &TestHub{\n\t\tApp:     testApp,\n\t\tTestApp: testApp,\n\t\tHub:     hub,\n\t}\n\treturn t, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go", "rel_path": "src/tests/hub.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 67, "end_line": 93, "text": "// Helper function to create a test user for config tests\nfunc CreateUser(app core.App, email string, password string) (*core.Record, error) {\n\tuserCollection, err := app.FindCachedCollectionByNameOrId(\"users\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuser := core.NewRecord(userCollection)\n\tuser.Set(\"email\", email)\n\tuser.Set(\"password\", password)\n\n\treturn user, app.Save(user)\n}\n\n// Helper function to create a test record\nfunc CreateRecord(app core.App, collectionName string, fields map[string]any) (*core.Record, error) {\n\tcollection, err := app.FindCachedCollectionByNameOrId(collectionName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trecord := core.NewRecord(collection)\n\trecord.Load(fields)\n\n\treturn record, app.Save(record)\n}\n", "n_tokens": 169, "primary_symbol": "CreateUser", "primary_kind": "function", "primary_span": [68, 93], "def_symbols": ["CreateUser", "CreateRecord"], "symbols": ["CreateUser", "CreateRecord", "Helper", "function", "create", "test", "user", "for", "config", "tests", "func", "app", "core", "App", "email", "string", "password", "Record", "error", "userCollection", "err", "FindCachedCollectionByNameOrId", "users", "nil", "return", "NewRecord", "Set", "Save", "record", "collectionName", "fields", "map", "any", "collection", "Load"], "doc_head": "// Helper function to create a test user for config tests\nfunc CreateUser(app core.App, email string, password string) (*core.Record, error) {\n\tuserCollection, err := app.FindCachedCollectionByNameOrId(\"users\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuser := core.NewRecord(userCollection)\n\tuser.Set(\"email\", email)\n\tuser.Set(\"password\", password)\n\treturn user, app.Save(user)\n}\n// Helper function to create a test record\nfunc CreateRecord(app core.App, collectionName string, fields map[string]any) (*core.Record, error) {\n\tcollection, err := app.FindCachedCollectionByNameOrId(collectionName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trecord := core.NewRecord(collection)\n\trecord.Load(fields)\n\treturn record, app.Save(record)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go", "rel_path": "src/tests/hub.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 94, "end_line": 106, "text": "func ClearCollection(t testing.TB, app core.App, collectionName string) error {\n\t_, err := app.DB().NewQuery(fmt.Sprintf(\"DELETE from %s\", collectionName)).Execute()\n\trecordCount, err := app.CountRecords(collectionName)\n\tassert.EqualValues(t, recordCount, 0, \"should have 0 records after clearing\")\n\treturn err\n}\n\nfunc (h *TestHub) Cleanup() {\n\th.GetAlertManager().StopWorker()\n\th.GetSystemManager().RemoveAllSystems()\n\th.TestApp.Cleanup()\n}\n", "n_tokens": 109, "primary_symbol": "ClearCollection", "primary_kind": "function", "primary_span": [94, 106], "def_symbols": ["ClearCollection", "Cleanup"], "symbols": ["ClearCollection", "Cleanup", "func", "testing", "app", "core", "App", "collectionName", "string", "error", "err", "NewQuery", "fmt", "Sprintf", "DELETE", "from", "Execute", "recordCount", "CountRecords", "assert", "EqualValues", "should", "have", "records", "after", "clearing", "return", "TestHub", "GetAlertManager", "StopWorker", "GetSystemManager", "RemoveAllSystems", "TestApp"], "doc_head": "func ClearCollection(t testing.TB, app core.App, collectionName string) error {\n\t_, err := app.DB().NewQuery(fmt.Sprintf(\"DELETE from %s\", collectionName)).Execute()\n\trecordCount, err := app.CountRecords(collectionName)\n\tassert.EqualValues(t, recordCount, 0, \"should have 0 records after clearing\")\n\treturn err\n}\nfunc (h *TestHub) Cleanup() {\n\th.GetAlertManager().StopWorker()\n\th.GetSystemManager().RemoveAllSystems()\n\th.TestApp.Cleanup()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/hub.go", "rel_path": "src/tests/hub.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 107, "end_line": 128, "text": "func CreateSystems(app core.App, count int, userId string, status string) ([]*core.Record, error) {\n\tsystems := make([]*core.Record, 0, count)\n\tfor i := range count {\n\t\tsystem, err := CreateRecord(app, \"systems\", map[string]any{\n\t\t\t\"name\":  fmt.Sprintf(\"test-system-%d\", i),\n\t\t\t\"host\":  fmt.Sprintf(\"127.0.0.%d\", i),\n\t\t\t\"port\":  \"33914\",\n\t\t\t\"users\": []string{userId},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsystem.Set(\"status\", status)\n\t\terr = app.SaveNoValidate(system)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsystems = append(systems, system)\n\t}\n\treturn systems, nil\n}\n", "n_tokens": 182, "primary_symbol": "CreateSystems", "primary_kind": "function", "primary_span": [107, 128], "def_symbols": ["CreateSystems"], "symbols": ["CreateSystems", "func", "app", "core", "App", "count", "int", "userId", "string", "status", "Record", "error", "systems", "make", "for", "range", "system", "err", "CreateRecord", "map", "any", "name", "fmt", "Sprintf", "test", "host", "port", "users", "nil", "return", "Set", "SaveNoValidate", "append"], "doc_head": "func CreateSystems(app core.App, count int, userId string, status string) ([]*core.Record, error) {\n\tsystems := make([]*core.Record, 0, count)\n\tfor i := range count {\n\t\tsystem, err := CreateRecord(app, \"systems\", map[string]any{\n\t\t\t\"name\":  fmt.Sprintf(\"test-system-%d\", i),\n\t\t\t\"host\":  fmt.Sprintf(\"127.0.0.%d\", i),\n\t\t\t\"port\":  \"33914\",\n\t\t\t\"users\": []string{userId},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsystem.Set(\"status\", status)\n\t\terr = app.SaveNoValidate(system)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsystems = append(systems, system)\n\t}\n\treturn systems, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go", "rel_path": "src/tests/api.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 25, "text": "package tests\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"maps\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pocketbase/pocketbase/apis\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\tpbtests \"github.com/pocketbase/pocketbase/tests\"\n\t\"github.com/pocketbase/pocketbase/tools/hook\"\n)\n\n// NOTE: This is a copy of https://github.com/pocketbase/pocketbase/blob/master/tests/api.go\n// with the following changes:\n// - Removed automatic cleanup of the test app in ApiScenario.Test (Aug 17 2025)\n", "n_tokens": 146, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 25], "def_symbols": [], "symbols": ["package", "tests", "import", "bytes", "context", "encoding", "json", "fmt", "maps", "net", "http", "httptest", "strings", "testing", "time", "github", "com", "pocketbase", "apis", "core", "pbtests", "tools", "hook", "NOTE", "This", "copy", "https", "blob", "master", "api", "with", "the", "following", "changes", "Removed", "automatic", "cleanup", "test", "app", "ApiScenario", "Test", "Aug"], "doc_head": "package tests\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"maps\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\t\"github.com/pocketbase/pocketbase/apis\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\tpbtests \"github.com/pocketbase/pocketbase/tests\"\n\t\"github.com/pocketbase/pocketbase/tools/hook\"\n)\n// NOTE: This is a copy of https://github.com/pocketbase/pocketbase/blob/master/tests/api.go\n// with the following changes:\n// - Removed automatic cleanup of the test app in ApiScenario.Test (Aug 17 2025)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go", "rel_path": "src/tests/api.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 26, "end_line": 93, "text": "// ApiScenario defines a single api request test case/scenario.\ntype ApiScenario struct {\n\t// Name is the test name.\n\tName string\n\n\t// Method is the HTTP method of the test request to use.\n\tMethod string\n\n\t// URL is the url/path of the endpoint you want to test.\n\tURL string\n\n\t// Body specifies the body to send with the request.\n\t//\n\t// For example:\n\t//\n\t//\tstrings.NewReader(`{\"title\":\"abc\"}`)\n\tBody io.Reader\n\n\t// Headers specifies the headers to send with the request (e.g. \"Authorization\": \"abc\")\n\tHeaders map[string]string\n\n\t// Delay adds a delay before checking the expectations usually\n\t// to ensure that all fired non-awaited go routines have finished\n\tDelay time.Duration\n\n\t// Timeout specifies how long to wait before cancelling the request context.\n\t//\n\t// A zero or negative value means that there will be no timeout.\n\tTimeout time.Duration\n\n\t// expectations\n\t// ---------------------------------------------------------------\n\n\t// ExpectedStatus specifies the expected response HTTP status code.\n\tExpectedStatus int\n\n\t// List of keywords that MUST exist in the response body.\n\t//\n\t// Either ExpectedContent or NotExpectedContent must be set if the response body is non-empty.\n\t// Leave both fields empty if you want to ensure that the response didn't have any body (e.g. 204).\n\tExpectedContent []string\n\n\t// List of keywords that MUST NOT exist in the response body.\n\t//\n\t// Either ExpectedContent or NotExpectedContent must be set if the response body is non-empty.\n\t// Leave both fields empty if you want to ensure that the response didn't have any body (e.g. 204).\n\tNotExpectedContent []string\n\n\t// List of hook events to check whether they were fired or not.\n\t//\n\t// You can use the wildcard \"*\" event key if you want to ensure\n\t// that no other hook events except those listed have been fired.\n\t//\n\t// For example:\n\t//\n\t//\tmap[string]int{ \"*\": 0 } // no hook events were fired\n\t//\tmap[string]int{ \"*\": 0, \"EventA\": 2 } // no hook events, except EventA were fired\n\t//\tmap[string]int{ \"EventA\": 2, \"EventB\": 0 } // ensures that EventA was fired exactly 2 times and EventB exactly 0 times.\n\tExpectedEvents map[string]int\n\n\t// test hooks\n\t// ---------------------------------------------------------------\n\n\tTestAppFactory func(t testing.TB) *pbtests.TestApp\n\tBeforeTestFunc func(t testing.TB, app *pbtests.TestApp, e *core.ServeEvent)\n\tAfterTestFunc  func(t testing.TB, app *pbtests.TestApp, res *http.Response)\n}\n", "n_tokens": 579, "primary_symbol": "", "primary_kind": "", "primary_span": [26, 93], "def_symbols": [], "symbols": ["ApiScenario", "defines", "single", "api", "request", "test", "case", "scenario", "type", "struct", "Name", "the", "name", "string", "Method", "HTTP", "method", "use", "URL", "url", "path", "endpoint", "you", "want", "Body", "specifies", "body", "send", "with", "For", "example", "strings", "NewReader", "title", "abc", "Reader", "Headers", "headers", "Authorization", "map", "Delay", "adds", "delay", "before", "checking", "expectations", "usually", "ensure", "that", "all", "fired", "non", "awaited", "routines", "have", "finished", "time", "Duration", "Timeout", "how", "long", "wait", "cancelling", "context", "zero", "negative", "value", "means", "there", "will", "timeout", "ExpectedStatus", "expected", "response", "status", "code", "int", "List", "keywords", "MUST", "exist", "Either", "ExpectedContent", "NotExpectedContent", "must", "set", "empty", "Leave", "both", "fields", "didn", "any", "NOT", "hook", "events", "check", "whether", "they", "were", "not", "You", "can", "wildcard", "event", "key", "other", "except", "those", "listed", "been", "EventA", "EventB", "ensures", "was", "exactly", "times", "and", "ExpectedEvents", "hooks", "TestAppFactory", "func", "testing", "pbtests", "TestApp", "BeforeTestFunc", "app", "core", "ServeEvent", "AfterTestFunc", "res", "http", "Response"], "doc_head": "// ApiScenario defines a single api request test case/scenario.\ntype ApiScenario struct {\n\t// Name is the test name.\n\tName string\n\t// Method is the HTTP method of the test request to use.\n\tMethod string\n\t// URL is the url/path of the endpoint you want to test.\n\tURL string\n\t// Body specifies the body to send with the request.\n\t//\n\t// For example:\n\t//\n\t//\tstrings.NewReader(`{\"title\":\"abc\"}`)\n\tBody io.Reader\n\t// Headers specifies the headers to send with the request (e.g. \"Authorization\": \"abc\")\n\tHeaders map[string]string\n\t// Delay adds a delay before checking the expectations usually\n\t// to ensure that all fired non-awaited go routines have finished\n\tDelay time.Duration\n\t// Timeout specifies how long to wait before cancelling the request context.\n\t//\n\t// A zero or negative value means that there will be no timeout.\n\tTimeout time.Duration\n\t// expectations\n\t// ---------------------------------------------------------------\n\t// ExpectedStatus specifies the expected response HTTP status code.\n\tExpectedStatus int\n\t// List of keywords that MUST exist in the response body.\n\t//\n\t// Either ExpectedContent or NotExpectedContent must be set if the response body is non-empty.\n\t// Leave both fiel"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go", "rel_path": "src/tests/api.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 94, "end_line": 123, "text": "// Test executes the test scenario.\n//\n// Example:\n//\n//\tfunc TestListExample(t *testing.T) {\n//\t    scenario := tests.ApiScenario{\n//\t        Name:           \"list example collection\",\n//\t        Method:         http.MethodGet,\n//\t        URL:            \"/api/collections/example/records\",\n//\t        ExpectedStatus: 200,\n//\t        ExpectedContent: []string{\n//\t            `\"totalItems\":3`,\n//\t            `\"id\":\"0yxhwia2amd8gec\"`,\n//\t            `\"id\":\"achvryl401bhse3\"`,\n//\t            `\"id\":\"llvuca81nly1qls\"`,\n//\t        },\n//\t        ExpectedEvents: map[string]int{\n//\t            \"OnRecordsListRequest\": 1,\n//\t            \"OnRecordEnrich\":       3,\n//\t        },\n//\t    }\n//\n//\t    scenario.Test(t)\n//\t}\nfunc (scenario *ApiScenario) Test(t *testing.T) {\n\tt.Run(scenario.normalizedName(), func(t *testing.T) {\n\t\tscenario.test(t)\n\t})\n}\n", "n_tokens": 222, "primary_symbol": "Test", "primary_kind": "function", "primary_span": [98, 123], "def_symbols": ["Test"], "symbols": ["Test", "executes", "the", "test", "scenario", "Example", "func", "TestListExample", "testing", "tests", "ApiScenario", "Name", "list", "example", "collection", "Method", "http", "MethodGet", "URL", "api", "collections", "records", "ExpectedStatus", "ExpectedContent", "string", "totalItems", "achvryl401bhse3", "llvuca81nly1qls", "ExpectedEvents", "map", "int", "OnRecordsListRequest", "OnRecordEnrich", "Run", "normalizedName"], "doc_head": "// Test executes the test scenario.\n//\n// Example:\n//\n//\tfunc TestListExample(t *testing.T) {\n//\t    scenario := tests.ApiScenario{\n//\t        Name:           \"list example collection\",\n//\t        Method:         http.MethodGet,\n//\t        URL:            \"/api/collections/example/records\",\n//\t        ExpectedStatus: 200,\n//\t        ExpectedContent: []string{\n//\t            `\"totalItems\":3`,\n//\t            `\"id\":\"0yxhwia2amd8gec\"`,\n//\t            `\"id\":\"achvryl401bhse3\"`,\n//\t            `\"id\":\"llvuca81nly1qls\"`,\n//\t        },\n//\t        ExpectedEvents: map[string]int{\n//\t            \"OnRecordsListRequest\": 1,\n//\t            \"OnRecordEnrich\":       3,\n//\t        },\n//\t    }\n//\n//\t    scenario.Test(t)\n//\t}\nfunc (scenario *ApiScenario) Test(t *testing.T) {\n\tt.Run(scenario.normalizedName(), func(t *testing.T) {\n\t\tscenario.test(t)\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go", "rel_path": "src/tests/api.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 124, "end_line": 155, "text": "// Benchmark benchmarks the test scenario.\n//\n// Example:\n//\n//\tfunc BenchmarkListExample(b *testing.B) {\n//\t    scenario := tests.ApiScenario{\n//\t        Name:           \"list example collection\",\n//\t        Method:         http.MethodGet,\n//\t        URL:            \"/api/collections/example/records\",\n//\t        ExpectedStatus: 200,\n//\t        ExpectedContent: []string{\n//\t            `\"totalItems\":3`,\n//\t            `\"id\":\"0yxhwia2amd8gec\"`,\n//\t            `\"id\":\"achvryl401bhse3\"`,\n//\t            `\"id\":\"llvuca81nly1qls\"`,\n//\t        },\n//\t        ExpectedEvents: map[string]int{\n//\t            \"OnRecordsListRequest\": 1,\n//\t            \"OnRecordEnrich\":       3,\n//\t        },\n//\t    }\n//\n//\t    scenario.Benchmark(b)\n//\t}\nfunc (scenario *ApiScenario) Benchmark(b *testing.B) {\n\tb.Run(scenario.normalizedName(), func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tscenario.test(b)\n\t\t}\n\t})\n}\n", "n_tokens": 241, "primary_symbol": "Benchmark", "primary_kind": "function", "primary_span": [128, 155], "def_symbols": ["Benchmark"], "symbols": ["Benchmark", "benchmarks", "the", "test", "scenario", "Example", "func", "BenchmarkListExample", "testing", "tests", "ApiScenario", "Name", "list", "example", "collection", "Method", "http", "MethodGet", "URL", "api", "collections", "records", "ExpectedStatus", "ExpectedContent", "string", "totalItems", "achvryl401bhse3", "llvuca81nly1qls", "ExpectedEvents", "map", "int", "OnRecordsListRequest", "OnRecordEnrich", "Run", "normalizedName", "for"], "doc_head": "// Benchmark benchmarks the test scenario.\n//\n// Example:\n//\n//\tfunc BenchmarkListExample(b *testing.B) {\n//\t    scenario := tests.ApiScenario{\n//\t        Name:           \"list example collection\",\n//\t        Method:         http.MethodGet,\n//\t        URL:            \"/api/collections/example/records\",\n//\t        ExpectedStatus: 200,\n//\t        ExpectedContent: []string{\n//\t            `\"totalItems\":3`,\n//\t            `\"id\":\"0yxhwia2amd8gec\"`,\n//\t            `\"id\":\"achvryl401bhse3\"`,\n//\t            `\"id\":\"llvuca81nly1qls\"`,\n//\t        },\n//\t        ExpectedEvents: map[string]int{\n//\t            \"OnRecordsListRequest\": 1,\n//\t            \"OnRecordEnrich\":       3,\n//\t        },\n//\t    }\n//\n//\t    scenario.Benchmark(b)\n//\t}\nfunc (scenario *ApiScenario) Benchmark(b *testing.B) {\n\tb.Run(scenario.normalizedName(), func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tscenario.test(b)\n\t\t}\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go", "rel_path": "src/tests/api.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 156, "end_line": 165, "text": "func (scenario *ApiScenario) normalizedName() string {\n\tvar name = scenario.Name\n\n\tif name == \"\" {\n\t\tname = fmt.Sprintf(\"%s:%s\", scenario.Method, scenario.URL)\n\t}\n\n\treturn name\n}\n", "n_tokens": 45, "primary_symbol": "normalizedName", "primary_kind": "function", "primary_span": [156, 165], "def_symbols": ["normalizedName"], "symbols": ["normalizedName", "func", "scenario", "ApiScenario", "string", "var", "name", "Name", "fmt", "Sprintf", "Method", "URL", "return"], "doc_head": "func (scenario *ApiScenario) normalizedName() string {\n\tvar name = scenario.Name\n\tif name == \"\" {\n\t\tname = fmt.Sprintf(\"%s:%s\", scenario.Method, scenario.URL)\n\t}\n\treturn name\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/tests/api.go", "rel_path": "src/tests/api.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 166, "end_line": 310, "text": "func (scenario *ApiScenario) test(t testing.TB) {\n\tvar testApp *pbtests.TestApp\n\tif scenario.TestAppFactory != nil {\n\t\ttestApp = scenario.TestAppFactory(t)\n\t\tif testApp == nil {\n\t\t\tt.Fatal(\"TestAppFactory must return a non-nill app instance\")\n\t\t}\n\t} else {\n\t\tvar testAppErr error\n\t\ttestApp, testAppErr = pbtests.NewTestApp()\n\t\tif testAppErr != nil {\n\t\t\tt.Fatalf(\"Failed to initialize the test app instance: %v\", testAppErr)\n\t\t}\n\t}\n\t// defer testApp.Cleanup()\n\n\tbaseRouter, err := apis.NewRouter(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// manually trigger the serve event to ensure that custom app routes and middlewares are registered\n\tserveEvent := new(core.ServeEvent)\n\tserveEvent.App = testApp\n\tserveEvent.Router = baseRouter\n\n\tserveErr := testApp.OnServe().Trigger(serveEvent, func(e *core.ServeEvent) error {\n\t\tif scenario.BeforeTestFunc != nil {\n\t\t\tscenario.BeforeTestFunc(t, testApp, e)\n\t\t}\n\n\t\t// reset the event counters in case a hook was triggered from a before func (eg. db save)\n\t\ttestApp.ResetEventCalls()\n\n\t\t// add middleware to timeout long-running requests (eg. keep-alive routes)\n\t\te.Router.Bind(&hook.Handler[*core.RequestEvent]{\n\t\t\tFunc: func(re *core.RequestEvent) error {\n\t\t\t\tslowTimer := time.AfterFunc(3*time.Second, func() {\n\t\t\t\t\tt.Logf(\"[WARN] Long running test %q\", scenario.Name)\n\t\t\t\t})\n\t\t\t\tdefer slowTimer.Stop()\n\n\t\t\t\tif scenario.Timeout > 0 {\n\t\t\t\t\tctx, cancelFunc := context.WithTimeout(re.Request.Context(), scenario.Timeout)\n\t\t\t\t\tdefer cancelFunc()\n\t\t\t\t\tre.Request = re.Request.Clone(ctx)\n\t\t\t\t}\n\n\t\t\t\treturn re.Next()\n\t\t\t},\n\t\t\tPriority: -9999,\n\t\t})\n\n\t\trecorder := httptest.NewRecorder()\n\n\t\treq := httptest.NewRequest(scenario.Method, scenario.URL, scenario.Body)\n\n\t\t// set default header\n\t\treq.Header.Set(\"content-type\", \"application/json\")\n\n\t\t// set scenario headers\n\t\tfor k, v := range scenario.Headers {\n\t\t\treq.Header.Set(k, v)\n\t\t}\n\n\t\t// execute request\n\t\tmux, err := e.Router.BuildMux()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to build router mux: %v\", err)\n\t\t}\n\t\tmux.ServeHTTP(recorder, req)\n\n\t\tres := recorder.Result()\n\n\t\tif res.StatusCode != scenario.ExpectedStatus {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", scenario.ExpectedStatus, res.StatusCode)\n\t\t}\n\n\t\tif scenario.Delay > 0 {\n\t\t\ttime.Sleep(scenario.Delay)\n\t\t}\n\n\t\tif len(scenario.ExpectedContent) == 0 && len(scenario.NotExpectedContent) == 0 {\n\t\t\tif len(recorder.Body.Bytes()) != 0 {\n\t\t\t\tt.Errorf(\"Expected empty body, got \\n%v\", recorder.Body.String())\n\t\t\t}\n\t\t} else {\n\t\t\t// normalize json response format\n\t\t\tbuffer := new(bytes.Buffer)\n\t\t\terr := json.Compact(buffer, recorder.Body.Bytes())\n\t\t\tvar normalizedBody string\n\t\t\tif err != nil {\n\t\t\t\t// not a json...\n\t\t\t\tnormalizedBody = recorder.Body.String()\n\t\t\t} else {\n\t\t\t\tnormalizedBody = buffer.String()\n\t\t\t}\n\n\t\t\tfor _, item := range scenario.ExpectedContent {\n\t\t\t\tif !strings.Contains(normalizedBody, item) {\n\t\t\t\t\tt.Errorf(\"Cannot find %v in response body \\n%v\", item, normalizedBody)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor _, item := range scenario.NotExpectedContent {\n\t\t\t\tif strings.Contains(normalizedBody, item) {\n\t\t\t\t\tt.Errorf(\"Didn't expect %v in response body \\n%v\", item, normalizedBody)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tremainingEvents := maps.Clone(testApp.EventCalls)\n\n\t\tvar noOtherEventsShouldRemain bool\n\t\tfor event, expectedNum := range scenario.ExpectedEvents {\n\t\t\tif event == \"*\" && expectedNum <= 0 {\n\t\t\t\tnoOtherEventsShouldRemain = true\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tactualNum := remainingEvents[event]\n\t\t\tif actualNum != expectedNum {\n\t\t\t\tt.Errorf(\"Expected event %s to be called %d, got %d\", event, expectedNum, actualNum)\n\t\t\t}\n\n\t\t\tdelete(remainingEvents, event)\n\t\t}\n\n\t\tif noOtherEventsShouldRemain && len(remainingEvents) > 0 {\n\t\t\tt.Errorf(\"Missing expected remaining events:\\n%#v\\nAll triggered app events are:\\n%#v\", remainingEvents, testApp.EventCalls)\n\t\t}\n\n\t\tif scenario.AfterTestFunc != nil {\n\t\t\tscenario.AfterTestFunc(t, testApp, res)\n\t\t}\n\n\t\treturn nil\n\t})\n\tif serveErr != nil {\n\t\tt.Fatalf(\"Failed to trigger app serve hook: %v\", serveErr)\n\t}\n}\n", "n_tokens": 1076, "primary_symbol": "test", "primary_kind": "function", "primary_span": [166, 310], "def_symbols": ["test"], "symbols": ["test", "func", "scenario", "ApiScenario", "testing", "var", "testApp", "pbtests", "TestApp", "TestAppFactory", "nil", "Fatal", "must", "return", "non", "nill", "app", "instance", "else", "testAppErr", "error", "NewTestApp", "Fatalf", "Failed", "initialize", "the", "defer", "Cleanup", "baseRouter", "err", "apis", "NewRouter", "manually", "trigger", "serve", "event", "ensure", "that", "custom", "routes", "and", "middlewares", "are", "registered", "serveEvent", "new", "core", "ServeEvent", "App", "Router", "serveErr", "OnServe", "Trigger", "BeforeTestFunc", "reset", "counters", "case", "hook", "was", "triggered", "from", "before", "save", "ResetEventCalls", "add", "middleware", "timeout", "long", "running", "requests", "keep", "alive", "Bind", "Handler", "RequestEvent", "Func", "slowTimer", "time", "AfterFunc", "Second", "Logf", "WARN", "Long", "Name", "Stop", "Timeout", "ctx", "cancelFunc", "context", "WithTimeout", "Request", "Context", "Clone", "Next", "Priority", "recorder", "httptest", "NewRecorder", "req", "NewRequest", "Method", "URL", "Body", "set", "default", "header", "Header", "Set", "content", "type", "application", "json", "headers", "for", "range", "Headers", "execute", "request", "mux", "BuildMux", "build", "router", "ServeHTTP", "res", "Result", "StatusCode", "ExpectedStatus", "Errorf", "Expected", "status", "code", "got", "Delay", "Sleep", "len", "ExpectedContent", "NotExpectedContent", "Bytes", "empty", "body", "String", "normalize", "response", "format", "buffer", "bytes", "Buffer", "Compact", "normalizedBody", "string", "not", "item", "strings", "Contains", "Cannot", "find", "break", "Didn", "expect", "remainingEvents", "maps", "EventCalls", "noOtherEventsShouldRemain", "bool", "expectedNum", "ExpectedEvents", "true", "continue", "actualNum", "called", "delete", "Missing", "expected", "remaining", "events", "nAll", "AfterTestFunc"], "doc_head": "func (scenario *ApiScenario) test(t testing.TB) {\n\tvar testApp *pbtests.TestApp\n\tif scenario.TestAppFactory != nil {\n\t\ttestApp = scenario.TestAppFactory(t)\n\t\tif testApp == nil {\n\t\t\tt.Fatal(\"TestAppFactory must return a non-nill app instance\")\n\t\t}\n\t} else {\n\t\tvar testAppErr error\n\t\ttestApp, testAppErr = pbtests.NewTestApp()\n\t\tif testAppErr != nil {\n\t\t\tt.Fatalf(\"Failed to initialize the test app instance: %v\", testAppErr)\n\t\t}\n\t}\n\t// defer testApp.Cleanup()\n\tbaseRouter, err := apis.NewRouter(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// manually trigger the serve event to ensure that custom app routes and middlewares are registered\n\tserveEvent := new(core.ServeEvent)\n\tserveEvent.App = testApp\n\tserveEvent.Router = baseRouter\n\tserveErr := testApp.OnServe().Trigger(serveEvent, func(e *core.ServeEvent) error {\n\t\tif scenario.BeforeTestFunc != nil {\n\t\t\tscenario.BeforeTestFunc(t, testApp, e)\n\t\t}\n\t\t// reset the event counters in case a hook was triggered from a before func (eg. db save)\n\t\ttestApp.ResetEventCalls()\n\t\t// add middleware to timeout long-running requests (eg. keep-alive routes)\n\t\te.Router.Bind(&hook.Handler[*core.RequestEvent]{\n\t\t\tFunc: func(re *core.RequestEvent) error {\n\t\t\t\tsl"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go", "rel_path": "src/alerts/alerts_status.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 24, "text": "package alerts\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n\ntype alertTask struct {\n\taction      string // \"schedule\" or \"cancel\"\n\tsystemName  string\n\talertRecord *core.Record\n\tdelay       time.Duration\n}\n\ntype alertInfo struct {\n\tsystemName  string\n\talertRecord *core.Record\n\texpireTime  time.Time\n}\n", "n_tokens": 92, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 24], "def_symbols": [], "symbols": ["package", "alerts", "import", "fmt", "strings", "time", "github", "com", "pocketbase", "dbx", "core", "type", "alertTask", "struct", "action", "string", "schedule", "cancel", "systemName", "alertRecord", "Record", "delay", "Duration", "alertInfo", "expireTime", "Time"], "doc_head": "package alerts\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\ntype alertTask struct {\n\taction      string // \"schedule\" or \"cancel\"\n\tsystemName  string\n\talertRecord *core.Record\n\tdelay       time.Duration\n}\ntype alertInfo struct {\n\tsystemName  string\n\talertRecord *core.Record\n\texpireTime  time.Time\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go", "rel_path": "src/alerts/alerts_status.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 25, "end_line": 58, "text": "// startWorker is a long-running goroutine that processes alert tasks\n// every x seconds. It must be running to process status alerts.\nfunc (am *AlertManager) startWorker() {\n\ttick := time.Tick(15 * time.Second)\n\tfor {\n\t\tselect {\n\t\tcase <-am.stopChan:\n\t\t\treturn\n\t\tcase task := <-am.alertQueue:\n\t\t\tswitch task.action {\n\t\t\tcase \"schedule\":\n\t\t\t\tam.pendingAlerts.Store(task.alertRecord.Id, &alertInfo{\n\t\t\t\t\tsystemName:  task.systemName,\n\t\t\t\t\talertRecord: task.alertRecord,\n\t\t\t\t\texpireTime:  time.Now().Add(task.delay),\n\t\t\t\t})\n\t\t\tcase \"cancel\":\n\t\t\t\tam.pendingAlerts.Delete(task.alertRecord.Id)\n\t\t\t}\n\t\tcase <-tick:\n\t\t\t// Check for expired alerts every tick\n\t\t\tnow := time.Now()\n\t\t\tfor key, value := range am.pendingAlerts.Range {\n\t\t\t\tinfo := value.(*alertInfo)\n\t\t\t\tif now.After(info.expireTime) {\n\t\t\t\t\t// Downtime delay has passed, process alert\n\t\t\t\t\tam.sendStatusAlert(\"down\", info.systemName, info.alertRecord)\n\t\t\t\t\tam.pendingAlerts.Delete(key)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "n_tokens": 255, "primary_symbol": "startWorker", "primary_kind": "function", "primary_span": [27, 58], "def_symbols": ["startWorker"], "symbols": ["startWorker", "long", "running", "goroutine", "that", "processes", "alert", "tasks", "every", "seconds", "must", "process", "status", "alerts", "func", "AlertManager", "tick", "time", "Tick", "Second", "for", "select", "case", "stopChan", "return", "task", "alertQueue", "switch", "action", "schedule", "pendingAlerts", "Store", "alertRecord", "alertInfo", "systemName", "expireTime", "Now", "Add", "delay", "cancel", "Delete", "Check", "expired", "now", "key", "value", "range", "Range", "info", "After", "Downtime", "has", "passed", "sendStatusAlert", "down"], "doc_head": "// startWorker is a long-running goroutine that processes alert tasks\n// every x seconds. It must be running to process status alerts.\nfunc (am *AlertManager) startWorker() {\n\ttick := time.Tick(15 * time.Second)\n\tfor {\n\t\tselect {\n\t\tcase <-am.stopChan:\n\t\t\treturn\n\t\tcase task := <-am.alertQueue:\n\t\t\tswitch task.action {\n\t\t\tcase \"schedule\":\n\t\t\t\tam.pendingAlerts.Store(task.alertRecord.Id, &alertInfo{\n\t\t\t\t\tsystemName:  task.systemName,\n\t\t\t\t\talertRecord: task.alertRecord,\n\t\t\t\t\texpireTime:  time.Now().Add(task.delay),\n\t\t\t\t})\n\t\t\tcase \"cancel\":\n\t\t\t\tam.pendingAlerts.Delete(task.alertRecord.Id)\n\t\t\t}\n\t\tcase <-tick:\n\t\t\t// Check for expired alerts every tick\n\t\t\tnow := time.Now()\n\t\t\tfor key, value := range am.pendingAlerts.Range {\n\t\t\t\tinfo := value.(*alertInfo)\n\t\t\t\tif now.After(info.expireTime) {\n\t\t\t\t\t// Downtime delay has passed, process alert\n\t\t\t\t\tam.sendStatusAlert(\"down\", info.systemName, info.alertRecord)\n\t\t\t\t\tam.pendingAlerts.Delete(key)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go", "rel_path": "src/alerts/alerts_status.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 59, "end_line": 86, "text": "// StopWorker shuts down the AlertManager.worker goroutine\nfunc (am *AlertManager) StopWorker() {\n\tclose(am.stopChan)\n}\n\n// HandleStatusAlerts manages the logic when system status changes.\nfunc (am *AlertManager) HandleStatusAlerts(newStatus string, systemRecord *core.Record) error {\n\tif newStatus != \"up\" && newStatus != \"down\" {\n\t\treturn nil\n\t}\n\n\talertRecords, err := am.getSystemStatusAlerts(systemRecord.Id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(alertRecords) == 0 {\n\t\treturn nil\n\t}\n\n\tsystemName := systemRecord.GetString(\"name\")\n\tif newStatus == \"down\" {\n\t\tam.handleSystemDown(systemName, alertRecords)\n\t} else {\n\t\tam.handleSystemUp(systemName, alertRecords)\n\t}\n\treturn nil\n}\n", "n_tokens": 178, "primary_symbol": "StopWorker", "primary_kind": "function", "primary_span": [60, 86], "def_symbols": ["StopWorker", "HandleStatusAlerts"], "symbols": ["StopWorker", "HandleStatusAlerts", "shuts", "down", "the", "AlertManager", "worker", "goroutine", "func", "close", "stopChan", "manages", "logic", "when", "system", "status", "changes", "newStatus", "string", "systemRecord", "core", "Record", "error", "return", "nil", "alertRecords", "err", "getSystemStatusAlerts", "len", "systemName", "GetString", "name", "handleSystemDown", "else", "handleSystemUp"], "doc_head": "// StopWorker shuts down the AlertManager.worker goroutine\nfunc (am *AlertManager) StopWorker() {\n\tclose(am.stopChan)\n}\n// HandleStatusAlerts manages the logic when system status changes.\nfunc (am *AlertManager) HandleStatusAlerts(newStatus string, systemRecord *core.Record) error {\n\tif newStatus != \"up\" && newStatus != \"down\" {\n\t\treturn nil\n\t}\n\talertRecords, err := am.getSystemStatusAlerts(systemRecord.Id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(alertRecords) == 0 {\n\t\treturn nil\n\t}\n\tsystemName := systemRecord.GetString(\"name\")\n\tif newStatus == \"down\" {\n\t\tam.handleSystemDown(systemName, alertRecords)\n\t} else {\n\t\tam.handleSystemUp(systemName, alertRecords)\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go", "rel_path": "src/alerts/alerts_status.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 87, "end_line": 98, "text": "// getSystemStatusAlerts retrieves all \"Status\" alert records for a given system ID.\nfunc (am *AlertManager) getSystemStatusAlerts(systemID string) ([]*core.Record, error) {\n\talertRecords, err := am.hub.FindAllRecords(\"alerts\", dbx.HashExp{\n\t\t\"system\": systemID,\n\t\t\"name\":   \"Status\",\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn alertRecords, nil\n}\n", "n_tokens": 100, "primary_symbol": "getSystemStatusAlerts", "primary_kind": "function", "primary_span": [88, 98], "def_symbols": ["getSystemStatusAlerts"], "symbols": ["getSystemStatusAlerts", "retrieves", "all", "Status", "alert", "records", "for", "given", "system", "func", "AlertManager", "systemID", "string", "core", "Record", "error", "alertRecords", "err", "hub", "FindAllRecords", "alerts", "dbx", "HashExp", "name", "nil", "return"], "doc_head": "// getSystemStatusAlerts retrieves all \"Status\" alert records for a given system ID.\nfunc (am *AlertManager) getSystemStatusAlerts(systemID string) ([]*core.Record, error) {\n\talertRecords, err := am.hub.FindAllRecords(\"alerts\", dbx.HashExp{\n\t\t\"system\": systemID,\n\t\t\"name\":   \"Status\",\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn alertRecords, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go", "rel_path": "src/alerts/alerts_status.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 99, "end_line": 116, "text": "// Schedules delayed \"down\" alerts for each alert record.\nfunc (am *AlertManager) handleSystemDown(systemName string, alertRecords []*core.Record) {\n\tfor _, alertRecord := range alertRecords {\n\t\t// Continue if alert is already scheduled\n\t\tif _, exists := am.pendingAlerts.Load(alertRecord.Id); exists {\n\t\t\tcontinue\n\t\t}\n\t\t// Schedule by adding to queue\n\t\tmin := max(1, alertRecord.GetInt(\"min\"))\n\t\tam.alertQueue <- alertTask{\n\t\t\taction:      \"schedule\",\n\t\t\tsystemName:  systemName,\n\t\t\talertRecord: alertRecord,\n\t\t\tdelay:       time.Duration(min) * time.Minute,\n\t\t}\n\t}\n}\n", "n_tokens": 146, "primary_symbol": "handleSystemDown", "primary_kind": "function", "primary_span": [100, 116], "def_symbols": ["handleSystemDown"], "symbols": ["handleSystemDown", "Schedules", "delayed", "down", "alerts", "for", "each", "alert", "record", "func", "AlertManager", "systemName", "string", "alertRecords", "core", "Record", "alertRecord", "range", "Continue", "already", "scheduled", "exists", "pendingAlerts", "Load", "continue", "Schedule", "adding", "queue", "min", "max", "GetInt", "alertQueue", "alertTask", "action", "schedule", "delay", "time", "Duration", "Minute"], "doc_head": "// Schedules delayed \"down\" alerts for each alert record.\nfunc (am *AlertManager) handleSystemDown(systemName string, alertRecords []*core.Record) {\n\tfor _, alertRecord := range alertRecords {\n\t\t// Continue if alert is already scheduled\n\t\tif _, exists := am.pendingAlerts.Load(alertRecord.Id); exists {\n\t\t\tcontinue\n\t\t}\n\t\t// Schedule by adding to queue\n\t\tmin := max(1, alertRecord.GetInt(\"min\"))\n\t\tam.alertQueue <- alertTask{\n\t\t\taction:      \"schedule\",\n\t\t\tsystemName:  systemName,\n\t\t\talertRecord: alertRecord,\n\t\t\tdelay:       time.Duration(min) * time.Minute,\n\t\t}\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go", "rel_path": "src/alerts/alerts_status.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 117, "end_line": 136, "text": "// handleSystemUp manages the logic when a system status changes to \"up\".\n// It cancels any pending alerts and sends \"up\" alerts.\nfunc (am *AlertManager) handleSystemUp(systemName string, alertRecords []*core.Record) {\n\tfor _, alertRecord := range alertRecords {\n\t\talertRecordID := alertRecord.Id\n\t\t// If alert exists for record, delete and continue (down alert not sent)\n\t\tif _, exists := am.pendingAlerts.Load(alertRecordID); exists {\n\t\t\tam.alertQueue <- alertTask{\n\t\t\t\taction:      \"cancel\",\n\t\t\t\talertRecord: alertRecord,\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\t// No alert scheduled for this record, send \"up\" alert\n\t\tif err := am.sendStatusAlert(\"up\", systemName, alertRecord); err != nil {\n\t\t\tam.hub.Logger().Error(\"Failed to send alert\", \"err\", err)\n\t\t}\n\t}\n}\n", "n_tokens": 196, "primary_symbol": "handleSystemUp", "primary_kind": "function", "primary_span": [119, 136], "def_symbols": ["handleSystemUp"], "symbols": ["handleSystemUp", "manages", "the", "logic", "when", "system", "status", "changes", "cancels", "any", "pending", "alerts", "and", "sends", "func", "AlertManager", "systemName", "string", "alertRecords", "core", "Record", "for", "alertRecord", "range", "alertRecordID", "alert", "exists", "record", "delete", "continue", "down", "not", "sent", "pendingAlerts", "Load", "alertQueue", "alertTask", "action", "cancel", "scheduled", "this", "send", "err", "sendStatusAlert", "nil", "hub", "Logger", "Error", "Failed"], "doc_head": "// handleSystemUp manages the logic when a system status changes to \"up\".\n// It cancels any pending alerts and sends \"up\" alerts.\nfunc (am *AlertManager) handleSystemUp(systemName string, alertRecords []*core.Record) {\n\tfor _, alertRecord := range alertRecords {\n\t\talertRecordID := alertRecord.Id\n\t\t// If alert exists for record, delete and continue (down alert not sent)\n\t\tif _, exists := am.pendingAlerts.Load(alertRecordID); exists {\n\t\t\tam.alertQueue <- alertTask{\n\t\t\t\taction:      \"cancel\",\n\t\t\t\talertRecord: alertRecord,\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\t// No alert scheduled for this record, send \"up\" alert\n\t\tif err := am.sendStatusAlert(\"up\", systemName, alertRecord); err != nil {\n\t\t\tam.hub.Logger().Error(\"Failed to send alert\", \"err\", err)\n\t\t}\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_status.go", "rel_path": "src/alerts/alerts_status.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 137, "end_line": 173, "text": "// sendStatusAlert sends a status alert (\"up\" or \"down\") to the users associated with the alert records.\nfunc (am *AlertManager) sendStatusAlert(alertStatus string, systemName string, alertRecord *core.Record) error {\n\tswitch alertStatus {\n\tcase \"up\":\n\t\talertRecord.Set(\"triggered\", false)\n\tcase \"down\":\n\t\talertRecord.Set(\"triggered\", true)\n\t}\n\tam.hub.Save(alertRecord)\n\n\tvar emoji string\n\tif alertStatus == \"up\" {\n\t\temoji = \"\\u2705\" // Green checkmark emoji\n\t} else {\n\t\temoji = \"\\U0001F534\" // Red alert emoji\n\t}\n\n\ttitle := fmt.Sprintf(\"Connection to %s is %s %v\", systemName, alertStatus, emoji)\n\tmessage := strings.TrimSuffix(title, emoji)\n\n\t// if errs := am.hub.ExpandRecord(alertRecord, []string{\"user\"}, nil); len(errs) > 0 {\n\t// \treturn errs[\"user\"]\n\t// }\n\t// user := alertRecord.ExpandedOne(\"user\")\n\t// if user == nil {\n\t// \treturn nil\n\t// }\n\n\treturn am.SendAlert(AlertMessageData{\n\t\tUserID:   alertRecord.GetString(\"user\"),\n\t\tTitle:    title,\n\t\tMessage:  message,\n\t\tLink:     am.hub.MakeLink(\"system\", systemName),\n\t\tLinkText: \"View \" + systemName,\n\t})\n}\n", "n_tokens": 304, "primary_symbol": "sendStatusAlert", "primary_kind": "function", "primary_span": [138, 173], "def_symbols": ["sendStatusAlert"], "symbols": ["sendStatusAlert", "sends", "status", "alert", "down", "the", "users", "associated", "with", "records", "func", "AlertManager", "alertStatus", "string", "systemName", "alertRecord", "core", "Record", "error", "switch", "case", "Set", "triggered", "false", "true", "hub", "Save", "var", "emoji", "u2705", "Green", "checkmark", "else", "U0001F534", "Red", "title", "fmt", "Sprintf", "Connection", "message", "strings", "TrimSuffix", "errs", "ExpandRecord", "user", "nil", "len", "return", "ExpandedOne", "SendAlert", "AlertMessageData", "UserID", "GetString", "Title", "Message", "Link", "MakeLink", "system", "LinkText", "View"], "doc_head": "// sendStatusAlert sends a status alert (\"up\" or \"down\") to the users associated with the alert records.\nfunc (am *AlertManager) sendStatusAlert(alertStatus string, systemName string, alertRecord *core.Record) error {\n\tswitch alertStatus {\n\tcase \"up\":\n\t\talertRecord.Set(\"triggered\", false)\n\tcase \"down\":\n\t\talertRecord.Set(\"triggered\", true)\n\t}\n\tam.hub.Save(alertRecord)\n\tvar emoji string\n\tif alertStatus == \"up\" {\n\t\temoji = \"\\u2705\" // Green checkmark emoji\n\t} else {\n\t\temoji = \"\\U0001F534\" // Red alert emoji\n\t}\n\ttitle := fmt.Sprintf(\"Connection to %s is %s %v\", systemName, alertStatus, emoji)\n\tmessage := strings.TrimSuffix(title, emoji)\n\t// if errs := am.hub.ExpandRecord(alertRecord, []string{\"user\"}, nil); len(errs) > 0 {\n\t// \treturn errs[\"user\"]\n\t// }\n\t// user := alertRecord.ExpandedOne(\"user\")\n\t// if user == nil {\n\t// \treturn nil\n\t// }\n\treturn am.SendAlert(AlertMessageData{\n\t\tUserID:   alertRecord.GetString(\"user\"),\n\t\tTitle:    title,\n\t\tMessage:  message,\n\t\tLink:     am.hub.MakeLink(\"system\", systemName),\n\t\tLinkText: \"View \" + systemName,\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go", "rel_path": "src/alerts/alerts.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 41, "text": "// Package alerts handles alert management and delivery.\npackage alerts\n\nimport (\n\t\"fmt\"\n\t\"net/mail\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/nicholas-fedor/shoutrrr\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tools/mailer\"\n)\n\ntype hubLike interface {\n\tcore.App\n\tMakeLink(parts ...string) string\n}\n\ntype AlertManager struct {\n\thub           hubLike\n\talertQueue    chan alertTask\n\tstopChan      chan struct{}\n\tpendingAlerts sync.Map\n}\n\ntype AlertMessageData struct {\n\tUserID   string\n\tTitle    string\n\tMessage  string\n\tLink     string\n\tLinkText string\n}\n\ntype UserNotificationSettings struct {\n\tEmails   []string `json:\"emails\"`\n\tWebhooks []string `json:\"webhooks\"`\n}\n", "n_tokens": 187, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 41], "def_symbols": [], "symbols": ["Package", "alerts", "handles", "alert", "management", "and", "delivery", "package", "import", "fmt", "net", "mail", "url", "sync", "time", "github", "com", "nicholas", "fedor", "shoutrrr", "pocketbase", "dbx", "core", "tools", "mailer", "type", "hubLike", "interface", "App", "MakeLink", "parts", "string", "AlertManager", "struct", "hub", "alertQueue", "chan", "alertTask", "stopChan", "pendingAlerts", "Map", "AlertMessageData", "UserID", "Title", "Message", "Link", "LinkText", "UserNotificationSettings", "Emails", "json", "emails", "Webhooks", "webhooks"], "doc_head": "// Package alerts handles alert management and delivery.\npackage alerts\nimport (\n\t\"fmt\"\n\t\"net/mail\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\t\"github.com/nicholas-fedor/shoutrrr\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tools/mailer\"\n)\ntype hubLike interface {\n\tcore.App\n\tMakeLink(parts ...string) string\n}\ntype AlertManager struct {\n\thub           hubLike\n\talertQueue    chan alertTask\n\tstopChan      chan struct{}\n\tpendingAlerts sync.Map\n}\ntype AlertMessageData struct {\n\tUserID   string\n\tTitle    string\n\tMessage  string\n\tLink     string\n\tLinkText string\n}\ntype UserNotificationSettings struct {\n\tEmails   []string `json:\"emails\"`\n\tWebhooks []string `json:\"webhooks\"`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go", "rel_path": "src/alerts/alerts.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 42, "end_line": 66, "text": "type SystemAlertStats struct {\n\tCpu          float64            `json:\"cpu\"`\n\tMem          float64            `json:\"mp\"`\n\tDisk         float64            `json:\"dp\"`\n\tNetSent      float64            `json:\"ns\"`\n\tNetRecv      float64            `json:\"nr\"`\n\tTemperatures map[string]float32 `json:\"t\"`\n\tLoadAvg      [3]float64         `json:\"la\"`\n}\n\ntype SystemAlertData struct {\n\tsystemRecord *core.Record\n\talertRecord  *core.Record\n\tname         string\n\tunit         string\n\tval          float64\n\tthreshold    float64\n\ttriggered    bool\n\ttime         time.Time\n\tcount        uint8\n\tmin          uint8\n\tmapSums      map[string]float32\n\tdescriptor   string // override descriptor in notification body (for temp sensor, disk partition, etc)\n}\n", "n_tokens": 182, "primary_symbol": "", "primary_kind": "", "primary_span": [42, 66], "def_symbols": [], "symbols": ["type", "SystemAlertStats", "struct", "Cpu", "float64", "json", "cpu", "Mem", "Disk", "NetSent", "NetRecv", "Temperatures", "map", "string", "float32", "LoadAvg", "SystemAlertData", "systemRecord", "core", "Record", "alertRecord", "name", "unit", "val", "threshold", "triggered", "bool", "time", "Time", "count", "uint8", "min", "mapSums", "descriptor", "override", "notification", "body", "for", "temp", "sensor", "disk", "partition", "etc"], "doc_head": "type SystemAlertStats struct {\n\tCpu          float64            `json:\"cpu\"`\n\tMem          float64            `json:\"mp\"`\n\tDisk         float64            `json:\"dp\"`\n\tNetSent      float64            `json:\"ns\"`\n\tNetRecv      float64            `json:\"nr\"`\n\tTemperatures map[string]float32 `json:\"t\"`\n\tLoadAvg      [3]float64         `json:\"la\"`\n}\ntype SystemAlertData struct {\n\tsystemRecord *core.Record\n\talertRecord  *core.Record\n\tname         string\n\tunit         string\n\tval          float64\n\tthreshold    float64\n\ttriggered    bool\n\ttime         time.Time\n\tcount        uint8\n\tmin          uint8\n\tmapSums      map[string]float32\n\tdescriptor   string // override descriptor in notification body (for temp sensor, disk partition, etc)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go", "rel_path": "src/alerts/alerts.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 67, "end_line": 97, "text": "// notification services that support title param\nvar supportsTitle = map[string]struct{}{\n\t\"bark\":       {},\n\t\"discord\":    {},\n\t\"gotify\":     {},\n\t\"ifttt\":      {},\n\t\"join\":       {},\n\t\"lark\":       {},\n\t\"matrix\":     {},\n\t\"ntfy\":       {},\n\t\"opsgenie\":   {},\n\t\"pushbullet\": {},\n\t\"pushover\":   {},\n\t\"slack\":      {},\n\t\"teams\":      {},\n\t\"telegram\":   {},\n\t\"zulip\":      {},\n}\n\n// NewAlertManager creates a new AlertManager instance.\nfunc NewAlertManager(app hubLike) *AlertManager {\n\tam := &AlertManager{\n\t\thub:        app,\n\t\talertQueue: make(chan alertTask, 5),\n\t\tstopChan:   make(chan struct{}),\n\t}\n\tam.bindEvents()\n\tgo am.startWorker()\n\treturn am\n}\n", "n_tokens": 193, "primary_symbol": "NewAlertManager", "primary_kind": "function", "primary_span": [87, 97], "def_symbols": ["NewAlertManager"], "symbols": ["NewAlertManager", "notification", "services", "that", "support", "title", "param", "var", "supportsTitle", "map", "string", "struct", "bark", "discord", "gotify", "ifttt", "join", "lark", "matrix", "ntfy", "opsgenie", "pushbullet", "pushover", "slack", "teams", "telegram", "zulip", "creates", "new", "AlertManager", "instance", "func", "app", "hubLike", "hub", "alertQueue", "make", "chan", "alertTask", "stopChan", "bindEvents", "startWorker", "return"], "doc_head": "// notification services that support title param\nvar supportsTitle = map[string]struct{}{\n\t\"bark\":       {},\n\t\"discord\":    {},\n\t\"gotify\":     {},\n\t\"ifttt\":      {},\n\t\"join\":       {},\n\t\"lark\":       {},\n\t\"matrix\":     {},\n\t\"ntfy\":       {},\n\t\"opsgenie\":   {},\n\t\"pushbullet\": {},\n\t\"pushover\":   {},\n\t\"slack\":      {},\n\t\"teams\":      {},\n\t\"telegram\":   {},\n\t\"zulip\":      {},\n}\n// NewAlertManager creates a new AlertManager instance.\nfunc NewAlertManager(app hubLike) *AlertManager {\n\tam := &AlertManager{\n\t\thub:        app,\n\t\talertQueue: make(chan alertTask, 5),\n\t\tstopChan:   make(chan struct{}),\n\t}\n\tam.bindEvents()\n\tgo am.startWorker()\n\treturn am\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go", "rel_path": "src/alerts/alerts.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 98, "end_line": 103, "text": "// Bind events to the alerts collection lifecycle\nfunc (am *AlertManager) bindEvents() {\n\tam.hub.OnRecordAfterUpdateSuccess(\"alerts\").BindFunc(updateHistoryOnAlertUpdate)\n\tam.hub.OnRecordAfterDeleteSuccess(\"alerts\").BindFunc(resolveHistoryOnAlertDelete)\n}\n", "n_tokens": 61, "primary_symbol": "bindEvents", "primary_kind": "function", "primary_span": [99, 103], "def_symbols": ["bindEvents"], "symbols": ["bindEvents", "Bind", "events", "the", "alerts", "collection", "lifecycle", "func", "AlertManager", "hub", "OnRecordAfterUpdateSuccess", "BindFunc", "updateHistoryOnAlertUpdate", "OnRecordAfterDeleteSuccess", "resolveHistoryOnAlertDelete"], "doc_head": "// Bind events to the alerts collection lifecycle\nfunc (am *AlertManager) bindEvents() {\n\tam.hub.OnRecordAfterUpdateSuccess(\"alerts\").BindFunc(updateHistoryOnAlertUpdate)\n\tam.hub.OnRecordAfterDeleteSuccess(\"alerts\").BindFunc(resolveHistoryOnAlertDelete)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go", "rel_path": "src/alerts/alerts.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 104, "end_line": 152, "text": "// SendAlert sends an alert to the user\nfunc (am *AlertManager) SendAlert(data AlertMessageData) error {\n\t// get user settings\n\trecord, err := am.hub.FindFirstRecordByFilter(\n\t\t\"user_settings\", \"user={:user}\",\n\t\tdbx.Params{\"user\": data.UserID},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// unmarshal user settings\n\tuserAlertSettings := UserNotificationSettings{\n\t\tEmails:   []string{},\n\t\tWebhooks: []string{},\n\t}\n\tif err := record.UnmarshalJSONField(\"settings\", &userAlertSettings); err != nil {\n\t\tam.hub.Logger().Error(\"Failed to unmarshal user settings\", \"err\", err)\n\t}\n\t// send alerts via webhooks\n\tfor _, webhook := range userAlertSettings.Webhooks {\n\t\tif err := am.SendShoutrrrAlert(webhook, data.Title, data.Message, data.Link, data.LinkText); err != nil {\n\t\t\tam.hub.Logger().Error(\"Failed to send shoutrrr alert\", \"err\", err)\n\t\t}\n\t}\n\t// send alerts via email\n\tif len(userAlertSettings.Emails) == 0 {\n\t\treturn nil\n\t}\n\taddresses := []mail.Address{}\n\tfor _, email := range userAlertSettings.Emails {\n\t\taddresses = append(addresses, mail.Address{Address: email})\n\t}\n\tmessage := mailer.Message{\n\t\tTo:      addresses,\n\t\tSubject: data.Title,\n\t\tText:    data.Message + fmt.Sprintf(\"\\n\\n%s\", data.Link),\n\t\tFrom: mail.Address{\n\t\t\tAddress: am.hub.Settings().Meta.SenderAddress,\n\t\t\tName:    am.hub.Settings().Meta.SenderName,\n\t\t},\n\t}\n\terr = am.hub.NewMailClient().Send(&message)\n\tif err != nil {\n\t\treturn err\n\t}\n\tam.hub.Logger().Info(\"Sent email alert\", \"to\", message.To, \"subj\", message.Subject)\n\treturn nil\n}\n", "n_tokens": 421, "primary_symbol": "SendAlert", "primary_kind": "function", "primary_span": [105, 152], "def_symbols": ["SendAlert"], "symbols": ["SendAlert", "sends", "alert", "the", "user", "func", "AlertManager", "data", "AlertMessageData", "error", "get", "settings", "record", "err", "hub", "FindFirstRecordByFilter", "user_settings", "dbx", "Params", "UserID", "nil", "return", "unmarshal", "userAlertSettings", "UserNotificationSettings", "Emails", "string", "Webhooks", "UnmarshalJSONField", "Logger", "Error", "Failed", "send", "alerts", "via", "webhooks", "for", "webhook", "range", "SendShoutrrrAlert", "Title", "Message", "Link", "LinkText", "shoutrrr", "email", "len", "addresses", "mail", "Address", "append", "message", "mailer", "Subject", "Text", "fmt", "Sprintf", "From", "Settings", "Meta", "SenderAddress", "Name", "SenderName", "NewMailClient", "Send", "Info", "Sent", "subj"], "doc_head": "// SendAlert sends an alert to the user\nfunc (am *AlertManager) SendAlert(data AlertMessageData) error {\n\t// get user settings\n\trecord, err := am.hub.FindFirstRecordByFilter(\n\t\t\"user_settings\", \"user={:user}\",\n\t\tdbx.Params{\"user\": data.UserID},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// unmarshal user settings\n\tuserAlertSettings := UserNotificationSettings{\n\t\tEmails:   []string{},\n\t\tWebhooks: []string{},\n\t}\n\tif err := record.UnmarshalJSONField(\"settings\", &userAlertSettings); err != nil {\n\t\tam.hub.Logger().Error(\"Failed to unmarshal user settings\", \"err\", err)\n\t}\n\t// send alerts via webhooks\n\tfor _, webhook := range userAlertSettings.Webhooks {\n\t\tif err := am.SendShoutrrrAlert(webhook, data.Title, data.Message, data.Link, data.LinkText); err != nil {\n\t\t\tam.hub.Logger().Error(\"Failed to send shoutrrr alert\", \"err\", err)\n\t\t}\n\t}\n\t// send alerts via email\n\tif len(userAlertSettings.Emails) == 0 {\n\t\treturn nil\n\t}\n\taddresses := []mail.Address{}\n\tfor _, email := range userAlertSettings.Emails {\n\t\taddresses = append(addresses, mail.Address{Address: email})\n\t}\n\tmessage := mailer.Message{\n\t\tTo:      addresses,\n\t\tSubject: data.Title,\n\t\tText:    data.Message + fmt.Sprintf(\"\\n\\n%s\", data.Link),\n\t\tF"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go", "rel_path": "src/alerts/alerts.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 153, "end_line": 206, "text": "// SendShoutrrrAlert sends an alert via a Shoutrrr URL\nfunc (am *AlertManager) SendShoutrrrAlert(notificationUrl, title, message, link, linkText string) error {\n\t// Parse the URL\n\tparsedURL, err := url.Parse(notificationUrl)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing URL: %v\", err)\n\t}\n\tscheme := parsedURL.Scheme\n\tqueryParams := parsedURL.Query()\n\n\t// Add title\n\tif _, ok := supportsTitle[scheme]; ok {\n\t\tqueryParams.Add(\"title\", title)\n\t} else if scheme == \"mattermost\" {\n\t\t// use markdown title for mattermost\n\t\tmessage = \"##### \" + title + \"\\n\\n\" + message\n\t} else if scheme == \"generic\" && queryParams.Has(\"template\") {\n\t\t// add title as property if using generic with template json\n\t\ttitleKey := queryParams.Get(\"titlekey\")\n\t\tif titleKey == \"\" {\n\t\t\ttitleKey = \"title\"\n\t\t}\n\t\tqueryParams.Add(\"$\"+titleKey, title)\n\t} else {\n\t\t// otherwise just add title to message\n\t\tmessage = title + \"\\n\\n\" + message\n\t}\n\n\t// Add link\n\tif scheme == \"ntfy\" {\n\t\tqueryParams.Add(\"Actions\", fmt.Sprintf(\"view, %s, %s\", linkText, link))\n\t} else if scheme == \"lark\" {\n\t\tqueryParams.Add(\"link\", link)\n\t} else if scheme == \"bark\" {\n\t\tqueryParams.Add(\"url\", link)\n\t} else {\n\t\tmessage += \"\\n\\n\" + link\n\t}\n\n\t// Encode the modified query parameters back into the URL\n\tparsedURL.RawQuery = queryParams.Encode()\n\t// log.Println(\"URL after modification:\", parsedURL.String())\n\n\terr = shoutrrr.Send(parsedURL.String(), message)\n\n\tif err == nil {\n\t\tam.hub.Logger().Info(\"Sent shoutrrr alert\", \"title\", title)\n\t} else {\n\t\tam.hub.Logger().Error(\"Error sending shoutrrr alert\", \"err\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n", "n_tokens": 457, "primary_symbol": "SendShoutrrrAlert", "primary_kind": "function", "primary_span": [154, 206], "def_symbols": ["SendShoutrrrAlert"], "symbols": ["SendShoutrrrAlert", "sends", "alert", "via", "Shoutrrr", "URL", "func", "AlertManager", "notificationUrl", "title", "message", "link", "linkText", "string", "error", "Parse", "the", "parsedURL", "err", "url", "nil", "return", "fmt", "Errorf", "parsing", "scheme", "Scheme", "queryParams", "Query", "Add", "supportsTitle", "else", "mattermost", "use", "markdown", "for", "generic", "Has", "template", "add", "property", "using", "with", "json", "titleKey", "Get", "titlekey", "otherwise", "just", "ntfy", "Actions", "Sprintf", "view", "lark", "bark", "Encode", "modified", "query", "parameters", "back", "into", "RawQuery", "log", "Println", "after", "modification", "String", "shoutrrr", "Send", "hub", "Logger", "Info", "Sent", "Error", "sending"], "doc_head": "// SendShoutrrrAlert sends an alert via a Shoutrrr URL\nfunc (am *AlertManager) SendShoutrrrAlert(notificationUrl, title, message, link, linkText string) error {\n\t// Parse the URL\n\tparsedURL, err := url.Parse(notificationUrl)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing URL: %v\", err)\n\t}\n\tscheme := parsedURL.Scheme\n\tqueryParams := parsedURL.Query()\n\t// Add title\n\tif _, ok := supportsTitle[scheme]; ok {\n\t\tqueryParams.Add(\"title\", title)\n\t} else if scheme == \"mattermost\" {\n\t\t// use markdown title for mattermost\n\t\tmessage = \"##### \" + title + \"\\n\\n\" + message\n\t} else if scheme == \"generic\" && queryParams.Has(\"template\") {\n\t\t// add title as property if using generic with template json\n\t\ttitleKey := queryParams.Get(\"titlekey\")\n\t\tif titleKey == \"\" {\n\t\t\ttitleKey = \"title\"\n\t\t}\n\t\tqueryParams.Add(\"$\"+titleKey, title)\n\t} else {\n\t\t// otherwise just add title to message\n\t\tmessage = title + \"\\n\\n\" + message\n\t}\n\t// Add link\n\tif scheme == \"ntfy\" {\n\t\tqueryParams.Add(\"Actions\", fmt.Sprintf(\"view, %s, %s\", linkText, link))\n\t} else if scheme == \"lark\" {\n\t\tqueryParams.Add(\"link\", link)\n\t} else if scheme == \"bark\" {\n\t\tqueryParams.Add(\"url\", link)\n\t} else {\n\t\tmessage += \"\\n\\n\" + link\n\t}\n\t// Encode "}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts.go", "rel_path": "src/alerts/alerts.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 207, "end_line": 221, "text": "func (am *AlertManager) SendTestNotification(e *core.RequestEvent) error {\n\tvar data struct {\n\t\tURL string `json:\"url\"`\n\t}\n\terr := e.BindBody(&data)\n\tif err != nil || data.URL == \"\" {\n\t\treturn e.BadRequestError(\"URL is required\", err)\n\t}\n\terr = am.SendShoutrrrAlert(data.URL, \"Test Alert\", \"This is a notification from Beszel.\", am.hub.Settings().Meta.AppURL, \"View Beszel\")\n\tif err != nil {\n\t\treturn e.JSON(200, map[string]string{\"err\": err.Error()})\n\t}\n\treturn e.JSON(200, map[string]bool{\"err\": false})\n}\n", "n_tokens": 141, "primary_symbol": "SendTestNotification", "primary_kind": "function", "primary_span": [207, 221], "def_symbols": ["SendTestNotification"], "symbols": ["SendTestNotification", "func", "AlertManager", "core", "RequestEvent", "error", "var", "data", "struct", "URL", "string", "json", "url", "err", "BindBody", "nil", "return", "BadRequestError", "required", "SendShoutrrrAlert", "Test", "Alert", "This", "notification", "from", "Beszel", "hub", "Settings", "Meta", "AppURL", "View", "JSON", "map", "Error", "bool", "false"], "doc_head": "func (am *AlertManager) SendTestNotification(e *core.RequestEvent) error {\n\tvar data struct {\n\t\tURL string `json:\"url\"`\n\t}\n\terr := e.BindBody(&data)\n\tif err != nil || data.URL == \"\" {\n\t\treturn e.BadRequestError(\"URL is required\", err)\n\t}\n\terr = am.SendShoutrrrAlert(data.URL, \"Test Alert\", \"This is a notification from Beszel.\", am.hub.Settings().Meta.AppURL, \"View Beszel\")\n\tif err != nil {\n\t\treturn e.JSON(200, map[string]string{\"err\": err.Error()})\n\t}\n\treturn e.JSON(200, map[string]bool{\"err\": false})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test.go", "rel_path": "src/alerts/alerts_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 32, "text": "//go:build testing\n// +build testing\n\npackage alerts_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\t\"testing/synctest\"\n\t\"time\"\n\n\tbeszelTests \"github.com/henrygd/beszel/src/tests\"\n\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\tpbTests \"github.com/pocketbase/pocketbase/tests\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// marshal to json and return an io.Reader (for use in ApiScenario.Body)\nfunc jsonReader(v any) io.Reader {\n\tdata, err := json.Marshal(v)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn bytes.NewReader(data)\n}\n", "n_tokens": 156, "primary_symbol": "jsonReader", "primary_kind": "function", "primary_span": [25, 32], "def_symbols": ["jsonReader"], "symbols": ["jsonReader", "build", "testing", "package", "alerts_test", "import", "bytes", "encoding", "json", "net", "http", "strings", "synctest", "time", "beszelTests", "github", "com", "henrygd", "beszel", "src", "tests", "pocketbase", "dbx", "core", "pbTests", "stretchr", "testify", "assert", "marshal", "and", "return", "Reader", "for", "use", "ApiScenario", "Body", "func", "any", "data", "err", "Marshal", "nil", "panic", "NewReader"], "doc_head": "//go:build testing\n// +build testing\npackage alerts_test\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\t\"testing/synctest\"\n\t\"time\"\n\tbeszelTests \"github.com/henrygd/beszel/src/tests\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\tpbTests \"github.com/pocketbase/pocketbase/tests\"\n\t\"github.com/stretchr/testify/assert\"\n)\n// marshal to json and return an io.Reader (for use in ApiScenario.Body)\nfunc jsonReader(v any) io.Reader {\n\tdata, err := json.Marshal(v)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn bytes.NewReader(data)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test.go", "rel_path": "src/alerts/alerts_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 33, "end_line": 371, "text": "func TestUserAlertsApi(t *testing.T) {\n\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\tdefer hub.Cleanup()\n\n\thub.StartHub()\n\n\tuser1, _ := beszelTests.CreateUser(hub, \"alertstest@example.com\", \"password\")\n\tuser1Token, _ := user1.NewAuthToken()\n\n\tuser2, _ := beszelTests.CreateUser(hub, \"alertstest2@example.com\", \"password\")\n\tuser2Token, _ := user2.NewAuthToken()\n\n\tsystem1, _ := beszelTests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":  \"system1\",\n\t\t\"users\": []string{user1.Id},\n\t\t\"host\":  \"127.0.0.1\",\n\t})\n\n\tsystem2, _ := beszelTests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":  \"system2\",\n\t\t\"users\": []string{user1.Id, user2.Id},\n\t\t\"host\":  \"127.0.0.2\",\n\t})\n\n\tuserRecords, _ := hub.CountRecords(\"users\")\n\tassert.EqualValues(t, 2, userRecords, \"all users should be created\")\n\n\tsystemRecords, _ := hub.CountRecords(\"systems\")\n\tassert.EqualValues(t, 2, systemRecords, \"all systems should be created\")\n\n\ttestAppFactory := func(t testing.TB) *pbTests.TestApp {\n\t\treturn hub.TestApp\n\t}\n\n\tscenarios := []beszelTests.ApiScenario{\n\t\t// {\n\t\t// \tName:            \"GET not implemented - returns index\",\n\t\t// \tMethod:          http.MethodGet,\n\t\t// \tURL:             \"/api/beszel/user-alerts\",\n\t\t// \tExpectedStatus:  200,\n\t\t// \tExpectedContent: []string{\"<html \", \"globalThis.BESZEL\"},\n\t\t// \tTestAppFactory:  testAppFactory,\n\t\t// },\n\t\t{\n\t\t\tName:            \"POST no auth\",\n\t\t\tMethod:          http.MethodPost,\n\t\t\tURL:             \"/api/beszel/user-alerts\",\n\t\t\tExpectedStatus:  401,\n\t\t\tExpectedContent: []string{\"requires valid\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:   \"POST no body\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": user1Token,\n\t\t\t},\n\t\t\tExpectedStatus:  400,\n\t\t\tExpectedContent: []string{\"Bad data\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:   \"POST bad data\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": user1Token,\n\t\t\t},\n\t\t\tExpectedStatus:  400,\n\t\t\tExpectedContent: []string{\"Bad data\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"invalidField\": \"this should cause validation error\",\n\t\t\t\t\"threshold\":    \"not a number\",\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tName:   \"POST malformed JSON\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": user1Token,\n\t\t\t},\n\t\t\tExpectedStatus:  400,\n\t\t\tExpectedContent: []string{\"Bad data\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody:            strings.NewReader(`{\"alertType\": \"cpu\", \"threshold\": 80, \"enabled\": true,}`),\n\t\t},\n\t\t{\n\t\t\tName:   \"POST valid alert data multiple systems\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": user1Token,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"success\\\":true\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":      \"CPU\",\n\t\t\t\t\"value\":     69,\n\t\t\t\t\"min\":       9,\n\t\t\t\t\"systems\":   []string{system1.Id, system2.Id},\n\t\t\t\t\"overwrite\": false,\n\t\t\t}),\n\t\t\tAfterTestFunc: func(t testing.TB, app *pbTests.TestApp, res *http.Response) {\n\t\t\t\t// check total alerts\n\t\t\t\talerts, _ := app.CountRecords(\"alerts\")\n\t\t\t\tassert.EqualValues(t, 2, alerts, \"should have 2 alerts\")\n\t\t\t\t// check alert has correct values\n\t\t\t\tmatchingAlerts, _ := app.CountRecords(\"alerts\", dbx.HashExp{\"name\": \"CPU\", \"user\": user1.Id, \"system\": system1.Id, \"value\": 69, \"min\": 9})\n\t\t\t\tassert.EqualValues(t, 1, matchingAlerts, \"should have 1 alert\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:   \"POST valid alert data single system\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": user1Token,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"success\\\":true\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":    \"Memory\",\n\t\t\t\t\"systems\": []string{system1.Id},\n\t\t\t\t\"value\":   90,\n\t\t\t\t\"min\":     10,\n\t\t\t}),\n\t\t\tAfterTestFunc: func(t testing.TB, app *pbTests.TestApp, res *http.Response) {\n\t\t\t\tuser1Alerts, _ := app.CountRecords(\"alerts\", dbx.HashExp{\"user\": user1.Id})\n\t\t\t\tassert.EqualValues(t, 3, user1Alerts, \"should have 3 alerts\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:   \"Overwrite: false, should not overwrite existing alert\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": user1Token,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"success\\\":true\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":      \"CPU\",\n\t\t\t\t\"value\":     45,\n\t\t\t\t\"min\":       5,\n\t\t\t\t\"systems\":   []string{system1.Id},\n\t\t\t\t\"overwrite\": false,\n\t\t\t}),\n\t\t\tBeforeTestFunc: func(t testing.TB, app *pbTests.TestApp, e *core.ServeEvent) {\n\t\t\t\tbeszelTests.ClearCollection(t, app, \"alerts\")\n\t\t\t\tbeszelTests.CreateRecord(app, \"alerts\", map[string]any{\n\t\t\t\t\t\"name\":   \"CPU\",\n\t\t\t\t\t\"system\": system1.Id,\n\t\t\t\t\t\"user\":   user1.Id,\n\t\t\t\t\t\"value\":  80,\n\t\t\t\t\t\"min\":    10,\n\t\t\t\t})\n\t\t\t},\n\t\t\tAfterTestFunc: func(t testing.TB, app *pbTests.TestApp, res *http.Response) {\n\t\t\t\talerts, _ := app.CountRecords(\"alerts\")\n\t\t\t\tassert.EqualValues(t, 1, alerts, \"should have 1 alert\")\n\t\t\t\talert, _ := app.FindFirstRecordByFilter(\"alerts\", \"name = 'CPU' && user = {:user}\", dbx.Params{\"user\": user1.Id})\n\t\t\t\tassert.EqualValues(t, 80, alert.Get(\"value\"), \"should have 80 as value\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:   \"Overwrite: true, should overwrite existing alert\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": user2Token,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"success\\\":true\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":      \"CPU\",\n\t\t\t\t\"value\":     45,\n\t\t\t\t\"min\":       5,\n\t\t\t\t\"systems\":   []string{system2.Id},\n\t\t\t\t\"overwrite\": true,\n\t\t\t}),\n\t\t\tBeforeTestFunc: func(t testing.TB, app *pbTests.TestApp, e *core.ServeEvent) {\n\t\t\t\tbeszelTests.ClearCollection(t, app, \"alerts\")\n\t\t\t\tbeszelTests.CreateRecord(app, \"alerts\", map[string]any{\n\t\t\t\t\t\"name\":   \"CPU\",\n\t\t\t\t\t\"system\": system2.Id,\n\t\t\t\t\t\"user\":   user2.Id,\n\t\t\t\t\t\"value\":  80,\n\t\t\t\t\t\"min\":    10,\n\t\t\t\t})\n\t\t\t},\n\t\t\tAfterTestFunc: func(t testing.TB, app *pbTests.TestApp, res *http.Response) {\n\t\t\t\talerts, _ := app.CountRecords(\"alerts\")\n\t\t\t\tassert.EqualValues(t, 1, alerts, \"should have 1 alert\")\n\t\t\t\talert, _ := app.FindFirstRecordByFilter(\"alerts\", \"name = 'CPU' && user = {:user}\", dbx.Params{\"user\": user2.Id})\n\t\t\t\tassert.EqualValues(t, 45, alert.Get(\"value\"), \"should have 45 as value\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:            \"DELETE no auth\",\n\t\t\tMethod:          http.MethodDelete,\n\t\t\tURL:             \"/api/beszel/user-alerts\",\n\t\t\tExpectedStatus:  401,\n\t\t\tExpectedContent: []string{\"requires valid\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":    \"CPU\",\n\t\t\t\t\"systems\": []string{system1.Id},\n\t\t\t}),\n\t\t\tBeforeTestFunc: func(t testing.TB, app *pbTests.TestApp, e *core.ServeEvent) {\n\t\t\t\tbeszelTests.ClearCollection(t, app, \"alerts\")\n\t\t\t\tbeszelTests.CreateRecord(app, \"alerts\", map[string]any{\n\t\t\t\t\t\"name\":   \"CPU\",\n\t\t\t\t\t\"system\": system1.Id,\n\t\t\t\t\t\"user\":   user1.Id,\n\t\t\t\t\t\"value\":  80,\n\t\t\t\t\t\"min\":    10,\n\t\t\t\t})\n\t\t\t},\n\t\t\tAfterTestFunc: func(t testing.TB, app *pbTests.TestApp, res *http.Response) {\n\t\t\t\talerts, _ := app.CountRecords(\"alerts\")\n\t\t\t\tassert.EqualValues(t, 1, alerts, \"should have 1 alert\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:   \"DELETE alert\",\n\t\t\tMethod: http.MethodDelete,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": user1Token,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"count\\\":1\", \"\\\"success\\\":true\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":    \"CPU\",\n\t\t\t\t\"systems\": []string{system1.Id},\n\t\t\t}),\n\t\t\tBeforeTestFunc: func(t testing.TB, app *pbTests.TestApp, e *core.ServeEvent) {\n\t\t\t\tbeszelTests.ClearCollection(t, app, \"alerts\")\n\t\t\t\tbeszelTests.CreateRecord(app, \"alerts\", map[string]any{\n\t\t\t\t\t\"name\":   \"CPU\",\n\t\t\t\t\t\"system\": system1.Id,\n\t\t\t\t\t\"user\":   user1.Id,\n\t\t\t\t\t\"value\":  80,\n\t\t\t\t\t\"min\":    10,\n\t\t\t\t})\n\t\t\t},\n\t\t\tAfterTestFunc: func(t testing.TB, app *pbTests.TestApp, res *http.Response) {\n\t\t\t\talerts, _ := app.CountRecords(\"alerts\")\n\t\t\t\tassert.Zero(t, alerts, \"should have 0 alerts\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:   \"DELETE alert multiple systems\",\n\t\t\tMethod: http.MethodDelete,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": user1Token,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"count\\\":2\", \"\\\"success\\\":true\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":    \"Memory\",\n\t\t\t\t\"systems\": []string{system1.Id, system2.Id},\n\t\t\t}),\n\t\t\tBeforeTestFunc: func(t testing.TB, app *pbTests.TestApp, e *core.ServeEvent) {\n\t\t\t\tbeszelTests.ClearCollection(t, app, \"alerts\")\n\t\t\t\tfor _, systemId := range []string{system1.Id, system2.Id} {\n\t\t\t\t\t_, err := beszelTests.CreateRecord(app, \"alerts\", map[string]any{\n\t\t\t\t\t\t\"name\":   \"Memory\",\n\t\t\t\t\t\t\"system\": systemId,\n\t\t\t\t\t\t\"user\":   user1.Id,\n\t\t\t\t\t\t\"value\":  90,\n\t\t\t\t\t\t\"min\":    10,\n\t\t\t\t\t})\n\t\t\t\t\tassert.NoError(t, err, \"should create alert\")\n\t\t\t\t}\n\t\t\t\talerts, _ := app.CountRecords(\"alerts\")\n\t\t\t\tassert.EqualValues(t, 2, alerts, \"should have 2 alerts\")\n\t\t\t},\n\t\t\tAfterTestFunc: func(t testing.TB, app *pbTests.TestApp, res *http.Response) {\n\t\t\t\talerts, _ := app.CountRecords(\"alerts\")\n\t\t\t\tassert.Zero(t, alerts, \"should have 0 alerts\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:   \"User 2 should not be able to delete alert of user 1\",\n\t\t\tMethod: http.MethodDelete,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": user2Token,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"count\\\":1\", \"\\\"success\\\":true\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":    \"CPU\",\n\t\t\t\t\"systems\": []string{system2.Id},\n\t\t\t}),\n\t\t\tBeforeTestFunc: func(t testing.TB, app *pbTests.TestApp, e *core.ServeEvent) {\n\t\t\t\tbeszelTests.ClearCollection(t, app, \"alerts\")\n\t\t\t\tfor _, user := range []string{user1.Id, user2.Id} {\n\t\t\t\t\tbeszelTests.CreateRecord(app, \"alerts\", map[string]any{\n\t\t\t\t\t\t\"name\":   \"CPU\",\n\t\t\t\t\t\t\"system\": system2.Id,\n\t\t\t\t\t\t\"user\":   user,\n\t\t\t\t\t\t\"value\":  80,\n\t\t\t\t\t\t\"min\":    10,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\talerts, _ := app.CountRecords(\"alerts\")\n\t\t\t\tassert.EqualValues(t, 2, alerts, \"should have 2 alerts\")\n\t\t\t\tuser1AlertCount, _ := app.CountRecords(\"alerts\", dbx.HashExp{\"user\": user1.Id})\n\t\t\t\tassert.EqualValues(t, 1, user1AlertCount, \"should have 1 alert\")\n\t\t\t\tuser2AlertCount, _ := app.CountRecords(\"alerts\", dbx.HashExp{\"user\": user2.Id})\n\t\t\t\tassert.EqualValues(t, 1, user2AlertCount, \"should have 1 alert\")\n\t\t\t},\n\t\t\tAfterTestFunc: func(t testing.TB, app *pbTests.TestApp, res *http.Response) {\n\t\t\t\tuser1AlertCount, _ := app.CountRecords(\"alerts\", dbx.HashExp{\"user\": user1.Id})\n\t\t\t\tassert.EqualValues(t, 1, user1AlertCount, \"should have 1 alert\")\n\t\t\t\tuser2AlertCount, _ := app.CountRecords(\"alerts\", dbx.HashExp{\"user\": user2.Id})\n\t\t\t\tassert.Zero(t, user2AlertCount, \"should have 0 alerts\")\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, scenario := range scenarios {\n\t\tscenario.Test(t)\n\t}\n}\n", "n_tokens": 3489, "primary_symbol": "TestUserAlertsApi", "primary_kind": "function", "primary_span": [33, 371], "def_symbols": ["TestUserAlertsApi"], "symbols": ["TestUserAlertsApi", "func", "testing", "hub", "beszelTests", "NewTestHub", "TempDir", "defer", "Cleanup", "StartHub", "user1", "CreateUser", "alertstest", "example", "com", "password", "user1Token", "NewAuthToken", "user2", "alertstest2", "user2Token", "system1", "CreateRecord", "systems", "map", "string", "any", "name", "users", "host", "system2", "userRecords", "CountRecords", "assert", "EqualValues", "all", "should", "created", "systemRecords", "testAppFactory", "pbTests", "TestApp", "return", "scenarios", "ApiScenario", "Name", "GET", "not", "implemented", "returns", "index", "Method", "http", "MethodGet", "URL", "api", "beszel", "user", "alerts", "ExpectedStatus", "ExpectedContent", "html", "globalThis", "BESZEL", "TestAppFactory", "POST", "auth", "MethodPost", "requires", "valid", "body", "Headers", "Authorization", "Bad", "data", "bad", "Body", "jsonReader", "invalidField", "this", "cause", "validation", "error", "threshold", "number", "malformed", "JSON", "strings", "NewReader", "alertType", "cpu", "enabled", "true", "alert", "multiple", "success", "CPU", "value", "min", "overwrite", "false", "AfterTestFunc", "app", "res", "Response", "check", "total", "have", "has", "correct", "values", "matchingAlerts", "dbx", "HashExp", "system", "single", "Memory", "user1Alerts", "Overwrite", "existing", "BeforeTestFunc", "core", "ServeEvent", "ClearCollection", "FindFirstRecordByFilter", "Params", "Get", "DELETE", "MethodDelete", "count", "Zero", "for", "systemId", "range", "err", "NoError", "create", "User", "able", "delete", "user1AlertCount", "user2AlertCount", "scenario", "Test"], "doc_head": "func TestUserAlertsApi(t *testing.T) {\n\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\tdefer hub.Cleanup()\n\thub.StartHub()\n\tuser1, _ := beszelTests.CreateUser(hub, \"alertstest@example.com\", \"password\")\n\tuser1Token, _ := user1.NewAuthToken()\n\tuser2, _ := beszelTests.CreateUser(hub, \"alertstest2@example.com\", \"password\")\n\tuser2Token, _ := user2.NewAuthToken()\n\tsystem1, _ := beszelTests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":  \"system1\",\n\t\t\"users\": []string{user1.Id},\n\t\t\"host\":  \"127.0.0.1\",\n\t})\n\tsystem2, _ := beszelTests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":  \"system2\",\n\t\t\"users\": []string{user1.Id, user2.Id},\n\t\t\"host\":  \"127.0.0.2\",\n\t})\n\tuserRecords, _ := hub.CountRecords(\"users\")\n\tassert.EqualValues(t, 2, userRecords, \"all users should be created\")\n\tsystemRecords, _ := hub.CountRecords(\"systems\")\n\tassert.EqualValues(t, 2, systemRecords, \"all systems should be created\")\n\ttestAppFactory := func(t testing.TB) *pbTests.TestApp {\n\t\treturn hub.TestApp\n\t}\n\tscenarios := []beszelTests.ApiScenario{\n\t\t// {\n\t\t// \tName:            \"GET not implemented - returns index\",\n\t\t// \tMethod:          http.MethodGet,\n\t\t// \tURL:             \"/api/beszel/user-alerts\",\n\t\t// \t"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test.go", "rel_path": "src/alerts/alerts_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 372, "end_line": 395, "text": "func getHubWithUser(t *testing.T) (*beszelTests.TestHub, *core.Record) {\n\thub, err := beszelTests.NewTestHub(t.TempDir())\n\tassert.NoError(t, err)\n\thub.StartHub()\n\n\t// Manually initialize the system manager to bind event hooks\n\terr = hub.GetSystemManager().Initialize()\n\tassert.NoError(t, err)\n\n\t// Create a test user\n\tuser, err := beszelTests.CreateUser(hub, \"test@example.com\", \"password\")\n\tassert.NoError(t, err)\n\n\t// Create user settings for the test user (required for alert notifications)\n\tuserSettingsData := map[string]any{\n\t\t\"user\":     user.Id,\n\t\t\"settings\": `{\"emails\":[test@example.com],\"webhooks\":[]}`,\n\t}\n\t_, err = beszelTests.CreateRecord(hub, \"user_settings\", userSettingsData)\n\tassert.NoError(t, err)\n\n\treturn hub, user\n}\n", "n_tokens": 193, "primary_symbol": "getHubWithUser", "primary_kind": "function", "primary_span": [372, 395], "def_symbols": ["getHubWithUser"], "symbols": ["getHubWithUser", "func", "testing", "beszelTests", "TestHub", "core", "Record", "hub", "err", "NewTestHub", "TempDir", "assert", "NoError", "StartHub", "Manually", "initialize", "the", "system", "manager", "bind", "event", "hooks", "GetSystemManager", "Initialize", "Create", "test", "user", "CreateUser", "example", "com", "password", "settings", "for", "required", "alert", "notifications", "userSettingsData", "map", "string", "any", "emails", "webhooks", "CreateRecord", "user_settings", "return"], "doc_head": "func getHubWithUser(t *testing.T) (*beszelTests.TestHub, *core.Record) {\n\thub, err := beszelTests.NewTestHub(t.TempDir())\n\tassert.NoError(t, err)\n\thub.StartHub()\n\t// Manually initialize the system manager to bind event hooks\n\terr = hub.GetSystemManager().Initialize()\n\tassert.NoError(t, err)\n\t// Create a test user\n\tuser, err := beszelTests.CreateUser(hub, \"test@example.com\", \"password\")\n\tassert.NoError(t, err)\n\t// Create user settings for the test user (required for alert notifications)\n\tuserSettingsData := map[string]any{\n\t\t\"user\":     user.Id,\n\t\t\"settings\": `{\"emails\":[test@example.com],\"webhooks\":[]}`,\n\t}\n\t_, err = beszelTests.CreateRecord(hub, \"user_settings\", userSettingsData)\n\tassert.NoError(t, err)\n\treturn hub, user\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test.go", "rel_path": "src/alerts/alerts_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 396, "end_line": 476, "text": "func TestStatusAlerts(t *testing.T) {\n\tsynctest.Test(t, func(t *testing.T) {\n\t\thub, user := getHubWithUser(t)\n\t\tdefer hub.Cleanup()\n\n\t\tsystems, err := beszelTests.CreateSystems(hub, 4, user.Id, \"paused\")\n\t\tassert.NoError(t, err)\n\n\t\tvar alerts []*core.Record\n\t\tfor i, system := range systems {\n\t\t\talert, err := beszelTests.CreateRecord(hub, \"alerts\", map[string]any{\n\t\t\t\t\"name\":   \"Status\",\n\t\t\t\t\"system\": system.Id,\n\t\t\t\t\"user\":   user.Id,\n\t\t\t\t\"min\":    i + 1,\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\t\t\talerts = append(alerts, alert)\n\t\t}\n\n\t\ttime.Sleep(10 * time.Millisecond)\n\n\t\tfor _, alert := range alerts {\n\t\t\tassert.False(t, alert.GetBool(\"triggered\"), \"Alert should not be triggered immediately\")\n\t\t}\n\t\tif hub.TestMailer.TotalSend() != 0 {\n\t\t\tassert.Zero(t, hub.TestMailer.TotalSend(), \"Expected 0 messages, got %d\", hub.TestMailer.TotalSend())\n\t\t}\n\t\tfor _, system := range systems {\n\t\t\tassert.EqualValues(t, \"paused\", system.GetString(\"status\"), \"System should be paused\")\n\t\t}\n\t\tfor _, system := range systems {\n\t\t\tsystem.Set(\"status\", \"up\")\n\t\t\terr = hub.SaveNoValidate(system)\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t\tassert.EqualValues(t, 0, hub.GetPendingAlertsCount(), \"should have 0 alerts in the pendingAlerts map\")\n\t\tfor _, system := range systems {\n\t\t\tsystem.Set(\"status\", \"down\")\n\t\t\terr = hub.SaveNoValidate(system)\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t\t// after 30 seconds, should have 4 alerts in the pendingAlerts map, no triggered alerts\n\t\ttime.Sleep(time.Second * 30)\n\t\tassert.EqualValues(t, 4, hub.GetPendingAlertsCount(), \"should have 4 alerts in the pendingAlerts map\")\n\t\ttriggeredCount, err := hub.CountRecords(\"alerts\", dbx.HashExp{\"triggered\": true})\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 0, triggeredCount, \"should have 0 alert triggered\")\n\t\tassert.EqualValues(t, 0, hub.TestMailer.TotalSend(), \"should have 0 messages sent\")\n\t\t// after 1:30 seconds, should have 1 triggered alert and 3 pending alerts\n\t\ttime.Sleep(time.Second * 60)\n\t\tassert.EqualValues(t, 3, hub.GetPendingAlertsCount(), \"should have 3 alerts in the pendingAlerts map\")\n\t\ttriggeredCount, err = hub.CountRecords(\"alerts\", dbx.HashExp{\"triggered\": true})\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 1, triggeredCount, \"should have 1 alert triggered\")\n\t\tassert.EqualValues(t, 1, hub.TestMailer.TotalSend(), \"should have 1 messages sent\")\n\t\t// after 2:30 seconds, should have 2 triggered alerts and 2 pending alerts\n\t\ttime.Sleep(time.Second * 60)\n\t\tassert.EqualValues(t, 2, hub.GetPendingAlertsCount(), \"should have 2 alerts in the pendingAlerts map\")\n\t\ttriggeredCount, err = hub.CountRecords(\"alerts\", dbx.HashExp{\"triggered\": true})\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 2, triggeredCount, \"should have 2 alert triggered\")\n\t\tassert.EqualValues(t, 2, hub.TestMailer.TotalSend(), \"should have 2 messages sent\")\n\t\t// now we will bring the remaning systems back up\n\t\tfor _, system := range systems {\n\t\t\tsystem.Set(\"status\", \"up\")\n\t\t\terr = hub.SaveNoValidate(system)\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t\t// should have 0 alerts in the pendingAlerts map and 0 alerts triggered\n\t\tassert.EqualValues(t, 0, hub.GetPendingAlertsCount(), \"should have 0 alerts in the pendingAlerts map\")\n\t\ttriggeredCount, err = hub.CountRecords(\"alerts\", dbx.HashExp{\"triggered\": true})\n\t\tassert.NoError(t, err)\n\t\tassert.Zero(t, triggeredCount, \"should have 0 alert triggered\")\n\t\t// 4 messages sent, 2 down alerts and 2 up alerts for first 2 systems\n\t\tassert.EqualValues(t, 4, hub.TestMailer.TotalSend(), \"should have 4 messages sent\")\n\t})\n}\n", "n_tokens": 988, "primary_symbol": "TestStatusAlerts", "primary_kind": "function", "primary_span": [396, 476], "def_symbols": ["TestStatusAlerts"], "symbols": ["TestStatusAlerts", "func", "testing", "synctest", "Test", "hub", "user", "getHubWithUser", "defer", "Cleanup", "systems", "err", "beszelTests", "CreateSystems", "paused", "assert", "NoError", "var", "alerts", "core", "Record", "for", "system", "range", "alert", "CreateRecord", "map", "string", "any", "name", "Status", "min", "append", "time", "Sleep", "Millisecond", "False", "GetBool", "triggered", "Alert", "should", "not", "immediately", "TestMailer", "TotalSend", "Zero", "Expected", "messages", "got", "EqualValues", "GetString", "status", "System", "Set", "SaveNoValidate", "Second", "GetPendingAlertsCount", "have", "the", "pendingAlerts", "down", "after", "seconds", "triggeredCount", "CountRecords", "dbx", "HashExp", "true", "sent", "and", "pending", "now", "will", "bring", "remaning", "back", "first"], "doc_head": "func TestStatusAlerts(t *testing.T) {\n\tsynctest.Test(t, func(t *testing.T) {\n\t\thub, user := getHubWithUser(t)\n\t\tdefer hub.Cleanup()\n\t\tsystems, err := beszelTests.CreateSystems(hub, 4, user.Id, \"paused\")\n\t\tassert.NoError(t, err)\n\t\tvar alerts []*core.Record\n\t\tfor i, system := range systems {\n\t\t\talert, err := beszelTests.CreateRecord(hub, \"alerts\", map[string]any{\n\t\t\t\t\"name\":   \"Status\",\n\t\t\t\t\"system\": system.Id,\n\t\t\t\t\"user\":   user.Id,\n\t\t\t\t\"min\":    i + 1,\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\t\t\talerts = append(alerts, alert)\n\t\t}\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tfor _, alert := range alerts {\n\t\t\tassert.False(t, alert.GetBool(\"triggered\"), \"Alert should not be triggered immediately\")\n\t\t}\n\t\tif hub.TestMailer.TotalSend() != 0 {\n\t\t\tassert.Zero(t, hub.TestMailer.TotalSend(), \"Expected 0 messages, got %d\", hub.TestMailer.TotalSend())\n\t\t}\n\t\tfor _, system := range systems {\n\t\t\tassert.EqualValues(t, \"paused\", system.GetString(\"status\"), \"System should be paused\")\n\t\t}\n\t\tfor _, system := range systems {\n\t\t\tsystem.Set(\"status\", \"up\")\n\t\t\terr = hub.SaveNoValidate(system)\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t\tassert.EqualValues(t, 0, hub.GetPendingAlertsCount(), \"should have 0 ale"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test.go", "rel_path": "src/alerts/alerts_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 477, "end_line": 605, "text": "func TestAlertsHistory(t *testing.T) {\n\tsynctest.Test(t, func(t *testing.T) {\n\t\thub, user := getHubWithUser(t)\n\t\tdefer hub.Cleanup()\n\n\t\t// Create systems and alerts\n\t\tsystems, err := beszelTests.CreateSystems(hub, 1, user.Id, \"up\")\n\t\tassert.NoError(t, err)\n\t\tsystem := systems[0]\n\n\t\talert, err := beszelTests.CreateRecord(hub, \"alerts\", map[string]any{\n\t\t\t\"name\":   \"Status\",\n\t\t\t\"system\": system.Id,\n\t\t\t\"user\":   user.Id,\n\t\t\t\"min\":    1,\n\t\t})\n\t\tassert.NoError(t, err)\n\n\t\t// Initially, no alert history records should exist\n\t\tinitialHistoryCount, err := hub.CountRecords(\"alerts_history\", nil)\n\t\tassert.NoError(t, err)\n\t\tassert.Zero(t, initialHistoryCount, \"Should have 0 alert history records initially\")\n\n\t\t// Set system to up initially\n\t\tsystem.Set(\"status\", \"up\")\n\t\terr = hub.SaveNoValidate(system)\n\t\tassert.NoError(t, err)\n\t\ttime.Sleep(10 * time.Millisecond)\n\n\t\t// Set system to down to trigger alert\n\t\tsystem.Set(\"status\", \"down\")\n\t\terr = hub.SaveNoValidate(system)\n\t\tassert.NoError(t, err)\n\n\t\t// Wait for alert to trigger (after the downtime delay)\n\t\t// With 1 minute delay, we need to wait at least 1 minute + some buffer\n\t\ttime.Sleep(time.Second * 75)\n\n\t\t// Check that alert is triggered\n\t\ttriggeredCount, err := hub.CountRecords(\"alerts\", dbx.HashExp{\"triggered\": true, \"id\": alert.Id})\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 1, triggeredCount, \"Alert should be triggered\")\n\n\t\t// Check that alert history record was created\n\t\thistoryCount, err := hub.CountRecords(\"alerts_history\", dbx.HashExp{\"alert_id\": alert.Id})\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 1, historyCount, \"Should have 1 alert history record for triggered alert\")\n\n\t\t// Get the alert history record and verify it's not resolved immediately\n\t\thistoryRecord, err := hub.FindFirstRecordByFilter(\"alerts_history\", \"alert_id={:alert_id}\", dbx.Params{\"alert_id\": alert.Id})\n\t\tassert.NoError(t, err)\n\t\tassert.NotNil(t, historyRecord, \"Alert history record should exist\")\n\t\tassert.Equal(t, alert.Id, historyRecord.GetString(\"alert_id\"), \"Alert history should reference correct alert\")\n\t\tassert.Equal(t, system.Id, historyRecord.GetString(\"system\"), \"Alert history should reference correct system\")\n\t\tassert.Equal(t, \"Status\", historyRecord.GetString(\"name\"), \"Alert history should have correct name\")\n\n\t\t// The alert history might be resolved immediately in some cases, so let's check the alert's triggered status\n\t\talertRecord, err := hub.FindFirstRecordByFilter(\"alerts\", \"id={:id}\", dbx.Params{\"id\": alert.Id})\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, alertRecord.GetBool(\"triggered\"), \"Alert should still be triggered when checking history\")\n\n\t\t// Now resolve the alert by setting system back to up\n\t\tsystem.Set(\"status\", \"up\")\n\t\terr = hub.SaveNoValidate(system)\n\t\tassert.NoError(t, err)\n\t\ttime.Sleep(200 * time.Millisecond)\n\n\t\t// Check that alert is no longer triggered\n\t\ttriggeredCount, err = hub.CountRecords(\"alerts\", dbx.HashExp{\"triggered\": true, \"id\": alert.Id})\n\t\tassert.NoError(t, err)\n\t\tassert.Zero(t, triggeredCount, \"Alert should not be triggered after system is back up\")\n\n\t\t// Check that alert history record is now resolved\n\t\thistoryRecord, err = hub.FindFirstRecordByFilter(\"alerts_history\", \"alert_id={:alert_id}\", dbx.Params{\"alert_id\": alert.Id})\n\t\tassert.NoError(t, err)\n\t\tassert.NotNil(t, historyRecord, \"Alert history record should still exist\")\n\t\tassert.NotNil(t, historyRecord.Get(\"resolved\"), \"Alert history should be resolved\")\n\n\t\t// Test deleting a triggered alert resolves its history\n\t\t// Create another system and alert\n\t\tsystems2, err := beszelTests.CreateSystems(hub, 1, user.Id, \"up\")\n\t\tassert.NoError(t, err)\n\t\tsystem2 := systems2[0]\n\t\tsystem2.Set(\"name\", \"test-system-2\") // Rename for clarity\n\t\terr = hub.SaveNoValidate(system2)\n\t\tassert.NoError(t, err)\n\n\t\talert2, err := beszelTests.CreateRecord(hub, \"alerts\", map[string]any{\n\t\t\t\"name\":   \"Status\",\n\t\t\t\"system\": system2.Id,\n\t\t\t\"user\":   user.Id,\n\t\t\t\"min\":    1,\n\t\t})\n\t\tassert.NoError(t, err)\n\n\t\t// Set system2 to down to trigger alert\n\t\tsystem2.Set(\"status\", \"down\")\n\t\terr = hub.SaveNoValidate(system2)\n\t\tassert.NoError(t, err)\n\n\t\t// Wait for alert to trigger\n\t\ttime.Sleep(time.Second * 75)\n\n\t\t// Verify alert is triggered and history record exists\n\t\ttriggeredCount, err = hub.CountRecords(\"alerts\", dbx.HashExp{\"triggered\": true, \"id\": alert2.Id})\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 1, triggeredCount, \"Second alert should be triggered\")\n\n\t\thistoryCount, err = hub.CountRecords(\"alerts_history\", dbx.HashExp{\"alert_id\": alert2.Id})\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 1, historyCount, \"Should have 1 alert history record for second alert\")\n\n\t\t// Delete the triggered alert\n\t\terr = hub.Delete(alert2)\n\t\tassert.NoError(t, err)\n\n\t\t// Check that alert history record is resolved after deletion\n\t\thistoryRecord2, err := hub.FindFirstRecordByFilter(\"alerts_history\", \"alert_id={:alert_id}\", dbx.Params{\"alert_id\": alert2.Id})\n\t\tassert.NoError(t, err)\n\t\tassert.NotNil(t, historyRecord2, \"Alert history record should still exist after alert deletion\")\n\t\tassert.NotNil(t, historyRecord2.Get(\"resolved\"), \"Alert history should be resolved after alert deletion\")\n\n\t\t// Verify total history count is correct (2 records total)\n\t\ttotalHistoryCount, err := hub.CountRecords(\"alerts_history\", nil)\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 2, totalHistoryCount, \"Should have 2 total alert history records\")\n\t})\n}\n", "n_tokens": 1415, "primary_symbol": "TestAlertsHistory", "primary_kind": "function", "primary_span": [477, 605], "def_symbols": ["TestAlertsHistory"], "symbols": ["TestAlertsHistory", "func", "testing", "synctest", "Test", "hub", "user", "getHubWithUser", "defer", "Cleanup", "Create", "systems", "and", "alerts", "err", "beszelTests", "CreateSystems", "assert", "NoError", "system", "alert", "CreateRecord", "map", "string", "any", "name", "Status", "min", "Initially", "history", "records", "should", "exist", "initialHistoryCount", "CountRecords", "alerts_history", "nil", "Zero", "Should", "have", "initially", "Set", "status", "SaveNoValidate", "time", "Sleep", "Millisecond", "down", "trigger", "Wait", "for", "after", "the", "downtime", "delay", "With", "minute", "need", "wait", "least", "some", "buffer", "Second", "Check", "that", "triggered", "triggeredCount", "dbx", "HashExp", "true", "EqualValues", "Alert", "record", "was", "created", "historyCount", "alert_id", "Get", "verify", "not", "resolved", "immediately", "historyRecord", "FindFirstRecordByFilter", "Params", "NotNil", "Equal", "GetString", "reference", "correct", "The", "might", "cases", "let", "check", "alertRecord", "True", "GetBool", "still", "when", "checking", "Now", "resolve", "setting", "back", "longer", "now", "deleting", "resolves", "its", "another", "systems2", "system2", "test", "Rename", "clarity", "alert2", "Verify", "exists", "second", "Delete", "deletion", "historyRecord2", "total", "count", "totalHistoryCount"], "doc_head": "func TestAlertsHistory(t *testing.T) {\n\tsynctest.Test(t, func(t *testing.T) {\n\t\thub, user := getHubWithUser(t)\n\t\tdefer hub.Cleanup()\n\t\t// Create systems and alerts\n\t\tsystems, err := beszelTests.CreateSystems(hub, 1, user.Id, \"up\")\n\t\tassert.NoError(t, err)\n\t\tsystem := systems[0]\n\t\talert, err := beszelTests.CreateRecord(hub, \"alerts\", map[string]any{\n\t\t\t\"name\":   \"Status\",\n\t\t\t\"system\": system.Id,\n\t\t\t\"user\":   user.Id,\n\t\t\t\"min\":    1,\n\t\t})\n\t\tassert.NoError(t, err)\n\t\t// Initially, no alert history records should exist\n\t\tinitialHistoryCount, err := hub.CountRecords(\"alerts_history\", nil)\n\t\tassert.NoError(t, err)\n\t\tassert.Zero(t, initialHistoryCount, \"Should have 0 alert history records initially\")\n\t\t// Set system to up initially\n\t\tsystem.Set(\"status\", \"up\")\n\t\terr = hub.SaveNoValidate(system)\n\t\tassert.NoError(t, err)\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\t// Set system to down to trigger alert\n\t\tsystem.Set(\"status\", \"down\")\n\t\terr = hub.SaveNoValidate(system)\n\t\tassert.NoError(t, err)\n\t\t// Wait for alert to trigger (after the downtime delay)\n\t\t// With 1 minute delay, we need to wait at least 1 minute + some buffer\n\t\ttime.Sleep(time.Second * 75)\n\t\t// Check that alert is triggered\n\t\ttriggered"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_api.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_api.go", "rel_path": "src/alerts/alerts_api.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 16, "text": "package alerts\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n\n// UpsertUserAlerts handles API request to create or update alerts for a user\n// across multiple systems (POST /api/beszel/user-alerts)\nfunc UpsertUserAlerts(e *core.RequestEvent) error {\n\tuserID := e.Auth.Id\n", "n_tokens": 92, "primary_symbol": "UpsertUserAlerts", "primary_kind": "function", "primary_span": [14, 16], "def_symbols": ["UpsertUserAlerts"], "symbols": ["UpsertUserAlerts", "package", "alerts", "import", "database", "sql", "errors", "net", "http", "github", "com", "pocketbase", "dbx", "core", "handles", "API", "request", "create", "update", "for", "user", "across", "multiple", "systems", "POST", "api", "beszel", "func", "RequestEvent", "error", "userID", "Auth"], "doc_head": "package alerts\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"net/http\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n// UpsertUserAlerts handles API request to create or update alerts for a user\n// across multiple systems (POST /api/beszel/user-alerts)\nfunc UpsertUserAlerts(e *core.RequestEvent) error {\n\tuserID := e.Auth.Id"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_api.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_api.go", "rel_path": "src/alerts/alerts_api.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 17, "end_line": 74, "text": "\treqData := struct {\n\t\tMin       uint8    `json:\"min\"`\n\t\tValue     float64  `json:\"value\"`\n\t\tName      string   `json:\"name\"`\n\t\tSystems   []string `json:\"systems\"`\n\t\tOverwrite bool     `json:\"overwrite\"`\n\t}{}\n\terr := e.BindBody(&reqData)\n\tif err != nil || userID == \"\" || reqData.Name == \"\" || len(reqData.Systems) == 0 {\n\t\treturn e.BadRequestError(\"Bad data\", err)\n\t}\n\n\talertsCollection, err := e.App.FindCachedCollectionByNameOrId(\"alerts\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = e.App.RunInTransaction(func(txApp core.App) error {\n\t\tfor _, systemId := range reqData.Systems {\n\t\t\t// find existing matching alert\n\t\t\talertRecord, err := txApp.FindFirstRecordByFilter(alertsCollection,\n\t\t\t\t\"system={:system} && name={:name} && user={:user}\",\n\t\t\t\tdbx.Params{\"system\": systemId, \"name\": reqData.Name, \"user\": userID})\n\n\t\t\tif err != nil && !errors.Is(err, sql.ErrNoRows) {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// skip if alert already exists and overwrite is not set\n\t\t\tif !reqData.Overwrite && alertRecord != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// create new alert if it doesn't exist\n\t\t\tif alertRecord == nil {\n\t\t\t\talertRecord = core.NewRecord(alertsCollection)\n\t\t\t\talertRecord.Set(\"user\", userID)\n\t\t\t\talertRecord.Set(\"system\", systemId)\n\t\t\t\talertRecord.Set(\"name\", reqData.Name)\n\t\t\t}\n\n\t\t\talertRecord.Set(\"value\", reqData.Value)\n\t\t\talertRecord.Set(\"min\", reqData.Min)\n\n\t\t\tif err := txApp.SaveNoValidate(alertRecord); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn e.JSON(http.StatusOK, map[string]any{\"success\": true})\n}\n", "n_tokens": 434, "primary_symbol": "", "primary_kind": "", "primary_span": [17, 74], "def_symbols": [], "symbols": ["reqData", "struct", "Min", "uint8", "json", "min", "Value", "float64", "value", "Name", "string", "name", "Systems", "systems", "Overwrite", "bool", "overwrite", "err", "BindBody", "nil", "userID", "len", "return", "BadRequestError", "Bad", "data", "alertsCollection", "App", "FindCachedCollectionByNameOrId", "alerts", "RunInTransaction", "func", "txApp", "core", "error", "for", "systemId", "range", "find", "existing", "matching", "alert", "alertRecord", "FindFirstRecordByFilter", "system", "user", "dbx", "Params", "errors", "sql", "ErrNoRows", "skip", "already", "exists", "and", "not", "set", "continue", "create", "new", "doesn", "exist", "NewRecord", "Set", "SaveNoValidate", "JSON", "http", "StatusOK", "map", "any", "success", "true"], "doc_head": "\treqData := struct {\n\t\tMin       uint8    `json:\"min\"`\n\t\tValue     float64  `json:\"value\"`\n\t\tName      string   `json:\"name\"`\n\t\tSystems   []string `json:\"systems\"`\n\t\tOverwrite bool     `json:\"overwrite\"`\n\t}{}\n\terr := e.BindBody(&reqData)\n\tif err != nil || userID == \"\" || reqData.Name == \"\" || len(reqData.Systems) == 0 {\n\t\treturn e.BadRequestError(\"Bad data\", err)\n\t}\n\talertsCollection, err := e.App.FindCachedCollectionByNameOrId(\"alerts\")\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = e.App.RunInTransaction(func(txApp core.App) error {\n\t\tfor _, systemId := range reqData.Systems {\n\t\t\t// find existing matching alert\n\t\t\talertRecord, err := txApp.FindFirstRecordByFilter(alertsCollection,\n\t\t\t\t\"system={:system} && name={:name} && user={:user}\",\n\t\t\t\tdbx.Params{\"system\": systemId, \"name\": reqData.Name, \"user\": userID})\n\t\t\tif err != nil && !errors.Is(err, sql.ErrNoRows) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// skip if alert already exists and overwrite is not set\n\t\t\tif !reqData.Overwrite && alertRecord != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// create new alert if it doesn't exist\n\t\t\tif alertRecord == nil {\n\t\t\t\talertRecord = core.NewRecord(alertsCollection)\n\t\t\t\talertRecord.Set(\"user\", userID)\n\t\t\t\talertRecord.Set(\"system\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_api.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_api.go", "rel_path": "src/alerts/alerts_api.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 75, "end_line": 79, "text": "// DeleteUserAlerts handles API request to delete alerts for a user across multiple systems\n// (DELETE /api/beszel/user-alerts)\nfunc DeleteUserAlerts(e *core.RequestEvent) error {\n\tuserID := e.Auth.Id\n", "n_tokens": 50, "primary_symbol": "DeleteUserAlerts", "primary_kind": "function", "primary_span": [77, 79], "def_symbols": ["DeleteUserAlerts"], "symbols": ["DeleteUserAlerts", "handles", "API", "request", "delete", "alerts", "for", "user", "across", "multiple", "systems", "DELETE", "api", "beszel", "func", "core", "RequestEvent", "error", "userID", "Auth"], "doc_head": "// DeleteUserAlerts handles API request to delete alerts for a user across multiple systems\n// (DELETE /api/beszel/user-alerts)\nfunc DeleteUserAlerts(e *core.RequestEvent) error {\n\tuserID := e.Auth.Id"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_api.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_api.go", "rel_path": "src/alerts/alerts_api.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 80, "end_line": 120, "text": "\treqData := struct {\n\t\tAlertName string   `json:\"name\"`\n\t\tSystems   []string `json:\"systems\"`\n\t}{}\n\terr := e.BindBody(&reqData)\n\tif err != nil || userID == \"\" || reqData.AlertName == \"\" || len(reqData.Systems) == 0 {\n\t\treturn e.BadRequestError(\"Bad data\", err)\n\t}\n\n\tvar numDeleted uint16\n\n\terr = e.App.RunInTransaction(func(txApp core.App) error {\n\t\tfor _, systemId := range reqData.Systems {\n\t\t\t// Find existing alert to delete\n\t\t\talertRecord, err := txApp.FindFirstRecordByFilter(\"alerts\",\n\t\t\t\t\"system={:system} && name={:name} && user={:user}\",\n\t\t\t\tdbx.Params{\"system\": systemId, \"name\": reqData.AlertName, \"user\": userID})\n\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\t\t\t// alert doesn't exist, continue to next system\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := txApp.Delete(alertRecord); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tnumDeleted++\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn e.JSON(http.StatusOK, map[string]any{\"success\": true, \"count\": numDeleted})\n}\n", "n_tokens": 290, "primary_symbol": "", "primary_kind": "", "primary_span": [80, 120], "def_symbols": [], "symbols": ["reqData", "struct", "AlertName", "string", "json", "name", "Systems", "systems", "err", "BindBody", "nil", "userID", "len", "return", "BadRequestError", "Bad", "data", "var", "numDeleted", "uint16", "App", "RunInTransaction", "func", "txApp", "core", "error", "for", "systemId", "range", "Find", "existing", "alert", "delete", "alertRecord", "FindFirstRecordByFilter", "alerts", "system", "user", "dbx", "Params", "errors", "sql", "ErrNoRows", "doesn", "exist", "continue", "next", "Delete", "JSON", "http", "StatusOK", "map", "any", "success", "true", "count"], "doc_head": "\treqData := struct {\n\t\tAlertName string   `json:\"name\"`\n\t\tSystems   []string `json:\"systems\"`\n\t}{}\n\terr := e.BindBody(&reqData)\n\tif err != nil || userID == \"\" || reqData.AlertName == \"\" || len(reqData.Systems) == 0 {\n\t\treturn e.BadRequestError(\"Bad data\", err)\n\t}\n\tvar numDeleted uint16\n\terr = e.App.RunInTransaction(func(txApp core.App) error {\n\t\tfor _, systemId := range reqData.Systems {\n\t\t\t// Find existing alert to delete\n\t\t\talertRecord, err := txApp.FindFirstRecordByFilter(\"alerts\",\n\t\t\t\t\"system={:system} && name={:name} && user={:user}\",\n\t\t\t\tdbx.Params{\"system\": systemId, \"name\": reqData.AlertName, \"user\": userID})\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\t\t\t// alert doesn't exist, continue to next system\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := txApp.Delete(alertRecord); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tnumDeleted++\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn e.JSON(http.StatusOK, map[string]any{\"success\": true, \"count\": numDeleted})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test_helpers.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test_helpers.go", "rel_path": "src/alerts/alerts_test_helpers.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 26, "text": "package alerts\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n\nfunc (am *AlertManager) GetAlertManager() *AlertManager {\n\treturn am\n}\n\nfunc (am *AlertManager) GetPendingAlerts() *sync.Map {\n\treturn &am.pendingAlerts\n}\n\nfunc (am *AlertManager) GetPendingAlertsCount() int {\n\tcount := 0\n\tam.pendingAlerts.Range(func(key, value any) bool {\n\t\tcount++\n\t\treturn true\n\t})\n\treturn count\n}\n", "n_tokens": 113, "primary_symbol": "GetAlertManager", "primary_kind": "function", "primary_span": [10, 26], "def_symbols": ["GetAlertManager", "GetPendingAlerts", "GetPendingAlertsCount"], "symbols": ["GetAlertManager", "GetPendingAlerts", "GetPendingAlertsCount", "package", "alerts", "import", "sync", "time", "github", "com", "pocketbase", "core", "func", "AlertManager", "return", "Map", "pendingAlerts", "int", "count", "Range", "key", "value", "any", "bool", "true"], "doc_head": "package alerts\nimport (\n\t\"sync\"\n\t\"time\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\nfunc (am *AlertManager) GetAlertManager() *AlertManager {\n\treturn am\n}\nfunc (am *AlertManager) GetPendingAlerts() *sync.Map {\n\treturn &am.pendingAlerts\n}\nfunc (am *AlertManager) GetPendingAlertsCount() int {\n\tcount := 0\n\tam.pendingAlerts.Range(func(key, value any) bool {\n\t\tcount++\n\t\treturn true\n\t})\n\treturn count\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test_helpers.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test_helpers.go", "rel_path": "src/alerts/alerts_test_helpers.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 27, "end_line": 46, "text": "// ProcessPendingAlerts manually processes all expired alerts (for testing)\nfunc (am *AlertManager) ProcessPendingAlerts() ([]*core.Record, error) {\n\tnow := time.Now()\n\tvar lastErr error\n\tvar processedAlerts []*core.Record\n\tam.pendingAlerts.Range(func(key, value any) bool {\n\t\tinfo := value.(*alertInfo)\n\t\tif now.After(info.expireTime) {\n\t\t\t// Downtime delay has passed, process alert\n\t\t\tif err := am.sendStatusAlert(\"down\", info.systemName, info.alertRecord); err != nil {\n\t\t\t\tlastErr = err\n\t\t\t}\n\t\t\tprocessedAlerts = append(processedAlerts, info.alertRecord)\n\t\t\tam.pendingAlerts.Delete(key)\n\t\t}\n\t\treturn true\n\t})\n\treturn processedAlerts, lastErr\n}\n", "n_tokens": 171, "primary_symbol": "ProcessPendingAlerts", "primary_kind": "function", "primary_span": [28, 46], "def_symbols": ["ProcessPendingAlerts"], "symbols": ["ProcessPendingAlerts", "manually", "processes", "all", "expired", "alerts", "for", "testing", "func", "AlertManager", "core", "Record", "error", "now", "time", "Now", "var", "lastErr", "processedAlerts", "pendingAlerts", "Range", "key", "value", "any", "bool", "info", "alertInfo", "After", "expireTime", "Downtime", "delay", "has", "passed", "process", "alert", "err", "sendStatusAlert", "down", "systemName", "alertRecord", "nil", "append", "Delete", "return", "true"], "doc_head": "// ProcessPendingAlerts manually processes all expired alerts (for testing)\nfunc (am *AlertManager) ProcessPendingAlerts() ([]*core.Record, error) {\n\tnow := time.Now()\n\tvar lastErr error\n\tvar processedAlerts []*core.Record\n\tam.pendingAlerts.Range(func(key, value any) bool {\n\t\tinfo := value.(*alertInfo)\n\t\tif now.After(info.expireTime) {\n\t\t\t// Downtime delay has passed, process alert\n\t\t\tif err := am.sendStatusAlert(\"down\", info.systemName, info.alertRecord); err != nil {\n\t\t\t\tlastErr = err\n\t\t\t}\n\t\t\tprocessedAlerts = append(processedAlerts, info.alertRecord)\n\t\t\tam.pendingAlerts.Delete(key)\n\t\t}\n\t\treturn true\n\t})\n\treturn processedAlerts, lastErr\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test_helpers.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_test_helpers.go", "rel_path": "src/alerts/alerts_test_helpers.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 47, "end_line": 56, "text": "// ForceExpirePendingAlerts sets all pending alerts to expire immediately (for testing)\nfunc (am *AlertManager) ForceExpirePendingAlerts() {\n\tnow := time.Now()\n\tam.pendingAlerts.Range(func(key, value any) bool {\n\t\tinfo := value.(*alertInfo)\n\t\tinfo.expireTime = now.Add(-time.Second) // Set to 1 second ago\n\t\treturn true\n\t})\n}\n", "n_tokens": 87, "primary_symbol": "ForceExpirePendingAlerts", "primary_kind": "function", "primary_span": [48, 56], "def_symbols": ["ForceExpirePendingAlerts"], "symbols": ["ForceExpirePendingAlerts", "sets", "all", "pending", "alerts", "expire", "immediately", "for", "testing", "func", "AlertManager", "now", "time", "Now", "pendingAlerts", "Range", "key", "value", "any", "bool", "info", "alertInfo", "expireTime", "Add", "Second", "Set", "second", "ago", "return", "true"], "doc_head": "// ForceExpirePendingAlerts sets all pending alerts to expire immediately (for testing)\nfunc (am *AlertManager) ForceExpirePendingAlerts() {\n\tnow := time.Now()\n\tam.pendingAlerts.Range(func(key, value any) bool {\n\t\tinfo := value.(*alertInfo)\n\t\tinfo.expireTime = now.Add(-time.Second) // Set to 1 second ago\n\t\treturn true\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_system.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_system.go", "rel_path": "src/alerts/alerts_system.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 16, "text": "package alerts\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tools/types\"\n\t\"github.com/spf13/cast\"\n)\n", "n_tokens": 74, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 16], "def_symbols": [], "symbols": ["package", "alerts", "import", "encoding", "json", "fmt", "strings", "time", "github", "com", "henrygd", "beszel", "src", "entities", "system", "pocketbase", "dbx", "core", "tools", "types", "spf13", "cast"], "doc_head": "package alerts\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tools/types\"\n\t\"github.com/spf13/cast\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_system.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_system.go", "rel_path": "src/alerts/alerts_system.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 17, "end_line": 107, "text": "func (am *AlertManager) HandleSystemAlerts(systemRecord *core.Record, data *system.CombinedData) error {\n\talertRecords, err := am.hub.FindAllRecords(\"alerts\",\n\t\tdbx.NewExp(\"system={:system} AND name!='Status'\", dbx.Params{\"system\": systemRecord.Id}),\n\t)\n\tif err != nil || len(alertRecords) == 0 {\n\t\t// log.Println(\"no alerts found for system\")\n\t\treturn nil\n\t}\n\n\tvar validAlerts []SystemAlertData\n\tnow := systemRecord.GetDateTime(\"updated\").Time().UTC()\n\toldestTime := now\n\n\tfor _, alertRecord := range alertRecords {\n\t\tname := alertRecord.GetString(\"name\")\n\t\tvar val float64\n\t\tunit := \"%\"\n\n\t\tswitch name {\n\t\tcase \"CPU\":\n\t\t\tval = data.Info.Cpu\n\t\tcase \"Memory\":\n\t\t\tval = data.Info.MemPct\n\t\tcase \"Bandwidth\":\n\t\t\tval = data.Info.Bandwidth\n\t\t\tunit = \" MB/s\"\n\t\tcase \"Disk\":\n\t\t\tmaxUsedPct := data.Info.DiskPct\n\t\t\tfor _, fs := range data.Stats.ExtraFs {\n\t\t\t\tusedPct := fs.DiskUsed / fs.DiskTotal * 100\n\t\t\t\tif usedPct > maxUsedPct {\n\t\t\t\t\tmaxUsedPct = usedPct\n\t\t\t\t}\n\t\t\t}\n\t\t\tval = maxUsedPct\n\t\tcase \"Temperature\":\n\t\t\tif data.Info.DashboardTemp < 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tval = data.Info.DashboardTemp\n\t\t\tunit = \"C\"\n\t\tcase \"LoadAvg1\":\n\t\t\tval = data.Info.LoadAvg[0]\n\t\t\tunit = \"\"\n\t\tcase \"LoadAvg5\":\n\t\t\tval = data.Info.LoadAvg[1]\n\t\t\tunit = \"\"\n\t\tcase \"LoadAvg15\":\n\t\t\tval = data.Info.LoadAvg[2]\n\t\t\tunit = \"\"\n\t\t}\n\n\t\ttriggered := alertRecord.GetBool(\"triggered\")\n\t\tthreshold := alertRecord.GetFloat(\"value\")\n\n\t\t// CONTINUE\n\t\t// IF alert is not triggered and curValue is less than threshold\n\t\t// OR alert is triggered and curValue is greater than threshold\n\t\tif (!triggered && val <= threshold) || (triggered && val > threshold) {\n\t\t\t// log.Printf(\"Skipping alert %s: val %f | threshold %f | triggered %v\\n\", name, val, threshold, triggered)\n\t\t\tcontinue\n\t\t}\n\n\t\tmin := max(1, cast.ToUint8(alertRecord.Get(\"min\")))\n\n\t\talert := SystemAlertData{\n\t\t\tsystemRecord: systemRecord,\n\t\t\talertRecord:  alertRecord,\n\t\t\tname:         name,\n\t\t\tunit:         unit,\n\t\t\tval:          val,\n\t\t\tthreshold:    threshold,\n\t\t\ttriggered:    triggered,\n\t\t\tmin:          min,\n\t\t}\n\n\t\t// send alert immediately if min is 1 - no need to sum up values.\n\t\tif min == 1 {\n\t\t\talert.triggered = val > threshold\n\t\t\tgo am.sendSystemAlert(alert)\n\t\t\tcontinue\n\t\t}\n\n\t\talert.time = now.Add(-time.Duration(min) * time.Minute)\n\t\tif alert.time.Before(oldestTime) {\n\t\t\toldestTime = alert.time\n\t\t}\n\n\t\tvalidAlerts = append(validAlerts, alert)\n\t}\n", "n_tokens": 701, "primary_symbol": "HandleSystemAlerts", "primary_kind": "function", "primary_span": [17, 107], "def_symbols": ["HandleSystemAlerts"], "symbols": ["HandleSystemAlerts", "func", "AlertManager", "systemRecord", "core", "Record", "data", "system", "CombinedData", "error", "alertRecords", "err", "hub", "FindAllRecords", "alerts", "dbx", "NewExp", "AND", "name", "Status", "Params", "nil", "len", "log", "Println", "found", "for", "return", "var", "validAlerts", "SystemAlertData", "now", "GetDateTime", "updated", "Time", "UTC", "oldestTime", "alertRecord", "range", "GetString", "val", "float64", "unit", "switch", "case", "CPU", "Info", "Cpu", "Memory", "MemPct", "Bandwidth", "Disk", "maxUsedPct", "DiskPct", "Stats", "ExtraFs", "usedPct", "DiskUsed", "DiskTotal", "Temperature", "DashboardTemp", "continue", "LoadAvg1", "LoadAvg", "LoadAvg5", "LoadAvg15", "triggered", "GetBool", "threshold", "GetFloat", "value", "CONTINUE", "alert", "not", "and", "curValue", "less", "than", "greater", "Printf", "Skipping", "min", "max", "cast", "ToUint8", "Get", "send", "immediately", "need", "sum", "values", "sendSystemAlert", "time", "Add", "Duration", "Minute", "Before", "append"], "doc_head": "func (am *AlertManager) HandleSystemAlerts(systemRecord *core.Record, data *system.CombinedData) error {\n\talertRecords, err := am.hub.FindAllRecords(\"alerts\",\n\t\tdbx.NewExp(\"system={:system} AND name!='Status'\", dbx.Params{\"system\": systemRecord.Id}),\n\t)\n\tif err != nil || len(alertRecords) == 0 {\n\t\t// log.Println(\"no alerts found for system\")\n\t\treturn nil\n\t}\n\tvar validAlerts []SystemAlertData\n\tnow := systemRecord.GetDateTime(\"updated\").Time().UTC()\n\toldestTime := now\n\tfor _, alertRecord := range alertRecords {\n\t\tname := alertRecord.GetString(\"name\")\n\t\tvar val float64\n\t\tunit := \"%\"\n\t\tswitch name {\n\t\tcase \"CPU\":\n\t\t\tval = data.Info.Cpu\n\t\tcase \"Memory\":\n\t\t\tval = data.Info.MemPct\n\t\tcase \"Bandwidth\":\n\t\t\tval = data.Info.Bandwidth\n\t\t\tunit = \" MB/s\"\n\t\tcase \"Disk\":\n\t\t\tmaxUsedPct := data.Info.DiskPct\n\t\t\tfor _, fs := range data.Stats.ExtraFs {\n\t\t\t\tusedPct := fs.DiskUsed / fs.DiskTotal * 100\n\t\t\t\tif usedPct > maxUsedPct {\n\t\t\t\t\tmaxUsedPct = usedPct\n\t\t\t\t}\n\t\t\t}\n\t\t\tval = maxUsedPct\n\t\tcase \"Temperature\":\n\t\t\tif data.Info.DashboardTemp < 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tval = data.Info.DashboardTemp\n\t\t\tunit = \"C\"\n\t\tcase \"LoadAvg1\":\n\t\t\tval = data.Info.LoadAvg[0]\n\t\t\tunit = \"\"\n\t\tcase \"LoadAvg5\":\n\t\t\tval = data.Inf"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_system.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_system.go", "rel_path": "src/alerts/alerts_system.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 108, "end_line": 257, "text": "\tsystemStats := []struct {\n\t\tStats   []byte         `db:\"stats\"`\n\t\tCreated types.DateTime `db:\"created\"`\n\t}{}\n\n\terr = am.hub.DB().\n\t\tSelect(\"stats\", \"created\").\n\t\tFrom(\"system_stats\").\n\t\tWhere(dbx.NewExp(\n\t\t\t\"system={:system} AND type='1m' AND created > {:created}\",\n\t\t\tdbx.Params{\n\t\t\t\t\"system\": systemRecord.Id,\n\t\t\t\t// subtract some time to give us a bit of buffer\n\t\t\t\t\"created\": oldestTime.Add(-time.Second * 90),\n\t\t\t},\n\t\t)).\n\t\tOrderBy(\"created\").\n\t\tAll(&systemStats)\n\tif err != nil || len(systemStats) == 0 {\n\t\treturn err\n\t}\n\n\t// get oldest record creation time from first record in the slice\n\toldestRecordTime := systemStats[0].Created.Time()\n\t// log.Println(\"oldestRecordTime\", oldestRecordTime.String())\n\n\t// Filter validAlerts to keep only those with time newer than oldestRecord\n\tfilteredAlerts := make([]SystemAlertData, 0, len(validAlerts))\n\tfor _, alert := range validAlerts {\n\t\tif alert.time.After(oldestRecordTime) {\n\t\t\tfilteredAlerts = append(filteredAlerts, alert)\n\t\t}\n\t}\n\tvalidAlerts = filteredAlerts\n\n\tif len(validAlerts) == 0 {\n\t\t// log.Println(\"no valid alerts found\")\n\t\treturn nil\n\t}\n\n\tvar stats SystemAlertStats\n\n\t// we can skip the latest systemStats record since it's the current value\n\tfor i := range systemStats {\n\t\tstat := systemStats[i]\n\t\t// subtract 10 seconds to give a small time buffer\n\t\tsystemStatsCreation := stat.Created.Time().Add(-time.Second * 10)\n\t\tif err := json.Unmarshal(stat.Stats, &stats); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// log.Println(\"stats\", stats)\n\t\tfor j := range validAlerts {\n\t\t\talert := &validAlerts[j]\n\t\t\t// reset alert val on first iteration\n\t\t\tif i == 0 {\n\t\t\t\talert.val = 0\n\t\t\t}\n\t\t\t// continue if system_stats is older than alert time range\n\t\t\tif systemStatsCreation.Before(alert.time) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// add to alert value\n\t\t\tswitch alert.name {\n\t\t\tcase \"CPU\":\n\t\t\t\talert.val += stats.Cpu\n\t\t\tcase \"Memory\":\n\t\t\t\talert.val += stats.Mem\n\t\t\tcase \"Bandwidth\":\n\t\t\t\talert.val += stats.NetSent + stats.NetRecv\n\t\t\tcase \"Disk\":\n\t\t\t\tif alert.mapSums == nil {\n\t\t\t\t\talert.mapSums = make(map[string]float32, len(data.Stats.ExtraFs)+1)\n\t\t\t\t}\n\t\t\t\t// add root disk\n\t\t\t\tif _, ok := alert.mapSums[\"root\"]; !ok {\n\t\t\t\t\talert.mapSums[\"root\"] = 0.0\n\t\t\t\t}\n\t\t\t\talert.mapSums[\"root\"] += float32(stats.Disk)\n\t\t\t\t// add extra disks\n\t\t\t\tfor key, fs := range data.Stats.ExtraFs {\n\t\t\t\t\tif _, ok := alert.mapSums[key]; !ok {\n\t\t\t\t\t\talert.mapSums[key] = 0.0\n\t\t\t\t\t}\n\t\t\t\t\talert.mapSums[key] += float32(fs.DiskUsed / fs.DiskTotal * 100)\n\t\t\t\t}\n\t\t\tcase \"Temperature\":\n\t\t\t\tif alert.mapSums == nil {\n\t\t\t\t\talert.mapSums = make(map[string]float32, len(stats.Temperatures))\n\t\t\t\t}\n\t\t\t\tfor key, temp := range stats.Temperatures {\n\t\t\t\t\tif _, ok := alert.mapSums[key]; !ok {\n\t\t\t\t\t\talert.mapSums[key] = float32(0)\n\t\t\t\t\t}\n\t\t\t\t\talert.mapSums[key] += temp\n\t\t\t\t}\n\t\t\tcase \"LoadAvg1\":\n\t\t\t\talert.val += stats.LoadAvg[0]\n\t\t\tcase \"LoadAvg5\":\n\t\t\t\talert.val += stats.LoadAvg[1]\n\t\t\tcase \"LoadAvg15\":\n\t\t\t\talert.val += stats.LoadAvg[2]\n\t\t\tdefault:\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\talert.count++\n\t\t}\n\t}\n\t// sum up vals for each alert\n\tfor _, alert := range validAlerts {\n\t\tswitch alert.name {\n\t\tcase \"Disk\":\n\t\t\tmaxPct := float32(0)\n\t\t\tfor key, value := range alert.mapSums {\n\t\t\t\tsumPct := float32(value)\n\t\t\t\tif sumPct > maxPct {\n\t\t\t\t\tmaxPct = sumPct\n\t\t\t\t\talert.descriptor = fmt.Sprintf(\"Usage of %s\", key)\n\t\t\t\t}\n\t\t\t}\n\t\t\talert.val = float64(maxPct / float32(alert.count))\n\t\tcase \"Temperature\":\n\t\t\tmaxTemp := float32(0)\n\t\t\tfor key, value := range alert.mapSums {\n\t\t\t\tsumTemp := float32(value) / float32(alert.count)\n\t\t\t\tif sumTemp > maxTemp {\n\t\t\t\t\tmaxTemp = sumTemp\n\t\t\t\t\talert.descriptor = fmt.Sprintf(\"Highest sensor %s\", key)\n\t\t\t\t}\n\t\t\t}\n\t\t\talert.val = float64(maxTemp)\n\t\tdefault:\n\t\t\talert.val = alert.val / float64(alert.count)\n\t\t}\n\t\tminCount := float32(alert.min) / 1.2\n\t\t// log.Println(\"alert\", alert.name, \"val\", alert.val, \"threshold\", alert.threshold, \"triggered\", alert.triggered)\n\t\t// log.Printf(\"%s: val %f | count %d | min-count %f | threshold %f\\n\", alert.name, alert.val, alert.count, minCount, alert.threshold)\n\t\t// pass through alert if count is greater than or equal to minCount\n\t\tif float32(alert.count) >= minCount {\n\t\t\tif !alert.triggered && alert.val > alert.threshold {\n\t\t\t\talert.triggered = true\n\t\t\t\tgo am.sendSystemAlert(alert)\n\t\t\t} else if alert.triggered && alert.val <= alert.threshold {\n\t\t\t\talert.triggered = false\n\t\t\t\tgo am.sendSystemAlert(alert)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n", "n_tokens": 1282, "primary_symbol": "", "primary_kind": "", "primary_span": [108, 257], "def_symbols": [], "symbols": ["systemStats", "struct", "Stats", "byte", "stats", "Created", "types", "DateTime", "created", "err", "hub", "Select", "From", "system_stats", "Where", "dbx", "NewExp", "system", "AND", "type", "Params", "systemRecord", "subtract", "some", "time", "give", "bit", "buffer", "oldestTime", "Add", "Second", "OrderBy", "All", "nil", "len", "return", "get", "oldest", "record", "creation", "from", "first", "the", "slice", "oldestRecordTime", "Time", "log", "Println", "String", "Filter", "validAlerts", "keep", "only", "those", "with", "newer", "than", "oldestRecord", "filteredAlerts", "make", "SystemAlertData", "for", "alert", "range", "After", "append", "valid", "alerts", "found", "var", "SystemAlertStats", "can", "skip", "latest", "since", "current", "value", "stat", "seconds", "small", "systemStatsCreation", "json", "Unmarshal", "reset", "val", "iteration", "continue", "older", "Before", "add", "switch", "name", "case", "CPU", "Cpu", "Memory", "Mem", "Bandwidth", "NetSent", "NetRecv", "Disk", "mapSums", "map", "string", "float32", "data", "ExtraFs", "root", "disk", "extra", "disks", "key", "DiskUsed", "DiskTotal", "Temperature", "Temperatures", "temp", "LoadAvg1", "LoadAvg", "LoadAvg5", "LoadAvg15", "default", "count", "sum", "vals", "each", "maxPct", "sumPct", "descriptor", "fmt", "Sprintf", "Usage", "float64", "maxTemp", "sumTemp", "Highest", "sensor", "minCount", "min", "threshold", "triggered", "Printf", "pass", "through", "greater", "equal", "true", "sendSystemAlert", "else", "false"], "doc_head": "\tsystemStats := []struct {\n\t\tStats   []byte         `db:\"stats\"`\n\t\tCreated types.DateTime `db:\"created\"`\n\t}{}\n\terr = am.hub.DB().\n\t\tSelect(\"stats\", \"created\").\n\t\tFrom(\"system_stats\").\n\t\tWhere(dbx.NewExp(\n\t\t\t\"system={:system} AND type='1m' AND created > {:created}\",\n\t\t\tdbx.Params{\n\t\t\t\t\"system\": systemRecord.Id,\n\t\t\t\t// subtract some time to give us a bit of buffer\n\t\t\t\t\"created\": oldestTime.Add(-time.Second * 90),\n\t\t\t},\n\t\t)).\n\t\tOrderBy(\"created\").\n\t\tAll(&systemStats)\n\tif err != nil || len(systemStats) == 0 {\n\t\treturn err\n\t}\n\t// get oldest record creation time from first record in the slice\n\toldestRecordTime := systemStats[0].Created.Time()\n\t// log.Println(\"oldestRecordTime\", oldestRecordTime.String())\n\t// Filter validAlerts to keep only those with time newer than oldestRecord\n\tfilteredAlerts := make([]SystemAlertData, 0, len(validAlerts))\n\tfor _, alert := range validAlerts {\n\t\tif alert.time.After(oldestRecordTime) {\n\t\t\tfilteredAlerts = append(filteredAlerts, alert)\n\t\t}\n\t}\n\tvalidAlerts = filteredAlerts\n\tif len(validAlerts) == 0 {\n\t\t// log.Println(\"no valid alerts found\")\n\t\treturn nil\n\t}\n\tvar stats SystemAlertStats\n\t// we can skip the latest systemStats record since it's the current val"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_system.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_system.go", "rel_path": "src/alerts/alerts_system.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 258, "end_line": 305, "text": "func (am *AlertManager) sendSystemAlert(alert SystemAlertData) {\n\t// log.Printf(\"Sending alert %s: val %f | count %d | threshold %f\\n\", alert.name, alert.val, alert.count, alert.threshold)\n\tsystemName := alert.systemRecord.GetString(\"name\")\n\n\t// change Disk to Disk usage\n\tif alert.name == \"Disk\" {\n\t\talert.name += \" usage\"\n\t}\n\t// format LoadAvg5 and LoadAvg15\n\tif after, ok := strings.CutPrefix(alert.name, \"LoadAvg\"); ok {\n\t\talert.name = after + \"m Load\"\n\t}\n\n\t// make title alert name lowercase if not CPU\n\ttitleAlertName := alert.name\n\tif titleAlertName != \"CPU\" {\n\t\ttitleAlertName = strings.ToLower(titleAlertName)\n\t}\n\n\tvar subject string\n\tif alert.triggered {\n\t\tsubject = fmt.Sprintf(\"%s %s above threshold\", systemName, titleAlertName)\n\t} else {\n\t\tsubject = fmt.Sprintf(\"%s %s below threshold\", systemName, titleAlertName)\n\t}\n\tminutesLabel := \"minute\"\n\tif alert.min > 1 {\n\t\tminutesLabel += \"s\"\n\t}\n\tif alert.descriptor == \"\" {\n\t\talert.descriptor = alert.name\n\t}\n\tbody := fmt.Sprintf(\"%s averaged %.2f%s for the previous %v %s.\", alert.descriptor, alert.val, alert.unit, alert.min, minutesLabel)\n\n\talert.alertRecord.Set(\"triggered\", alert.triggered)\n\tif err := am.hub.Save(alert.alertRecord); err != nil {\n\t\t// app.Logger().Error(\"failed to save alert record\", \"err\", err)\n\t\treturn\n\t}\n\tam.SendAlert(AlertMessageData{\n\t\tUserID:   alert.alertRecord.GetString(\"user\"),\n\t\tTitle:    subject,\n\t\tMessage:  body,\n\t\tLink:     am.hub.MakeLink(\"system\", systemName),\n\t\tLinkText: \"View \" + systemName,\n\t})\n}\n", "n_tokens": 410, "primary_symbol": "sendSystemAlert", "primary_kind": "function", "primary_span": [258, 305], "def_symbols": ["sendSystemAlert"], "symbols": ["sendSystemAlert", "func", "AlertManager", "alert", "SystemAlertData", "log", "Printf", "Sending", "val", "count", "threshold", "name", "systemName", "systemRecord", "GetString", "change", "Disk", "usage", "format", "LoadAvg5", "and", "LoadAvg15", "after", "strings", "CutPrefix", "LoadAvg", "Load", "make", "title", "lowercase", "not", "CPU", "titleAlertName", "ToLower", "var", "subject", "string", "triggered", "fmt", "Sprintf", "above", "else", "below", "minutesLabel", "minute", "min", "descriptor", "body", "averaged", "for", "the", "previous", "unit", "alertRecord", "Set", "err", "hub", "Save", "nil", "app", "Logger", "Error", "failed", "save", "record", "return", "SendAlert", "AlertMessageData", "UserID", "user", "Title", "Message", "Link", "MakeLink", "system", "LinkText", "View"], "doc_head": "func (am *AlertManager) sendSystemAlert(alert SystemAlertData) {\n\t// log.Printf(\"Sending alert %s: val %f | count %d | threshold %f\\n\", alert.name, alert.val, alert.count, alert.threshold)\n\tsystemName := alert.systemRecord.GetString(\"name\")\n\t// change Disk to Disk usage\n\tif alert.name == \"Disk\" {\n\t\talert.name += \" usage\"\n\t}\n\t// format LoadAvg5 and LoadAvg15\n\tif after, ok := strings.CutPrefix(alert.name, \"LoadAvg\"); ok {\n\t\talert.name = after + \"m Load\"\n\t}\n\t// make title alert name lowercase if not CPU\n\ttitleAlertName := alert.name\n\tif titleAlertName != \"CPU\" {\n\t\ttitleAlertName = strings.ToLower(titleAlertName)\n\t}\n\tvar subject string\n\tif alert.triggered {\n\t\tsubject = fmt.Sprintf(\"%s %s above threshold\", systemName, titleAlertName)\n\t} else {\n\t\tsubject = fmt.Sprintf(\"%s %s below threshold\", systemName, titleAlertName)\n\t}\n\tminutesLabel := \"minute\"\n\tif alert.min > 1 {\n\t\tminutesLabel += \"s\"\n\t}\n\tif alert.descriptor == \"\" {\n\t\talert.descriptor = alert.name\n\t}\n\tbody := fmt.Sprintf(\"%s averaged %.2f%s for the previous %v %s.\", alert.descriptor, alert.val, alert.unit, alert.min, minutesLabel)\n\talert.alertRecord.Set(\"triggered\", alert.triggered)\n\tif err := am.hub.Save(alert.alertRecord); err != "}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_history.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_history.go", "rel_path": "src/alerts/alerts_history.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 18, "text": "package alerts\n\nimport (\n\t\"time\"\n\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n\n// On triggered alert record delete, set matching alert history record to resolved\nfunc resolveHistoryOnAlertDelete(e *core.RecordEvent) error {\n\tif !e.Record.GetBool(\"triggered\") {\n\t\treturn e.Next()\n\t}\n\t_ = resolveAlertHistoryRecord(e.App, e.Record.Id)\n\treturn e.Next()\n}\n", "n_tokens": 95, "primary_symbol": "resolveHistoryOnAlertDelete", "primary_kind": "function", "primary_span": [11, 18], "def_symbols": ["resolveHistoryOnAlertDelete"], "symbols": ["resolveHistoryOnAlertDelete", "package", "alerts", "import", "time", "github", "com", "pocketbase", "dbx", "core", "triggered", "alert", "record", "delete", "set", "matching", "history", "resolved", "func", "RecordEvent", "error", "Record", "GetBool", "return", "Next", "resolveAlertHistoryRecord", "App"], "doc_head": "package alerts\nimport (\n\t\"time\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n// On triggered alert record delete, set matching alert history record to resolved\nfunc resolveHistoryOnAlertDelete(e *core.RecordEvent) error {\n\tif !e.Record.GetBool(\"triggered\") {\n\t\treturn e.Next()\n\t}\n\t_ = resolveAlertHistoryRecord(e.App, e.Record.Id)\n\treturn e.Next()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_history.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_history.go", "rel_path": "src/alerts/alerts_history.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 19, "end_line": 42, "text": "// On alert record update, update alert history record\nfunc updateHistoryOnAlertUpdate(e *core.RecordEvent) error {\n\toriginal := e.Record.Original()\n\tnew := e.Record\n\n\toriginalTriggered := original.GetBool(\"triggered\")\n\tnewTriggered := new.GetBool(\"triggered\")\n\n\t// no need to update alert history if triggered state has not changed\n\tif originalTriggered == newTriggered {\n\t\treturn e.Next()\n\t}\n\n\t// if new state is triggered, create new alert history record\n\tif newTriggered {\n\t\t_, _ = createAlertHistoryRecord(e.App, new)\n\t\treturn e.Next()\n\t}\n\n\t// if new state is not triggered, check for matching alert history record and set it to resolved\n\t_ = resolveAlertHistoryRecord(e.App, new.Id)\n\treturn e.Next()\n}\n", "n_tokens": 171, "primary_symbol": "updateHistoryOnAlertUpdate", "primary_kind": "function", "primary_span": [20, 42], "def_symbols": ["updateHistoryOnAlertUpdate"], "symbols": ["updateHistoryOnAlertUpdate", "alert", "record", "update", "history", "func", "core", "RecordEvent", "error", "original", "Record", "Original", "new", "originalTriggered", "GetBool", "triggered", "newTriggered", "need", "state", "has", "not", "changed", "return", "Next", "create", "createAlertHistoryRecord", "App", "check", "for", "matching", "and", "set", "resolved", "resolveAlertHistoryRecord"], "doc_head": "// On alert record update, update alert history record\nfunc updateHistoryOnAlertUpdate(e *core.RecordEvent) error {\n\toriginal := e.Record.Original()\n\tnew := e.Record\n\toriginalTriggered := original.GetBool(\"triggered\")\n\tnewTriggered := new.GetBool(\"triggered\")\n\t// no need to update alert history if triggered state has not changed\n\tif originalTriggered == newTriggered {\n\t\treturn e.Next()\n\t}\n\t// if new state is triggered, create new alert history record\n\tif newTriggered {\n\t\t_, _ = createAlertHistoryRecord(e.App, new)\n\t\treturn e.Next()\n\t}\n\t// if new state is not triggered, check for matching alert history record and set it to resolved\n\t_ = resolveAlertHistoryRecord(e.App, new.Id)\n\treturn e.Next()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_history.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_history.go", "rel_path": "src/alerts/alerts_history.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 43, "end_line": 56, "text": "// resolveAlertHistoryRecord sets the resolved field to the current time\nfunc resolveAlertHistoryRecord(app core.App, alertRecordID string) error {\n\talertHistoryRecord, err := app.FindFirstRecordByFilter(\"alerts_history\", \"alert_id={:alert_id} && resolved=null\", dbx.Params{\"alert_id\": alertRecordID})\n\tif err != nil || alertHistoryRecord == nil {\n\t\treturn err\n\t}\n\talertHistoryRecord.Set(\"resolved\", time.Now().UTC())\n\terr = app.Save(alertHistoryRecord)\n\tif err != nil {\n\t\tapp.Logger().Error(\"Failed to resolve alert history\", \"err\", err)\n\t}\n\treturn err\n}\n", "n_tokens": 134, "primary_symbol": "resolveAlertHistoryRecord", "primary_kind": "function", "primary_span": [44, 56], "def_symbols": ["resolveAlertHistoryRecord"], "symbols": ["resolveAlertHistoryRecord", "sets", "the", "resolved", "field", "current", "time", "func", "app", "core", "App", "alertRecordID", "string", "error", "alertHistoryRecord", "err", "FindFirstRecordByFilter", "alerts_history", "alert_id", "null", "dbx", "Params", "nil", "return", "Set", "Now", "UTC", "Save", "Logger", "Error", "Failed", "resolve", "alert", "history"], "doc_head": "// resolveAlertHistoryRecord sets the resolved field to the current time\nfunc resolveAlertHistoryRecord(app core.App, alertRecordID string) error {\n\talertHistoryRecord, err := app.FindFirstRecordByFilter(\"alerts_history\", \"alert_id={:alert_id} && resolved=null\", dbx.Params{\"alert_id\": alertRecordID})\n\tif err != nil || alertHistoryRecord == nil {\n\t\treturn err\n\t}\n\talertHistoryRecord.Set(\"resolved\", time.Now().UTC())\n\terr = app.Save(alertHistoryRecord)\n\tif err != nil {\n\t\tapp.Logger().Error(\"Failed to resolve alert history\", \"err\", err)\n\t}\n\treturn err\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_history.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/alerts/alerts_history.go", "rel_path": "src/alerts/alerts_history.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 57, "end_line": 75, "text": "// createAlertHistoryRecord creates a new alert history record\nfunc createAlertHistoryRecord(app core.App, alertRecord *core.Record) (alertHistoryRecord *core.Record, err error) {\n\talertHistoryCollection, err := app.FindCachedCollectionByNameOrId(\"alerts_history\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\talertHistoryRecord = core.NewRecord(alertHistoryCollection)\n\talertHistoryRecord.Set(\"alert_id\", alertRecord.Id)\n\talertHistoryRecord.Set(\"user\", alertRecord.GetString(\"user\"))\n\talertHistoryRecord.Set(\"system\", alertRecord.GetString(\"system\"))\n\talertHistoryRecord.Set(\"name\", alertRecord.GetString(\"name\"))\n\talertHistoryRecord.Set(\"value\", alertRecord.GetFloat(\"value\"))\n\terr = app.Save(alertHistoryRecord)\n\tif err != nil {\n\t\tapp.Logger().Error(\"Failed to save alert history\", \"err\", err)\n\t}\n\treturn alertHistoryRecord, err\n}\n", "n_tokens": 185, "primary_symbol": "createAlertHistoryRecord", "primary_kind": "function", "primary_span": [58, 75], "def_symbols": ["createAlertHistoryRecord"], "symbols": ["createAlertHistoryRecord", "creates", "new", "alert", "history", "record", "func", "app", "core", "App", "alertRecord", "Record", "alertHistoryRecord", "err", "error", "alertHistoryCollection", "FindCachedCollectionByNameOrId", "alerts_history", "nil", "return", "NewRecord", "Set", "alert_id", "user", "GetString", "system", "name", "value", "GetFloat", "Save", "Logger", "Error", "Failed", "save"], "doc_head": "// createAlertHistoryRecord creates a new alert history record\nfunc createAlertHistoryRecord(app core.App, alertRecord *core.Record) (alertHistoryRecord *core.Record, err error) {\n\talertHistoryCollection, err := app.FindCachedCollectionByNameOrId(\"alerts_history\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\talertHistoryRecord = core.NewRecord(alertHistoryCollection)\n\talertHistoryRecord.Set(\"alert_id\", alertRecord.Id)\n\talertHistoryRecord.Set(\"user\", alertRecord.GetString(\"user\"))\n\talertHistoryRecord.Set(\"system\", alertRecord.GetString(\"system\"))\n\talertHistoryRecord.Set(\"name\", alertRecord.GetString(\"name\"))\n\talertHistoryRecord.Set(\"value\", alertRecord.GetFloat(\"value\"))\n\terr = app.Save(alertHistoryRecord)\n\tif err != nil {\n\t\tapp.Logger().Error(\"Failed to save alert history\", \"err\", err)\n\t}\n\treturn alertHistoryRecord, err\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/release.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/release.go", "rel_path": "src/ghupdate/release.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 24, "text": "package ghupdate\n\nimport (\n\t\"errors\"\n\t\"strings\"\n)\n\ntype releaseAsset struct {\n\tName        string `json:\"name\"`\n\tDownloadUrl string `json:\"browser_download_url\"`\n\tId          int    `json:\"id\"`\n\tSize        int    `json:\"size\"`\n}\n\ntype release struct {\n\tName      string          `json:\"name\"`\n\tTag       string          `json:\"tag_name\"`\n\tPublished string          `json:\"published_at\"`\n\tUrl       string          `json:\"html_url\"`\n\tBody      string          `json:\"body\"`\n\tAssets    []*releaseAsset `json:\"assets\"`\n\tId        int             `json:\"id\"`\n}\n", "n_tokens": 132, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 24], "def_symbols": [], "symbols": ["package", "ghupdate", "import", "errors", "strings", "type", "releaseAsset", "struct", "Name", "string", "json", "name", "DownloadUrl", "browser_download_url", "int", "Size", "size", "release", "Tag", "tag_name", "Published", "published_at", "Url", "html_url", "Body", "body", "Assets", "assets"], "doc_head": "package ghupdate\nimport (\n\t\"errors\"\n\t\"strings\"\n)\ntype releaseAsset struct {\n\tName        string `json:\"name\"`\n\tDownloadUrl string `json:\"browser_download_url\"`\n\tId          int    `json:\"id\"`\n\tSize        int    `json:\"size\"`\n}\ntype release struct {\n\tName      string          `json:\"name\"`\n\tTag       string          `json:\"tag_name\"`\n\tPublished string          `json:\"published_at\"`\n\tUrl       string          `json:\"html_url\"`\n\tBody      string          `json:\"body\"`\n\tAssets    []*releaseAsset `json:\"assets\"`\n\tId        int             `json:\"id\"`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/release.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/release.go", "rel_path": "src/ghupdate/release.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 25, "end_line": 37, "text": "// findAssetBySuffix returns the first available asset containing the specified suffix.\nfunc (r *release) findAssetBySuffix(suffix string) (*releaseAsset, error) {\n\tif suffix != \"\" {\n\t\tfor _, asset := range r.Assets {\n\t\t\tif strings.HasSuffix(asset.Name, suffix) {\n\t\t\t\treturn asset, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"missing asset containing \" + suffix)\n}\n", "n_tokens": 89, "primary_symbol": "findAssetBySuffix", "primary_kind": "function", "primary_span": [26, 37], "def_symbols": ["findAssetBySuffix"], "symbols": ["findAssetBySuffix", "returns", "the", "first", "available", "asset", "containing", "specified", "suffix", "func", "release", "string", "releaseAsset", "error", "for", "range", "Assets", "strings", "HasSuffix", "Name", "return", "nil", "errors", "New", "missing"], "doc_head": "// findAssetBySuffix returns the first available asset containing the specified suffix.\nfunc (r *release) findAssetBySuffix(suffix string) (*releaseAsset, error) {\n\tif suffix != \"\" {\n\t\tfor _, asset := range r.Assets {\n\t\t\tif strings.HasSuffix(asset.Name, suffix) {\n\t\t\t\treturn asset, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, errors.New(\"missing asset containing \" + suffix)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go", "rel_path": "src/ghupdate/ghupdate.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 35, "text": "// Package ghupdate implements a new command to self update the current\n// executable with the latest GitHub release. This is based on PocketBase's\n// ghupdate package with modifications.\npackage ghupdate\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/henrygd/beszel\"\n\n\t\"github.com/blang/semver\"\n)\n\n// Minimal color functions using ANSI escape codes\nconst (\n\tcolorReset  = \"\\033[0m\"\n\tColorYellow = \"\\033[33m\"\n\tColorGreen  = \"\\033[32m\"\n\tcolorCyan   = \"\\033[36m\"\n\tcolorGray   = \"\\033[90m\"\n)\n\nfunc ColorPrint(color, text string) {\n\tfmt.Println(color + text + colorReset)\n}\n", "n_tokens": 181, "primary_symbol": "ColorPrint", "primary_kind": "function", "primary_span": [32, 35], "def_symbols": ["ColorPrint"], "symbols": ["ColorPrint", "Package", "ghupdate", "implements", "new", "command", "self", "update", "the", "current", "executable", "with", "latest", "GitHub", "release", "This", "based", "PocketBase", "package", "modifications", "import", "context", "encoding", "json", "fmt", "log", "slog", "net", "http", "path", "filepath", "runtime", "strings", "github", "com", "henrygd", "beszel", "blang", "semver", "Minimal", "color", "functions", "using", "ANSI", "escape", "codes", "const", "colorReset", "ColorYellow", "ColorGreen", "colorCyan", "colorGray", "func", "text", "string", "Println"], "doc_head": "// Package ghupdate implements a new command to self update the current\n// executable with the latest GitHub release. This is based on PocketBase's\n// ghupdate package with modifications.\npackage ghupdate\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/blang/semver\"\n)\n// Minimal color functions using ANSI escape codes\nconst (\n\tcolorReset  = \"\\033[0m\"\n\tColorYellow = \"\\033[33m\"\n\tColorGreen  = \"\\033[32m\"\n\tcolorCyan   = \"\\033[36m\"\n\tcolorGray   = \"\\033[90m\"\n)\nfunc ColorPrint(color, text string) {\n\tfmt.Println(color + text + colorReset)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go", "rel_path": "src/ghupdate/ghupdate.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 36, "end_line": 44, "text": "func ColorPrintf(color, format string, args ...interface{}) {\n\tfmt.Printf(color+format+colorReset+\"\\n\", args...)\n}\n\n// HttpClient is a base HTTP client interface (usually used for test purposes).\ntype HttpClient interface {\n\tDo(req *http.Request) (*http.Response, error)\n}\n", "n_tokens": 60, "primary_symbol": "ColorPrintf", "primary_kind": "function", "primary_span": [36, 44], "def_symbols": ["ColorPrintf"], "symbols": ["ColorPrintf", "func", "color", "format", "string", "args", "interface", "fmt", "Printf", "colorReset", "HttpClient", "base", "HTTP", "client", "usually", "used", "for", "test", "purposes", "type", "req", "http", "Request", "Response", "error"], "doc_head": "func ColorPrintf(color, format string, args ...interface{}) {\n\tfmt.Printf(color+format+colorReset+\"\\n\", args...)\n}\n// HttpClient is a base HTTP client interface (usually used for test purposes).\ntype HttpClient interface {\n\tDo(req *http.Request) (*http.Response, error)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go", "rel_path": "src/ghupdate/ghupdate.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 45, "end_line": 73, "text": "// Config defines the config options of the ghupdate plugin.\n//\n// NB! This plugin is considered experimental and its config options may change in the future.\ntype Config struct {\n\t// Owner specifies the account owner of the repository (default to \"pocketbase\").\n\tOwner string\n\n\t// Repo specifies the name of the repository (default to \"pocketbase\").\n\tRepo string\n\n\t// ArchiveExecutable specifies the name of the executable file in the release archive\n\t// (default to \"pocketbase\"; an additional \".exe\" check is also performed as a fallback).\n\tArchiveExecutable string\n\n\t// Optional context to use when fetching and downloading the latest release.\n\tContext context.Context\n\n\t// The HTTP client to use when fetching and downloading the latest release.\n\t// Defaults to `http.DefaultClient`.\n\tHttpClient HttpClient\n\n\t// The data directory to use when fetching and downloading the latest release.\n\tDataDir string\n\n\t// UseMirror specifies whether to use the beszel.dev mirror instead of GitHub API.\n\t// When false (default), always uses api.github.com. When true, uses gh.beszel.dev.\n\tUseMirror bool\n}\n", "n_tokens": 233, "primary_symbol": "", "primary_kind": "", "primary_span": [45, 73], "def_symbols": [], "symbols": ["Config", "defines", "the", "config", "options", "ghupdate", "plugin", "This", "considered", "experimental", "and", "its", "may", "change", "future", "type", "struct", "Owner", "specifies", "account", "owner", "repository", "default", "pocketbase", "string", "Repo", "name", "ArchiveExecutable", "executable", "file", "release", "archive", "additional", "exe", "check", "also", "performed", "fallback", "Optional", "context", "use", "when", "fetching", "downloading", "latest", "Context", "The", "HTTP", "client", "Defaults", "http", "DefaultClient", "HttpClient", "data", "directory", "DataDir", "UseMirror", "whether", "beszel", "dev", "mirror", "instead", "GitHub", "API", "When", "false", "always", "uses", "api", "github", "com", "true", "bool"], "doc_head": "// Config defines the config options of the ghupdate plugin.\n//\n// NB! This plugin is considered experimental and its config options may change in the future.\ntype Config struct {\n\t// Owner specifies the account owner of the repository (default to \"pocketbase\").\n\tOwner string\n\t// Repo specifies the name of the repository (default to \"pocketbase\").\n\tRepo string\n\t// ArchiveExecutable specifies the name of the executable file in the release archive\n\t// (default to \"pocketbase\"; an additional \".exe\" check is also performed as a fallback).\n\tArchiveExecutable string\n\t// Optional context to use when fetching and downloading the latest release.\n\tContext context.Context\n\t// The HTTP client to use when fetching and downloading the latest release.\n\t// Defaults to `http.DefaultClient`.\n\tHttpClient HttpClient\n\t// The data directory to use when fetching and downloading the latest release.\n\tDataDir string\n\t// UseMirror specifies whether to use the beszel.dev mirror instead of GitHub API.\n\t// When false (default), always uses api.github.com. When true, uses gh.beszel.dev.\n\tUseMirror bool\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go", "rel_path": "src/ghupdate/ghupdate.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 74, "end_line": 87, "text": "type updater struct {\n\tconfig         Config\n\tcurrentVersion string\n}\n\nfunc Update(config Config) (updated bool, err error) {\n\tp := &updater{\n\t\tcurrentVersion: beszel.Version,\n\t\tconfig:         config,\n\t}\n\n\treturn p.update()\n}\n", "n_tokens": 53, "primary_symbol": "Update", "primary_kind": "function", "primary_span": [79, 87], "def_symbols": ["Update"], "symbols": ["Update", "type", "updater", "struct", "config", "Config", "currentVersion", "string", "func", "updated", "bool", "err", "error", "beszel", "Version", "return", "update"], "doc_head": "type updater struct {\n\tconfig         Config\n\tcurrentVersion string\n}\nfunc Update(config Config) (updated bool, err error) {\n\tp := &updater{\n\t\tcurrentVersion: beszel.Version,\n\t\tconfig:         config,\n\t}\n\treturn p.update()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go", "rel_path": "src/ghupdate/ghupdate.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 88, "end_line": 227, "text": "func (p *updater) update() (updated bool, err error) {\n\tColorPrint(ColorYellow, \"Fetching release information...\")\n\n\tif p.config.DataDir == \"\" {\n\t\tp.config.DataDir = os.TempDir()\n\t}\n\n\tif p.config.Owner == \"\" {\n\t\tp.config.Owner = \"henrygd\"\n\t}\n\n\tif p.config.Repo == \"\" {\n\t\tp.config.Repo = \"beszel\"\n\t}\n\n\tif p.config.Context == nil {\n\t\tp.config.Context = context.Background()\n\t}\n\n\tif p.config.HttpClient == nil {\n\t\tp.config.HttpClient = http.DefaultClient\n\t}\n\n\tvar latest *release\n\tvar useMirror bool\n\n\t// Determine the API endpoint based on UseMirror flag\n\tapiURL := fmt.Sprintf(\"https://api.github.com/repos/%s/%s/releases/latest\", p.config.Owner, p.config.Repo)\n\tif p.config.UseMirror {\n\t\tuseMirror = true\n\t\tapiURL = fmt.Sprintf(\"https://gh.beszel.dev/repos/%s/%s/releases/latest?api=true\", p.config.Owner, p.config.Repo)\n\t\tColorPrint(ColorYellow, \"Using mirror for update.\")\n\t}\n\n\tlatest, err = fetchLatestRelease(\n\t\tp.config.Context,\n\t\tp.config.HttpClient,\n\t\tapiURL,\n\t)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tcurrentVersion := semver.MustParse(strings.TrimPrefix(p.currentVersion, \"v\"))\n\tnewVersion := semver.MustParse(strings.TrimPrefix(latest.Tag, \"v\"))\n\n\tif newVersion.LTE(currentVersion) {\n\t\tColorPrintf(ColorGreen, \"You already have the latest version %s.\", p.currentVersion)\n\t\treturn false, nil\n\t}\n\n\tsuffix := archiveSuffix(p.config.ArchiveExecutable, runtime.GOOS, runtime.GOARCH)\n\tasset, err := latest.findAssetBySuffix(suffix)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treleaseDir := filepath.Join(p.config.DataDir, \".beszel_update\")\n\tdefer os.RemoveAll(releaseDir)\n\n\tColorPrintf(ColorYellow, \"Downloading %s...\", asset.Name)\n\n\t// download the release asset\n\tassetPath := filepath.Join(releaseDir, asset.Name)\n\tif err := downloadFile(p.config.Context, p.config.HttpClient, asset.DownloadUrl, assetPath, useMirror); err != nil {\n\t\treturn false, err\n\t}\n\n\tColorPrintf(ColorYellow, \"Extracting %s...\", asset.Name)\n\n\textractDir := filepath.Join(releaseDir, \"extracted_\"+asset.Name)\n\tdefer os.RemoveAll(extractDir)\n\n\t// Extract the archive (automatically detects format)\n\tif err := extract(assetPath, extractDir); err != nil {\n\t\treturn false, err\n\t}\n\n\tColorPrint(ColorYellow, \"Replacing the executable...\")\n\n\toldExec, err := os.Executable()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\trenamedOldExec := oldExec + \".old\"\n\tdefer os.Remove(renamedOldExec)\n\n\tnewExec := filepath.Join(extractDir, p.config.ArchiveExecutable)\n\tif _, err := os.Stat(newExec); err != nil {\n\t\t// try again with an .exe extension\n\t\tnewExec = newExec + \".exe\"\n\t\tif _, fallbackErr := os.Stat(newExec); fallbackErr != nil {\n\t\t\treturn false, fmt.Errorf(\"the executable in the extracted path is missing or it is inaccessible: %v, %v\", err, fallbackErr)\n\t\t}\n\t}\n\n\t// rename the current executable\n\tif err := os.Rename(oldExec, renamedOldExec); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to rename the current executable: %w\", err)\n\t}\n\n\ttryToRevertExecChanges := func() {\n\t\tif revertErr := os.Rename(renamedOldExec, oldExec); revertErr != nil {\n\t\t\tslog.Debug(\n\t\t\t\t\"Failed to revert executable\",\n\t\t\t\tslog.String(\"old\", renamedOldExec),\n\t\t\t\tslog.String(\"new\", oldExec),\n\t\t\t\tslog.String(\"error\", revertErr.Error()),\n\t\t\t)\n\t\t}\n\t}\n\n\t// replace with the extracted binary\n\tif err := os.Rename(newExec, oldExec); err != nil {\n\t\t// If rename fails due to cross-device link, try copying instead\n\t\tif isCrossDeviceError(err) {\n\t\t\tif err := copyFile(newExec, oldExec); err != nil {\n\t\t\t\ttryToRevertExecChanges()\n\t\t\t\treturn false, fmt.Errorf(\"failed replacing the executable: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\ttryToRevertExecChanges()\n\t\t\treturn false, fmt.Errorf(\"failed replacing the executable: %w\", err)\n\t\t}\n\t}\n\n\tColorPrint(colorGray, \"---\")\n\tColorPrint(ColorGreen, \"Update completed successfully!\")\n\n\t// print the release notes\n\tif latest.Body != \"\" {\n\t\tfmt.Print(\"\\n\")\n\t\treleaseNotes := strings.TrimSpace(strings.Replace(latest.Body, \"> _To update the prebuilt executable you can run `./\"+p.config.ArchiveExecutable+\" update`._\", \"\", 1))\n\t\tColorPrint(colorCyan, releaseNotes)\n\t\tfmt.Print(\"\\n\")\n\t}\n\n\treturn true, nil\n}\n", "n_tokens": 1065, "primary_symbol": "update", "primary_kind": "function", "primary_span": [88, 227], "def_symbols": ["update"], "symbols": ["update", "func", "updater", "updated", "bool", "err", "error", "ColorPrint", "ColorYellow", "Fetching", "release", "information", "config", "DataDir", "TempDir", "Owner", "henrygd", "Repo", "beszel", "Context", "nil", "context", "Background", "HttpClient", "http", "DefaultClient", "var", "latest", "useMirror", "Determine", "the", "API", "endpoint", "based", "UseMirror", "flag", "apiURL", "fmt", "Sprintf", "https", "api", "github", "com", "repos", "releases", "true", "dev", "Using", "mirror", "for", "fetchLatestRelease", "return", "false", "currentVersion", "semver", "MustParse", "strings", "TrimPrefix", "newVersion", "Tag", "LTE", "ColorPrintf", "ColorGreen", "You", "already", "have", "version", "suffix", "archiveSuffix", "ArchiveExecutable", "runtime", "GOOS", "GOARCH", "asset", "findAssetBySuffix", "releaseDir", "filepath", "Join", "beszel_update", "defer", "RemoveAll", "Downloading", "Name", "download", "assetPath", "downloadFile", "DownloadUrl", "Extracting", "extractDir", "extracted_", "Extract", "archive", "automatically", "detects", "format", "extract", "Replacing", "executable", "oldExec", "Executable", "renamedOldExec", "old", "Remove", "newExec", "Stat", "try", "again", "with", "exe", "extension", "fallbackErr", "Errorf", "extracted", "path", "missing", "inaccessible", "rename", "current", "Rename", "failed", "tryToRevertExecChanges", "revertErr", "slog", "Debug", "Failed", "revert", "String", "new", "Error", "replace", "binary", "fails", "due", "cross", "device", "link", "copying", "instead", "isCrossDeviceError", "copyFile", "replacing", "else", "colorGray", "Update", "completed", "successfully", "print", "notes", "Body", "Print", "releaseNotes", "TrimSpace", "Replace", "_To", "prebuilt", "you", "can", "run", "colorCyan"], "doc_head": "func (p *updater) update() (updated bool, err error) {\n\tColorPrint(ColorYellow, \"Fetching release information...\")\n\tif p.config.DataDir == \"\" {\n\t\tp.config.DataDir = os.TempDir()\n\t}\n\tif p.config.Owner == \"\" {\n\t\tp.config.Owner = \"henrygd\"\n\t}\n\tif p.config.Repo == \"\" {\n\t\tp.config.Repo = \"beszel\"\n\t}\n\tif p.config.Context == nil {\n\t\tp.config.Context = context.Background()\n\t}\n\tif p.config.HttpClient == nil {\n\t\tp.config.HttpClient = http.DefaultClient\n\t}\n\tvar latest *release\n\tvar useMirror bool\n\t// Determine the API endpoint based on UseMirror flag\n\tapiURL := fmt.Sprintf(\"https://api.github.com/repos/%s/%s/releases/latest\", p.config.Owner, p.config.Repo)\n\tif p.config.UseMirror {\n\t\tuseMirror = true\n\t\tapiURL = fmt.Sprintf(\"https://gh.beszel.dev/repos/%s/%s/releases/latest?api=true\", p.config.Owner, p.config.Repo)\n\t\tColorPrint(ColorYellow, \"Using mirror for update.\")\n\t}\n\tlatest, err = fetchLatestRelease(\n\t\tp.config.Context,\n\t\tp.config.HttpClient,\n\t\tapiURL,\n\t)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcurrentVersion := semver.MustParse(strings.TrimPrefix(p.currentVersion, \"v\"))\n\tnewVersion := semver.MustParse(strings.TrimPrefix(latest.Tag, \"v\"))\n\tif newVersion.LTE(currentVersion) {\n\t\tColorPrintf"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go", "rel_path": "src/ghupdate/ghupdate.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 228, "end_line": 265, "text": "func fetchLatestRelease(\n\tctx context.Context,\n\tclient HttpClient,\n\turl string,\n) (*release, error) {\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\trawBody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// http.Client doesn't treat non 2xx responses as error\n\tif res.StatusCode >= 400 {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"(%d) failed to fetch latest releases:\\n%s\",\n\t\t\tres.StatusCode,\n\t\t\tstring(rawBody),\n\t\t)\n\t}\n\n\tresult := &release{}\n\tif err := json.Unmarshal(rawBody, result); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n", "n_tokens": 191, "primary_symbol": "fetchLatestRelease", "primary_kind": "function", "primary_span": [228, 265], "def_symbols": ["fetchLatestRelease"], "symbols": ["fetchLatestRelease", "func", "ctx", "context", "Context", "client", "HttpClient", "url", "string", "release", "error", "req", "err", "http", "NewRequestWithContext", "GET", "nil", "return", "res", "defer", "Body", "Close", "rawBody", "ReadAll", "Client", "doesn", "treat", "non", "responses", "StatusCode", "fmt", "Errorf", "failed", "fetch", "latest", "releases", "result", "json", "Unmarshal"], "doc_head": "func fetchLatestRelease(\n\tctx context.Context,\n\tclient HttpClient,\n\turl string,\n) (*release, error) {\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\trawBody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// http.Client doesn't treat non 2xx responses as error\n\tif res.StatusCode >= 400 {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"(%d) failed to fetch latest releases:\\n%s\",\n\t\t\tres.StatusCode,\n\t\t\tstring(rawBody),\n\t\t)\n\t}\n\tresult := &release{}\n\tif err := json.Unmarshal(rawBody, result); err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go", "rel_path": "src/ghupdate/ghupdate.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 266, "end_line": 309, "text": "func downloadFile(\n\tctx context.Context,\n\tclient HttpClient,\n\turl string,\n\tdestPath string,\n\tuseMirror bool,\n) error {\n\tif useMirror {\n\t\turl = strings.Replace(url, \"github.com\", \"gh.beszel.dev\", 1)\n\t}\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\n\t// http.Client doesn't treat non 2xx responses as error\n\tif res.StatusCode >= 400 {\n\t\treturn fmt.Errorf(\"(%d) failed to send download file request\", res.StatusCode)\n\t}\n\n\t// ensure that the dest parent dir(s) exist\n\tif err := os.MkdirAll(filepath.Dir(destPath), os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\n\tdest, err := os.Create(destPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dest.Close()\n\n\tif _, err := io.Copy(dest, res.Body); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "n_tokens": 231, "primary_symbol": "downloadFile", "primary_kind": "function", "primary_span": [266, 309], "def_symbols": ["downloadFile"], "symbols": ["downloadFile", "func", "ctx", "context", "Context", "client", "HttpClient", "url", "string", "destPath", "useMirror", "bool", "error", "strings", "Replace", "github", "com", "beszel", "dev", "req", "err", "http", "NewRequestWithContext", "GET", "nil", "return", "res", "defer", "Body", "Close", "Client", "doesn", "treat", "non", "responses", "StatusCode", "fmt", "Errorf", "failed", "send", "download", "file", "request", "ensure", "that", "the", "dest", "parent", "dir", "exist", "MkdirAll", "filepath", "Dir", "ModePerm", "Create", "Copy"], "doc_head": "func downloadFile(\n\tctx context.Context,\n\tclient HttpClient,\n\turl string,\n\tdestPath string,\n\tuseMirror bool,\n) error {\n\tif useMirror {\n\t\turl = strings.Replace(url, \"github.com\", \"gh.beszel.dev\", 1)\n\t}\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\t// http.Client doesn't treat non 2xx responses as error\n\tif res.StatusCode >= 400 {\n\t\treturn fmt.Errorf(\"(%d) failed to send download file request\", res.StatusCode)\n\t}\n\t// ensure that the dest parent dir(s) exist\n\tif err := os.MkdirAll(filepath.Dir(destPath), os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\tdest, err := os.Create(destPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dest.Close()\n\tif _, err := io.Copy(dest, res.Body); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go", "rel_path": "src/ghupdate/ghupdate.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 310, "end_line": 343, "text": "// isCrossDeviceError checks if the error is due to a cross-device link\nfunc isCrossDeviceError(err error) bool {\n\treturn err != nil && (strings.Contains(err.Error(), \"cross-device\") ||\n\t\tstrings.Contains(err.Error(), \"EXDEV\"))\n}\n\n// copyFile copies a file from src to dst, preserving permissions\nfunc copyFile(src, dst string) error {\n\tsourceFile, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer sourceFile.Close()\n\n\tdestFile, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer destFile.Close()\n\n\t// Copy the file contents\n\tif _, err := io.Copy(destFile, sourceFile); err != nil {\n\t\treturn err\n\t}\n\n\t// Preserve the original file permissions\n\tsourceInfo, err := sourceFile.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn destFile.Chmod(sourceInfo.Mode())\n}\n", "n_tokens": 196, "primary_symbol": "isCrossDeviceError", "primary_kind": "function", "primary_span": [311, 343], "def_symbols": ["isCrossDeviceError", "copyFile"], "symbols": ["isCrossDeviceError", "copyFile", "checks", "the", "error", "due", "cross", "device", "link", "func", "err", "bool", "return", "nil", "strings", "Contains", "Error", "EXDEV", "copies", "file", "from", "src", "dst", "preserving", "permissions", "string", "sourceFile", "Open", "defer", "Close", "destFile", "Create", "Copy", "contents", "Preserve", "original", "sourceInfo", "Stat", "Chmod", "Mode"], "doc_head": "// isCrossDeviceError checks if the error is due to a cross-device link\nfunc isCrossDeviceError(err error) bool {\n\treturn err != nil && (strings.Contains(err.Error(), \"cross-device\") ||\n\t\tstrings.Contains(err.Error(), \"EXDEV\"))\n}\n// copyFile copies a file from src to dst, preserving permissions\nfunc copyFile(src, dst string) error {\n\tsourceFile, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer sourceFile.Close()\n\tdestFile, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer destFile.Close()\n\t// Copy the file contents\n\tif _, err := io.Copy(destFile, sourceFile); err != nil {\n\t\treturn err\n\t}\n\t// Preserve the original file permissions\n\tsourceInfo, err := sourceFile.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn destFile.Chmod(sourceInfo.Mode())\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate.go", "rel_path": "src/ghupdate/ghupdate.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 344, "end_line": 350, "text": "func archiveSuffix(binaryName, goos, goarch string) string {\n\tif goos == \"windows\" {\n\t\treturn fmt.Sprintf(\"%s_%s_%s.zip\", binaryName, goos, goarch)\n\t}\n\treturn fmt.Sprintf(\"%s_%s_%s.tar.gz\", binaryName, goos, goarch)\n}\n", "n_tokens": 68, "primary_symbol": "archiveSuffix", "primary_kind": "function", "primary_span": [344, 350], "def_symbols": ["archiveSuffix"], "symbols": ["archiveSuffix", "func", "binaryName", "goos", "goarch", "string", "windows", "return", "fmt", "Sprintf", "zip", "tar"], "doc_head": "func archiveSuffix(binaryName, goos, goarch string) string {\n\tif goos == \"windows\" {\n\t\treturn fmt.Sprintf(\"%s_%s_%s.zip\", binaryName, goos, goarch)\n\t}\n\treturn fmt.Sprintf(\"%s_%s_%s.tar.gz\", binaryName, goos, goarch)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/extract.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/extract.go", "rel_path": "src/ghupdate/extract.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 23, "text": "package ghupdate\n\nimport (\n\t\"archive/tar\"\n\t\"archive/zip\"\n\t\"compress/gzip\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// extract extracts an archive file to the destination directory.\n// Supports .zip and .tar.gz files based on the file extension.\nfunc extract(srcPath, destDir string) error {\n\tif strings.HasSuffix(srcPath, \".tar.gz\") {\n\t\treturn extractTarGz(srcPath, destDir)\n\t}\n\t// Default to zip extraction\n\treturn extractZip(srcPath, destDir)\n}\n", "n_tokens": 121, "primary_symbol": "extract", "primary_kind": "function", "primary_span": [16, 23], "def_symbols": ["extract"], "symbols": ["extract", "package", "ghupdate", "import", "archive", "tar", "zip", "compress", "gzip", "fmt", "path", "filepath", "strings", "extracts", "file", "the", "destination", "directory", "Supports", "and", "files", "based", "extension", "func", "srcPath", "destDir", "string", "error", "HasSuffix", "return", "extractTarGz", "Default", "extraction", "extractZip"], "doc_head": "package ghupdate\nimport (\n\t\"archive/tar\"\n\t\"archive/zip\"\n\t\"compress/gzip\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n// extract extracts an archive file to the destination directory.\n// Supports .zip and .tar.gz files based on the file extension.\nfunc extract(srcPath, destDir string) error {\n\tif strings.HasSuffix(srcPath, \".tar.gz\") {\n\t\treturn extractTarGz(srcPath, destDir)\n\t}\n\t// Default to zip extraction\n\treturn extractZip(srcPath, destDir)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/extract.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/extract.go", "rel_path": "src/ghupdate/extract.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 24, "end_line": 74, "text": "// extractTarGz extracts a tar.gz archive to the destination directory.\nfunc extractTarGz(srcPath, destDir string) error {\n\tsrc, err := os.Open(srcPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer src.Close()\n\n\tgz, err := gzip.NewReader(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer gz.Close()\n\n\ttr := tar.NewReader(gz)\n\n\tfor {\n\t\theader, err := tr.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif header.Typeflag == tar.TypeDir {\n\t\t\tif err := os.MkdirAll(filepath.Join(destDir, header.Name), 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := os.MkdirAll(filepath.Dir(filepath.Join(destDir, header.Name)), 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\toutFile, err := os.Create(filepath.Join(destDir, header.Name))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := io.Copy(outFile, tr); err != nil {\n\t\t\toutFile.Close()\n\t\t\treturn err\n\t\t}\n\t\toutFile.Close()\n\t}\n\n\treturn nil\n}\n", "n_tokens": 268, "primary_symbol": "extractTarGz", "primary_kind": "function", "primary_span": [25, 74], "def_symbols": ["extractTarGz"], "symbols": ["extractTarGz", "extracts", "tar", "archive", "the", "destination", "directory", "func", "srcPath", "destDir", "string", "error", "src", "err", "Open", "nil", "return", "defer", "Close", "gzip", "NewReader", "for", "header", "Next", "EOF", "break", "Typeflag", "TypeDir", "MkdirAll", "filepath", "Join", "Name", "continue", "Dir", "outFile", "Create", "Copy"], "doc_head": "// extractTarGz extracts a tar.gz archive to the destination directory.\nfunc extractTarGz(srcPath, destDir string) error {\n\tsrc, err := os.Open(srcPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer src.Close()\n\tgz, err := gzip.NewReader(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer gz.Close()\n\ttr := tar.NewReader(gz)\n\tfor {\n\t\theader, err := tr.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif header.Typeflag == tar.TypeDir {\n\t\t\tif err := os.MkdirAll(filepath.Join(destDir, header.Name), 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif err := os.MkdirAll(filepath.Dir(filepath.Join(destDir, header.Name)), 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\toutFile, err := os.Create(filepath.Join(destDir, header.Name))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := io.Copy(outFile, tr); err != nil {\n\t\t\toutFile.Close()\n\t\t\treturn err\n\t\t}\n\t\toutFile.Close()\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/extract.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/extract.go", "rel_path": "src/ghupdate/extract.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 75, "end_line": 99, "text": "// extractZip extracts the zip archive at \"src\" to \"dest\".\n//\n// Note that only dirs and regular files will be extracted.\n// Symbolic links, named pipes, sockets, or any other irregular files\n// are skipped because they come with too many edge cases and ambiguities.\nfunc extractZip(src, dest string) error {\n\tzr, err := zip.OpenReader(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer zr.Close()\n\n\t// normalize dest path to check later for Zip Slip\n\tdest = filepath.Clean(dest) + string(os.PathSeparator)\n\n\tfor _, f := range zr.File {\n\t\terr := extractFile(f, dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n", "n_tokens": 157, "primary_symbol": "extractZip", "primary_kind": "function", "primary_span": [80, 99], "def_symbols": ["extractZip"], "symbols": ["extractZip", "extracts", "the", "zip", "archive", "src", "dest", "Note", "that", "only", "dirs", "and", "regular", "files", "will", "extracted", "Symbolic", "links", "named", "pipes", "sockets", "any", "other", "irregular", "are", "skipped", "because", "they", "come", "with", "too", "many", "edge", "cases", "ambiguities", "func", "string", "error", "err", "OpenReader", "nil", "return", "defer", "Close", "normalize", "path", "check", "later", "for", "Zip", "Slip", "filepath", "Clean", "PathSeparator", "range", "File", "extractFile"], "doc_head": "// extractZip extracts the zip archive at \"src\" to \"dest\".\n//\n// Note that only dirs and regular files will be extracted.\n// Symbolic links, named pipes, sockets, or any other irregular files\n// are skipped because they come with too many edge cases and ambiguities.\nfunc extractZip(src, dest string) error {\n\tzr, err := zip.OpenReader(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer zr.Close()\n\t// normalize dest path to check later for Zip Slip\n\tdest = filepath.Clean(dest) + string(os.PathSeparator)\n\tfor _, f := range zr.File {\n\t\terr := extractFile(f, dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/extract.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/extract.go", "rel_path": "src/ghupdate/extract.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 100, "end_line": 141, "text": "// extractFile extracts the provided zipFile into \"basePath/zipFileName\" path,\n// creating all the necessary path directories.\nfunc extractFile(zipFile *zip.File, basePath string) error {\n\tpath := filepath.Join(basePath, zipFile.Name)\n\n\t// check for Zip Slip\n\tif !strings.HasPrefix(path, basePath) {\n\t\treturn fmt.Errorf(\"invalid file path: %s\", path)\n\t}\n\n\tr, err := zipFile.Open()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\n\t// allow only dirs or regular files\n\tif zipFile.FileInfo().IsDir() {\n\t\tif err := os.MkdirAll(path, os.ModePerm); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if zipFile.FileInfo().Mode().IsRegular() {\n\t\t// ensure that the file path directories are created\n\t\tif err := os.MkdirAll(filepath.Dir(path), os.ModePerm); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tf, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, zipFile.Mode())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\n\t\t_, err = io.Copy(f, r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n", "n_tokens": 277, "primary_symbol": "extractFile", "primary_kind": "function", "primary_span": [102, 141], "def_symbols": ["extractFile"], "symbols": ["extractFile", "extracts", "the", "provided", "zipFile", "into", "basePath", "zipFileName", "path", "creating", "all", "necessary", "directories", "func", "zip", "File", "string", "error", "filepath", "Join", "Name", "check", "for", "Zip", "Slip", "strings", "HasPrefix", "return", "fmt", "Errorf", "invalid", "file", "err", "Open", "nil", "defer", "Close", "allow", "only", "dirs", "regular", "files", "FileInfo", "IsDir", "MkdirAll", "ModePerm", "else", "Mode", "IsRegular", "ensure", "that", "are", "created", "Dir", "OpenFile", "O_WRONLY", "O_CREATE", "O_TRUNC", "Copy"], "doc_head": "// extractFile extracts the provided zipFile into \"basePath/zipFileName\" path,\n// creating all the necessary path directories.\nfunc extractFile(zipFile *zip.File, basePath string) error {\n\tpath := filepath.Join(basePath, zipFile.Name)\n\t// check for Zip Slip\n\tif !strings.HasPrefix(path, basePath) {\n\t\treturn fmt.Errorf(\"invalid file path: %s\", path)\n\t}\n\tr, err := zipFile.Open()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\t// allow only dirs or regular files\n\tif zipFile.FileInfo().IsDir() {\n\t\tif err := os.MkdirAll(path, os.ModePerm); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if zipFile.FileInfo().Mode().IsRegular() {\n\t\t// ensure that the file path directories are created\n\t\tif err := os.MkdirAll(filepath.Dir(path), os.ModePerm); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, zipFile.Mode())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\t\t_, err = io.Copy(f, r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate_test.go", "rel_path": "src/ghupdate/ghupdate_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 27, "text": "package ghupdate\n\nimport (\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestReleaseFindAssetBySuffix(t *testing.T) {\n\tr := release{\n\t\tAssets: []*releaseAsset{\n\t\t\t{Name: \"test1.zip\", Id: 1},\n\t\t\t{Name: \"test2.zip\", Id: 2},\n\t\t\t{Name: \"test22.zip\", Id: 22},\n\t\t\t{Name: \"test3.zip\", Id: 3},\n\t\t},\n\t}\n\n\tasset, err := r.findAssetBySuffix(\"2.zip\")\n\tif err != nil {\n\t\tt.Fatalf(\"Expected nil, got err: %v\", err)\n\t}\n\n\tif asset.Id != 2 {\n\t\tt.Fatalf(\"Expected asset with id %d, got %v\", 2, asset)\n\t}\n}\n", "n_tokens": 166, "primary_symbol": "TestReleaseFindAssetBySuffix", "primary_kind": "function", "primary_span": [8, 27], "def_symbols": ["TestReleaseFindAssetBySuffix"], "symbols": ["TestReleaseFindAssetBySuffix", "package", "ghupdate", "import", "path", "filepath", "testing", "func", "release", "Assets", "releaseAsset", "Name", "test1", "zip", "test2", "test22", "test3", "asset", "err", "findAssetBySuffix", "nil", "Fatalf", "Expected", "got", "with"], "doc_head": "package ghupdate\nimport (\n\t\"path/filepath\"\n\t\"testing\"\n)\nfunc TestReleaseFindAssetBySuffix(t *testing.T) {\n\tr := release{\n\t\tAssets: []*releaseAsset{\n\t\t\t{Name: \"test1.zip\", Id: 1},\n\t\t\t{Name: \"test2.zip\", Id: 2},\n\t\t\t{Name: \"test22.zip\", Id: 22},\n\t\t\t{Name: \"test3.zip\", Id: 3},\n\t\t},\n\t}\n\tasset, err := r.findAssetBySuffix(\"2.zip\")\n\tif err != nil {\n\t\tt.Fatalf(\"Expected nil, got err: %v\", err)\n\t}\n\tif asset.Id != 2 {\n\t\tt.Fatalf(\"Expected asset with id %d, got %v\", 2, asset)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/ghupdate/ghupdate_test.go", "rel_path": "src/ghupdate/ghupdate_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 28, "end_line": 46, "text": "func TestExtractFailure(t *testing.T) {\n\ttestDir := t.TempDir()\n\n\t// Test with missing zip file\n\tmissingZipPath := filepath.Join(testDir, \"missing_test.zip\")\n\textractedPath := filepath.Join(testDir, \"zip_extract\")\n\n\tif err := extract(missingZipPath, extractedPath); err == nil {\n\t\tt.Fatal(\"Expected Extract to fail due to missing zip file\")\n\t}\n\n\t// Test with missing tar.gz file\n\tmissingTarPath := filepath.Join(testDir, \"missing_test.tar.gz\")\n\n\tif err := extract(missingTarPath, extractedPath); err == nil {\n\t\tt.Fatal(\"Expected Extract to fail due to missing tar.gz file\")\n\t}\n}\n", "n_tokens": 144, "primary_symbol": "TestExtractFailure", "primary_kind": "function", "primary_span": [28, 46], "def_symbols": ["TestExtractFailure"], "symbols": ["TestExtractFailure", "func", "testing", "testDir", "TempDir", "Test", "with", "missing", "zip", "file", "missingZipPath", "filepath", "Join", "missing_test", "extractedPath", "zip_extract", "err", "extract", "nil", "Fatal", "Expected", "Extract", "fail", "due", "tar", "missingTarPath"], "doc_head": "func TestExtractFailure(t *testing.T) {\n\ttestDir := t.TempDir()\n\t// Test with missing zip file\n\tmissingZipPath := filepath.Join(testDir, \"missing_test.zip\")\n\textractedPath := filepath.Join(testDir, \"zip_extract\")\n\tif err := extract(missingZipPath, extractedPath); err == nil {\n\t\tt.Fatal(\"Expected Extract to fail due to missing zip file\")\n\t}\n\t// Test with missing tar.gz file\n\tmissingTarPath := filepath.Join(testDir, \"missing_test.tar.gz\")\n\tif err := extract(missingTarPath, extractedPath); err == nil {\n\t\tt.Fatal(\"Expected Extract to fail due to missing tar.gz file\")\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/common/common-ws.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/common/common-ws.go", "rel_path": "src/common/common-ws.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 26, "text": "package common\n\ntype WebSocketAction = uint8\n\n// Not implemented yet\n// type AgentError = uint8\n\nconst (\n\t// Request system data from agent\n\tGetData WebSocketAction = iota\n\t// Check the fingerprint of the agent\n\tCheckFingerprint\n)\n\n// HubRequest defines the structure for requests sent from hub to agent.\ntype HubRequest[T any] struct {\n\tAction WebSocketAction `cbor:\"0,keyasint\"`\n\tData   T               `cbor:\"1,keyasint,omitempty,omitzero\"`\n\t// Error  AgentError      `cbor:\"error,omitempty,omitzero\"`\n}\n\ntype FingerprintRequest struct {\n\tSignature   []byte `cbor:\"0,keyasint\"`\n\tNeedSysInfo bool   `cbor:\"1,keyasint\"` // For universal token system creation\n}\n", "n_tokens": 168, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 26], "def_symbols": [], "symbols": ["package", "common", "type", "WebSocketAction", "uint8", "Not", "implemented", "yet", "AgentError", "const", "Request", "system", "data", "from", "agent", "GetData", "iota", "Check", "the", "fingerprint", "CheckFingerprint", "HubRequest", "defines", "structure", "for", "requests", "sent", "hub", "any", "struct", "Action", "cbor", "keyasint", "Data", "omitempty", "omitzero", "Error", "error", "FingerprintRequest", "Signature", "byte", "NeedSysInfo", "bool", "For", "universal", "token", "creation"], "doc_head": "package common\ntype WebSocketAction = uint8\n// Not implemented yet\n// type AgentError = uint8\nconst (\n\t// Request system data from agent\n\tGetData WebSocketAction = iota\n\t// Check the fingerprint of the agent\n\tCheckFingerprint\n)\n// HubRequest defines the structure for requests sent from hub to agent.\ntype HubRequest[T any] struct {\n\tAction WebSocketAction `cbor:\"0,keyasint\"`\n\tData   T               `cbor:\"1,keyasint,omitempty,omitzero\"`\n\t// Error  AgentError      `cbor:\"error,omitempty,omitzero\"`\n}\ntype FingerprintRequest struct {\n\tSignature   []byte `cbor:\"0,keyasint\"`\n\tNeedSysInfo bool   `cbor:\"1,keyasint\"` // For universal token system creation\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/common/common-ws.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/common/common-ws.go", "rel_path": "src/common/common-ws.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 27, "end_line": 33, "text": "type FingerprintResponse struct {\n\tFingerprint string `cbor:\"0,keyasint\"`\n\t// Optional system info for universal token system creation\n\tHostname string `cbor:\"1,keyasint,omitempty,omitzero\"`\n\tPort     string `cbor:\"2,keyasint,omitempty,omitzero\"`\n}\n", "n_tokens": 64, "primary_symbol": "", "primary_kind": "", "primary_span": [27, 33], "def_symbols": [], "symbols": ["type", "FingerprintResponse", "struct", "Fingerprint", "string", "cbor", "keyasint", "Optional", "system", "info", "for", "universal", "token", "creation", "Hostname", "omitempty", "omitzero", "Port"], "doc_head": "type FingerprintResponse struct {\n\tFingerprint string `cbor:\"0,keyasint\"`\n\t// Optional system info for universal token system creation\n\tHostname string `cbor:\"1,keyasint,omitempty,omitzero\"`\n\tPort     string `cbor:\"2,keyasint,omitempty,omitzero\"`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/common/common-ssh.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/common/common-ssh.go", "rel_path": "src/common/common-ssh.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 11, "text": "package common\n\nvar (\n\t// Allowed ssh key exchanges\n\tDefaultKeyExchanges = []string{\"curve25519-sha256\"}\n\t// Allowed ssh macs\n\tDefaultMACs = []string{\"hmac-sha2-256-etm@openssh.com\"}\n\t// Allowed ssh ciphers\n\tDefaultCiphers = []string{\"chacha20-poly1305@openssh.com\"}\n)\n", "n_tokens": 82, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 11], "def_symbols": [], "symbols": ["package", "common", "var", "Allowed", "ssh", "key", "exchanges", "DefaultKeyExchanges", "string", "curve25519", "sha256", "macs", "DefaultMACs", "hmac", "sha2", "etm", "openssh", "com", "ciphers", "DefaultCiphers", "chacha20", "poly1305"], "doc_head": "package common\nvar (\n\t// Allowed ssh key exchanges\n\tDefaultKeyExchanges = []string{\"curve25519-sha256\"}\n\t// Allowed ssh macs\n\tDefaultMACs = []string{\"hmac-sha2-256-etm@openssh.com\"}\n\t// Allowed ssh ciphers\n\tDefaultCiphers = []string{\"chacha20-poly1305@openssh.com\"}\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/users/users.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/users/users.go", "rel_path": "src/users/users.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 34, "text": "// Package users handles user-related custom functionality.\npackage users\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/henrygd/beszel/src/migrations\"\n\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n\ntype UserManager struct {\n\tapp core.App\n}\n\nfunc NewUserManager(app core.App) *UserManager {\n\treturn &UserManager{\n\t\tapp: app,\n\t}\n}\n\n// Initialize user role if not set\nfunc (um *UserManager) InitializeUserRole(e *core.RecordEvent) error {\n\tif e.Record.GetString(\"role\") == \"\" {\n\t\te.Record.Set(\"role\", \"user\")\n\t}\n\treturn e.Next()\n}\n\n// Initialize user settings with defaults if not set\nfunc (um *UserManager) InitializeUserSettings(e *core.RecordEvent) error {\n\trecord := e.Record", "n_tokens": 174, "primary_symbol": "NewUserManager", "primary_kind": "function", "primary_span": [18, 34], "def_symbols": ["NewUserManager", "InitializeUserRole", "InitializeUserSettings"], "symbols": ["NewUserManager", "InitializeUserRole", "InitializeUserSettings", "Package", "users", "handles", "user", "related", "custom", "functionality", "package", "import", "log", "net", "http", "github", "com", "henrygd", "beszel", "src", "migrations", "pocketbase", "dbx", "core", "type", "UserManager", "struct", "app", "App", "func", "return", "Initialize", "role", "not", "set", "RecordEvent", "error", "Record", "GetString", "Set", "Next", "settings", "with", "defaults", "record"], "doc_head": "// Package users handles user-related custom functionality.\npackage users\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"github.com/henrygd/beszel/src/migrations\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\ntype UserManager struct {\n\tapp core.App\n}\nfunc NewUserManager(app core.App) *UserManager {\n\treturn &UserManager{\n\t\tapp: app,\n\t}\n}\n// Initialize user role if not set\nfunc (um *UserManager) InitializeUserRole(e *core.RecordEvent) error {\n\tif e.Record.GetString(\"role\") == \"\" {\n\t\te.Record.Set(\"role\", \"user\")\n\t}\n\treturn e.Next()\n}\n// Initialize user settings with defaults if not set\nfunc (um *UserManager) InitializeUserSettings(e *core.RecordEvent) error {\n\trecord := e.Record"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/users/users.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/users/users.go", "rel_path": "src/users/users.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 35, "end_line": 58, "text": "\t// intialize settings with defaults (zero values can be ignored)\n\tsettings := struct {\n\t\tChartTime string   `json:\"chartTime\"`\n\t\tEmails    []string `json:\"emails\"`\n\t}{\n\t\tChartTime: \"1h\",\n\t}\n\trecord.UnmarshalJSONField(\"settings\", &settings)\n\t// get user email from auth record\n\tvar user struct {\n\t\tEmail string `db:\"email\"`\n\t}\n\terr := e.App.DB().NewQuery(\"SELECT email FROM users WHERE id = {:id}\").Bind(dbx.Params{\n\t\t\"id\": record.GetString(\"user\"),\n\t}).One(&user)\n\tif err != nil {\n\t\tlog.Println(\"failed to get user email\", \"err\", err)\n\t\treturn err\n\t}\n\tsettings.Emails = []string{user.Email}\n\trecord.Set(\"settings\", settings)\n\treturn e.Next()\n}\n", "n_tokens": 178, "primary_symbol": "", "primary_kind": "", "primary_span": [35, 58], "def_symbols": [], "symbols": ["intialize", "settings", "with", "defaults", "zero", "values", "can", "ignored", "struct", "ChartTime", "string", "json", "chartTime", "Emails", "emails", "record", "UnmarshalJSONField", "get", "user", "email", "from", "auth", "var", "Email", "err", "App", "NewQuery", "SELECT", "FROM", "users", "WHERE", "Bind", "dbx", "Params", "GetString", "One", "nil", "log", "Println", "failed", "return", "Set", "Next"], "doc_head": "\t// intialize settings with defaults (zero values can be ignored)\n\tsettings := struct {\n\t\tChartTime string   `json:\"chartTime\"`\n\t\tEmails    []string `json:\"emails\"`\n\t}{\n\t\tChartTime: \"1h\",\n\t}\n\trecord.UnmarshalJSONField(\"settings\", &settings)\n\t// get user email from auth record\n\tvar user struct {\n\t\tEmail string `db:\"email\"`\n\t}\n\terr := e.App.DB().NewQuery(\"SELECT email FROM users WHERE id = {:id}\").Bind(dbx.Params{\n\t\t\"id\": record.GetString(\"user\"),\n\t}).One(&user)\n\tif err != nil {\n\t\tlog.Println(\"failed to get user email\", \"err\", err)\n\t\treturn err\n\t}\n\tsettings.Emails = []string{user.Email}\n\trecord.Set(\"settings\", settings)\n\treturn e.Next()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/users/users.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/users/users.go", "rel_path": "src/users/users.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 59, "end_line": 71, "text": "// Custom API endpoint to create the first user.\n// Mimics previous default behavior in PocketBase < 0.23.0 allowing user to be created through the Beszel UI.\nfunc (um *UserManager) CreateFirstUser(e *core.RequestEvent) error {\n\t// check that there are no users\n\ttotalUsers, err := um.app.CountRecords(\"users\")\n\tif err != nil || totalUsers > 0 {\n\t\treturn e.JSON(http.StatusForbidden, map[string]string{\"err\": \"Forbidden\"})\n\t}\n\t// check that there is only one superuser and the email matches the email of the superuser we set up in initial-settings.go\n\tadminUsers, err := um.app.FindAllRecords(core.CollectionNameSuperusers)\n\tif err != nil || len(adminUsers) != 1 || adminUsers[0].GetString(\"email\") != migrations.TempAdminEmail {\n\t\treturn e.JSON(http.StatusForbidden, map[string]string{\"err\": \"Forbidden\"})\n\t}", "n_tokens": 197, "primary_symbol": "CreateFirstUser", "primary_kind": "function", "primary_span": [61, 71], "def_symbols": ["CreateFirstUser"], "symbols": ["CreateFirstUser", "Custom", "API", "endpoint", "create", "the", "first", "user", "Mimics", "previous", "default", "behavior", "PocketBase", "allowing", "created", "through", "Beszel", "func", "UserManager", "core", "RequestEvent", "error", "check", "that", "there", "are", "users", "totalUsers", "err", "app", "CountRecords", "nil", "return", "JSON", "http", "StatusForbidden", "map", "string", "Forbidden", "only", "one", "superuser", "and", "email", "matches", "set", "initial", "settings", "adminUsers", "FindAllRecords", "CollectionNameSuperusers", "len", "GetString", "migrations", "TempAdminEmail"], "doc_head": "// Custom API endpoint to create the first user.\n// Mimics previous default behavior in PocketBase < 0.23.0 allowing user to be created through the Beszel UI.\nfunc (um *UserManager) CreateFirstUser(e *core.RequestEvent) error {\n\t// check that there are no users\n\ttotalUsers, err := um.app.CountRecords(\"users\")\n\tif err != nil || totalUsers > 0 {\n\t\treturn e.JSON(http.StatusForbidden, map[string]string{\"err\": \"Forbidden\"})\n\t}\n\t// check that there is only one superuser and the email matches the email of the superuser we set up in initial-settings.go\n\tadminUsers, err := um.app.FindAllRecords(core.CollectionNameSuperusers)\n\tif err != nil || len(adminUsers) != 1 || adminUsers[0].GetString(\"email\") != migrations.TempAdminEmail {\n\t\treturn e.JSON(http.StatusForbidden, map[string]string{\"err\": \"Forbidden\"})\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/users/users.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/users/users.go", "rel_path": "src/users/users.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 72, "end_line": 107, "text": "\t// create first user using supplied email and password in request body\n\tdata := struct {\n\t\tEmail    string `json:\"email\"`\n\t\tPassword string `json:\"password\"`\n\t}{}\n\tif err := e.BindBody(&data); err != nil {\n\t\treturn e.JSON(http.StatusBadRequest, map[string]string{\"err\": err.Error()})\n\t}\n\tif data.Email == \"\" || data.Password == \"\" {\n\t\treturn e.JSON(http.StatusBadRequest, map[string]string{\"err\": \"Bad request\"})\n\t}\n\n\tcollection, _ := um.app.FindCollectionByNameOrId(\"users\")\n\tuser := core.NewRecord(collection)\n\tuser.SetEmail(data.Email)\n\tuser.SetPassword(data.Password)\n\tuser.Set(\"role\", \"admin\")\n\tuser.Set(\"verified\", true)\n\tif err := um.app.Save(user); err != nil {\n\t\treturn e.JSON(http.StatusInternalServerError, map[string]string{\"err\": err.Error()})\n\t}\n\t// create superuser using the email of the first user\n\tcollection, _ = um.app.FindCollectionByNameOrId(core.CollectionNameSuperusers)\n\tadminUser := core.NewRecord(collection)\n\tadminUser.SetEmail(data.Email)\n\tadminUser.SetPassword(data.Password)\n\tif err := um.app.Save(adminUser); err != nil {\n\t\treturn e.JSON(http.StatusInternalServerError, map[string]string{\"err\": err.Error()})\n\t}\n\t// delete the intial superuser\n\tif err := um.app.Delete(adminUsers[0]); err != nil {\n\t\treturn e.JSON(http.StatusInternalServerError, map[string]string{\"err\": err.Error()})\n\t}\n\treturn e.JSON(http.StatusOK, map[string]string{\"msg\": \"User created\"})\n}\n", "n_tokens": 323, "primary_symbol": "", "primary_kind": "", "primary_span": [72, 107], "def_symbols": [], "symbols": ["create", "first", "user", "using", "supplied", "email", "and", "password", "request", "body", "data", "struct", "Email", "string", "json", "Password", "err", "BindBody", "nil", "return", "JSON", "http", "StatusBadRequest", "map", "Error", "Bad", "collection", "app", "FindCollectionByNameOrId", "users", "core", "NewRecord", "SetEmail", "SetPassword", "Set", "role", "admin", "verified", "true", "Save", "StatusInternalServerError", "superuser", "the", "CollectionNameSuperusers", "adminUser", "delete", "intial", "Delete", "adminUsers", "StatusOK", "msg", "User", "created"], "doc_head": "\t// create first user using supplied email and password in request body\n\tdata := struct {\n\t\tEmail    string `json:\"email\"`\n\t\tPassword string `json:\"password\"`\n\t}{}\n\tif err := e.BindBody(&data); err != nil {\n\t\treturn e.JSON(http.StatusBadRequest, map[string]string{\"err\": err.Error()})\n\t}\n\tif data.Email == \"\" || data.Password == \"\" {\n\t\treturn e.JSON(http.StatusBadRequest, map[string]string{\"err\": \"Bad request\"})\n\t}\n\tcollection, _ := um.app.FindCollectionByNameOrId(\"users\")\n\tuser := core.NewRecord(collection)\n\tuser.SetEmail(data.Email)\n\tuser.SetPassword(data.Password)\n\tuser.Set(\"role\", \"admin\")\n\tuser.Set(\"verified\", true)\n\tif err := um.app.Save(user); err != nil {\n\t\treturn e.JSON(http.StatusInternalServerError, map[string]string{\"err\": err.Error()})\n\t}\n\t// create superuser using the email of the first user\n\tcollection, _ = um.app.FindCollectionByNameOrId(core.CollectionNameSuperusers)\n\tadminUser := core.NewRecord(collection)\n\tadminUser.SetEmail(data.Email)\n\tadminUser.SetPassword(data.Password)\n\tif err := um.app.Save(adminUser); err != nil {\n\t\treturn e.JSON(http.StatusInternalServerError, map[string]string{\"err\": err.Error()})\n\t}\n\t// delete the intial superuser\n\tif err := um.app.Delete"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/embed.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/embed.go", "rel_path": "src/site/embed.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 14, "text": "// Package site handles the Beszel frontend embedding.\npackage site\n\nimport (\n\t\"embed\"\n\t\"io/fs\"\n)\n\n//go:embed all:dist\nvar distDir embed.FS\n\n// DistDirFS contains the embedded dist directory files (without the \"dist\" prefix)\nvar DistDirFS, _ = fs.Sub(distDir, \"dist\")\n", "n_tokens": 72, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 14], "def_symbols": [], "symbols": ["Package", "site", "handles", "the", "Beszel", "frontend", "embedding", "package", "import", "embed", "all", "dist", "var", "distDir", "DistDirFS", "contains", "embedded", "directory", "files", "without", "prefix", "Sub"], "doc_head": "// Package site handles the Beszel frontend embedding.\npackage site\nimport (\n\t\"embed\"\n\t\"io/fs\"\n)\n//go:embed all:dist\nvar distDir embed.FS\n// DistDirFS contains the embedded dist directory files (without the \"dist\" prefix)\nvar DistDirFS, _ = fs.Sub(distDir, \"dist\")"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/lingui.config.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/lingui.config.ts", "rel_path": "src/site/lingui.config.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 2, "text": "import { defineConfig } from \"@lingui/cli\"\n", "n_tokens": 11, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 2], "def_symbols": [], "symbols": ["import", "defineConfig", "from", "lingui", "cli"], "doc_head": "import { defineConfig } from \"@lingui/cli\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/lingui.config.ts#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/lingui.config.ts", "rel_path": "src/site/lingui.config.ts", "ext": "ts", "language": "typescript", "chunk_number": 2, "start_line": 3, "end_line": 46, "text": "export default defineConfig({\n\tlocales: [\n\t\t\"en\",\n\t\t\"ar\",\n\t\t\"bg\",\n\t\t\"cs\",\n\t\t\"da\",\n\t\t\"de\",\n\t\t\"es\",\n\t\t\"fa\",\n\t\t\"fr\",\n\t\t\"hr\",\n\t\t\"hu\",\n\t\t\"it\",\n\t\t\"is\",\n\t\t\"ja\",\n\t\t\"ko\",\n\t\t\"nl\",\n\t\t\"no\",\n\t\t\"pl\",\n\t\t\"pt\",\n\t\t\"tr\",\n\t\t\"ru\",\n\t\t\"sl\",\n\t\t\"sv\",\n\t\t\"uk\",\n\t\t\"vi\",\n\t\t\"zh\",\n\t\t\"zh-CN\",\n\t\t\"zh-HK\",\n\t],\n\tsourceLocale: \"en\",\n\tcompileNamespace: \"ts\",\n\tformatOptions: {\n\t\tlineNumbers: false,\n\t},\n\tcatalogs: [\n\t\t{\n\t\t\tpath: \"<rootDir>/src/locales/{locale}/{locale}\",\n\t\t\tinclude: [\"src\"],\n\t\t},\n\t],\n})\n", "n_tokens": 213, "primary_symbol": "", "primary_kind": "", "primary_span": [3, 46], "def_symbols": [], "symbols": ["export", "default", "defineConfig", "locales", "sourceLocale", "compileNamespace", "formatOptions", "lineNumbers", "false", "catalogs", "path", "rootDir", "src", "locale", "include"], "doc_head": "export default defineConfig({\n\tlocales: [\n\t\t\"en\",\n\t\t\"ar\",\n\t\t\"bg\",\n\t\t\"cs\",\n\t\t\"da\",\n\t\t\"de\",\n\t\t\"es\",\n\t\t\"fa\",\n\t\t\"fr\",\n\t\t\"hr\",\n\t\t\"hu\",\n\t\t\"it\",\n\t\t\"is\",\n\t\t\"ja\",\n\t\t\"ko\",\n\t\t\"nl\",\n\t\t\"no\",\n\t\t\"pl\",\n\t\t\"pt\",\n\t\t\"tr\",\n\t\t\"ru\",\n\t\t\"sl\",\n\t\t\"sv\",\n\t\t\"uk\",\n\t\t\"vi\",\n\t\t\"zh\",\n\t\t\"zh-CN\",\n\t\t\"zh-HK\",\n\t],\n\tsourceLocale: \"en\",\n\tcompileNamespace: \"ts\",\n\tformatOptions: {\n\t\tlineNumbers: false,\n\t},\n\tcatalogs: [\n\t\t{\n\t\t\tpath: \"<rootDir>/src/locales/{locale}/{locale}\",\n\t\t\tinclude: [\"src\"],\n\t\t},\n\t],\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/vite.config.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/vite.config.ts", "rel_path": "src/site/vite.config.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 25, "text": "import { defineConfig } from \"vite\"\nimport path from \"path\"\nimport tailwindcss from \"@tailwindcss/vite\"\nimport react from \"@vitejs/plugin-react-swc\"\nimport { lingui } from \"@lingui/vite-plugin\"\n\nexport default defineConfig({\n\tbase: \"./\",\n\tplugins: [\n\t\treact({\n\t\t\tplugins: [[\"@lingui/swc-plugin\", {}]],\n\t\t}),\n\t\tlingui(),\n\t\ttailwindcss(),\n\t],\n\tesbuild: {\n\t\tlegalComments: \"external\",\n\t},\n\tresolve: {\n\t\talias: {\n\t\t\t\"@\": path.resolve(__dirname, \"./src\"),\n\t\t},\n\t},\n})\n", "n_tokens": 140, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 25], "def_symbols": [], "symbols": ["import", "defineConfig", "from", "vite", "path", "tailwindcss", "react", "vitejs", "plugin", "swc", "lingui", "export", "default", "base", "plugins", "esbuild", "legalComments", "external", "resolve", "alias", "__dirname", "src"], "doc_head": "import { defineConfig } from \"vite\"\nimport path from \"path\"\nimport tailwindcss from \"@tailwindcss/vite\"\nimport react from \"@vitejs/plugin-react-swc\"\nimport { lingui } from \"@lingui/vite-plugin\"\nexport default defineConfig({\n\tbase: \"./\",\n\tplugins: [\n\t\treact({\n\t\t\tplugins: [[\"@lingui/swc-plugin\", {}]],\n\t\t}),\n\t\tlingui(),\n\t\ttailwindcss(),\n\t],\n\tesbuild: {\n\t\tlegalComments: \"external\",\n\t},\n\tresolve: {\n\t\talias: {\n\t\t\t\"@\": path.resolve(__dirname, \"./src\"),\n\t\t},\n\t},\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx", "rel_path": "src/site/src/main.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 15, "text": "import \"./index.css\"\n// import { Suspense, lazy, useEffect, StrictMode } from \"react\"\nimport { Suspense, lazy, memo, useEffect } from \"react\"\nimport ReactDOM from \"react-dom/client\"\nimport { ThemeProvider } from \"./components/theme-provider.tsx\"\nimport { DirectionProvider } from \"@radix-ui/react-direction\"\nimport { $authenticated, $publicKey, $copyContent, $direction } from \"./lib/stores.ts\"\nimport { pb, updateUserSettings } from \"./lib/api.ts\"\nimport * as systemsManager from \"./lib/systemsManager.ts\"\nimport { useStore } from \"@nanostores/react\"\nimport { Toaster } from \"./components/ui/toaster.tsx\"\nimport { $router } from \"./components/router.tsx\"\nimport Navbar from \"./components/navbar.tsx\"\nimport { I18nProvider } from \"@lingui/react\"\nimport { i18n } from \"@lingui/core\"", "n_tokens": 192, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 15], "def_symbols": [], "symbols": ["import", "index", "css", "Suspense", "lazy", "useEffect", "StrictMode", "from", "react", "memo", "ReactDOM", "dom", "client", "ThemeProvider", "components", "theme", "provider", "tsx", "DirectionProvider", "radix", "direction", "authenticated", "publicKey", "copyContent", "lib", "stores", "updateUserSettings", "api", "systemsManager", "useStore", "nanostores", "Toaster", "toaster", "router", "Navbar", "navbar", "I18nProvider", "lingui", "i18n", "core"], "doc_head": "import \"./index.css\"\n// import { Suspense, lazy, useEffect, StrictMode } from \"react\"\nimport { Suspense, lazy, memo, useEffect } from \"react\"\nimport ReactDOM from \"react-dom/client\"\nimport { ThemeProvider } from \"./components/theme-provider.tsx\"\nimport { DirectionProvider } from \"@radix-ui/react-direction\"\nimport { $authenticated, $publicKey, $copyContent, $direction } from \"./lib/stores.ts\"\nimport { pb, updateUserSettings } from \"./lib/api.ts\"\nimport * as systemsManager from \"./lib/systemsManager.ts\"\nimport { useStore } from \"@nanostores/react\"\nimport { Toaster } from \"./components/ui/toaster.tsx\"\nimport { $router } from \"./components/router.tsx\"\nimport Navbar from \"./components/navbar.tsx\"\nimport { I18nProvider } from \"@lingui/react\"\nimport { i18n } from \"@lingui/core\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx", "rel_path": "src/site/src/main.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 16, "end_line": 32, "text": "import { getLocale, dynamicActivate } from \"./lib/i18n\"\nimport { alertManager } from \"./lib/alerts\"\nimport Settings from \"./components/routes/settings/layout.tsx\"\n\nconst LoginPage = lazy(() => import(\"@/components/login/login.tsx\"))\nconst Home = lazy(() => import(\"@/components/routes/home.tsx\"))\nconst SystemDetail = lazy(() => import(\"@/components/routes/system.tsx\"))\nconst CopyToClipboardDialog = lazy(() => import(\"@/components/copy-to-clipboard.tsx\"))\n\nconst App = memo(() => {\n\tconst page = useStore($router)\n\n\tuseEffect(() => {\n\t\t// change auth store on auth change\n\t\tpb.authStore.onChange(() => {\n\t\t\t$authenticated.set(pb.authStore.isValid)\n\t\t})", "n_tokens": 156, "primary_symbol": "", "primary_kind": "", "primary_span": [16, 32], "def_symbols": [], "symbols": ["import", "getLocale", "dynamicActivate", "from", "lib", "i18n", "alertManager", "alerts", "Settings", "components", "routes", "settings", "layout", "tsx", "const", "LoginPage", "lazy", "login", "Home", "home", "SystemDetail", "system", "CopyToClipboardDialog", "copy", "clipboard", "App", "memo", "page", "useStore", "router", "useEffect", "change", "auth", "store", "authStore", "onChange", "authenticated", "set", "isValid"], "doc_head": "import { getLocale, dynamicActivate } from \"./lib/i18n\"\nimport { alertManager } from \"./lib/alerts\"\nimport Settings from \"./components/routes/settings/layout.tsx\"\nconst LoginPage = lazy(() => import(\"@/components/login/login.tsx\"))\nconst Home = lazy(() => import(\"@/components/routes/home.tsx\"))\nconst SystemDetail = lazy(() => import(\"@/components/routes/system.tsx\"))\nconst CopyToClipboardDialog = lazy(() => import(\"@/components/copy-to-clipboard.tsx\"))\nconst App = memo(() => {\n\tconst page = useStore($router)\n\tuseEffect(() => {\n\t\t// change auth store on auth change\n\t\tpb.authStore.onChange(() => {\n\t\t\t$authenticated.set(pb.authStore.isValid)\n\t\t})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx", "rel_path": "src/site/src/main.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 33, "end_line": 58, "text": "\t\t// get version / public key\n\t\tpb.send(\"/api/beszel/getkey\", {}).then((data) => {\n\t\t\t$publicKey.set(data.key)\n\t\t})\n\t\t// get user settings\n\t\tupdateUserSettings()\n\t\t// need to get system list before alerts\n\t\tsystemsManager.init()\n\t\tsystemsManager\n\t\t\t// get current systems list\n\t\t\t.refresh()\n\t\t\t// subscribe to new system updates\n\t\t\t.then(systemsManager.subscribe)\n\t\t\t// get current alerts\n\t\t\t.then(alertManager.refresh)\n\t\t\t// subscribe to new alert updates\n\t\t\t.then(alertManager.subscribe)\n\t\treturn () => {\n\t\t\t// updateFavicon(\"favicon.svg\")\n\t\t\talertManager.unsubscribe()\n\t\t\tsystemsManager.unsubscribe()\n\t\t}\n\t}, [])\n\n\tif (!page) {\n\t\treturn <h1 className=\"text-3xl text-center my-14\">404</h1>", "n_tokens": 192, "primary_symbol": "", "primary_kind": "", "primary_span": [33, 58], "def_symbols": [], "symbols": ["get", "version", "public", "key", "send", "api", "beszel", "getkey", "then", "data", "publicKey", "set", "user", "settings", "updateUserSettings", "need", "system", "list", "before", "alerts", "systemsManager", "init", "current", "systems", "refresh", "subscribe", "new", "updates", "alertManager", "alert", "return", "updateFavicon", "favicon", "svg", "unsubscribe", "page", "className", "text", "center"], "doc_head": "\t\t// get version / public key\n\t\tpb.send(\"/api/beszel/getkey\", {}).then((data) => {\n\t\t\t$publicKey.set(data.key)\n\t\t})\n\t\t// get user settings\n\t\tupdateUserSettings()\n\t\t// need to get system list before alerts\n\t\tsystemsManager.init()\n\t\tsystemsManager\n\t\t\t// get current systems list\n\t\t\t.refresh()\n\t\t\t// subscribe to new system updates\n\t\t\t.then(systemsManager.subscribe)\n\t\t\t// get current alerts\n\t\t\t.then(alertManager.refresh)\n\t\t\t// subscribe to new alert updates\n\t\t\t.then(alertManager.subscribe)\n\t\treturn () => {\n\t\t\t// updateFavicon(\"favicon.svg\")\n\t\t\talertManager.unsubscribe()\n\t\t\tsystemsManager.unsubscribe()\n\t\t}\n\t}, [])\n\tif (!page) {\n\t\treturn <h1 className=\"text-3xl text-center my-14\">404</h1>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx", "rel_path": "src/site/src/main.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 59, "end_line": 72, "text": "\t} else if (page.route === \"home\") {\n\t\treturn <Home />\n\t} else if (page.route === \"system\") {\n\t\treturn <SystemDetail name={page.params.name} />\n\t} else if (page.route === \"settings\") {\n\t\treturn <Settings />\n\t}\n})\n\nconst Layout = () => {\n\tconst authenticated = useStore($authenticated)\n\tconst copyContent = useStore($copyContent)\n\tconst direction = useStore($direction)\n", "n_tokens": 93, "primary_symbol": "Layout", "primary_kind": "function", "primary_span": [59, 72], "def_symbols": ["Layout"], "symbols": ["Layout", "else", "page", "route", "home", "return", "Home", "system", "SystemDetail", "name", "params", "settings", "Settings", "const", "authenticated", "useStore", "copyContent", "direction"], "doc_head": "\t} else if (page.route === \"home\") {\n\t\treturn <Home />\n\t} else if (page.route === \"system\") {\n\t\treturn <SystemDetail name={page.params.name} />\n\t} else if (page.route === \"settings\") {\n\t\treturn <Settings />\n\t}\n})\nconst Layout = () => {\n\tconst authenticated = useStore($authenticated)\n\tconst copyContent = useStore($copyContent)\n\tconst direction = useStore($direction)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx", "rel_path": "src/site/src/main.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 73, "end_line": 102, "text": "\tuseEffect(() => {\n\t\tdocument.documentElement.dir = direction\n\t}, [direction])\n\n\treturn (\n\t\t<DirectionProvider dir={direction}>\n\t\t\t{!authenticated ? (\n\t\t\t\t<Suspense>\n\t\t\t\t\t<LoginPage />\n\t\t\t\t</Suspense>\n\t\t\t) : (\n\t\t\t\t<>\n\t\t\t\t\t<div className=\"container\">\n\t\t\t\t\t\t<Navbar />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"container relative\">\n\t\t\t\t\t\t<App />\n\t\t\t\t\t\t{copyContent && (\n\t\t\t\t\t\t\t<Suspense>\n\t\t\t\t\t\t\t\t<CopyToClipboardDialog content={copyContent} />\n\t\t\t\t\t\t\t</Suspense>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t</>\n\t\t\t)}\n\t\t</DirectionProvider>\n\t)\n}\n\nconst I18nApp = () => {", "n_tokens": 154, "primary_symbol": "I18nApp", "primary_kind": "function", "primary_span": [73, 102], "def_symbols": ["I18nApp"], "symbols": ["I18nApp", "useEffect", "document", "documentElement", "dir", "direction", "return", "DirectionProvider", "authenticated", "Suspense", "LoginPage", "div", "className", "container", "Navbar", "relative", "App", "copyContent", "CopyToClipboardDialog", "content", "const"], "doc_head": "\tuseEffect(() => {\n\t\tdocument.documentElement.dir = direction\n\t}, [direction])\n\treturn (\n\t\t<DirectionProvider dir={direction}>\n\t\t\t{!authenticated ? (\n\t\t\t\t<Suspense>\n\t\t\t\t\t<LoginPage />\n\t\t\t\t</Suspense>\n\t\t\t) : (\n\t\t\t\t<>\n\t\t\t\t\t<div className=\"container\">\n\t\t\t\t\t\t<Navbar />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"container relative\">\n\t\t\t\t\t\t<App />\n\t\t\t\t\t\t{copyContent && (\n\t\t\t\t\t\t\t<Suspense>\n\t\t\t\t\t\t\t\t<CopyToClipboardDialog content={copyContent} />\n\t\t\t\t\t\t\t</Suspense>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t</>\n\t\t\t)}\n\t\t</DirectionProvider>\n\t)\n}\nconst I18nApp = () => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/main.tsx", "rel_path": "src/site/src/main.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 103, "end_line": 124, "text": "\tuseEffect(() => {\n\t\tdynamicActivate(getLocale())\n\t}, [])\n\n\treturn (\n\t\t<I18nProvider i18n={i18n}>\n\t\t\t<ThemeProvider>\n\t\t\t\t<Layout />\n\t\t\t\t<Toaster />\n\t\t\t</ThemeProvider>\n\t\t</I18nProvider>\n\t)\n}\n\nReactDOM.createRoot(document.getElementById(\"app\")!).render(\n\t// strict mode in dev mounts / unmounts components twice\n\t// and breaks the clipboard dialog\n\t//<StrictMode>\n\t<I18nApp />\n\t//</StrictMode>\n)\n", "n_tokens": 115, "primary_symbol": "", "primary_kind": "", "primary_span": [103, 124], "def_symbols": [], "symbols": ["useEffect", "dynamicActivate", "getLocale", "return", "I18nProvider", "i18n", "ThemeProvider", "Layout", "Toaster", "ReactDOM", "createRoot", "document", "getElementById", "app", "render", "strict", "mode", "dev", "mounts", "unmounts", "components", "twice", "and", "breaks", "the", "clipboard", "dialog", "StrictMode", "I18nApp"], "doc_head": "\tuseEffect(() => {\n\t\tdynamicActivate(getLocale())\n\t}, [])\n\treturn (\n\t\t<I18nProvider i18n={i18n}>\n\t\t\t<ThemeProvider>\n\t\t\t\t<Layout />\n\t\t\t\t<Toaster />\n\t\t\t</ThemeProvider>\n\t\t</I18nProvider>\n\t)\n}\nReactDOM.createRoot(document.getElementById(\"app\")!).render(\n\t// strict mode in dev mounts / unmounts components twice\n\t// and breaks the clipboard dialog\n\t//<StrictMode>\n\t<I18nApp />\n\t//</StrictMode>\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts", "rel_path": "src/site/src/types.d.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 34, "text": "import { RecordModel } from \"pocketbase\"\nimport { Unit, Os, BatteryState } from \"./lib/enums\"\n\n// global window properties\ndeclare global {\n\tvar BESZEL: {\n\t\tBASE_PATH: string\n\t\tHUB_VERSION: string\n\t\tHUB_URL: string\n\t}\n}\n\nexport interface FingerprintRecord extends RecordModel {\n\tid: string\n\tsystem: string\n\tfingerprint: string\n\ttoken: string\n\texpand: {\n\t\tsystem: {\n\t\t\tname: string\n\t\t}\n\t}\n}\n\nexport interface SystemRecord extends RecordModel {\n\tname: string\n\thost: string\n\tstatus: \"up\" | \"down\" | \"paused\" | \"pending\"\n\tport: string\n\tinfo: SystemInfo\n\tv: string\n\tupdated: string\n}\n", "n_tokens": 162, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 34], "def_symbols": [], "symbols": ["import", "RecordModel", "from", "pocketbase", "Unit", "BatteryState", "lib", "enums", "global", "window", "properties", "declare", "var", "BESZEL", "BASE_PATH", "string", "HUB_VERSION", "HUB_URL", "export", "interface", "FingerprintRecord", "extends", "system", "fingerprint", "token", "expand", "name", "SystemRecord", "host", "status", "down", "paused", "pending", "port", "info", "SystemInfo", "updated"], "doc_head": "import { RecordModel } from \"pocketbase\"\nimport { Unit, Os, BatteryState } from \"./lib/enums\"\n// global window properties\ndeclare global {\n\tvar BESZEL: {\n\t\tBASE_PATH: string\n\t\tHUB_VERSION: string\n\t\tHUB_URL: string\n\t}\n}\nexport interface FingerprintRecord extends RecordModel {\n\tid: string\n\tsystem: string\n\tfingerprint: string\n\ttoken: string\n\texpand: {\n\t\tsystem: {\n\t\t\tname: string\n\t\t}\n\t}\n}\nexport interface SystemRecord extends RecordModel {\n\tname: string\n\thost: string\n\tstatus: \"up\" | \"down\" | \"paused\" | \"pending\"\n\tport: string\n\tinfo: SystemInfo\n\tv: string\n\tupdated: string\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts", "rel_path": "src/site/src/types.d.ts", "ext": "ts", "language": "typescript", "chunk_number": 2, "start_line": 35, "end_line": 79, "text": "export interface SystemInfo {\n\t/** hostname */\n\th: string\n\t/** kernel **/\n\tk?: string\n\t/** cpu percent */\n\tcpu: number\n\t/** cpu threads */\n\tt?: number\n\t/** cpu cores */\n\tc: number\n\t/** cpu model */\n\tm: string\n\t/** load average 1 minute */\n\tl1?: number\n\t/** load average 5 minutes */\n\tl5?: number\n\t/** load average 15 minutes */\n\tl15?: number\n\t/** load average */\n\tla?: [number, number, number]\n\t/** operating system */\n\to?: string\n\t/** uptime */\n\tu: number\n\t/** memory percent */\n\tmp: number\n\t/** disk percent */\n\tdp: number\n\t/** bandwidth (mb) */\n\tb: number\n\t/** bandwidth bytes */\n\tbb?: number\n\t/** agent version */\n\tv: string\n\t/** system is using podman */\n\tp?: boolean\n\t/** highest gpu utilization */\n\tg?: number\n\t/** dashboard display temperature */\n\tdt?: number\n\t/** operating system */\n\tos?: Os\n}\n", "n_tokens": 218, "primary_symbol": "", "primary_kind": "", "primary_span": [35, 79], "def_symbols": [], "symbols": ["export", "interface", "SystemInfo", "hostname", "string", "kernel", "cpu", "percent", "number", "threads", "cores", "model", "load", "average", "minute", "minutes", "l15", "operating", "system", "uptime", "memory", "disk", "bandwidth", "bytes", "agent", "version", "using", "podman", "boolean", "highest", "gpu", "utilization", "dashboard", "display", "temperature"], "doc_head": "export interface SystemInfo {\n\t/** hostname */\n\th: string\n\t/** kernel **/\n\tk?: string\n\t/** cpu percent */\n\tcpu: number\n\t/** cpu threads */\n\tt?: number\n\t/** cpu cores */\n\tc: number\n\t/** cpu model */\n\tm: string\n\t/** load average 1 minute */\n\tl1?: number\n\t/** load average 5 minutes */\n\tl5?: number\n\t/** load average 15 minutes */\n\tl15?: number\n\t/** load average */\n\tla?: [number, number, number]\n\t/** operating system */\n\to?: string\n\t/** uptime */\n\tu: number\n\t/** memory percent */\n\tmp: number\n\t/** disk percent */\n\tdp: number\n\t/** bandwidth (mb) */\n\tb: number\n\t/** bandwidth bytes */\n\tbb?: number\n\t/** agent version */\n\tv: string\n\t/** system is using podman */\n\tp?: boolean\n\t/** highest gpu utilization */\n\tg?: number\n\t/** dashboard display temperature */\n\tdt?: number\n\t/** operating system */\n\tos?: Os\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts", "rel_path": "src/site/src/types.d.ts", "ext": "ts", "language": "typescript", "chunk_number": 3, "start_line": 80, "end_line": 145, "text": "export interface SystemStats {\n\t/** cpu percent */\n\tcpu: number\n\t/** peak cpu */\n\tcpum?: number\n\t// TODO: remove these in future release in favor of la\n\t/** load average 1 minute */\n\tl1?: number\n\t/** load average 5 minutes */\n\tl5?: number\n\t/** load average 15 minutes */\n\tl15?: number\n\t/** load average */\n\tla?: [number, number, number]\n\t/** total memory (gb) */\n\tm: number\n\t/** memory used (gb) */\n\tmu: number\n\t/** memory percent */\n\tmp: number\n\t/** memory buffer + cache (gb) */\n\tmb: number\n\t/** max used memory (gb) */\n\tmm?: number\n\t/** zfs arc memory (gb) */\n\tmz?: number\n\t/** swap space (gb) */\n\ts: number\n\t/** swap used (gb) */\n\tsu: number\n\t/** disk size (gb) */\n\td: number\n\t/** disk used (gb) */\n\tdu: number\n\t/** disk percent */\n\tdp: number\n\t/** disk read (mb) */\n\tdr: number\n\t/** disk write (mb) */\n\tdw: number\n\t/** max disk read (mb) */\n\tdrm?: number\n\t/** max disk write (mb) */\n\tdwm?: number\n\t/** network sent (mb) */\n\tns: number\n\t/** network received (mb) */\n\tnr: number\n\t/** bandwidth bytes [sent, recv] */\n\tb?: [number, number]\n\t/** max network sent (mb) */\n\tnsm?: number\n\t/** max network received (mb) */\n\tnrm?: number\n\t/** max network sent (bytes) */\n\tbm?: [number, number]\n\t/** temperatures */\n\tt?: Record<string, number>\n\t/** extra filesystems */\n\tefs?: Record<string, ExtraFsStats>\n\t/** GPU data */\n\tg?: Record<string, GPUData>\n\t/** battery percent and state */\n\tbat?: [number, BatteryState]\n}\n", "n_tokens": 427, "primary_symbol": "", "primary_kind": "", "primary_span": [80, 145], "def_symbols": [], "symbols": ["export", "interface", "SystemStats", "cpu", "percent", "number", "peak", "cpum", "TODO", "remove", "these", "future", "release", "favor", "load", "average", "minute", "minutes", "l15", "total", "memory", "used", "buffer", "cache", "max", "zfs", "arc", "swap", "space", "disk", "size", "read", "write", "drm", "dwm", "network", "sent", "received", "bandwidth", "bytes", "recv", "nsm", "nrm", "temperatures", "Record", "string", "extra", "filesystems", "efs", "ExtraFsStats", "GPU", "data", "GPUData", "battery", "and", "state", "bat", "BatteryState"], "doc_head": "export interface SystemStats {\n\t/** cpu percent */\n\tcpu: number\n\t/** peak cpu */\n\tcpum?: number\n\t// TODO: remove these in future release in favor of la\n\t/** load average 1 minute */\n\tl1?: number\n\t/** load average 5 minutes */\n\tl5?: number\n\t/** load average 15 minutes */\n\tl15?: number\n\t/** load average */\n\tla?: [number, number, number]\n\t/** total memory (gb) */\n\tm: number\n\t/** memory used (gb) */\n\tmu: number\n\t/** memory percent */\n\tmp: number\n\t/** memory buffer + cache (gb) */\n\tmb: number\n\t/** max used memory (gb) */\n\tmm?: number\n\t/** zfs arc memory (gb) */\n\tmz?: number\n\t/** swap space (gb) */\n\ts: number\n\t/** swap used (gb) */\n\tsu: number\n\t/** disk size (gb) */\n\td: number\n\t/** disk used (gb) */\n\tdu: number\n\t/** disk percent */\n\tdp: number\n\t/** disk read (mb) */\n\tdr: number\n\t/** disk write (mb) */\n\tdw: number\n\t/** max disk read (mb) */\n\tdrm?: number\n\t/** max disk write (mb) */\n\tdwm?: number\n\t/** network sent (mb) */\n\tns: number\n\t/** network received (mb) */\n\tnr: number\n\t/** bandwidth bytes [sent, recv] */\n\tb?: [number, number]"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts", "rel_path": "src/site/src/types.d.ts", "ext": "ts", "language": "typescript", "chunk_number": 4, "start_line": 146, "end_line": 179, "text": "export interface GPUData {\n\t/** name */\n\tn: string\n\t/** memory used (mb) */\n\tmu?: number\n\t/** memory total (mb) */\n\tmt?: number\n\t/** usage (%) */\n\tu: number\n\t/** power (w) */\n\tp?: number\n}\n\nexport interface ExtraFsStats {\n\t/** disk size (gb) */\n\td: number\n\t/** disk used (gb) */\n\tdu: number\n\t/** total read (mb) */\n\tr: number\n\t/** total write (mb) */\n\tw: number\n\t/** max read (mb) */\n\trm: number\n\t/** max write (mb) */\n\twm: number\n}\n\nexport interface ContainerStatsRecord extends RecordModel {\n\tsystem: string\n\tstats: ContainerStats[]\n\tcreated: string | number\n}\n", "n_tokens": 167, "primary_symbol": "", "primary_kind": "", "primary_span": [146, 179], "def_symbols": [], "symbols": ["export", "interface", "GPUData", "name", "string", "memory", "used", "number", "total", "usage", "power", "ExtraFsStats", "disk", "size", "read", "write", "max", "ContainerStatsRecord", "extends", "RecordModel", "system", "stats", "ContainerStats", "created"], "doc_head": "export interface GPUData {\n\t/** name */\n\tn: string\n\t/** memory used (mb) */\n\tmu?: number\n\t/** memory total (mb) */\n\tmt?: number\n\t/** usage (%) */\n\tu: number\n\t/** power (w) */\n\tp?: number\n}\nexport interface ExtraFsStats {\n\t/** disk size (gb) */\n\td: number\n\t/** disk used (gb) */\n\tdu: number\n\t/** total read (mb) */\n\tr: number\n\t/** total write (mb) */\n\tw: number\n\t/** max read (mb) */\n\trm: number\n\t/** max write (mb) */\n\twm: number\n}\nexport interface ContainerStatsRecord extends RecordModel {\n\tsystem: string\n\tstats: ContainerStats[]\n\tcreated: string | number\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts", "rel_path": "src/site/src/types.d.ts", "ext": "ts", "language": "typescript", "chunk_number": 5, "start_line": 180, "end_line": 220, "text": "interface ContainerStats {\n\t/** name */\n\tn: string\n\t/** cpu percent */\n\tc: number\n\t/** memory used (gb) */\n\tm: number\n\t// network sent (mb)\n\tns: number\n\t// network received (mb)\n\tnr: number\n}\n\nexport interface SystemStatsRecord extends RecordModel {\n\tsystem: string\n\tstats: SystemStats\n\tcreated: string | number\n}\n\nexport interface AlertRecord extends RecordModel {\n\tid: string\n\tsystem: string\n\tname: string\n\ttriggered: boolean\n\tvalue: number\n\tmin: number\n\t// user: string\n}\n\nexport interface AlertsHistoryRecord extends RecordModel {\n\talert: string\n\tuser: string\n\tsystem: string\n\tname: string\n\tval: number\n\tcreated: string\n\tresolved?: string | null\n}\n\nexport type ChartTimes = \"1h\" | \"12h\" | \"24h\" | \"1w\" | \"30d\"\n", "n_tokens": 194, "primary_symbol": "", "primary_kind": "", "primary_span": [180, 220], "def_symbols": [], "symbols": ["interface", "ContainerStats", "name", "string", "cpu", "percent", "number", "memory", "used", "network", "sent", "received", "export", "SystemStatsRecord", "extends", "RecordModel", "system", "stats", "SystemStats", "created", "AlertRecord", "triggered", "boolean", "value", "min", "user", "AlertsHistoryRecord", "alert", "val", "resolved", "null", "type", "ChartTimes"], "doc_head": "interface ContainerStats {\n\t/** name */\n\tn: string\n\t/** cpu percent */\n\tc: number\n\t/** memory used (gb) */\n\tm: number\n\t// network sent (mb)\n\tns: number\n\t// network received (mb)\n\tnr: number\n}\nexport interface SystemStatsRecord extends RecordModel {\n\tsystem: string\n\tstats: SystemStats\n\tcreated: string | number\n}\nexport interface AlertRecord extends RecordModel {\n\tid: string\n\tsystem: string\n\tname: string\n\ttriggered: boolean\n\tvalue: number\n\tmin: number\n\t// user: string\n}\nexport interface AlertsHistoryRecord extends RecordModel {\n\talert: string\n\tuser: string\n\tsystem: string\n\tname: string\n\tval: number\n\tcreated: string\n\tresolved?: string | null\n}\nexport type ChartTimes = \"1h\" | \"12h\" | \"24h\" | \"1w\" | \"30d\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts", "rel_path": "src/site/src/types.d.ts", "ext": "ts", "language": "typescript", "chunk_number": 6, "start_line": 221, "end_line": 254, "text": "export interface ChartTimeData {\n\t[key: string]: {\n\t\ttype: \"1m\" | \"10m\" | \"20m\" | \"120m\" | \"480m\"\n\t\texpectedInterval: number\n\t\tlabel: () => string\n\t\tticks?: number\n\t\tformat: (timestamp: string) => string\n\t\tgetOffset: (endTime: Date) => Date\n\t}\n}\n\nexport interface UserSettings {\n\tchartTime: ChartTimes\n\temails?: string[]\n\twebhooks?: string[]\n\tunitTemp?: Unit\n\tunitNet?: Unit\n\tunitDisk?: Unit\n\tcolorWarn?: number\n\tcolorCrit?: number\n}\n\ntype ChartDataContainer = {\n\tcreated: number | null\n} & {\n\t[key: string]: key extends \"created\" ? never : ContainerStats\n}\n\nexport interface SemVer {\n\tmajor: number\n\tminor: number\n\tpatch: number\n}\n", "n_tokens": 186, "primary_symbol": "", "primary_kind": "", "primary_span": [221, 254], "def_symbols": [], "symbols": ["export", "interface", "ChartTimeData", "key", "string", "type", "expectedInterval", "number", "label", "ticks", "format", "timestamp", "getOffset", "endTime", "Date", "UserSettings", "chartTime", "ChartTimes", "emails", "webhooks", "unitTemp", "Unit", "unitNet", "unitDisk", "colorWarn", "colorCrit", "ChartDataContainer", "created", "null", "extends", "never", "ContainerStats", "SemVer", "major", "minor", "patch"], "doc_head": "export interface ChartTimeData {\n\t[key: string]: {\n\t\ttype: \"1m\" | \"10m\" | \"20m\" | \"120m\" | \"480m\"\n\t\texpectedInterval: number\n\t\tlabel: () => string\n\t\tticks?: number\n\t\tformat: (timestamp: string) => string\n\t\tgetOffset: (endTime: Date) => Date\n\t}\n}\nexport interface UserSettings {\n\tchartTime: ChartTimes\n\temails?: string[]\n\twebhooks?: string[]\n\tunitTemp?: Unit\n\tunitNet?: Unit\n\tunitDisk?: Unit\n\tcolorWarn?: number\n\tcolorCrit?: number\n}\ntype ChartDataContainer = {\n\tcreated: number | null\n} & {\n\t[key: string]: key extends \"created\" ? never : ContainerStats\n}\nexport interface SemVer {\n\tmajor: number\n\tminor: number\n\tpatch: number\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/types.d.ts", "rel_path": "src/site/src/types.d.ts", "ext": "ts", "language": "typescript", "chunk_number": 7, "start_line": 255, "end_line": 279, "text": "export interface ChartData {\n\tagentVersion: SemVer\n\tsystemStats: SystemStatsRecord[]\n\tcontainerData: ChartDataContainer[]\n\torientation: \"right\" | \"left\"\n\tticks: number[]\n\tdomain: number[]\n\tchartTime: ChartTimes\n}\n\ninterface AlertInfo {\n\tname: () => string\n\tunit: string\n\ticon: any\n\tdesc: () => string\n\tmax?: number\n\tmin?: number\n\tstep?: number\n\tstart?: number\n\t/** Single value description (when there's only one value, like status) */\n\tsingleDesc?: () => string\n}\n\nexport type AlertMap = Record<string, Map<string, AlertRecord>>\n", "n_tokens": 134, "primary_symbol": "", "primary_kind": "", "primary_span": [255, 279], "def_symbols": [], "symbols": ["export", "interface", "ChartData", "agentVersion", "SemVer", "systemStats", "SystemStatsRecord", "containerData", "ChartDataContainer", "orientation", "right", "left", "ticks", "number", "domain", "chartTime", "ChartTimes", "AlertInfo", "name", "string", "unit", "icon", "any", "desc", "max", "min", "step", "start", "Single", "value", "description", "when", "there", "only", "one", "like", "status", "singleDesc", "type", "AlertMap", "Record", "Map", "AlertRecord"], "doc_head": "export interface ChartData {\n\tagentVersion: SemVer\n\tsystemStats: SystemStatsRecord[]\n\tcontainerData: ChartDataContainer[]\n\torientation: \"right\" | \"left\"\n\tticks: number[]\n\tdomain: number[]\n\tchartTime: ChartTimes\n}\ninterface AlertInfo {\n\tname: () => string\n\tunit: string\n\ticon: any\n\tdesc: () => string\n\tmax?: number\n\tmin?: number\n\tstep?: number\n\tstart?: number\n\t/** Single value description (when there's only one value, like status) */\n\tsingleDesc?: () => string\n}\nexport type AlertMap = Record<string, Map<string, AlertRecord>>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/vite-env.d.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/vite-env.d.ts", "rel_path": "src/site/src/vite-env.d.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 2, "text": "/// <reference types=\"vite/client\" />\n", "n_tokens": 10, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 2], "def_symbols": [], "symbols": ["reference", "types", "vite", "client"], "doc_head": "/// <reference types=\"vite/client\" />"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/theme-provider.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/theme-provider.tsx", "rel_path": "src/site/src/components/theme-provider.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 35, "text": "import { createContext, useContext, useEffect, useState } from \"react\"\n\ntype Theme = \"dark\" | \"light\" | \"system\"\n\ntype ThemeProviderProps = {\n\tchildren: React.ReactNode\n\tdefaultTheme?: Theme\n\tstorageKey?: string\n}\n\ntype ThemeProviderState = {\n\ttheme: Theme\n\tsetTheme: (theme: Theme) => void\n}\n\nconst initialState: ThemeProviderState = {\n\ttheme: \"system\",\n\tsetTheme: () => null,\n}\n\nconst ThemeProviderContext = createContext<ThemeProviderState>(initialState)\n\nexport function ThemeProvider({\n\tchildren,\n\tdefaultTheme = \"system\",\n\tstorageKey = \"ui-theme\",\n\t...props\n}: ThemeProviderProps) {\n\tconst [theme, setTheme] = useState<Theme>(() => (localStorage.getItem(storageKey) as Theme) || defaultTheme)\n\n\tuseEffect(() => {\n\t\tconst root = window.document.documentElement\n\n\t\troot.classList.remove(\"light\", \"dark\")\n", "n_tokens": 189, "primary_symbol": "ThemeProvider", "primary_kind": "function", "primary_span": [23, 35], "def_symbols": ["ThemeProvider"], "symbols": ["ThemeProvider", "import", "createContext", "useContext", "useEffect", "useState", "from", "react", "type", "Theme", "dark", "light", "system", "ThemeProviderProps", "children", "React", "ReactNode", "defaultTheme", "storageKey", "string", "ThemeProviderState", "theme", "setTheme", "void", "const", "initialState", "null", "ThemeProviderContext", "export", "function", "props", "localStorage", "getItem", "root", "window", "document", "documentElement", "classList", "remove"], "doc_head": "import { createContext, useContext, useEffect, useState } from \"react\"\ntype Theme = \"dark\" | \"light\" | \"system\"\ntype ThemeProviderProps = {\n\tchildren: React.ReactNode\n\tdefaultTheme?: Theme\n\tstorageKey?: string\n}\ntype ThemeProviderState = {\n\ttheme: Theme\n\tsetTheme: (theme: Theme) => void\n}\nconst initialState: ThemeProviderState = {\n\ttheme: \"system\",\n\tsetTheme: () => null,\n}\nconst ThemeProviderContext = createContext<ThemeProviderState>(initialState)\nexport function ThemeProvider({\n\tchildren,\n\tdefaultTheme = \"system\",\n\tstorageKey = \"ui-theme\",\n\t...props\n}: ThemeProviderProps) {\n\tconst [theme, setTheme] = useState<Theme>(() => (localStorage.getItem(storageKey) as Theme) || defaultTheme)\n\tuseEffect(() => {\n\t\tconst root = window.document.documentElement\n\t\troot.classList.remove(\"light\", \"dark\")"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/theme-provider.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/theme-provider.tsx", "rel_path": "src/site/src/components/theme-provider.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 36, "end_line": 62, "text": "\t\tif (theme === \"system\") {\n\t\t\tconst systemTheme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\"\n\n\t\t\troot.classList.add(systemTheme)\n\t\t\treturn\n\t\t}\n\n\t\troot.classList.add(theme)\n\t}, [theme])\n\n\tconst value = {\n\t\ttheme,\n\t\tsetTheme: (theme: Theme) => {\n\t\t\tlocalStorage.setItem(storageKey, theme)\n\t\t\tsetTheme(theme)\n\t\t},\n\t}\n\n\treturn (\n\t\t<ThemeProviderContext.Provider {...props} value={value}>\n\t\t\t{children}\n\t\t</ThemeProviderContext.Provider>\n\t)\n}\n\nexport const useTheme = () => useContext(ThemeProviderContext)\n", "n_tokens": 139, "primary_symbol": "", "primary_kind": "", "primary_span": [36, 62], "def_symbols": [], "symbols": ["theme", "system", "const", "systemTheme", "window", "matchMedia", "prefers", "color", "scheme", "dark", "matches", "light", "root", "classList", "add", "return", "value", "setTheme", "Theme", "localStorage", "setItem", "storageKey", "ThemeProviderContext", "Provider", "props", "children", "export", "useTheme", "useContext"], "doc_head": "\t\tif (theme === \"system\") {\n\t\t\tconst systemTheme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\"\n\t\t\troot.classList.add(systemTheme)\n\t\t\treturn\n\t\t}\n\t\troot.classList.add(theme)\n\t}, [theme])\n\tconst value = {\n\t\ttheme,\n\t\tsetTheme: (theme: Theme) => {\n\t\t\tlocalStorage.setItem(storageKey, theme)\n\t\t\tsetTheme(theme)\n\t\t},\n\t}\n\treturn (\n\t\t<ThemeProviderContext.Provider {...props} value={value}>\n\t\t\t{children}\n\t\t</ThemeProviderContext.Provider>\n\t)\n}\nexport const useTheme = () => useContext(ThemeProviderContext)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/navbar.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/navbar.tsx", "rel_path": "src/site/src/components/navbar.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 28, "text": "import { Trans } from \"@lingui/react/macro\"\nimport { useState, lazy, Suspense } from \"react\"\nimport { Button, buttonVariants } from \"@/components/ui/button\"\nimport {\n\tDatabaseBackupIcon,\n\tLogOutIcon,\n\tLogsIcon,\n\tSearchIcon,\n\tServerIcon,\n\tSettingsIcon,\n\tUserIcon,\n\tUsersIcon,\n} from \"lucide-react\"\nimport { $router, basePath, Link, prependBasePath } from \"./router\"\nimport { LangToggle } from \"./lang-toggle\"\nimport { ModeToggle } from \"./mode-toggle\"\nimport { Logo } from \"./logo\"\nimport { cn, runOnce } from \"@/lib/utils\"\nimport { isReadOnlyUser, isAdmin, logOut, pb } from \"@/lib/api\"\nimport {\n\tDropdownMenu,\n\tDropdownMenuTrigger,\n\tDropdownMenuContent,\n\tDropdownMenuLabel,\n\tDropdownMenuSeparator,\n\tDropdownMenuGroup,\n\tDropdownMenuItem,\n} from \"@/components/ui/dropdown-menu\"", "n_tokens": 199, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 28], "def_symbols": [], "symbols": ["import", "Trans", "from", "lingui", "react", "macro", "useState", "lazy", "Suspense", "Button", "buttonVariants", "components", "button", "DatabaseBackupIcon", "LogOutIcon", "LogsIcon", "SearchIcon", "ServerIcon", "SettingsIcon", "UserIcon", "UsersIcon", "lucide", "router", "basePath", "Link", "prependBasePath", "LangToggle", "lang", "toggle", "ModeToggle", "mode", "Logo", "logo", "runOnce", "lib", "utils", "isReadOnlyUser", "isAdmin", "logOut", "api", "DropdownMenu", "DropdownMenuTrigger", "DropdownMenuContent", "DropdownMenuLabel", "DropdownMenuSeparator", "DropdownMenuGroup", "DropdownMenuItem", "dropdown", "menu"], "doc_head": "import { Trans } from \"@lingui/react/macro\"\nimport { useState, lazy, Suspense } from \"react\"\nimport { Button, buttonVariants } from \"@/components/ui/button\"\nimport {\n\tDatabaseBackupIcon,\n\tLogOutIcon,\n\tLogsIcon,\n\tSearchIcon,\n\tServerIcon,\n\tSettingsIcon,\n\tUserIcon,\n\tUsersIcon,\n} from \"lucide-react\"\nimport { $router, basePath, Link, prependBasePath } from \"./router\"\nimport { LangToggle } from \"./lang-toggle\"\nimport { ModeToggle } from \"./mode-toggle\"\nimport { Logo } from \"./logo\"\nimport { cn, runOnce } from \"@/lib/utils\"\nimport { isReadOnlyUser, isAdmin, logOut, pb } from \"@/lib/api\"\nimport {\n\tDropdownMenu,\n\tDropdownMenuTrigger,\n\tDropdownMenuContent,\n\tDropdownMenuLabel,\n\tDropdownMenuSeparator,\n\tDropdownMenuGroup,\n\tDropdownMenuItem,\n} from \"@/components/ui/dropdown-menu\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/navbar.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/navbar.tsx", "rel_path": "src/site/src/components/navbar.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 29, "end_line": 48, "text": "import { AddSystemButton } from \"./add-system\"\nimport { getPagePath } from \"@nanostores/router\"\n\nconst CommandPalette = lazy(() => import(\"./command-palette\"))\n\nconst isMac = navigator.platform.toUpperCase().indexOf(\"MAC\") >= 0\n\nexport default function Navbar() {\n\treturn (\n\t\t<div className=\"flex items-center h-14 md:h-16 bg-card px-4 pe-3 sm:px-6 border border-border/60 bt-0 rounded-md my-4\">\n\t\t\t<Link\n\t\t\t\thref={basePath}\n\t\t\t\taria-label=\"Home\"\n\t\t\t\tclassName=\"p-2 ps-0 me-3\"\n\t\t\t\tonMouseEnter={runOnce(() => import(\"@/components/routes/home\"))}\n\t\t\t>\n\t\t\t\t<Logo className=\"h-[1.1rem] md:h-5 fill-foreground\" />\n\t\t\t</Link>\n\t\t\t<SearchButton />\n", "n_tokens": 185, "primary_symbol": "", "primary_kind": "", "primary_span": [29, 48], "def_symbols": [], "symbols": ["import", "AddSystemButton", "from", "add", "system", "getPagePath", "nanostores", "router", "const", "CommandPalette", "lazy", "command", "palette", "isMac", "navigator", "platform", "toUpperCase", "indexOf", "MAC", "export", "default", "function", "Navbar", "return", "div", "className", "flex", "items", "center", "card", "border", "rounded", "Link", "href", "basePath", "aria", "label", "Home", "onMouseEnter", "runOnce", "components", "routes", "home", "Logo", "fill", "foreground", "SearchButton"], "doc_head": "import { AddSystemButton } from \"./add-system\"\nimport { getPagePath } from \"@nanostores/router\"\nconst CommandPalette = lazy(() => import(\"./command-palette\"))\nconst isMac = navigator.platform.toUpperCase().indexOf(\"MAC\") >= 0\nexport default function Navbar() {\n\treturn (\n\t\t<div className=\"flex items-center h-14 md:h-16 bg-card px-4 pe-3 sm:px-6 border border-border/60 bt-0 rounded-md my-4\">\n\t\t\t<Link\n\t\t\t\thref={basePath}\n\t\t\t\taria-label=\"Home\"\n\t\t\t\tclassName=\"p-2 ps-0 me-3\"\n\t\t\t\tonMouseEnter={runOnce(() => import(\"@/components/routes/home\"))}\n\t\t\t>\n\t\t\t\t<Logo className=\"h-[1.1rem] md:h-5 fill-foreground\" />\n\t\t\t</Link>\n\t\t\t<SearchButton />"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/navbar.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/navbar.tsx", "rel_path": "src/site/src/components/navbar.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 49, "end_line": 120, "text": "\t\t\t<div className=\"flex items-center ms-auto\" onMouseEnter={() => import(\"@/components/routes/settings/general\")}>\n\t\t\t\t<LangToggle />\n\t\t\t\t<ModeToggle />\n\t\t\t\t<Link\n\t\t\t\t\thref={getPagePath($router, \"settings\", { name: \"general\" })}\n\t\t\t\t\taria-label=\"Settings\"\n\t\t\t\t\tclassName={cn(\"\", buttonVariants({ variant: \"ghost\", size: \"icon\" }))}\n\t\t\t\t>\n\t\t\t\t\t<SettingsIcon className=\"h-[1.2rem] w-[1.2rem]\" />\n\t\t\t\t</Link>\n\t\t\t\t<DropdownMenu>\n\t\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t\t<button aria-label=\"User Actions\" className={cn(\"\", buttonVariants({ variant: \"ghost\", size: \"icon\" }))}>\n\t\t\t\t\t\t\t<UserIcon className=\"h-[1.2rem] w-[1.2rem]\" />\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t\t<DropdownMenuContent align={isReadOnlyUser() ? \"end\" : \"center\"} className=\"min-w-44\">\n\t\t\t\t\t\t<DropdownMenuLabel>{pb.authStore.record?.email}</DropdownMenuLabel>\n\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t<DropdownMenuGroup>\n\t\t\t\t\t\t\t{isAdmin() && (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<DropdownMenuItem asChild>\n\t\t\t\t\t\t\t\t\t\t<a href={prependBasePath(\"/_/\")} target=\"_blank\">\n\t\t\t\t\t\t\t\t\t\t\t<UsersIcon className=\"me-2.5 h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Users</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t\t\t\t<DropdownMenuItem asChild>\n\t\t\t\t\t\t\t\t\t\t<a href={prependBasePath(\"/_/#/collections?collection=systems\")} target=\"_blank\">\n\t\t\t\t\t\t\t\t\t\t\t<ServerIcon className=\"me-2.5 h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Systems</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t\t\t\t<DropdownMenuItem asChild>\n\t\t\t\t\t\t\t\t\t\t<a href={prependBasePath(\"/_/#/logs\")} target=\"_blank\">\n\t\t\t\t\t\t\t\t\t\t\t<LogsIcon className=\"me-2.5 h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Logs</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t\t\t\t<DropdownMenuItem asChild>\n\t\t\t\t\t\t\t\t\t\t<a href={prependBasePath(\"/_/#/settings/backups\")} target=\"_blank\">\n\t\t\t\t\t\t\t\t\t\t\t<DatabaseBackupIcon className=\"me-2.5 h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Backups</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</DropdownMenuGroup>\n\t\t\t\t\t\t<DropdownMenuItem onSelect={logOut}>\n\t\t\t\t\t\t\t<LogOutIcon className=\"me-2.5 h-4 w-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Log Out</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t</DropdownMenuContent>\n\t\t\t\t</DropdownMenu>\n\t\t\t\t<AddSystemButton className=\"ms-2\" />\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n", "n_tokens": 684, "primary_symbol": "", "primary_kind": "", "primary_span": [49, 120], "def_symbols": [], "symbols": ["div", "className", "flex", "items", "center", "auto", "onMouseEnter", "import", "components", "routes", "settings", "general", "LangToggle", "ModeToggle", "Link", "href", "getPagePath", "router", "name", "aria", "label", "Settings", "buttonVariants", "variant", "ghost", "size", "icon", "SettingsIcon", "DropdownMenu", "DropdownMenuTrigger", "asChild", "button", "User", "Actions", "UserIcon", "DropdownMenuContent", "align", "isReadOnlyUser", "end", "min", "DropdownMenuLabel", "authStore", "record", "email", "DropdownMenuSeparator", "DropdownMenuGroup", "isAdmin", "DropdownMenuItem", "prependBasePath", "target", "_blank", "UsersIcon", "span", "Trans", "Users", "collections", "collection", "systems", "ServerIcon", "Systems", "logs", "LogsIcon", "Logs", "backups", "DatabaseBackupIcon", "Backups", "onSelect", "logOut", "LogOutIcon", "Log", "Out", "AddSystemButton"], "doc_head": "\t\t\t<div className=\"flex items-center ms-auto\" onMouseEnter={() => import(\"@/components/routes/settings/general\")}>\n\t\t\t\t<LangToggle />\n\t\t\t\t<ModeToggle />\n\t\t\t\t<Link\n\t\t\t\t\thref={getPagePath($router, \"settings\", { name: \"general\" })}\n\t\t\t\t\taria-label=\"Settings\"\n\t\t\t\t\tclassName={cn(\"\", buttonVariants({ variant: \"ghost\", size: \"icon\" }))}\n\t\t\t\t>\n\t\t\t\t\t<SettingsIcon className=\"h-[1.2rem] w-[1.2rem]\" />\n\t\t\t\t</Link>\n\t\t\t\t<DropdownMenu>\n\t\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t\t<button aria-label=\"User Actions\" className={cn(\"\", buttonVariants({ variant: \"ghost\", size: \"icon\" }))}>\n\t\t\t\t\t\t\t<UserIcon className=\"h-[1.2rem] w-[1.2rem]\" />\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t\t<DropdownMenuContent align={isReadOnlyUser() ? \"end\" : \"center\"} className=\"min-w-44\">\n\t\t\t\t\t\t<DropdownMenuLabel>{pb.authStore.record?.email}</DropdownMenuLabel>\n\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t<DropdownMenuGroup>\n\t\t\t\t\t\t\t{isAdmin() && (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<DropdownMenuItem asChild>\n\t\t\t\t\t\t\t\t\t\t<a href={prependBasePath(\"/_/\")} target=\"_blank\">\n\t\t\t\t\t\t\t\t\t\t\t<UsersIcon className=\"me-2.5 h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Users</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t\t\t\t<"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/navbar.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/navbar.tsx", "rel_path": "src/site/src/components/navbar.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 121, "end_line": 134, "text": "function SearchButton() {\n\tconst [open, setOpen] = useState(false)\n\n\tconst Kbd = ({ children }: { children: React.ReactNode }) => (\n\t\t<kbd className=\"pointer-events-none inline-flex h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium text-muted-foreground opacity-100\">\n\t\t\t{children}\n\t\t</kbd>\n\t)\n\n\treturn (\n\t\t<>\n\t\t\t<Button\n\t\t\t\tvariant=\"outline\"\n\t\t\t\tclassName=\"hidden md:block text-sm text-muted-foreground px-4\"", "n_tokens": 121, "primary_symbol": "SearchButton", "primary_kind": "function", "primary_span": [121, 134], "def_symbols": ["SearchButton", "Kbd"], "symbols": ["SearchButton", "Kbd", "function", "const", "open", "setOpen", "useState", "false", "children", "React", "ReactNode", "kbd", "className", "pointer", "events", "none", "inline", "flex", "select", "items", "center", "gap", "rounded", "border", "muted", "font", "mono", "text", "medium", "foreground", "opacity", "return", "Button", "variant", "outline", "hidden", "block"], "doc_head": "function SearchButton() {\n\tconst [open, setOpen] = useState(false)\n\tconst Kbd = ({ children }: { children: React.ReactNode }) => (\n\t\t<kbd className=\"pointer-events-none inline-flex h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium text-muted-foreground opacity-100\">\n\t\t\t{children}\n\t\t</kbd>\n\t)\n\treturn (\n\t\t<>\n\t\t\t<Button\n\t\t\t\tvariant=\"outline\"\n\t\t\t\tclassName=\"hidden md:block text-sm text-muted-foreground px-4\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/navbar.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/navbar.tsx", "rel_path": "src/site/src/components/navbar.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 135, "end_line": 152, "text": "\t\t\t\tonClick={() => setOpen(true)}\n\t\t\t>\n\t\t\t\t<span className=\"flex items-center\">\n\t\t\t\t\t<SearchIcon className=\"me-1.5 h-4 w-4\" />\n\t\t\t\t\t<Trans>Search</Trans>\n\t\t\t\t\t<span className=\"flex items-center ms-3.5\">\n\t\t\t\t\t\t<Kbd>{isMac ? \"\" : \"Ctrl\"}</Kbd>\n\t\t\t\t\t\t<Kbd>K</Kbd>\n\t\t\t\t\t</span>\n\t\t\t\t</span>\n\t\t\t</Button>\n\t\t\t<Suspense>\n\t\t\t\t<CommandPalette open={open} setOpen={setOpen} />\n\t\t\t</Suspense>\n\t\t</>\n\t)\n}\n", "n_tokens": 141, "primary_symbol": "", "primary_kind": "", "primary_span": [135, 152], "def_symbols": [], "symbols": ["onClick", "setOpen", "true", "span", "className", "flex", "items", "center", "SearchIcon", "Trans", "Search", "Kbd", "isMac", "Ctrl", "Button", "Suspense", "CommandPalette", "open"], "doc_head": "\t\t\t\tonClick={() => setOpen(true)}\n\t\t\t>\n\t\t\t\t<span className=\"flex items-center\">\n\t\t\t\t\t<SearchIcon className=\"me-1.5 h-4 w-4\" />\n\t\t\t\t\t<Trans>Search</Trans>\n\t\t\t\t\t<span className=\"flex items-center ms-3.5\">\n\t\t\t\t\t\t<Kbd>{isMac ? \"\" : \"Ctrl\"}</Kbd>\n\t\t\t\t\t\t<Kbd>K</Kbd>\n\t\t\t\t\t</span>\n\t\t\t\t</span>\n\t\t\t</Button>\n\t\t\t<Suspense>\n\t\t\t\t<CommandPalette open={open} setOpen={setOpen} />\n\t\t\t</Suspense>\n\t\t</>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx", "rel_path": "src/site/src/components/alerts-history-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 18, "text": "import { ColumnDef } from \"@tanstack/react-table\"\nimport { AlertsHistoryRecord } from \"@/types\"\nimport { Button } from \"@/components/ui/button\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { formatShortDate, toFixedFloat, formatDuration, cn } from \"@/lib/utils\"\nimport { alertInfo } from \"@/lib/alerts\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\n\nexport const alertsHistoryColumns: ColumnDef<AlertsHistoryRecord>[] = [\n\t{\n\t\taccessorKey: \"system\",\n\t\tenableSorting: true,\n\t\theader: ({ column }) => (\n\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans>System</Trans>\n\t\t\t</Button>\n\t\t),", "n_tokens": 180, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 18], "def_symbols": [], "symbols": ["import", "ColumnDef", "from", "tanstack", "react", "table", "AlertsHistoryRecord", "types", "Button", "components", "button", "Badge", "badge", "formatShortDate", "toFixedFloat", "formatDuration", "lib", "utils", "alertInfo", "alerts", "Trans", "lingui", "macro", "core", "export", "const", "alertsHistoryColumns", "accessorKey", "system", "enableSorting", "true", "header", "column", "variant", "ghost", "onClick", "toggleSorting", "getIsSorted", "asc", "System"], "doc_head": "import { ColumnDef } from \"@tanstack/react-table\"\nimport { AlertsHistoryRecord } from \"@/types\"\nimport { Button } from \"@/components/ui/button\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { formatShortDate, toFixedFloat, formatDuration, cn } from \"@/lib/utils\"\nimport { alertInfo } from \"@/lib/alerts\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\nexport const alertsHistoryColumns: ColumnDef<AlertsHistoryRecord>[] = [\n\t{\n\t\taccessorKey: \"system\",\n\t\tenableSorting: true,\n\t\theader: ({ column }) => (\n\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans>System</Trans>\n\t\t\t</Button>\n\t\t),"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx", "rel_path": "src/site/src/components/alerts-history-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 19, "end_line": 39, "text": "\t\tcell: ({ row }) => (\n\t\t\t<div className=\"ps-2 max-w-60 truncate\">{row.original.expand?.system?.name || row.original.system}</div>\n\t\t),\n\t\tfilterFn: (row, _, filterValue) => {\n\t\t\tconst display = row.original.expand?.system?.name || row.original.system || \"\"\n\t\t\treturn display.toLowerCase().includes(filterValue.toLowerCase())\n\t\t},\n\t},\n\t{\n\t\t// accessorKey: \"name\",\n\t\tid: \"name\",\n\t\taccessorFn: (record) => {\n\t\t\tconst name = record.name\n\t\t\tconst info = alertInfo[name]\n\t\t\treturn info?.name().replace(\"cpu\", \"CPU\") || name\n\t\t},\n\t\theader: ({ column }) => (\n\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans>Name</Trans>\n\t\t\t</Button>\n\t\t),", "n_tokens": 193, "primary_symbol": "", "primary_kind": "", "primary_span": [19, 39], "def_symbols": [], "symbols": ["cell", "row", "div", "className", "max", "truncate", "original", "expand", "system", "name", "filterFn", "filterValue", "const", "display", "return", "toLowerCase", "includes", "accessorKey", "accessorFn", "record", "info", "alertInfo", "replace", "cpu", "CPU", "header", "column", "Button", "variant", "ghost", "onClick", "toggleSorting", "getIsSorted", "asc", "Trans", "Name"], "doc_head": "\t\tcell: ({ row }) => (\n\t\t\t<div className=\"ps-2 max-w-60 truncate\">{row.original.expand?.system?.name || row.original.system}</div>\n\t\t),\n\t\tfilterFn: (row, _, filterValue) => {\n\t\t\tconst display = row.original.expand?.system?.name || row.original.system || \"\"\n\t\t\treturn display.toLowerCase().includes(filterValue.toLowerCase())\n\t\t},\n\t},\n\t{\n\t\t// accessorKey: \"name\",\n\t\tid: \"name\",\n\t\taccessorFn: (record) => {\n\t\t\tconst name = record.name\n\t\t\tconst info = alertInfo[name]\n\t\t\treturn info?.name().replace(\"cpu\", \"CPU\") || name\n\t\t},\n\t\theader: ({ column }) => (\n\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans>Name</Trans>\n\t\t\t</Button>\n\t\t),"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx", "rel_path": "src/site/src/components/alerts-history-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 40, "end_line": 62, "text": "\t\tcell: ({ getValue, row }) => {\n\t\t\tlet name = getValue() as string\n\t\t\tconst info = alertInfo[row.original.name]\n\t\t\tconst Icon = info?.icon\n\n\t\t\treturn (\n\t\t\t\t<span className=\"flex items-center gap-2 ps-1 min-w-40\">\n\t\t\t\t\t{Icon && <Icon className=\"size-3.5\" />}\n\t\t\t\t\t{name}\n\t\t\t\t</span>\n\t\t\t)\n\t\t},\n\t},\n\t{\n\t\taccessorKey: \"value\",\n\t\tenableSorting: false,\n\t\theader: () => (\n\t\t\t<Button variant=\"ghost\">\n\t\t\t\t<Trans>Value</Trans>\n\t\t\t</Button>\n\t\t),\n\t\tcell({ row, getValue }) {\n\t\t\tconst name = row.original.name", "n_tokens": 155, "primary_symbol": "", "primary_kind": "", "primary_span": [40, 62], "def_symbols": [], "symbols": ["cell", "getValue", "row", "let", "name", "string", "const", "info", "alertInfo", "original", "Icon", "icon", "return", "span", "className", "flex", "items", "center", "gap", "min", "size", "accessorKey", "value", "enableSorting", "false", "header", "Button", "variant", "ghost", "Trans", "Value"], "doc_head": "\t\tcell: ({ getValue, row }) => {\n\t\t\tlet name = getValue() as string\n\t\t\tconst info = alertInfo[row.original.name]\n\t\t\tconst Icon = info?.icon\n\t\t\treturn (\n\t\t\t\t<span className=\"flex items-center gap-2 ps-1 min-w-40\">\n\t\t\t\t\t{Icon && <Icon className=\"size-3.5\" />}\n\t\t\t\t\t{name}\n\t\t\t\t</span>\n\t\t\t)\n\t\t},\n\t},\n\t{\n\t\taccessorKey: \"value\",\n\t\tenableSorting: false,\n\t\theader: () => (\n\t\t\t<Button variant=\"ghost\">\n\t\t\t\t<Trans>Value</Trans>\n\t\t\t</Button>\n\t\t),\n\t\tcell({ row, getValue }) {\n\t\t\tconst name = row.original.name"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx", "rel_path": "src/site/src/components/alerts-history-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 63, "end_line": 80, "text": "\t\t\tif (name === \"Status\") {\n\t\t\t\treturn <span className=\"ps-2\">{t`Down`}</span>\n\t\t\t}\n\t\t\tconst value = getValue() as number\n\t\t\tconst unit = alertInfo[name]?.unit\n\t\t\treturn (\n\t\t\t\t<span className=\"tabular-nums ps-2.5\">\n\t\t\t\t\t{toFixedFloat(value, value < 10 ? 2 : 1)}\n\t\t\t\t\t{unit}\n\t\t\t\t</span>\n\t\t\t)\n\t\t},\n\t},\n\t{\n\t\taccessorKey: \"state\",\n\t\tenableSorting: true,\n\t\tsortingFn: (rowA, rowB) => (rowA.original.resolved ? 1 : 0) - (rowB.original.resolved ? 1 : 0),\n\t\theader: ({ column }) => (", "n_tokens": 168, "primary_symbol": "", "primary_kind": "", "primary_span": [63, 80], "def_symbols": [], "symbols": ["name", "Status", "return", "span", "className", "Down", "const", "value", "getValue", "number", "unit", "alertInfo", "tabular", "nums", "toFixedFloat", "accessorKey", "state", "enableSorting", "true", "sortingFn", "rowA", "rowB", "original", "resolved", "header", "column"], "doc_head": "\t\t\tif (name === \"Status\") {\n\t\t\t\treturn <span className=\"ps-2\">{t`Down`}</span>\n\t\t\t}\n\t\t\tconst value = getValue() as number\n\t\t\tconst unit = alertInfo[name]?.unit\n\t\t\treturn (\n\t\t\t\t<span className=\"tabular-nums ps-2.5\">\n\t\t\t\t\t{toFixedFloat(value, value < 10 ? 2 : 1)}\n\t\t\t\t\t{unit}\n\t\t\t\t</span>\n\t\t\t)\n\t\t},\n\t},\n\t{\n\t\taccessorKey: \"state\",\n\t\tenableSorting: true,\n\t\tsortingFn: (rowA, rowB) => (rowA.original.resolved ? 1 : 0) - (rowB.original.resolved ? 1 : 0),\n\t\theader: ({ column }) => ("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx", "rel_path": "src/site/src/components/alerts-history-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 81, "end_line": 84, "text": "\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans comment=\"Context: alert state (active or resolved)\">State</Trans>\n\t\t\t</Button>\n\t\t),", "n_tokens": 50, "primary_symbol": "", "primary_kind": "", "primary_span": [81, 84], "def_symbols": [], "symbols": ["Button", "variant", "ghost", "onClick", "column", "toggleSorting", "getIsSorted", "asc", "Trans", "comment", "Context", "alert", "state", "active", "resolved", "State"], "doc_head": "\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans comment=\"Context: alert state (active or resolved)\">State</Trans>\n\t\t\t</Button>\n\t\t),"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx", "rel_path": "src/site/src/components/alerts-history-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 85, "end_line": 106, "text": "\t\tcell: ({ row }) => {\n\t\t\tconst resolved = row.original.resolved\n\t\t\treturn (\n\t\t\t\t<Badge\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"capitalize pointer-events-none\",\n\t\t\t\t\t\tresolved\n\t\t\t\t\t\t\t? \"bg-green-100 text-green-800 border-green-200 dark:opacity-80\"\n\t\t\t\t\t\t\t: \"bg-yellow-100 text-yellow-800 border-yellow-200\"\n\t\t\t\t\t)}\n\t\t\t\t>\n\t\t\t\t\t{/* {resolved ? <CircleCheckIcon className=\"size-3 me-0.5\" /> : <CircleAlertIcon className=\"size-3 me-0.5\" />} */}\n\t\t\t\t\t{resolved ? <Trans>Resolved</Trans> : <Trans>Active</Trans>}\n\t\t\t\t</Badge>\n\t\t\t)\n\t\t},\n\t},\n\t{\n\t\taccessorKey: \"created\",\n\t\taccessorFn: (record) => formatShortDate(record.created),\n\t\tenableSorting: true,\n\t\tinvertSorting: true,", "n_tokens": 201, "primary_symbol": "", "primary_kind": "", "primary_span": [85, 106], "def_symbols": [], "symbols": ["cell", "row", "const", "resolved", "original", "return", "Badge", "className", "capitalize", "pointer", "events", "none", "green", "text", "border", "dark", "opacity", "yellow", "CircleCheckIcon", "size", "CircleAlertIcon", "Trans", "Resolved", "Active", "accessorKey", "created", "accessorFn", "record", "formatShortDate", "enableSorting", "true", "invertSorting"], "doc_head": "\t\tcell: ({ row }) => {\n\t\t\tconst resolved = row.original.resolved\n\t\t\treturn (\n\t\t\t\t<Badge\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"capitalize pointer-events-none\",\n\t\t\t\t\t\tresolved\n\t\t\t\t\t\t\t? \"bg-green-100 text-green-800 border-green-200 dark:opacity-80\"\n\t\t\t\t\t\t\t: \"bg-yellow-100 text-yellow-800 border-yellow-200\"\n\t\t\t\t\t)}\n\t\t\t\t>\n\t\t\t\t\t{/* {resolved ? <CircleCheckIcon className=\"size-3 me-0.5\" /> : <CircleAlertIcon className=\"size-3 me-0.5\" />} */}\n\t\t\t\t\t{resolved ? <Trans>Resolved</Trans> : <Trans>Active</Trans>}\n\t\t\t\t</Badge>\n\t\t\t)\n\t\t},\n\t},\n\t{\n\t\taccessorKey: \"created\",\n\t\taccessorFn: (record) => formatShortDate(record.created),\n\t\tenableSorting: true,\n\t\tinvertSorting: true,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx", "rel_path": "src/site/src/components/alerts-history-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 107, "end_line": 128, "text": "\t\theader: ({ column }) => (\n\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans comment=\"Context: date created\">Created</Trans>\n\t\t\t</Button>\n\t\t),\n\t\tcell: ({ getValue, row }) => (\n\t\t\t<span className=\"ps-1 tabular-nums tracking-tight\" title={`${row.original.created} UTC`}>\n\t\t\t\t{getValue() as string}\n\t\t\t</span>\n\t\t),\n\t},\n\t{\n\t\taccessorKey: \"resolved\",\n\t\tenableSorting: true,\n\t\tinvertSorting: true,\n\t\theader: ({ column }) => (\n\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans>Resolved</Trans>\n\t\t\t</Button>\n\t\t),\n\t\tcell: ({ row, getValue }) => {\n\t\t\tconst resolved = getValue() as string | null", "n_tokens": 200, "primary_symbol": "", "primary_kind": "", "primary_span": [107, 128], "def_symbols": [], "symbols": ["header", "column", "Button", "variant", "ghost", "onClick", "toggleSorting", "getIsSorted", "asc", "Trans", "comment", "Context", "date", "created", "Created", "cell", "getValue", "row", "span", "className", "tabular", "nums", "tracking", "tight", "title", "original", "UTC", "string", "accessorKey", "resolved", "enableSorting", "true", "invertSorting", "Resolved", "const", "null"], "doc_head": "\t\theader: ({ column }) => (\n\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans comment=\"Context: date created\">Created</Trans>\n\t\t\t</Button>\n\t\t),\n\t\tcell: ({ getValue, row }) => (\n\t\t\t<span className=\"ps-1 tabular-nums tracking-tight\" title={`${row.original.created} UTC`}>\n\t\t\t\t{getValue() as string}\n\t\t\t</span>\n\t\t),\n\t},\n\t{\n\t\taccessorKey: \"resolved\",\n\t\tenableSorting: true,\n\t\tinvertSorting: true,\n\t\theader: ({ column }) => (\n\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans>Resolved</Trans>\n\t\t\t</Button>\n\t\t),\n\t\tcell: ({ row, getValue }) => {\n\t\t\tconst resolved = getValue() as string | null"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx", "rel_path": "src/site/src/components/alerts-history-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 129, "end_line": 142, "text": "\t\t\tif (!resolved) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\treturn (\n\t\t\t\t<span className=\"ps-1 tabular-nums tracking-tight\" title={`${row.original.resolved} UTC`}>\n\t\t\t\t\t{formatShortDate(resolved)}\n\t\t\t\t</span>\n\t\t\t)\n\t\t},\n\t},\n\t{\n\t\taccessorKey: \"duration\",\n\t\tinvertSorting: true,\n\t\tenableSorting: true,", "n_tokens": 89, "primary_symbol": "", "primary_kind": "", "primary_span": [129, 142], "def_symbols": [], "symbols": ["resolved", "return", "null", "span", "className", "tabular", "nums", "tracking", "tight", "title", "row", "original", "UTC", "formatShortDate", "accessorKey", "duration", "invertSorting", "true", "enableSorting"], "doc_head": "\t\t\tif (!resolved) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\treturn (\n\t\t\t\t<span className=\"ps-1 tabular-nums tracking-tight\" title={`${row.original.resolved} UTC`}>\n\t\t\t\t\t{formatShortDate(resolved)}\n\t\t\t\t</span>\n\t\t\t)\n\t\t},\n\t},\n\t{\n\t\taccessorKey: \"duration\",\n\t\tinvertSorting: true,\n\t\tenableSorting: true,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx", "rel_path": "src/site/src/components/alerts-history-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 143, "end_line": 154, "text": "\t\tsortingFn: (rowA, rowB) => {\n\t\t\tconst aCreated = new Date(rowA.original.created)\n\t\t\tconst bCreated = new Date(rowB.original.created)\n\t\t\tconst aResolved = rowA.original.resolved ? new Date(rowA.original.resolved) : null\n\t\t\tconst bResolved = rowB.original.resolved ? new Date(rowB.original.resolved) : null\n\t\t\tconst aDuration = aResolved ? aResolved.getTime() - aCreated.getTime() : null\n\t\t\tconst bDuration = bResolved ? bResolved.getTime() - bCreated.getTime() : null\n\t\t\tif (!aDuration && bDuration) return -1\n\t\t\tif (aDuration && !bDuration) return 1\n\t\t\treturn (aDuration || 0) - (bDuration || 0)\n\t\t},\n\t\theader: ({ column }) => (", "n_tokens": 177, "primary_symbol": "", "primary_kind": "", "primary_span": [143, 154], "def_symbols": [], "symbols": ["sortingFn", "rowA", "rowB", "const", "aCreated", "new", "Date", "original", "created", "bCreated", "aResolved", "resolved", "null", "bResolved", "aDuration", "getTime", "bDuration", "return", "header", "column"], "doc_head": "\t\tsortingFn: (rowA, rowB) => {\n\t\t\tconst aCreated = new Date(rowA.original.created)\n\t\t\tconst bCreated = new Date(rowB.original.created)\n\t\t\tconst aResolved = rowA.original.resolved ? new Date(rowA.original.resolved) : null\n\t\t\tconst bResolved = rowB.original.resolved ? new Date(rowB.original.resolved) : null\n\t\t\tconst aDuration = aResolved ? aResolved.getTime() - aCreated.getTime() : null\n\t\t\tconst bDuration = bResolved ? bResolved.getTime() - bCreated.getTime() : null\n\t\t\tif (!aDuration && bDuration) return -1\n\t\t\tif (aDuration && !bDuration) return 1\n\t\t\treturn (aDuration || 0) - (bDuration || 0)\n\t\t},\n\t\theader: ({ column }) => ("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts-history-columns.tsx", "rel_path": "src/site/src/components/alerts-history-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 155, "end_line": 168, "text": "\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans>Duration</Trans>\n\t\t\t</Button>\n\t\t),\n\t\tcell: ({ row }) => {\n\t\t\tconst duration = formatDuration(row.original.created, row.original.resolved)\n\t\t\tif (!duration) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\treturn <span className=\"ps-2\">{duration}</span>\n\t\t},\n\t},\n]\n", "n_tokens": 96, "primary_symbol": "", "primary_kind": "", "primary_span": [155, 168], "def_symbols": [], "symbols": ["Button", "variant", "ghost", "onClick", "column", "toggleSorting", "getIsSorted", "asc", "Trans", "Duration", "cell", "row", "const", "duration", "formatDuration", "original", "created", "resolved", "return", "null", "span", "className"], "doc_head": "\t\t\t<Button variant=\"ghost\" onClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}>\n\t\t\t\t<Trans>Duration</Trans>\n\t\t\t</Button>\n\t\t),\n\t\tcell: ({ row }) => {\n\t\t\tconst duration = formatDuration(row.original.created, row.original.resolved)\n\t\t\tif (!duration) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\treturn <span className=\"ps-2\">{duration}</span>\n\t\t},\n\t},\n]"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx", "rel_path": "src/site/src/components/command-palette.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 33, "text": "import {\n\tAlertOctagonIcon,\n\tBookIcon,\n\tDatabaseBackupIcon,\n\tFingerprintIcon,\n\tLayoutDashboard,\n\tLogsIcon,\n\tMailIcon,\n\tServer,\n\tSettingsIcon,\n\tUsersIcon,\n} from \"lucide-react\"\n\nimport {\n\tCommandDialog,\n\tCommandEmpty,\n\tCommandGroup,\n\tCommandInput,\n\tCommandItem,\n\tCommandList,\n\tCommandSeparator,\n\tCommandShortcut,\n} from \"@/components/ui/command\"\nimport { memo, useEffect, useMemo } from \"react\"\nimport { $systems } from \"@/lib/stores\"\nimport { getHostDisplayValue, listen } from \"@/lib/utils\"\nimport { $router, basePath, navigate, prependBasePath } from \"./router\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\nimport { getPagePath } from \"@nanostores/router\"\nimport { DialogDescription } from \"@radix-ui/react-dialog\"\nimport { isAdmin } from \"@/lib/api\"\n", "n_tokens": 196, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 33], "def_symbols": [], "symbols": ["import", "AlertOctagonIcon", "BookIcon", "DatabaseBackupIcon", "FingerprintIcon", "LayoutDashboard", "LogsIcon", "MailIcon", "Server", "SettingsIcon", "UsersIcon", "from", "lucide", "react", "CommandDialog", "CommandEmpty", "CommandGroup", "CommandInput", "CommandItem", "CommandList", "CommandSeparator", "CommandShortcut", "components", "command", "memo", "useEffect", "useMemo", "systems", "lib", "stores", "getHostDisplayValue", "listen", "utils", "router", "basePath", "navigate", "prependBasePath", "Trans", "lingui", "macro", "core", "getPagePath", "nanostores", "DialogDescription", "radix", "dialog", "isAdmin", "api"], "doc_head": "import {\n\tAlertOctagonIcon,\n\tBookIcon,\n\tDatabaseBackupIcon,\n\tFingerprintIcon,\n\tLayoutDashboard,\n\tLogsIcon,\n\tMailIcon,\n\tServer,\n\tSettingsIcon,\n\tUsersIcon,\n} from \"lucide-react\"\nimport {\n\tCommandDialog,\n\tCommandEmpty,\n\tCommandGroup,\n\tCommandInput,\n\tCommandItem,\n\tCommandList,\n\tCommandSeparator,\n\tCommandShortcut,\n} from \"@/components/ui/command\"\nimport { memo, useEffect, useMemo } from \"react\"\nimport { $systems } from \"@/lib/stores\"\nimport { getHostDisplayValue, listen } from \"@/lib/utils\"\nimport { $router, basePath, navigate, prependBasePath } from \"./router\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\nimport { getPagePath } from \"@nanostores/router\"\nimport { DialogDescription } from \"@radix-ui/react-dialog\"\nimport { isAdmin } from \"@/lib/api\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx", "rel_path": "src/site/src/components/command-palette.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 34, "end_line": 44, "text": "export default memo(function CommandPalette({ open, setOpen }: { open: boolean; setOpen: (open: boolean) => void }) {\n\tuseEffect(() => {\n\t\tconst down = (e: KeyboardEvent) => {\n\t\t\tif (e.key === \"k\" && (e.metaKey || e.ctrlKey)) {\n\t\t\t\te.preventDefault()\n\t\t\t\tsetOpen(!open)\n\t\t\t}\n\t\t}\n\t\treturn listen(document, \"keydown\", down)\n\t}, [open, setOpen])\n", "n_tokens": 97, "primary_symbol": "down", "primary_kind": "function", "primary_span": [34, 44], "def_symbols": ["down"], "symbols": ["down", "export", "default", "memo", "function", "CommandPalette", "open", "setOpen", "boolean", "void", "useEffect", "const", "KeyboardEvent", "key", "metaKey", "ctrlKey", "preventDefault", "return", "listen", "document", "keydown"], "doc_head": "export default memo(function CommandPalette({ open, setOpen }: { open: boolean; setOpen: (open: boolean) => void }) {\n\tuseEffect(() => {\n\t\tconst down = (e: KeyboardEvent) => {\n\t\t\tif (e.key === \"k\" && (e.metaKey || e.ctrlKey)) {\n\t\t\t\te.preventDefault()\n\t\t\t\tsetOpen(!open)\n\t\t\t}\n\t\t}\n\t\treturn listen(document, \"keydown\", down)\n\t}, [open, setOpen])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx", "rel_path": "src/site/src/components/command-palette.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 45, "end_line": 67, "text": "\treturn useMemo(() => {\n\t\tconst systems = $systems.get()\n\t\tconst SettingsShortcut = (\n\t\t\t<CommandShortcut>\n\t\t\t\t<Trans>Settings</Trans>\n\t\t\t</CommandShortcut>\n\t\t)\n\t\tconst AdminShortcut = (\n\t\t\t<CommandShortcut>\n\t\t\t\t<Trans>Admin</Trans>\n\t\t\t</CommandShortcut>\n\t\t)\n\t\treturn (\n\t\t\t<CommandDialog open={open} onOpenChange={setOpen}>\n\t\t\t\t<DialogDescription className=\"sr-only\">Command palette</DialogDescription>\n\t\t\t\t<CommandInput placeholder={t`Search for systems or settings...`} />\n\t\t\t\t<CommandList>\n\t\t\t\t\t{systems.length > 0 && (\n\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t\t{systems.map((system) => (\n\t\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\t\tkey={system.id}", "n_tokens": 172, "primary_symbol": "SettingsShortcut", "primary_kind": "function", "primary_span": [45, 67], "def_symbols": ["SettingsShortcut", "AdminShortcut"], "symbols": ["SettingsShortcut", "AdminShortcut", "return", "useMemo", "const", "systems", "get", "CommandShortcut", "Trans", "Settings", "Admin", "CommandDialog", "open", "onOpenChange", "setOpen", "DialogDescription", "className", "only", "Command", "palette", "CommandInput", "placeholder", "Search", "for", "settings", "CommandList", "length", "CommandGroup", "map", "system", "CommandItem", "key"], "doc_head": "\treturn useMemo(() => {\n\t\tconst systems = $systems.get()\n\t\tconst SettingsShortcut = (\n\t\t\t<CommandShortcut>\n\t\t\t\t<Trans>Settings</Trans>\n\t\t\t</CommandShortcut>\n\t\t)\n\t\tconst AdminShortcut = (\n\t\t\t<CommandShortcut>\n\t\t\t\t<Trans>Admin</Trans>\n\t\t\t</CommandShortcut>\n\t\t)\n\t\treturn (\n\t\t\t<CommandDialog open={open} onOpenChange={setOpen}>\n\t\t\t\t<DialogDescription className=\"sr-only\">Command palette</DialogDescription>\n\t\t\t\t<CommandInput placeholder={t`Search for systems or settings...`} />\n\t\t\t\t<CommandList>\n\t\t\t\t\t{systems.length > 0 && (\n\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t\t{systems.map((system) => (\n\t\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\t\tkey={system.id}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx", "rel_path": "src/site/src/components/command-palette.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 68, "end_line": 84, "text": "\t\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\t\tnavigate(getPagePath($router, \"system\", { name: system.name }))\n\t\t\t\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<Server className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t\t<span className=\"max-w-60 truncate\">{system.name}</span>\n\t\t\t\t\t\t\t\t\t\t<CommandShortcut>{getHostDisplayValue(system)}</CommandShortcut>\n\t\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t\t<CommandSeparator className=\"mb-1.5\" />\n\t\t\t\t\t\t</>\n\t\t\t\t\t)}\n\t\t\t\t\t<CommandGroup heading={t`Pages / Settings`}>\n\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\tkeywords={[\"home\"]}", "n_tokens": 143, "primary_symbol": "", "primary_kind": "", "primary_span": [68, 84], "def_symbols": [], "symbols": ["onSelect", "navigate", "getPagePath", "router", "system", "name", "setOpen", "false", "Server", "className", "size", "span", "max", "truncate", "CommandShortcut", "getHostDisplayValue", "CommandItem", "CommandGroup", "CommandSeparator", "heading", "Pages", "Settings", "keywords", "home"], "doc_head": "\t\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\t\tnavigate(getPagePath($router, \"system\", { name: system.name }))\n\t\t\t\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<Server className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t\t<span className=\"max-w-60 truncate\">{system.name}</span>\n\t\t\t\t\t\t\t\t\t\t<CommandShortcut>{getHostDisplayValue(system)}</CommandShortcut>\n\t\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t\t<CommandSeparator className=\"mb-1.5\" />\n\t\t\t\t\t\t</>\n\t\t\t\t\t)}\n\t\t\t\t\t<CommandGroup heading={t`Pages / Settings`}>\n\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\tkeywords={[\"home\"]}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx", "rel_path": "src/site/src/components/command-palette.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 85, "end_line": 111, "text": "\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\tnavigate(basePath)\n\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<LayoutDashboard className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Dashboard</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<CommandShortcut>\n\t\t\t\t\t\t\t\t<Trans>Page</Trans>\n\t\t\t\t\t\t\t</CommandShortcut>\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\tnavigate(getPagePath($router, \"settings\", { name: \"general\" }))\n\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<SettingsIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Settings</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t{SettingsShortcut}\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\tkeywords={[\"alerts\"]}", "n_tokens": 183, "primary_symbol": "", "primary_kind": "", "primary_span": [85, 111], "def_symbols": [], "symbols": ["onSelect", "navigate", "basePath", "setOpen", "false", "LayoutDashboard", "className", "size", "span", "Trans", "Dashboard", "CommandShortcut", "Page", "CommandItem", "getPagePath", "router", "settings", "name", "general", "SettingsIcon", "Settings", "SettingsShortcut", "keywords", "alerts"], "doc_head": "\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\tnavigate(basePath)\n\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<LayoutDashboard className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Dashboard</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<CommandShortcut>\n\t\t\t\t\t\t\t\t<Trans>Page</Trans>\n\t\t\t\t\t\t\t</CommandShortcut>\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\tnavigate(getPagePath($router, \"settings\", { name: \"general\" }))\n\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<SettingsIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Settings</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t{SettingsShortcut}\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\tkeywords={[\"alerts\"]}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx", "rel_path": "src/site/src/components/command-palette.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 112, "end_line": 136, "text": "\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\tnavigate(getPagePath($router, \"settings\", { name: \"notifications\" }))\n\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<MailIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Notifications</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t{SettingsShortcut}\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\tkeywords={[t`Universal token`]}\n\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\tnavigate(getPagePath($router, \"settings\", { name: \"tokens\" }))\n\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<FingerprintIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Tokens & Fingerprints</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t{SettingsShortcut}\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t<CommandItem", "n_tokens": 186, "primary_symbol": "", "primary_kind": "", "primary_span": [112, 136], "def_symbols": [], "symbols": ["onSelect", "navigate", "getPagePath", "router", "settings", "name", "notifications", "setOpen", "false", "MailIcon", "className", "size", "span", "Trans", "Notifications", "SettingsShortcut", "CommandItem", "keywords", "Universal", "token", "tokens", "FingerprintIcon", "Tokens", "Fingerprints"], "doc_head": "\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\tnavigate(getPagePath($router, \"settings\", { name: \"notifications\" }))\n\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<MailIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Notifications</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t{SettingsShortcut}\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\tkeywords={[t`Universal token`]}\n\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\tnavigate(getPagePath($router, \"settings\", { name: \"tokens\" }))\n\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<FingerprintIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Tokens & Fingerprints</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t{SettingsShortcut}\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t<CommandItem"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx", "rel_path": "src/site/src/components/command-palette.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 137, "end_line": 149, "text": "\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\tnavigate(getPagePath($router, \"settings\", { name: \"alert-history\" }))\n\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<AlertOctagonIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Alert History</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t{SettingsShortcut}\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\tkeywords={[\"help\", \"oauth\", \"oidc\"]}", "n_tokens": 105, "primary_symbol": "", "primary_kind": "", "primary_span": [137, 149], "def_symbols": [], "symbols": ["onSelect", "navigate", "getPagePath", "router", "settings", "name", "alert", "history", "setOpen", "false", "AlertOctagonIcon", "className", "size", "span", "Trans", "Alert", "History", "SettingsShortcut", "CommandItem", "keywords", "help", "oauth", "oidc"], "doc_head": "\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\tnavigate(getPagePath($router, \"settings\", { name: \"alert-history\" }))\n\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<AlertOctagonIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Alert History</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t{SettingsShortcut}\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\tkeywords={[\"help\", \"oauth\", \"oidc\"]}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx", "rel_path": "src/site/src/components/command-palette.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 150, "end_line": 166, "text": "\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\twindow.location.href = \"https://beszel.dev/guide/what-is-beszel\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<BookIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Documentation</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<CommandShortcut>beszel.dev</CommandShortcut>\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t{isAdmin() && (\n\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t<CommandSeparator className=\"mb-1.5\" />\n\t\t\t\t\t\t\t<CommandGroup heading={t`Admin`}>\n\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\tkeywords={[\"pocketbase\"]}", "n_tokens": 140, "primary_symbol": "", "primary_kind": "", "primary_span": [150, 166], "def_symbols": [], "symbols": ["onSelect", "window", "location", "href", "https", "beszel", "dev", "guide", "what", "BookIcon", "className", "size", "span", "Trans", "Documentation", "CommandShortcut", "CommandItem", "CommandGroup", "isAdmin", "CommandSeparator", "heading", "Admin", "keywords", "pocketbase"], "doc_head": "\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\twindow.location.href = \"https://beszel.dev/guide/what-is-beszel\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<BookIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t<Trans>Documentation</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<CommandShortcut>beszel.dev</CommandShortcut>\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t{isAdmin() && (\n\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t<CommandSeparator className=\"mb-1.5\" />\n\t\t\t\t\t\t\t<CommandGroup heading={t`Admin`}>\n\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\tkeywords={[\"pocketbase\"]}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx", "rel_path": "src/site/src/components/command-palette.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 167, "end_line": 190, "text": "\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t\t\t\twindow.open(prependBasePath(\"/_/\"), \"_blank\")\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<UsersIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t<Trans>Users</Trans>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t{AdminShortcut}\n\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t\t\t\twindow.open(prependBasePath(\"/_/#/logs\"), \"_blank\")\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<LogsIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t<Trans>Logs</Trans>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t{AdminShortcut}\n\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t<CommandItem", "n_tokens": 164, "primary_symbol": "", "primary_kind": "", "primary_span": [167, 190], "def_symbols": [], "symbols": ["onSelect", "setOpen", "false", "window", "open", "prependBasePath", "_blank", "UsersIcon", "className", "size", "span", "Trans", "Users", "AdminShortcut", "CommandItem", "logs", "LogsIcon", "Logs"], "doc_head": "\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t\t\t\twindow.open(prependBasePath(\"/_/\"), \"_blank\")\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<UsersIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t<Trans>Users</Trans>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t{AdminShortcut}\n\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t\t\t\twindow.open(prependBasePath(\"/_/#/logs\"), \"_blank\")\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<LogsIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t<Trans>Logs</Trans>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t{AdminShortcut}\n\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t<CommandItem"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx", "rel_path": "src/site/src/components/command-palette.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 191, "end_line": 203, "text": "\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t\t\t\twindow.open(prependBasePath(\"/_/#/settings/backups\"), \"_blank\")\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<DatabaseBackupIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t<Trans>Backups</Trans>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t{AdminShortcut}\n\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\tkeywords={[\"email\"]}", "n_tokens": 95, "primary_symbol": "", "primary_kind": "", "primary_span": [191, 203], "def_symbols": [], "symbols": ["onSelect", "setOpen", "false", "window", "open", "prependBasePath", "settings", "backups", "_blank", "DatabaseBackupIcon", "className", "size", "span", "Trans", "Backups", "AdminShortcut", "CommandItem", "keywords", "email"], "doc_head": "\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t\t\t\twindow.open(prependBasePath(\"/_/#/settings/backups\"), \"_blank\")\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<DatabaseBackupIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t<Trans>Backups</Trans>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t{AdminShortcut}\n\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\tkeywords={[\"email\"]}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/command-palette.tsx", "rel_path": "src/site/src/components/command-palette.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 11, "start_line": 204, "end_line": 226, "text": "\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t\t\t\twindow.open(prependBasePath(\"/_/#/settings/mail\"), \"_blank\")\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<MailIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t<Trans>SMTP settings</Trans>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t{AdminShortcut}\n\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t</>\n\t\t\t\t\t)}\n\t\t\t\t\t<CommandEmpty>\n\t\t\t\t\t\t<Trans>No results found.</Trans>\n\t\t\t\t\t</CommandEmpty>\n\t\t\t\t</CommandList>\n\t\t\t</CommandDialog>\n\t\t)\n\t}, [open])\n})\n", "n_tokens": 136, "primary_symbol": "", "primary_kind": "", "primary_span": [204, 226], "def_symbols": [], "symbols": ["onSelect", "setOpen", "false", "window", "open", "prependBasePath", "settings", "mail", "_blank", "MailIcon", "className", "size", "span", "Trans", "SMTP", "AdminShortcut", "CommandItem", "CommandGroup", "CommandEmpty", "results", "found", "CommandList", "CommandDialog"], "doc_head": "\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\tsetOpen(false)\n\t\t\t\t\t\t\t\t\t\twindow.open(prependBasePath(\"/_/#/settings/mail\"), \"_blank\")\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<MailIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t<Trans>SMTP settings</Trans>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t{AdminShortcut}\n\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t</>\n\t\t\t\t\t)}\n\t\t\t\t\t<CommandEmpty>\n\t\t\t\t\t\t<Trans>No results found.</Trans>\n\t\t\t\t\t</CommandEmpty>\n\t\t\t\t</CommandList>\n\t\t\t</CommandDialog>\n\t\t)\n\t}, [open])\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/router.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/router.tsx", "rel_path": "src/site/src/components/router.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 29, "text": "import { createRouter } from \"@nanostores/router\"\n\nconst routes = {\n\thome: \"/\",\n\tsystem: `/system/:name`,\n\tsettings: `/settings/:name?`,\n\tforgot_password: `/forgot-password`,\n\trequest_otp: `/request-otp`,\n} as const\n\n/**\n * The base path of the application.\n * This is used to prepend the base path to all routes.\n */\nexport const basePath = BESZEL?.BASE_PATH || \"\"\n\n/**\n * Prepends the base path to the given path.\n * @param path The path to prepend the base path to.\n * @returns The path with the base path prepended.\n */\nexport const prependBasePath = (path: string) => (basePath + path).replaceAll(\"//\", \"/\")\n\n// prepend base path to routes\nfor (const route in routes) {\n\t// @ts-ignore need as const above to get nanostores to parse types properly\n\troutes[route] = prependBasePath(routes[route])\n}\n", "n_tokens": 201, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 29], "def_symbols": [], "symbols": ["import", "createRouter", "from", "nanostores", "router", "const", "routes", "home", "system", "name", "settings", "forgot_password", "forgot", "password", "request_otp", "request", "otp", "The", "base", "path", "the", "application", "This", "used", "prepend", "all", "export", "basePath", "BESZEL", "BASE_PATH", "Prepends", "given", "param", "returns", "with", "prepended", "prependBasePath", "string", "replaceAll", "for", "route", "ignore", "need", "above", "get", "parse", "types", "properly"], "doc_head": "import { createRouter } from \"@nanostores/router\"\nconst routes = {\n\thome: \"/\",\n\tsystem: `/system/:name`,\n\tsettings: `/settings/:name?`,\n\tforgot_password: `/forgot-password`,\n\trequest_otp: `/request-otp`,\n} as const\n/**\n * The base path of the application.\n * This is used to prepend the base path to all routes.\n */\nexport const basePath = BESZEL?.BASE_PATH || \"\"\n/**\n * Prepends the base path to the given path.\n * @param path The path to prepend the base path to.\n * @returns The path with the base path prepended.\n */\nexport const prependBasePath = (path: string) => (basePath + path).replaceAll(\"//\", \"/\")\n// prepend base path to routes\nfor (const route in routes) {\n\t// @ts-ignore need as const above to get nanostores to parse types properly\n\troutes[route] = prependBasePath(routes[route])\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/router.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/router.tsx", "rel_path": "src/site/src/components/router.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 30, "end_line": 56, "text": "export const $router = createRouter(routes, { links: false })\n\n/** Navigate to url using router\n *  Base path is automatically prepended if serving from subpath\n */\nexport const navigate = (urlString: string) => {\n\t$router.open(urlString)\n}\n\nexport function Link(props: React.AnchorHTMLAttributes<HTMLAnchorElement>) {\n\treturn (\n\t\t<a\n\t\t\t{...props}\n\t\t\tonClick={(e) => {\n\t\t\t\te.preventDefault()\n\t\t\t\tconst href = props.href || \"\"\n\t\t\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t\t\twindow.open(href, \"_blank\")\n\t\t\t\t} else {\n\t\t\t\t\tnavigate(href)\n\t\t\t\t\tprops.onClick?.(e)\n\t\t\t\t}\n\t\t\t}}\n\t\t></a>\n\t)\n}\n", "n_tokens": 152, "primary_symbol": "Link", "primary_kind": "function", "primary_span": [39, 56], "def_symbols": ["Link"], "symbols": ["Link", "export", "const", "router", "createRouter", "routes", "links", "false", "Navigate", "url", "using", "Base", "path", "automatically", "prepended", "serving", "from", "subpath", "navigate", "urlString", "string", "open", "function", "props", "React", "AnchorHTMLAttributes", "HTMLAnchorElement", "return", "onClick", "preventDefault", "href", "ctrlKey", "metaKey", "window", "_blank", "else"], "doc_head": "export const $router = createRouter(routes, { links: false })\n/** Navigate to url using router\n *  Base path is automatically prepended if serving from subpath\n */\nexport const navigate = (urlString: string) => {\n\t$router.open(urlString)\n}\nexport function Link(props: React.AnchorHTMLAttributes<HTMLAnchorElement>) {\n\treturn (\n\t\t<a\n\t\t\t{...props}\n\t\t\tonClick={(e) => {\n\t\t\t\te.preventDefault()\n\t\t\t\tconst href = props.href || \"\"\n\t\t\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t\t\twindow.open(href, \"_blank\")\n\t\t\t\t} else {\n\t\t\t\t\tnavigate(href)\n\t\t\t\t\tprops.onClick?.(e)\n\t\t\t\t}\n\t\t\t}}\n\t\t></a>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 21, "text": "import { Trans } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n\tDialog,\n\tDialogContent,\n\tDialogDescription,\n\tDialogFooter,\n\tDialogHeader,\n\tDialogTitle,\n\tDialogTrigger,\n} from \"@/components/ui/dialog\"\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport { $publicKey } from \"@/lib/stores\"\nimport { cn, generateToken, tokenMap, useBrowserStorage } from \"@/lib/utils\"\nimport { pb, isReadOnlyUser } from \"@/lib/api\"\nimport { useStore } from \"@nanostores/react\"\nimport { ChevronDownIcon, ExternalLinkIcon, PlusIcon } from \"lucide-react\"\nimport { memo, useEffect, useRef, useState } from \"react\"", "n_tokens": 199, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 21], "def_symbols": [], "symbols": ["import", "Trans", "from", "lingui", "react", "macro", "core", "Button", "components", "button", "Dialog", "DialogContent", "DialogDescription", "DialogFooter", "DialogHeader", "DialogTitle", "DialogTrigger", "dialog", "Tabs", "TabsContent", "TabsList", "TabsTrigger", "tabs", "Input", "input", "Label", "label", "publicKey", "lib", "stores", "generateToken", "tokenMap", "useBrowserStorage", "utils", "isReadOnlyUser", "api", "useStore", "nanostores", "ChevronDownIcon", "ExternalLinkIcon", "PlusIcon", "lucide", "memo", "useEffect", "useRef", "useState"], "doc_head": "import { Trans } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n\tDialog,\n\tDialogContent,\n\tDialogDescription,\n\tDialogFooter,\n\tDialogHeader,\n\tDialogTitle,\n\tDialogTrigger,\n} from \"@/components/ui/dialog\"\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport { $publicKey } from \"@/lib/stores\"\nimport { cn, generateToken, tokenMap, useBrowserStorage } from \"@/lib/utils\"\nimport { pb, isReadOnlyUser } from \"@/lib/api\"\nimport { useStore } from \"@nanostores/react\"\nimport { ChevronDownIcon, ExternalLinkIcon, PlusIcon } from \"lucide-react\"\nimport { memo, useEffect, useRef, useState } from \"react\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 22, "end_line": 40, "text": "import { $router, basePath, Link, navigate } from \"./router\"\nimport { SystemRecord } from \"@/types\"\nimport { SystemStatus } from \"@/lib/enums\"\nimport { AppleIcon, DockerIcon, TuxIcon, WindowsIcon } from \"./ui/icons\"\nimport { InputCopy } from \"./ui/input-copy\"\nimport { getPagePath } from \"@nanostores/router\"\nimport {\n\tcopyDockerCompose,\n\tcopyDockerRun,\n\tcopyLinuxCommand,\n\tcopyWindowsCommand,\n\tDropdownItem,\n\tInstallDropdown,\n} from \"./install-dropdowns\"\nimport { DropdownMenu, DropdownMenuTrigger } from \"./ui/dropdown-menu\"\n\nexport function AddSystemButton({ className }: { className?: string }) {\n\tconst [open, setOpen] = useState(false)\n\tlet opened = useRef(false)", "n_tokens": 159, "primary_symbol": "AddSystemButton", "primary_kind": "function", "primary_span": [38, 40], "def_symbols": ["AddSystemButton"], "symbols": ["AddSystemButton", "import", "router", "basePath", "Link", "navigate", "from", "SystemRecord", "types", "SystemStatus", "lib", "enums", "AppleIcon", "DockerIcon", "TuxIcon", "WindowsIcon", "icons", "InputCopy", "input", "copy", "getPagePath", "nanostores", "copyDockerCompose", "copyDockerRun", "copyLinuxCommand", "copyWindowsCommand", "DropdownItem", "InstallDropdown", "install", "dropdowns", "DropdownMenu", "DropdownMenuTrigger", "dropdown", "menu", "export", "function", "className", "string", "const", "open", "setOpen", "useState", "false", "let", "opened", "useRef"], "doc_head": "import { $router, basePath, Link, navigate } from \"./router\"\nimport { SystemRecord } from \"@/types\"\nimport { SystemStatus } from \"@/lib/enums\"\nimport { AppleIcon, DockerIcon, TuxIcon, WindowsIcon } from \"./ui/icons\"\nimport { InputCopy } from \"./ui/input-copy\"\nimport { getPagePath } from \"@nanostores/router\"\nimport {\n\tcopyDockerCompose,\n\tcopyDockerRun,\n\tcopyLinuxCommand,\n\tcopyWindowsCommand,\n\tDropdownItem,\n\tInstallDropdown,\n} from \"./install-dropdowns\"\nimport { DropdownMenu, DropdownMenuTrigger } from \"./ui/dropdown-menu\"\nexport function AddSystemButton({ className }: { className?: string }) {\n\tconst [open, setOpen] = useState(false)\n\tlet opened = useRef(false)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 41, "end_line": 74, "text": "\tif (open) {\n\t\topened.current = true\n\t}\n\n\treturn (\n\t\t<Dialog open={open} onOpenChange={setOpen}>\n\t\t\t<DialogTrigger asChild>\n\t\t\t\t<Button\n\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\tclassName={cn(\"flex gap-1 max-xs:h-[2.4rem]\", className, isReadOnlyUser() && \"hidden\")}\n\t\t\t\t>\n\t\t\t\t\t<PlusIcon className=\"h-4 w-4 -ms-1\" />\n\t\t\t\t\t<Trans>\n\t\t\t\t\t\tAdd <span className=\"hidden sm:inline\">System</span>\n\t\t\t\t\t</Trans>\n\t\t\t\t</Button>\n\t\t\t</DialogTrigger>\n\t\t\t{opened.current && <SystemDialog setOpen={setOpen} />}\n\t\t</Dialog>\n\t)\n}\n\n/**\n * Token to be used for the next system.\n * Prevents token changing if user copies config, then closes dialog and opens again.\n */\nlet nextSystemToken: string | null = null\n\n/**\n * SystemDialog component for adding or editing a system.\n * @param {Object} props - The component props.\n * @param {function} props.setOpen - Function to set the open state of the dialog.\n * @param {SystemRecord} [props.system] - Optional system record for editing an existing system.\n */", "n_tokens": 263, "primary_symbol": "", "primary_kind": "", "primary_span": [41, 74], "def_symbols": [], "symbols": ["open", "opened", "current", "true", "return", "Dialog", "onOpenChange", "setOpen", "DialogTrigger", "asChild", "Button", "variant", "outline", "className", "flex", "gap", "max", "isReadOnlyUser", "hidden", "PlusIcon", "Trans", "Add", "span", "inline", "System", "SystemDialog", "Token", "used", "for", "the", "next", "system", "Prevents", "token", "changing", "user", "copies", "config", "then", "closes", "dialog", "and", "opens", "again", "let", "nextSystemToken", "string", "null", "component", "adding", "editing", "param", "Object", "props", "The", "function", "Function", "set", "state", "SystemRecord", "Optional", "record", "existing"], "doc_head": "\tif (open) {\n\t\topened.current = true\n\t}\n\treturn (\n\t\t<Dialog open={open} onOpenChange={setOpen}>\n\t\t\t<DialogTrigger asChild>\n\t\t\t\t<Button\n\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\tclassName={cn(\"flex gap-1 max-xs:h-[2.4rem]\", className, isReadOnlyUser() && \"hidden\")}\n\t\t\t\t>\n\t\t\t\t\t<PlusIcon className=\"h-4 w-4 -ms-1\" />\n\t\t\t\t\t<Trans>\n\t\t\t\t\t\tAdd <span className=\"hidden sm:inline\">System</span>\n\t\t\t\t\t</Trans>\n\t\t\t\t</Button>\n\t\t\t</DialogTrigger>\n\t\t\t{opened.current && <SystemDialog setOpen={setOpen} />}\n\t\t</Dialog>\n\t)\n}\n/**\n * Token to be used for the next system.\n * Prevents token changing if user copies config, then closes dialog and opens again.\n */\nlet nextSystemToken: string | null = null\n/**\n * SystemDialog component for adding or editing a system.\n * @param {Object} props - The component props.\n * @param {function} props.setOpen - Function to set the open state of the dialog.\n * @param {SystemRecord} [props.system] - Optional system record for editing an existing system.\n */"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 75, "end_line": 89, "text": "export const SystemDialog = ({ setOpen, system }: { setOpen: (open: boolean) => void; system?: SystemRecord }) => {\n\tconst publicKey = useStore($publicKey)\n\tconst port = useRef<HTMLInputElement>(null)\n\tconst [hostValue, setHostValue] = useState(system?.host ?? \"\")\n\tconst isUnixSocket = hostValue.startsWith(\"/\")\n\tconst [tab, setTab] = useBrowserStorage(\"as-tab\", \"docker\")\n\tconst [token, setToken] = useState(system?.token ?? \"\")\n\n\tuseEffect(() => {\n\t\t;(async () => {\n\t\t\t// if no system, generate a new token\n\t\t\tif (!system) {\n\t\t\t\tnextSystemToken ||= generateToken()\n\t\t\t\treturn setToken(nextSystemToken)\n\t\t\t}", "n_tokens": 151, "primary_symbol": "", "primary_kind": "", "primary_span": [75, 89], "def_symbols": [], "symbols": ["export", "const", "SystemDialog", "setOpen", "system", "open", "boolean", "void", "SystemRecord", "publicKey", "useStore", "port", "useRef", "HTMLInputElement", "null", "hostValue", "setHostValue", "useState", "host", "isUnixSocket", "startsWith", "tab", "setTab", "useBrowserStorage", "docker", "token", "setToken", "useEffect", "async", "generate", "new", "nextSystemToken", "generateToken", "return"], "doc_head": "export const SystemDialog = ({ setOpen, system }: { setOpen: (open: boolean) => void; system?: SystemRecord }) => {\n\tconst publicKey = useStore($publicKey)\n\tconst port = useRef<HTMLInputElement>(null)\n\tconst [hostValue, setHostValue] = useState(system?.host ?? \"\")\n\tconst isUnixSocket = hostValue.startsWith(\"/\")\n\tconst [tab, setTab] = useBrowserStorage(\"as-tab\", \"docker\")\n\tconst [token, setToken] = useState(system?.token ?? \"\")\n\tuseEffect(() => {\n\t\t;(async () => {\n\t\t\t// if no system, generate a new token\n\t\t\tif (!system) {\n\t\t\t\tnextSystemToken ||= generateToken()\n\t\t\t\treturn setToken(nextSystemToken)\n\t\t\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 90, "end_line": 110, "text": "\t\t\t// if system exists,get the token from the fingerprint record\n\t\t\tif (tokenMap.has(system.id)) {\n\t\t\t\treturn setToken(tokenMap.get(system.id)!)\n\t\t\t}\n\t\t\tconst { token } = await pb.collection(\"fingerprints\").getFirstListItem(`system = \"${system.id}\"`, {\n\t\t\t\tfields: \"token\",\n\t\t\t})\n\t\t\ttokenMap.set(system.id, token)\n\t\t\tsetToken(token)\n\t\t})()\n\t}, [system?.id, nextSystemToken])\n\n\tasync function handleSubmit(e: SubmitEvent) {\n\t\te.preventDefault()\n\t\tconst formData = new FormData(e.target as HTMLFormElement)\n\t\tconst data = Object.fromEntries(formData) as Record<string, any>\n\t\tdata.users = pb.authStore.record!.id\n\t\ttry {\n\t\t\tsetOpen(false)\n\t\t\tif (system) {\n\t\t\t\tawait pb.collection(\"systems\").update(system.id, { ...data, status: SystemStatus.Pending })", "n_tokens": 188, "primary_symbol": "handleSubmit", "primary_kind": "function", "primary_span": [102, 110], "def_symbols": ["handleSubmit"], "symbols": ["handleSubmit", "system", "exists", "get", "the", "token", "from", "fingerprint", "record", "tokenMap", "has", "return", "setToken", "const", "await", "collection", "fingerprints", "getFirstListItem", "fields", "set", "nextSystemToken", "async", "function", "SubmitEvent", "preventDefault", "formData", "new", "FormData", "target", "HTMLFormElement", "data", "Object", "fromEntries", "Record", "string", "any", "users", "authStore", "try", "setOpen", "false", "systems", "update", "status", "SystemStatus", "Pending"], "doc_head": "\t\t\t// if system exists,get the token from the fingerprint record\n\t\t\tif (tokenMap.has(system.id)) {\n\t\t\t\treturn setToken(tokenMap.get(system.id)!)\n\t\t\t}\n\t\t\tconst { token } = await pb.collection(\"fingerprints\").getFirstListItem(`system = \"${system.id}\"`, {\n\t\t\t\tfields: \"token\",\n\t\t\t})\n\t\t\ttokenMap.set(system.id, token)\n\t\t\tsetToken(token)\n\t\t})()\n\t}, [system?.id, nextSystemToken])\n\tasync function handleSubmit(e: SubmitEvent) {\n\t\te.preventDefault()\n\t\tconst formData = new FormData(e.target as HTMLFormElement)\n\t\tconst data = Object.fromEntries(formData) as Record<string, any>\n\t\tdata.users = pb.authStore.record!.id\n\t\ttry {\n\t\t\tsetOpen(false)\n\t\t\tif (system) {\n\t\t\t\tawait pb.collection(\"systems\").update(system.id, { ...data, status: SystemStatus.Pending })"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 111, "end_line": 129, "text": "\t\t\t} else {\n\t\t\t\tconst createdSystem = await pb.collection(\"systems\").create(data)\n\t\t\t\tawait pb.collection(\"fingerprints\").create({\n\t\t\t\t\tsystem: createdSystem.id,\n\t\t\t\t\ttoken,\n\t\t\t\t})\n\t\t\t\t// Reset the current token after successful system\n\t\t\t\t// creation so next system gets a new token\n\t\t\t\tnextSystemToken = null\n\t\t\t}\n\t\t\tnavigate(basePath)\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t}\n\t}\n\n\treturn (\n\t\t<DialogContent\n\t\t\tclassName=\"w-[90%] sm:w-auto sm:ns-dialog max-w-full rounded-lg\"", "n_tokens": 127, "primary_symbol": "", "primary_kind": "", "primary_span": [111, 129], "def_symbols": [], "symbols": ["else", "const", "createdSystem", "await", "collection", "systems", "create", "data", "fingerprints", "system", "token", "Reset", "the", "current", "after", "successful", "creation", "next", "gets", "new", "nextSystemToken", "null", "navigate", "basePath", "catch", "console", "error", "return", "DialogContent", "className", "auto", "dialog", "max", "full", "rounded"], "doc_head": "\t\t\t} else {\n\t\t\t\tconst createdSystem = await pb.collection(\"systems\").create(data)\n\t\t\t\tawait pb.collection(\"fingerprints\").create({\n\t\t\t\t\tsystem: createdSystem.id,\n\t\t\t\t\ttoken,\n\t\t\t\t})\n\t\t\t\t// Reset the current token after successful system\n\t\t\t\t// creation so next system gets a new token\n\t\t\t\tnextSystemToken = null\n\t\t\t}\n\t\t\tnavigate(basePath)\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t}\n\t}\n\treturn (\n\t\t<DialogContent\n\t\t\tclassName=\"w-[90%] sm:w-auto sm:ns-dialog max-w-full rounded-lg\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 130, "end_line": 153, "text": "\t\t\tonCloseAutoFocus={() => {\n\t\t\t\tsetHostValue(system?.host ?? \"\")\n\t\t\t}}\n\t\t>\n\t\t\t<Tabs defaultValue={tab} onValueChange={setTab}>\n\t\t\t\t<DialogHeader>\n\t\t\t\t\t<DialogTitle className=\"mb-1 pb-1 max-w-100 truncate pr-8\">\n\t\t\t\t\t\t{system ? `${t`Edit`} ${system?.name}` : <Trans>Add New System</Trans>}\n\t\t\t\t\t</DialogTitle>\n\t\t\t\t\t<TabsList className=\"grid w-full grid-cols-2\">\n\t\t\t\t\t\t<TabsTrigger value=\"docker\">Docker</TabsTrigger>\n\t\t\t\t\t\t<TabsTrigger value=\"binary\">\n\t\t\t\t\t\t\t<Trans>Binary</Trans>\n\t\t\t\t\t\t</TabsTrigger>\n\t\t\t\t\t</TabsList>\n\t\t\t\t</DialogHeader>\n\t\t\t\t{/* Docker (set tab index to prevent auto focusing content in edit system dialog) */}\n\t\t\t\t<TabsContent value=\"docker\" tabIndex={-1}>\n\t\t\t\t\t<DialogDescription className=\"mb-3 leading-relaxed w-0 min-w-full\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tCopy the\n\t\t\t\t\t\t\t<code className=\"bg-muted px-1 rounded-sm leading-3\">docker-compose.yml</code> content for the agent\n\t\t\t\t\t\t\tbelow, or register agents automatically with a{\" \"}\n\t\t\t\t\t\t\t<Link", "n_tokens": 266, "primary_symbol": "", "primary_kind": "", "primary_span": [130, 153], "def_symbols": [], "symbols": ["onCloseAutoFocus", "setHostValue", "system", "host", "Tabs", "defaultValue", "tab", "onValueChange", "setTab", "DialogHeader", "DialogTitle", "className", "max", "truncate", "Edit", "name", "Trans", "Add", "New", "System", "TabsList", "grid", "full", "cols", "TabsTrigger", "value", "docker", "Docker", "binary", "Binary", "set", "index", "prevent", "auto", "focusing", "content", "edit", "dialog", "TabsContent", "tabIndex", "DialogDescription", "leading", "relaxed", "min", "Copy", "the", "code", "muted", "rounded", "compose", "yml", "for", "agent", "below", "register", "agents", "automatically", "with", "Link"], "doc_head": "\t\t\tonCloseAutoFocus={() => {\n\t\t\t\tsetHostValue(system?.host ?? \"\")\n\t\t\t}}\n\t\t>\n\t\t\t<Tabs defaultValue={tab} onValueChange={setTab}>\n\t\t\t\t<DialogHeader>\n\t\t\t\t\t<DialogTitle className=\"mb-1 pb-1 max-w-100 truncate pr-8\">\n\t\t\t\t\t\t{system ? `${t`Edit`} ${system?.name}` : <Trans>Add New System</Trans>}\n\t\t\t\t\t</DialogTitle>\n\t\t\t\t\t<TabsList className=\"grid w-full grid-cols-2\">\n\t\t\t\t\t\t<TabsTrigger value=\"docker\">Docker</TabsTrigger>\n\t\t\t\t\t\t<TabsTrigger value=\"binary\">\n\t\t\t\t\t\t\t<Trans>Binary</Trans>\n\t\t\t\t\t\t</TabsTrigger>\n\t\t\t\t\t</TabsList>\n\t\t\t\t</DialogHeader>\n\t\t\t\t{/* Docker (set tab index to prevent auto focusing content in edit system dialog) */}\n\t\t\t\t<TabsContent value=\"docker\" tabIndex={-1}>\n\t\t\t\t\t<DialogDescription className=\"mb-3 leading-relaxed w-0 min-w-full\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tCopy the\n\t\t\t\t\t\t\t<code className=\"bg-muted px-1 rounded-sm leading-3\">docker-compose.yml</code> content for the agent\n\t\t\t\t\t\t\tbelow, or register agents automatically with a{\" \"}\n\t\t\t\t\t\t\t<Link"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 154, "end_line": 169, "text": "\t\t\t\t\t\t\t\tonClick={() => setOpen(false)}\n\t\t\t\t\t\t\t\thref={getPagePath($router, \"settings\", { name: \"tokens\" })}\n\t\t\t\t\t\t\t\tclassName=\"link\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tuniversal token\n\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t.\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</DialogDescription>\n\t\t\t\t</TabsContent>\n\t\t\t\t{/* Binary */}\n\t\t\t\t<TabsContent value=\"binary\" tabIndex={-1}>\n\t\t\t\t\t<DialogDescription className=\"mb-3 leading-relaxed w-0 min-w-full\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tCopy the installation command for the agent below, or register agents automatically with a{\" \"}\n\t\t\t\t\t\t\t<Link", "n_tokens": 130, "primary_symbol": "", "primary_kind": "", "primary_span": [154, 169], "def_symbols": [], "symbols": ["onClick", "setOpen", "false", "href", "getPagePath", "router", "settings", "name", "tokens", "className", "link", "universal", "token", "Link", "Trans", "DialogDescription", "TabsContent", "Binary", "value", "binary", "tabIndex", "leading", "relaxed", "min", "full", "Copy", "the", "installation", "command", "for", "agent", "below", "register", "agents", "automatically", "with"], "doc_head": "\t\t\t\t\t\t\t\tonClick={() => setOpen(false)}\n\t\t\t\t\t\t\t\thref={getPagePath($router, \"settings\", { name: \"tokens\" })}\n\t\t\t\t\t\t\t\tclassName=\"link\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tuniversal token\n\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t.\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</DialogDescription>\n\t\t\t\t</TabsContent>\n\t\t\t\t{/* Binary */}\n\t\t\t\t<TabsContent value=\"binary\" tabIndex={-1}>\n\t\t\t\t\t<DialogDescription className=\"mb-3 leading-relaxed w-0 min-w-full\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tCopy the installation command for the agent below, or register agents automatically with a{\" \"}\n\t\t\t\t\t\t\t<Link"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 170, "end_line": 193, "text": "\t\t\t\t\t\t\t\tonClick={() => setOpen(false)}\n\t\t\t\t\t\t\t\thref={getPagePath($router, \"settings\", { name: \"tokens\" })}\n\t\t\t\t\t\t\t\tclassName=\"link\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tuniversal token\n\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t.\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</DialogDescription>\n\t\t\t\t</TabsContent>\n\t\t\t\t<form onSubmit={handleSubmit as any}>\n\t\t\t\t\t<div className=\"grid xs:grid-cols-[auto_1fr] gap-y-3 gap-x-4 items-center mt-1 mb-4\">\n\t\t\t\t\t\t<Label htmlFor=\"name\" className=\"xs:text-end\">\n\t\t\t\t\t\t\t<Trans>Name</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<Input id=\"name\" name=\"name\" defaultValue={system?.name} required />\n\t\t\t\t\t\t<Label htmlFor=\"host\" className=\"xs:text-end\">\n\t\t\t\t\t\t\t<Trans>Host / IP</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\tid=\"host\"\n\t\t\t\t\t\t\tname=\"host\"\n\t\t\t\t\t\t\tvalue={hostValue}\n\t\t\t\t\t\t\trequired", "n_tokens": 204, "primary_symbol": "", "primary_kind": "", "primary_span": [170, 193], "def_symbols": [], "symbols": ["onClick", "setOpen", "false", "href", "getPagePath", "router", "settings", "name", "tokens", "className", "link", "universal", "token", "Link", "Trans", "DialogDescription", "TabsContent", "form", "onSubmit", "handleSubmit", "any", "div", "grid", "cols", "auto_1fr", "gap", "items", "center", "Label", "htmlFor", "text", "end", "Name", "Input", "defaultValue", "system", "required", "host", "Host", "value", "hostValue"], "doc_head": "\t\t\t\t\t\t\t\tonClick={() => setOpen(false)}\n\t\t\t\t\t\t\t\thref={getPagePath($router, \"settings\", { name: \"tokens\" })}\n\t\t\t\t\t\t\t\tclassName=\"link\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tuniversal token\n\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t.\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</DialogDescription>\n\t\t\t\t</TabsContent>\n\t\t\t\t<form onSubmit={handleSubmit as any}>\n\t\t\t\t\t<div className=\"grid xs:grid-cols-[auto_1fr] gap-y-3 gap-x-4 items-center mt-1 mb-4\">\n\t\t\t\t\t\t<Label htmlFor=\"name\" className=\"xs:text-end\">\n\t\t\t\t\t\t\t<Trans>Name</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<Input id=\"name\" name=\"name\" defaultValue={system?.name} required />\n\t\t\t\t\t\t<Label htmlFor=\"host\" className=\"xs:text-end\">\n\t\t\t\t\t\t\t<Trans>Host / IP</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\tid=\"host\"\n\t\t\t\t\t\t\tname=\"host\"\n\t\t\t\t\t\t\tvalue={hostValue}\n\t\t\t\t\t\t\trequired"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 194, "end_line": 222, "text": "\t\t\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\t\t\tsetHostValue(e.target.value)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<Label htmlFor=\"port\" className={cn(\"xs:text-end\", isUnixSocket && \"hidden\")}>\n\t\t\t\t\t\t\t<Trans>Port</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\tref={port}\n\t\t\t\t\t\t\tname=\"port\"\n\t\t\t\t\t\t\tid=\"port\"\n\t\t\t\t\t\t\tdefaultValue={system?.port || \"45876\"}\n\t\t\t\t\t\t\trequired={!isUnixSocket}\n\t\t\t\t\t\t\tclassName={cn(isUnixSocket && \"hidden\")}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<Label htmlFor=\"pkey\" className=\"xs:text-end whitespace-pre\">\n\t\t\t\t\t\t\t<Trans comment=\"Use 'Key' if your language requires many more characters\">Public Key</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<InputCopy value={publicKey} id=\"pkey\" name=\"pkey\" />\n\t\t\t\t\t\t<Label htmlFor=\"tkn\" className=\"xs:text-end whitespace-pre\">\n\t\t\t\t\t\t\t<Trans>Token</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<InputCopy value={token} id=\"tkn\" name=\"tkn\" />\n\t\t\t\t\t</div>\n\t\t\t\t\t<DialogFooter className=\"flex justify-end gap-x-2 gap-y-3 flex-col mt-5\">\n\t\t\t\t\t\t{/* Docker */}\n\t\t\t\t\t\t<TabsContent value=\"docker\" className=\"contents\">\n\t\t\t\t\t\t\t<CopyButton\n\t\t\t\t\t\t\t\ttext={t({ message: \"Copy docker compose\", context: \"Button to copy docker compose file content\" })}", "n_tokens": 304, "primary_symbol": "", "primary_kind": "", "primary_span": [194, 222], "def_symbols": [], "symbols": ["onChange", "setHostValue", "target", "value", "Label", "htmlFor", "port", "className", "text", "end", "isUnixSocket", "hidden", "Trans", "Port", "Input", "ref", "name", "defaultValue", "system", "required", "pkey", "whitespace", "pre", "comment", "Use", "Key", "your", "language", "requires", "many", "more", "characters", "Public", "InputCopy", "publicKey", "tkn", "Token", "token", "div", "DialogFooter", "flex", "justify", "gap", "col", "Docker", "TabsContent", "docker", "contents", "CopyButton", "message", "Copy", "compose", "context", "Button", "copy", "file", "content"], "doc_head": "\t\t\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\t\t\tsetHostValue(e.target.value)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<Label htmlFor=\"port\" className={cn(\"xs:text-end\", isUnixSocket && \"hidden\")}>\n\t\t\t\t\t\t\t<Trans>Port</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\tref={port}\n\t\t\t\t\t\t\tname=\"port\"\n\t\t\t\t\t\t\tid=\"port\"\n\t\t\t\t\t\t\tdefaultValue={system?.port || \"45876\"}\n\t\t\t\t\t\t\trequired={!isUnixSocket}\n\t\t\t\t\t\t\tclassName={cn(isUnixSocket && \"hidden\")}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<Label htmlFor=\"pkey\" className=\"xs:text-end whitespace-pre\">\n\t\t\t\t\t\t\t<Trans comment=\"Use 'Key' if your language requires many more characters\">Public Key</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<InputCopy value={publicKey} id=\"pkey\" name=\"pkey\" />\n\t\t\t\t\t\t<Label htmlFor=\"tkn\" className=\"xs:text-end whitespace-pre\">\n\t\t\t\t\t\t\t<Trans>Token</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<InputCopy value={token} id=\"tkn\" name=\"tkn\" />\n\t\t\t\t\t</div>\n\t\t\t\t\t<DialogFooter className=\"flex justify-end gap-x-2 gap-y-3 flex-col mt-5\">\n\t\t\t\t\t\t{/* Docker */}\n\t\t\t\t\t\t<TabsContent value=\"docker\" className=\"contents\">\n\t\t\t\t\t\t\t<CopyButton\n\t\t\t\t\t\t\t\ttext={t({ message: \"Copy docker compose\", context: \"Button to copy docker compose file content\" })}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 11, "start_line": 223, "end_line": 241, "text": "\t\t\t\t\t\t\t\tonClick={async () =>\n\t\t\t\t\t\t\t\t\tcopyDockerCompose(isUnixSocket ? hostValue : port.current?.value, publicKey, token)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ticon={<DockerIcon className=\"size-4 -me-0.5\" />}\n\t\t\t\t\t\t\t\tdropdownItems={[\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttext: t({ message: \"Copy docker run\", context: \"Button to copy docker run command\" }),\n\t\t\t\t\t\t\t\t\t\tonClick: async () =>\n\t\t\t\t\t\t\t\t\t\t\tcopyDockerRun(isUnixSocket ? hostValue : port.current?.value, publicKey, token),\n\t\t\t\t\t\t\t\t\t\ticons: [DockerIcon],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</TabsContent>\n\t\t\t\t\t\t{/* Binary */}\n\t\t\t\t\t\t<TabsContent value=\"binary\" className=\"contents\">\n\t\t\t\t\t\t\t<CopyButton\n\t\t\t\t\t\t\t\ttext={t`Copy Linux command`}\n\t\t\t\t\t\t\t\ticon={<TuxIcon className=\"size-4\" />}", "n_tokens": 177, "primary_symbol": "", "primary_kind": "", "primary_span": [223, 241], "def_symbols": [], "symbols": ["onClick", "async", "copyDockerCompose", "isUnixSocket", "hostValue", "port", "current", "value", "publicKey", "token", "icon", "DockerIcon", "className", "size", "dropdownItems", "text", "message", "Copy", "docker", "run", "context", "Button", "copy", "command", "copyDockerRun", "icons", "TabsContent", "Binary", "binary", "contents", "CopyButton", "Linux", "TuxIcon"], "doc_head": "\t\t\t\t\t\t\t\tonClick={async () =>\n\t\t\t\t\t\t\t\t\tcopyDockerCompose(isUnixSocket ? hostValue : port.current?.value, publicKey, token)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ticon={<DockerIcon className=\"size-4 -me-0.5\" />}\n\t\t\t\t\t\t\t\tdropdownItems={[\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttext: t({ message: \"Copy docker run\", context: \"Button to copy docker run command\" }),\n\t\t\t\t\t\t\t\t\t\tonClick: async () =>\n\t\t\t\t\t\t\t\t\t\t\tcopyDockerRun(isUnixSocket ? hostValue : port.current?.value, publicKey, token),\n\t\t\t\t\t\t\t\t\t\ticons: [DockerIcon],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</TabsContent>\n\t\t\t\t\t\t{/* Binary */}\n\t\t\t\t\t\t<TabsContent value=\"binary\" className=\"contents\">\n\t\t\t\t\t\t\t<CopyButton\n\t\t\t\t\t\t\t\ttext={t`Copy Linux command`}\n\t\t\t\t\t\t\t\ticon={<TuxIcon className=\"size-4\" />}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 12, "start_line": 242, "end_line": 251, "text": "\t\t\t\t\t\t\t\tonClick={async () => copyLinuxCommand(isUnixSocket ? hostValue : port.current?.value, publicKey, token)}\n\t\t\t\t\t\t\t\tdropdownItems={[\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttext: t({ message: \"Homebrew command\", context: \"Button to copy install command\" }),\n\t\t\t\t\t\t\t\t\t\tonClick: async () =>\n\t\t\t\t\t\t\t\t\t\t\tcopyLinuxCommand(isUnixSocket ? hostValue : port.current?.value, publicKey, token, true),\n\t\t\t\t\t\t\t\t\t\ticons: [AppleIcon, TuxIcon],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttext: t({ message: \"Windows command\", context: \"Button to copy install command\" }),", "n_tokens": 122, "primary_symbol": "", "primary_kind": "", "primary_span": [242, 251], "def_symbols": [], "symbols": ["onClick", "async", "copyLinuxCommand", "isUnixSocket", "hostValue", "port", "current", "value", "publicKey", "token", "dropdownItems", "text", "message", "Homebrew", "command", "context", "Button", "copy", "install", "true", "icons", "AppleIcon", "TuxIcon", "Windows"], "doc_head": "\t\t\t\t\t\t\t\tonClick={async () => copyLinuxCommand(isUnixSocket ? hostValue : port.current?.value, publicKey, token)}\n\t\t\t\t\t\t\t\tdropdownItems={[\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttext: t({ message: \"Homebrew command\", context: \"Button to copy install command\" }),\n\t\t\t\t\t\t\t\t\t\tonClick: async () =>\n\t\t\t\t\t\t\t\t\t\t\tcopyLinuxCommand(isUnixSocket ? hostValue : port.current?.value, publicKey, token, true),\n\t\t\t\t\t\t\t\t\t\ticons: [AppleIcon, TuxIcon],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttext: t({ message: \"Windows command\", context: \"Button to copy install command\" }),"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 13, "start_line": 252, "end_line": 279, "text": "\t\t\t\t\t\t\t\t\t\tonClick: async () =>\n\t\t\t\t\t\t\t\t\t\t\tcopyWindowsCommand(isUnixSocket ? hostValue : port.current?.value, publicKey, token),\n\t\t\t\t\t\t\t\t\t\ticons: [WindowsIcon],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttext: t`Manual setup instructions`,\n\t\t\t\t\t\t\t\t\t\turl: \"https://beszel.dev/guide/agent-installation#binary\",\n\t\t\t\t\t\t\t\t\t\ticons: [ExternalLinkIcon],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</TabsContent>\n\t\t\t\t\t\t{/* Save */}\n\t\t\t\t\t\t<Button>{system ? <Trans>Save system</Trans> : <Trans>Add system</Trans>}</Button>\n\t\t\t\t\t</DialogFooter>\n\t\t\t\t</form>\n\t\t\t</Tabs>\n\t\t</DialogContent>\n\t)\n}\n\ninterface CopyButtonProps {\n\ttext: string\n\tonClick: () => void\n\tdropdownItems: DropdownItem[]\n\ticon?: React.ReactElement<any>\n}\n", "n_tokens": 174, "primary_symbol": "", "primary_kind": "", "primary_span": [252, 279], "def_symbols": [], "symbols": ["onClick", "async", "copyWindowsCommand", "isUnixSocket", "hostValue", "port", "current", "value", "publicKey", "token", "icons", "WindowsIcon", "text", "Manual", "setup", "instructions", "url", "https", "beszel", "dev", "guide", "agent", "installation", "binary", "ExternalLinkIcon", "TabsContent", "Save", "Button", "system", "Trans", "Add", "DialogFooter", "form", "Tabs", "DialogContent", "interface", "CopyButtonProps", "string", "void", "dropdownItems", "DropdownItem", "icon", "React", "ReactElement", "any"], "doc_head": "\t\t\t\t\t\t\t\t\t\tonClick: async () =>\n\t\t\t\t\t\t\t\t\t\t\tcopyWindowsCommand(isUnixSocket ? hostValue : port.current?.value, publicKey, token),\n\t\t\t\t\t\t\t\t\t\ticons: [WindowsIcon],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttext: t`Manual setup instructions`,\n\t\t\t\t\t\t\t\t\t\turl: \"https://beszel.dev/guide/agent-installation#binary\",\n\t\t\t\t\t\t\t\t\t\ticons: [ExternalLinkIcon],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</TabsContent>\n\t\t\t\t\t\t{/* Save */}\n\t\t\t\t\t\t<Button>{system ? <Trans>Save system</Trans> : <Trans>Add system</Trans>}</Button>\n\t\t\t\t\t</DialogFooter>\n\t\t\t\t</form>\n\t\t\t</Tabs>\n\t\t</DialogContent>\n\t)\n}\ninterface CopyButtonProps {\n\ttext: string\n\tonClick: () => void\n\tdropdownItems: DropdownItem[]\n\ticon?: React.ReactElement<any>\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/add-system.tsx", "rel_path": "src/site/src/components/add-system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 14, "start_line": 280, "end_line": 303, "text": "const CopyButton = memo((props: CopyButtonProps) => {\n\treturn (\n\t\t<div className=\"flex gap-0 rounded-lg\">\n\t\t\t<Button\n\t\t\t\ttype=\"button\"\n\t\t\t\tvariant=\"outline\"\n\t\t\t\tonClick={props.onClick}\n\t\t\t\tclassName=\"rounded-e-none dark:border-e-0 grow flex items-center gap-2\"\n\t\t\t>\n\t\t\t\t{props.text} {props.icon}\n\t\t\t</Button>\n\t\t\t<div className=\"w-px h-full bg-muted\"></div>\n\t\t\t<DropdownMenu>\n\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t<Button variant=\"outline\" className={\"px-2 rounded-s-none border-s-0\"}>\n\t\t\t\t\t\t<ChevronDownIcon />\n\t\t\t\t\t</Button>\n\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t<InstallDropdown items={props.dropdownItems} />\n\t\t\t</DropdownMenu>\n\t\t</div>\n\t)\n})\n", "n_tokens": 182, "primary_symbol": "", "primary_kind": "", "primary_span": [280, 303], "def_symbols": [], "symbols": ["const", "CopyButton", "memo", "props", "CopyButtonProps", "return", "div", "className", "flex", "gap", "rounded", "Button", "type", "button", "variant", "outline", "onClick", "none", "dark", "border", "grow", "items", "center", "text", "icon", "full", "muted", "DropdownMenu", "DropdownMenuTrigger", "asChild", "ChevronDownIcon", "InstallDropdown", "dropdownItems"], "doc_head": "const CopyButton = memo((props: CopyButtonProps) => {\n\treturn (\n\t\t<div className=\"flex gap-0 rounded-lg\">\n\t\t\t<Button\n\t\t\t\ttype=\"button\"\n\t\t\t\tvariant=\"outline\"\n\t\t\t\tonClick={props.onClick}\n\t\t\t\tclassName=\"rounded-e-none dark:border-e-0 grow flex items-center gap-2\"\n\t\t\t>\n\t\t\t\t{props.text} {props.icon}\n\t\t\t</Button>\n\t\t\t<div className=\"w-px h-full bg-muted\"></div>\n\t\t\t<DropdownMenu>\n\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t<Button variant=\"outline\" className={\"px-2 rounded-s-none border-s-0\"}>\n\t\t\t\t\t\t<ChevronDownIcon />\n\t\t\t\t\t</Button>\n\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t<InstallDropdown items={props.dropdownItems} />\n\t\t\t</DropdownMenu>\n\t\t</div>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/logo.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/logo.tsx", "rel_path": "src/site/src/components/logo.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 18, "text": "export function Logo({ className }: { className?: string }) {\n\treturn (\n\t\t// Righteous\n\t\t<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 285 75\" className={className}>\n\t\t\t{/* <defs>\n\t\t\t\t<linearGradient id=\"gradient\" x1=\"0%\" y1=\"20%\" x2=\"100%\" y2=\"120%\">\n\t\t\t\t\t<stop offset=\"0%\" style={{ stopColor: \"#747bff\" }} />\n\t\t\t\t\t<stop offset=\"100%\" style={{ stopColor: \"#24eb5c\" }} />\n\t\t\t\t</linearGradient>\n\t\t\t</defs> */}\n\t\t\t<path\n\t\t\t\t// fill=\"url(#gradient)\"\n\t\t\t\td=\"M146.4 73.1h-30.5V59.8h30.5a3.2 3.2 0 0 0 2.3-1 3.2 3.2 0 0 0 1-2.3q0-.8-.3-1.3a1.5 1.5 0 0 0-.7-.6 4.7 4.7 0 0 0-1-.3l-1.3-.1h-13.9q-3.4 0-6.5-1.3-3-1.3-5.2-3.6a16.9 16.9 0 0 1-3.6-5.3 16.3 16.3 0 0 1-1.3-6.5 16.4 16.4 0 0 1 1.3-6.4q1.3-3.1 3.6-5.4 2.2-2.2 5.2-3.5a16.3 16.3 0 0 1 6.5-1.3h27v13.3h-27a3.2 3.2 0 0 0-2.3 1 3.2 3.2 0 0 0-1 2.3 3.3 3.3 0 0 0 1 2.4 3.3 3.3 0 0 0 1.2.8 3.2 3.2 0 0 0 1.1.2h13.9a18.1 18.1 0 0 1 6 1 17.3 17.3 0 0 1 .4.2q3 1.1 5.3 3.2a15.1 15.1 0 0 1 3.6 4.9 14.7 14.7 0 0 1 1.3 5.4 17.2 17.2 0 0 1 0 .9 16 16 0 0 1-1 5.8 15.4 15.4 0 0 1-.3.7 17.3 17.3 0 0 1-3.6 5.2 16.4 16.4 0 0 1-5.3 3.6 16.2 16.2 0 0 1-6.4 1.3Zm64.5-13.3v13.3h-43.6l22-39h-22V21h43.6l-22 39h22ZM35 73.1H0v-70h35q4.4 0 8.2 1.6a21.4 21.4 0 0 1 6.6 4.6q2.9 2.8 4.5 6.6 1.7 3.8 1.7 8.2a15.4 15.4 0 0 1-.3 3.2 17.6 17.6 0 0 1-.2.8 19.4 19.4 0 0 1-1.5 4 17 17 0 0 1-2.4 3.4 13.5 13.5 0 0 1-2.6 2.3 12.5 12.5 0 0 1-.4.3q1.7 1 3 2.5 1.4 1.6 2.4 3.5a18.3 18.3 0 0 1 1.5 4A17.4 17.4 0 0 1 56 51a15.3 15.3 0 0 1 0 1.1q0 4.3-1.7 8.2a21.4 21.4 0 0 1-4.5 6.6q-2.8 2.9-6.6 4.5-3.8 1.7-8.2 1.7Zm76-43L86 60.4l1.5.3a16.7 16.7 0 0 0 1.6 0q2 0 3.8-.4 1.8-.6 3.4-1.6 1.6-1 2.8-2.4a12.8 12.8 0 0 0 2-3.2l9.8 9.8q-1.9 2.6-4.3 4.7a27 27 0 0 1-5.2 3.6 26.1 26.1 0 0 1-6 2.2 26.8 26.8 0 0 1-6.3.8 26.4 26.4 0 0 1-10.4-2 26.2 26.2 0 0 1-8.5-5.8 26.7 26.7 0 0 1-5.5-8.3 30.4 30.4 0 0 1-.2-.4q-2.1-5-2.1-11.1a31.9 31.9 0 0 1 .7-7 27 27 0 0 1 1.4-4.3 27 27 0 0 1 3.8-6.6 24.5 24.5 0 0 1 2-2.2 26 26 0 0 1 8.4-5.6 27 27 0 0 1 10.4-2 26.3 26.3 0 0 1 6.4.8 26.9 26.9 0 0 1 6 2.2q2.7 1.5 5.2 3.6 2.4 2.1 4.3 4.8Zm152.3 0-25 30.2 1.5.3a16.7 16.7 0 0 0 1.6 0q2 0 3.8-.4 1.8-.6 3.4-1.6 1.5-1 2.8-2.4a12.8 12.8 0 0 0 2-3.2l9.8 9.8q-1.9 2.6-4.3 4.7a27 27 0 0 1-5.2 3.6 26.1 26.1 0 0 1-6 2.2 26.8 26.8 0 0 1-6.3.8 26.4 26.4 0 0 1-10.4-2 26.2 26.2 0 0 1-8.5-5.8A26.7 26.7 0 0 1 217 58a30.4 30.4 0 0 1-.2-.4q-2.1-5-2.1-11.1a31.9 31.9 0 0 1 .7-7 27 27 0 0 1 1.4-4.3 27 27 0 0 1 3.8-6.6 24.5 24.5 0 0 1 2-2.2 26 26 0 0 1 8.4-5.6 27 27 0 0 1 10.4-2 26.3 26.3 0 0 1 6.4.8 26.9 26.9 0 0 1 6 2.2q2.7 1.5 5.2 3.6 2.4 2.1 4.3 4.8ZM283.4 0v73.1H270V0h13.4ZM14 17v14.1h21a7 7 0 0 0 2.3-.4 6.6 6.6 0 0 0 .4-.1Q39 30 40 29a6.9 6.9 0 0 0 1.5-2.3q.5-1.3.5-2.7a7 7 0 0 0-.4-2.3 6.6 6.6 0 0 0-.1-.5q-.6-1.2-1.5-2.2a7 7 0 0 0-2.3-1.5 6.9 6.9 0 0 0-2.5-.5 7.9 7.9 0 0 0-.2 0H14Zm0 28.1v14h21a7 7 0 0 0 2.3-.4 6.6 6.6 0 0 0 .4-.2Q39 58 40 57.1a7 7 0 0 0 1.5-2.3 6.9 6.9 0 0 0 .5-2.5 7.9 7.9 0 0 0 0-.2 7 7 0 0 0-.4-2.3 6.6 6.6 0 0 0-.1-.4Q40.9 48 40 47a7 7 0 0 0-2.3-1.4 6.9 6.9 0 0 0-2.5-.6 7.9 7.9 0 0 0-.2 0H14Zm63.3 8.3 15.5-20.6a8 8 0 0 0-1.4-.4 7 7 0 0 0-.4 0 17.2 17.2 0 0 0-1.6-.1 19.2 19.2 0 0 0-.3 0 13.3 13.3 0 0 0-5.1 1q-2.5 1-4.2 2.8a13.1 13.1 0 0 0-2.5 3.6 15.5 15.5 0 0 0-.3.9 14.7 14.7 0 0 0-1 3.5 18.7 18.7 0 0 0 0 2.4 17.6 17.6 0 0 0 0 .7v.8a29.4 29.4 0 0 0 0 .1 19.2 19.2 0 0 0 .2 2 20.2 20.2 0 0 0 .4 1.6 18.6 18.6 0 0 0 0 .2 7.5 7.5 0 0 0 .4.9 6 6 0 0 0 .3.6Zm152.3 0L245 32.8a8 8 0 0 0-1.4-.4 7 7 0 0 0-.4 0 17.2 17.2 0 0 0-1.6-.1 19.2 19.2 0 0 0-.3 0 13.3 13.3 0 0 0-5.1 1q-2.5 1-4.2 2.8a13.1 13.1 0 0 0-2.5 3.6 15.5 15.5 0 0 0-.4.9 14.7 14.7 0 0 0-.8 3.5 18.7 18.7 0 0 0-.2 2.4 17.6 17.6 0 0 0 0 .7v.8a29.4 29.4 0 0 0 .1.1 19.2 19.2 0 0 0 .2 2 20.2 20.2 0 0 0 .4 1.6 18.6 18.6 0 0 0 0 .2 7.5 7.5 0 0 0 .4.9 6 6 0 0 0 .3.6Z\"\n\t\t\t/>\n\t\t</svg>\n\t)\n}\n", "n_tokens": 3136, "primary_symbol": "Logo", "primary_kind": "function", "primary_span": [1, 18], "def_symbols": ["Logo"], "symbols": ["Logo", "export", "function", "className", "string", "return", "Righteous", "svg", "xmlns", "http", "www", "org", "viewBox", "defs", "linearGradient", "gradient", "stop", "offset", "style", "stopColor", "path", "fill", "url", "M146"], "doc_head": "export function Logo({ className }: { className?: string }) {\n\treturn (\n\t\t// Righteous\n\t\t<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 285 75\" className={className}>\n\t\t\t{/* <defs>\n\t\t\t\t<linearGradient id=\"gradient\" x1=\"0%\" y1=\"20%\" x2=\"100%\" y2=\"120%\">\n\t\t\t\t\t<stop offset=\"0%\" style={{ stopColor: \"#747bff\" }} />\n\t\t\t\t\t<stop offset=\"100%\" style={{ stopColor: \"#24eb5c\" }} />\n\t\t\t\t</linearGradient>\n\t\t\t</defs> */}\n\t\t\t<path\n\t\t\t\t// fill=\"url(#gradient)\"\n\t\t\t\td=\"M146.4 73.1h-30.5V59.8h30.5a3.2 3.2 0 0 0 2.3-1 3.2 3.2 0 0 0 1-2.3q0-.8-.3-1.3a1.5 1.5 0 0 0-.7-.6 4.7 4.7 0 0 0-1-.3l-1.3-.1h-13.9q-3.4 0-6.5-1.3-3-1.3-5.2-3.6a16.9 16.9 0 0 1-3.6-5.3 16.3 16.3 0 0 1-1.3-6.5 16.4 16.4 0 0 1 1.3-6.4q1.3-3.1 3.6-5.4 2.2-2.2 5.2-3.5a16.3 16.3 0 0 1 6.5-1.3h27v13.3h-27a3.2 3.2 0 0 0-2.3 1 3.2 3.2 0 0 0-1 2.3 3.3 3.3 0 0 0 1 2.4 3.3 3.3 0 0 0 1.2.8 3.2 3.2 0 0 0 1.1.2h13.9a18.1 18.1 0 0 1 6 1 17.3 17.3 0 0 1 .4.2q3 1.1 5.3 3.2a15.1 15.1 0 0 1 3.6 4.9 14.7 14.7 0 0 1 1.3 5.4 17.2 17.2 0 0 1 0 .9 16 16 0 0 1-1 5.8 15.4 15.4 0 0 1-.3.7 17.3 17.3 0 0 1-3.6 5.2 16.4 16.4 0 0 1-5.3 3.6 16.2 16.2 0 0 1-6.4 1.3Zm64.5-13.3v13.3h-43.6l22-39h-22V21h43.6l-22 39h22ZM35 73.1H0v-70h35q4.4 0 8.2 1.6a21.4 21.4 0 0 1"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/lang-toggle.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/lang-toggle.tsx", "rel_path": "src/site/src/components/lang-toggle.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 9, "text": "import { LanguagesIcon } from \"lucide-react\"\n\nimport { Button } from \"@/components/ui/button\"\nimport { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from \"@/components/ui/dropdown-menu\"\nimport languages from \"@/lib/languages\"\nimport { cn } from \"@/lib/utils\"\nimport { useLingui } from \"@lingui/react/macro\"\nimport { dynamicActivate } from \"@/lib/i18n\"\n", "n_tokens": 90, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 9], "def_symbols": [], "symbols": ["import", "LanguagesIcon", "from", "lucide", "react", "Button", "components", "button", "DropdownMenu", "DropdownMenuContent", "DropdownMenuItem", "DropdownMenuTrigger", "dropdown", "menu", "languages", "lib", "utils", "useLingui", "lingui", "macro", "dynamicActivate", "i18n"], "doc_head": "import { LanguagesIcon } from \"lucide-react\"\nimport { Button } from \"@/components/ui/button\"\nimport { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from \"@/components/ui/dropdown-menu\"\nimport languages from \"@/lib/languages\"\nimport { cn } from \"@/lib/utils\"\nimport { useLingui } from \"@lingui/react/macro\"\nimport { dynamicActivate } from \"@/lib/i18n\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/lang-toggle.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/lang-toggle.tsx", "rel_path": "src/site/src/components/lang-toggle.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 10, "end_line": 25, "text": "export function LangToggle() {\n\tconst { i18n } = useLingui()\n\n\treturn (\n\t\t<DropdownMenu>\n\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t<Button variant={\"ghost\"} size=\"icon\" className=\"hidden 450:flex\">\n\t\t\t\t\t<LanguagesIcon className=\"absolute h-[1.2rem] w-[1.2rem] light:opacity-85\" />\n\t\t\t\t\t<span className=\"sr-only\">Language</span>\n\t\t\t\t</Button>\n\t\t\t</DropdownMenuTrigger>\n\t\t\t<DropdownMenuContent className=\"grid grid-cols-3\">\n\t\t\t\t{languages.map(({ lang, label, e }) => (\n\t\t\t\t\t<DropdownMenuItem\n\t\t\t\t\t\tkey={lang}\n\t\t\t\t\t\tclassName={cn(\"px-2.5 flex gap-2.5 cursor-pointer\", lang === i18n.locale && \"bg-accent/70 font-medium\")}", "n_tokens": 180, "primary_symbol": "LangToggle", "primary_kind": "function", "primary_span": [10, 25], "def_symbols": ["LangToggle"], "symbols": ["LangToggle", "export", "function", "const", "i18n", "useLingui", "return", "DropdownMenu", "DropdownMenuTrigger", "asChild", "Button", "variant", "ghost", "size", "icon", "className", "hidden", "flex", "LanguagesIcon", "absolute", "light", "opacity", "span", "only", "Language", "DropdownMenuContent", "grid", "cols", "languages", "map", "lang", "label", "DropdownMenuItem", "key", "gap", "cursor", "pointer", "locale", "accent", "font", "medium"], "doc_head": "export function LangToggle() {\n\tconst { i18n } = useLingui()\n\treturn (\n\t\t<DropdownMenu>\n\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t<Button variant={\"ghost\"} size=\"icon\" className=\"hidden 450:flex\">\n\t\t\t\t\t<LanguagesIcon className=\"absolute h-[1.2rem] w-[1.2rem] light:opacity-85\" />\n\t\t\t\t\t<span className=\"sr-only\">Language</span>\n\t\t\t\t</Button>\n\t\t\t</DropdownMenuTrigger>\n\t\t\t<DropdownMenuContent className=\"grid grid-cols-3\">\n\t\t\t\t{languages.map(({ lang, label, e }) => (\n\t\t\t\t\t<DropdownMenuItem\n\t\t\t\t\t\tkey={lang}\n\t\t\t\t\t\tclassName={cn(\"px-2.5 flex gap-2.5 cursor-pointer\", lang === i18n.locale && \"bg-accent/70 font-medium\")}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/lang-toggle.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/lang-toggle.tsx", "rel_path": "src/site/src/components/lang-toggle.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 26, "end_line": 35, "text": "\t\t\t\t\t\tonClick={() => dynamicActivate(lang)}\n\t\t\t\t\t>\n\t\t\t\t\t\t<span>{e}</span> {label}\n\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t))}\n\t\t\t</DropdownMenuContent>\n\t\t</DropdownMenu>\n\t)\n}\n", "n_tokens": 47, "primary_symbol": "", "primary_kind": "", "primary_span": [26, 35], "def_symbols": [], "symbols": ["onClick", "dynamicActivate", "lang", "span", "label", "DropdownMenuItem", "DropdownMenuContent", "DropdownMenu"], "doc_head": "\t\t\t\t\t\tonClick={() => dynamicActivate(lang)}\n\t\t\t\t\t>\n\t\t\t\t\t\t<span>{e}</span> {label}\n\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t))}\n\t\t\t</DropdownMenuContent>\n\t\t</DropdownMenu>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/mode-toggle.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/mode-toggle.tsx", "rel_path": "src/site/src/components/mode-toggle.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 14, "text": "import { t } from \"@lingui/core/macro\"\nimport { MoonStarIcon, SunIcon } from \"lucide-react\"\n\nimport { Button } from \"@/components/ui/button\"\nimport { useTheme } from \"@/components/theme-provider\"\n\nexport function ModeToggle() {\n\tconst { theme, setTheme } = useTheme()\n\n\treturn (\n\t\t<Button\n\t\t\tvariant={\"ghost\"}\n\t\t\tsize=\"icon\"\n\t\t\taria-label={t`Toggle theme`}", "n_tokens": 93, "primary_symbol": "ModeToggle", "primary_kind": "function", "primary_span": [7, 14], "def_symbols": ["ModeToggle"], "symbols": ["ModeToggle", "import", "from", "lingui", "core", "macro", "MoonStarIcon", "SunIcon", "lucide", "react", "Button", "components", "button", "useTheme", "theme", "provider", "export", "function", "const", "setTheme", "return", "variant", "ghost", "size", "icon", "aria", "label", "Toggle"], "doc_head": "import { t } from \"@lingui/core/macro\"\nimport { MoonStarIcon, SunIcon } from \"lucide-react\"\nimport { Button } from \"@/components/ui/button\"\nimport { useTheme } from \"@/components/theme-provider\"\nexport function ModeToggle() {\n\tconst { theme, setTheme } = useTheme()\n\treturn (\n\t\t<Button\n\t\t\tvariant={\"ghost\"}\n\t\t\tsize=\"icon\"\n\t\t\taria-label={t`Toggle theme`}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/mode-toggle.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/mode-toggle.tsx", "rel_path": "src/site/src/components/mode-toggle.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 15, "end_line": 22, "text": "\t\t\tonClick={() => setTheme(theme === \"dark\" ? \"light\" : \"dark\")}\n\t\t>\n\t\t\t<SunIcon className=\"h-[1.2rem] w-[1.2rem] transition-all -rotate-90 dark:opacity-0 dark:rotate-0\" />\n\t\t\t<MoonStarIcon className=\"absolute h-[1.2rem] w-[1.2rem] transition-all opacity-0 -rotate-90 dark:opacity-100 dark:rotate-0\" />\n\t\t</Button>\n\t)\n}\n", "n_tokens": 113, "primary_symbol": "", "primary_kind": "", "primary_span": [15, 22], "def_symbols": [], "symbols": ["onClick", "setTheme", "theme", "dark", "light", "SunIcon", "className", "transition", "all", "rotate", "opacity", "MoonStarIcon", "absolute", "Button"], "doc_head": "\t\t\tonClick={() => setTheme(theme === \"dark\" ? \"light\" : \"dark\")}\n\t\t>\n\t\t\t<SunIcon className=\"h-[1.2rem] w-[1.2rem] transition-all -rotate-90 dark:opacity-0 dark:rotate-0\" />\n\t\t\t<MoonStarIcon className=\"absolute h-[1.2rem] w-[1.2rem] transition-all opacity-0 -rotate-90 dark:opacity-100 dark:rotate-0\" />\n\t\t</Button>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/spinner.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/spinner.tsx", "rel_path": "src/site/src/components/spinner.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 15, "text": "import { cn } from \"@/lib/utils\"\nimport { LoaderCircleIcon } from \"lucide-react\"\n\nexport default function ({ msg, className }: { msg?: string; className?: string }) {\n\treturn (\n\t\t<div className={cn(className, \"flex flex-col items-center justify-center h-full absolute inset-0\")}>\n\t\t\t{msg ? (\n\t\t\t\t<p className={\"opacity-60 mb-2 text-center text-sm px-4\"}>{msg}</p>\n\t\t\t) : (\n\t\t\t\t<LoaderCircleIcon className=\"animate-spin h-10 w-10 opacity-60\" />\n\t\t\t)}\n\t\t</div>\n\t)\n}\n", "n_tokens": 133, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 15], "def_symbols": [], "symbols": ["import", "from", "lib", "utils", "LoaderCircleIcon", "lucide", "react", "export", "default", "function", "msg", "className", "string", "return", "div", "flex", "col", "items", "center", "justify", "full", "absolute", "inset", "opacity", "text", "animate", "spin"], "doc_head": "import { cn } from \"@/lib/utils\"\nimport { LoaderCircleIcon } from \"lucide-react\"\nexport default function ({ msg, className }: { msg?: string; className?: string }) {\n\treturn (\n\t\t<div className={cn(className, \"flex flex-col items-center justify-center h-full absolute inset-0\")}>\n\t\t\t{msg ? (\n\t\t\t\t<p className={\"opacity-60 mb-2 text-center text-sm px-4\"}>{msg}</p>\n\t\t\t) : (\n\t\t\t\t<LoaderCircleIcon className=\"animate-spin h-10 w-10 opacity-60\" />\n\t\t\t)}\n\t\t</div>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/copy-to-clipboard.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/copy-to-clipboard.tsx", "rel_path": "src/site/src/components/copy-to-clipboard.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 6, "text": "import { Trans } from \"@lingui/react/macro\";\nimport { useEffect, useMemo, useRef } from \"react\"\nimport { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from \"./ui/dialog\"\nimport { Textarea } from \"./ui/textarea\"\nimport { $copyContent } from \"@/lib/stores\"\n", "n_tokens": 68, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 6], "def_symbols": [], "symbols": ["import", "Trans", "from", "lingui", "react", "macro", "useEffect", "useMemo", "useRef", "Dialog", "DialogContent", "DialogDescription", "DialogHeader", "DialogTitle", "dialog", "Textarea", "textarea", "copyContent", "lib", "stores"], "doc_head": "import { Trans } from \"@lingui/react/macro\";\nimport { useEffect, useMemo, useRef } from \"react\"\nimport { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from \"./ui/dialog\"\nimport { Textarea } from \"./ui/textarea\"\nimport { $copyContent } from \"@/lib/stores\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/copy-to-clipboard.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/copy-to-clipboard.tsx", "rel_path": "src/site/src/components/copy-to-clipboard.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 7, "end_line": 32, "text": "export default function CopyToClipboard({ content }: { content: string }) {\n\treturn (\n\t\t<Dialog defaultOpen={true}>\n\t\t\t<DialogContent className=\"w-[90%] rounded-lg md:pt-4\" style={{ maxWidth: 530 }}>\n\t\t\t\t<DialogHeader>\n\t\t\t\t\t<DialogTitle>\n\t\t\t\t\t\t<Trans>Copy text</Trans>\n\t\t\t\t\t</DialogTitle>\n\t\t\t\t\t<DialogDescription className=\"hidden xs:block\">\n\t\t\t\t\t\t<Trans>Automatic copy requires a secure context.</Trans>\n\t\t\t\t\t</DialogDescription>\n\t\t\t\t</DialogHeader>\n\t\t\t\t<CopyTextarea content={content} />\n\t\t\t</DialogContent>\n\t\t</Dialog>\n\t)\n}\n\nfunction CopyTextarea({ content }: { content: string }) {\n\tconst textareaRef = useRef<HTMLTextAreaElement>(null)\n\n\tconst rows = useMemo(() => {\n\t\treturn content.split(\"\\n\").length\n\t}, [content])\n\n\tuseEffect(() => {", "n_tokens": 187, "primary_symbol": "CopyTextarea", "primary_kind": "function", "primary_span": [25, 32], "def_symbols": ["CopyTextarea"], "symbols": ["CopyTextarea", "export", "default", "function", "CopyToClipboard", "content", "string", "return", "Dialog", "defaultOpen", "true", "DialogContent", "className", "rounded", "style", "maxWidth", "DialogHeader", "DialogTitle", "Trans", "Copy", "text", "DialogDescription", "hidden", "block", "Automatic", "copy", "requires", "secure", "context", "const", "textareaRef", "useRef", "HTMLTextAreaElement", "null", "rows", "useMemo", "split", "length", "useEffect"], "doc_head": "export default function CopyToClipboard({ content }: { content: string }) {\n\treturn (\n\t\t<Dialog defaultOpen={true}>\n\t\t\t<DialogContent className=\"w-[90%] rounded-lg md:pt-4\" style={{ maxWidth: 530 }}>\n\t\t\t\t<DialogHeader>\n\t\t\t\t\t<DialogTitle>\n\t\t\t\t\t\t<Trans>Copy text</Trans>\n\t\t\t\t\t</DialogTitle>\n\t\t\t\t\t<DialogDescription className=\"hidden xs:block\">\n\t\t\t\t\t\t<Trans>Automatic copy requires a secure context.</Trans>\n\t\t\t\t\t</DialogDescription>\n\t\t\t\t</DialogHeader>\n\t\t\t\t<CopyTextarea content={content} />\n\t\t\t</DialogContent>\n\t\t</Dialog>\n\t)\n}\nfunction CopyTextarea({ content }: { content: string }) {\n\tconst textareaRef = useRef<HTMLTextAreaElement>(null)\n\tconst rows = useMemo(() => {\n\t\treturn content.split(\"\\n\").length\n\t}, [content])\n\tuseEffect(() => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/copy-to-clipboard.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/copy-to-clipboard.tsx", "rel_path": "src/site/src/components/copy-to-clipboard.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 33, "end_line": 52, "text": "\t\tif (textareaRef.current) {\n\t\t\ttextareaRef.current.select()\n\t\t}\n\t}, [textareaRef])\n\n\tuseEffect(() => {\n\t\treturn () => $copyContent.set(\"\")\n\t}, [])\n\n\treturn (\n\t\t<Textarea\n\t\t\tclassName=\"font-mono overflow-hidden whitespace-pre\"\n\t\t\trows={rows}\n\t\t\tvalue={content}\n\t\t\treadOnly\n\t\t\tref={textareaRef}\n\t\t/>\n\t)\n}\n", "n_tokens": 85, "primary_symbol": "", "primary_kind": "", "primary_span": [33, 52], "def_symbols": [], "symbols": ["textareaRef", "current", "select", "useEffect", "return", "copyContent", "set", "Textarea", "className", "font", "mono", "overflow", "hidden", "whitespace", "pre", "rows", "value", "content", "readOnly", "ref"], "doc_head": "\t\tif (textareaRef.current) {\n\t\t\ttextareaRef.current.select()\n\t\t}\n\t}, [textareaRef])\n\tuseEffect(() => {\n\t\treturn () => $copyContent.set(\"\")\n\t}, [])\n\treturn (\n\t\t<Textarea\n\t\t\tclassName=\"font-mono overflow-hidden whitespace-pre\"\n\t\t\trows={rows}\n\t\t\tvalue={content}\n\t\t\treadOnly\n\t\t\tref={textareaRef}\n\t\t/>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx", "rel_path": "src/site/src/components/install-dropdowns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 13, "text": "import { memo } from \"react\"\nimport { DropdownMenuContent, DropdownMenuItem } from \"./ui/dropdown-menu\"\nimport { copyToClipboard, getHubURL } from \"@/lib/utils\"\nimport { i18n } from \"@lingui/core\"\n\n// const isbeta = beszel.hub_version.includes(\"beta\")\n// const imagetag = isbeta ? \":edge\" : \"\"\n\n/**\n * Get the URL of the script to install the agent.\n * @param path - The path to the script (e.g. \"/brew\").\n * @returns The URL for the script.\n */", "n_tokens": 118, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 13], "def_symbols": [], "symbols": ["import", "memo", "from", "react", "DropdownMenuContent", "DropdownMenuItem", "dropdown", "menu", "copyToClipboard", "getHubURL", "lib", "utils", "i18n", "lingui", "core", "const", "isbeta", "beszel", "hub_version", "includes", "beta", "imagetag", "edge", "Get", "the", "URL", "script", "install", "agent", "param", "path", "The", "brew", "returns", "for"], "doc_head": "import { memo } from \"react\"\nimport { DropdownMenuContent, DropdownMenuItem } from \"./ui/dropdown-menu\"\nimport { copyToClipboard, getHubURL } from \"@/lib/utils\"\nimport { i18n } from \"@lingui/core\"\n// const isbeta = beszel.hub_version.includes(\"beta\")\n// const imagetag = isbeta ? \":edge\" : \"\"\n/**\n * Get the URL of the script to install the agent.\n * @param path - The path to the script (e.g. \"/brew\").\n * @returns The URL for the script.\n */"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx", "rel_path": "src/site/src/components/install-dropdowns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 14, "end_line": 24, "text": "const getScriptUrl = (path: string = \"\") => {\n\treturn `https://get.beszel.dev${path}`\n\t// no beta for now\n\t// const url = new URL(\"https://get.beszel.dev\")\n\t// url.pathname = path\n\t// if (isBeta) {\n\t// \turl.searchParams.set(\"beta\", \"1\")\n\t// }\n\t// return url.toString()\n}\n", "n_tokens": 86, "primary_symbol": "getScriptUrl", "primary_kind": "function", "primary_span": [14, 24], "def_symbols": ["getScriptUrl"], "symbols": ["getScriptUrl", "const", "path", "string", "return", "https", "get", "beszel", "dev", "beta", "for", "now", "url", "new", "URL", "pathname", "isBeta", "searchParams", "set", "toString"], "doc_head": "const getScriptUrl = (path: string = \"\") => {\n\treturn `https://get.beszel.dev${path}`\n\t// no beta for now\n\t// const url = new URL(\"https://get.beszel.dev\")\n\t// url.pathname = path\n\t// if (isBeta) {\n\t// \turl.searchParams.set(\"beta\", \"1\")\n\t// }\n\t// return url.toString()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx", "rel_path": "src/site/src/components/install-dropdowns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 25, "end_line": 43, "text": "export function copyDockerCompose(port = \"45876\", publicKey: string, token: string) {\n\tcopyToClipboard(`services:\n  beszel-agent:\n    image: henrygd/beszel-agent\n    container_name: beszel-agent\n    restart: unless-stopped\n    network_mode: host\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - ./beszel_agent_data:/var/lib/beszel-agent\n      # monitor other disks / partitions by mounting a folder in /extra-filesystems\n      # - /mnt/disk/.beszel:/extra-filesystems/sda1:ro\n    environment:\n      LISTEN: ${port}\n      KEY: '${publicKey}'\n      TOKEN: ${token}\n      HUB_URL: ${getHubURL()}`)\n}\n", "n_tokens": 171, "primary_symbol": "copyDockerCompose", "primary_kind": "function", "primary_span": [25, 43], "def_symbols": ["copyDockerCompose"], "symbols": ["copyDockerCompose", "export", "function", "port", "publicKey", "string", "token", "copyToClipboard", "services", "beszel", "agent", "image", "henrygd", "container_name", "restart", "unless", "stopped", "network_mode", "host", "volumes", "var", "run", "docker", "sock", "beszel_agent_data", "lib", "monitor", "other", "disks", "partitions", "mounting", "folder", "extra", "filesystems", "mnt", "disk", "sda1", "environment", "LISTEN", "KEY", "TOKEN", "HUB_URL", "getHubURL"], "doc_head": "export function copyDockerCompose(port = \"45876\", publicKey: string, token: string) {\n\tcopyToClipboard(`services:\n  beszel-agent:\n    image: henrygd/beszel-agent\n    container_name: beszel-agent\n    restart: unless-stopped\n    network_mode: host\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - ./beszel_agent_data:/var/lib/beszel-agent\n      # monitor other disks / partitions by mounting a folder in /extra-filesystems\n      # - /mnt/disk/.beszel:/extra-filesystems/sda1:ro\n    environment:\n      LISTEN: ${port}\n      KEY: '${publicKey}'\n      TOKEN: ${token}\n      HUB_URL: ${getHubURL()}`)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx", "rel_path": "src/site/src/components/install-dropdowns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 44, "end_line": 49, "text": "export function copyDockerRun(port = \"45876\", publicKey: string, token: string) {\n\tcopyToClipboard(\n\t\t`docker run -d --name beszel-agent --network host --restart unless-stopped -v /var/run/docker.sock:/var/run/docker.sock:ro -v ./beszel_agent_data:/var/lib/beszel-agent -e KEY=\"${publicKey}\" -e LISTEN=${port} -e TOKEN=\"${token}\" -e HUB_URL=\"${getHubURL()}\" henrygd/beszel-agent`\n\t)\n}\n", "n_tokens": 115, "primary_symbol": "copyDockerRun", "primary_kind": "function", "primary_span": [44, 49], "def_symbols": ["copyDockerRun"], "symbols": ["copyDockerRun", "export", "function", "port", "publicKey", "string", "token", "copyToClipboard", "docker", "run", "name", "beszel", "agent", "network", "host", "restart", "unless", "stopped", "var", "sock", "beszel_agent_data", "lib", "KEY", "LISTEN", "TOKEN", "HUB_URL", "getHubURL", "henrygd"], "doc_head": "export function copyDockerRun(port = \"45876\", publicKey: string, token: string) {\n\tcopyToClipboard(\n\t\t`docker run -d --name beszel-agent --network host --restart unless-stopped -v /var/run/docker.sock:/var/run/docker.sock:ro -v ./beszel_agent_data:/var/lib/beszel-agent -e KEY=\"${publicKey}\" -e LISTEN=${port} -e TOKEN=\"${token}\" -e HUB_URL=\"${getHubURL()}\" henrygd/beszel-agent`\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx", "rel_path": "src/site/src/components/install-dropdowns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 50, "end_line": 60, "text": "export function copyLinuxCommand(port = \"45876\", publicKey: string, token: string, brew = false) {\n\tlet cmd = `curl -sL ${getScriptUrl(\n\t\tbrew ? \"/brew\" : \"\"\n\t)} -o /tmp/install-agent.sh && chmod +x /tmp/install-agent.sh && /tmp/install-agent.sh -p ${port} -k \"${publicKey}\" -t \"${token}\" -url \"${getHubURL()}\"`\n\t// brew script does not support --china-mirrors\n\tif (!brew && (i18n.locale + navigator.language).includes(\"zh-CN\")) {\n\t\tcmd += ` --china-mirrors`\n\t}\n\tcopyToClipboard(cmd)\n}\n", "n_tokens": 144, "primary_symbol": "copyLinuxCommand", "primary_kind": "function", "primary_span": [50, 60], "def_symbols": ["copyLinuxCommand"], "symbols": ["copyLinuxCommand", "export", "function", "port", "publicKey", "string", "token", "brew", "false", "let", "cmd", "curl", "getScriptUrl", "tmp", "install", "agent", "chmod", "url", "getHubURL", "script", "does", "not", "support", "china", "mirrors", "i18n", "locale", "navigator", "language", "includes", "copyToClipboard"], "doc_head": "export function copyLinuxCommand(port = \"45876\", publicKey: string, token: string, brew = false) {\n\tlet cmd = `curl -sL ${getScriptUrl(\n\t\tbrew ? \"/brew\" : \"\"\n\t)} -o /tmp/install-agent.sh && chmod +x /tmp/install-agent.sh && /tmp/install-agent.sh -p ${port} -k \"${publicKey}\" -t \"${token}\" -url \"${getHubURL()}\"`\n\t// brew script does not support --china-mirrors\n\tif (!brew && (i18n.locale + navigator.language).includes(\"zh-CN\")) {\n\t\tcmd += ` --china-mirrors`\n\t}\n\tcopyToClipboard(cmd)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx", "rel_path": "src/site/src/components/install-dropdowns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 61, "end_line": 76, "text": "export function copyWindowsCommand(port = \"45876\", publicKey: string, token: string) {\n\tcopyToClipboard(\n\t\t`& iwr -useb ${getScriptUrl()} -OutFile \"$env:TEMP\\\\install-agent.ps1\"; & Powershell -ExecutionPolicy Bypass -File \"$env:TEMP\\\\install-agent.ps1\" -Key \"${publicKey}\" -Port ${port} -Token \"${token}\" -Url \"${getHubURL()}\"`\n\t)\n}\n\nexport interface DropdownItem {\n\ttext: string\n\tonClick?: () => void\n\turl?: string\n\ticons?: React.ComponentType<React.SVGProps<SVGSVGElement>>[]\n}\n\nexport const InstallDropdown = memo(({ items }: { items: DropdownItem[] }) => {\n\treturn (\n\t\t<DropdownMenuContent align=\"end\">", "n_tokens": 166, "primary_symbol": "copyWindowsCommand", "primary_kind": "function", "primary_span": [61, 76], "def_symbols": ["copyWindowsCommand"], "symbols": ["copyWindowsCommand", "export", "function", "port", "publicKey", "string", "token", "copyToClipboard", "iwr", "useb", "getScriptUrl", "OutFile", "env", "TEMP", "install", "agent", "ps1", "Powershell", "ExecutionPolicy", "Bypass", "File", "Key", "Port", "Token", "Url", "getHubURL", "interface", "DropdownItem", "text", "onClick", "void", "url", "icons", "React", "ComponentType", "SVGProps", "SVGSVGElement", "const", "InstallDropdown", "memo", "items", "return", "DropdownMenuContent", "align", "end"], "doc_head": "export function copyWindowsCommand(port = \"45876\", publicKey: string, token: string) {\n\tcopyToClipboard(\n\t\t`& iwr -useb ${getScriptUrl()} -OutFile \"$env:TEMP\\\\install-agent.ps1\"; & Powershell -ExecutionPolicy Bypass -File \"$env:TEMP\\\\install-agent.ps1\" -Key \"${publicKey}\" -Port ${port} -Token \"${token}\" -Url \"${getHubURL()}\"`\n\t)\n}\nexport interface DropdownItem {\n\ttext: string\n\tonClick?: () => void\n\turl?: string\n\ticons?: React.ComponentType<React.SVGProps<SVGSVGElement>>[]\n}\nexport const InstallDropdown = memo(({ items }: { items: DropdownItem[] }) => {\n\treturn (\n\t\t<DropdownMenuContent align=\"end\">"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx", "rel_path": "src/site/src/components/install-dropdowns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 77, "end_line": 90, "text": "\t\t\t{items.map((item, index) => {\n\t\t\t\tconst className = \"cursor-pointer flex items-center gap-1.5\"\n\t\t\t\treturn item.url ? (\n\t\t\t\t\t<DropdownMenuItem key={index} asChild>\n\t\t\t\t\t\t<a href={item.url} className={className} target=\"_blank\" rel=\"noopener noreferrer\">\n\t\t\t\t\t\t\t{item.text}{\" \"}\n\t\t\t\t\t\t\t{item.icons?.map((Icon, iconIndex) => (\n\t\t\t\t\t\t\t\t<Icon key={iconIndex} className=\"size-4\" />\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t) : (\n\t\t\t\t\t<DropdownMenuItem key={index} onClick={item.onClick} className={className}>\n\t\t\t\t\t\t{item.text}{\" \"}", "n_tokens": 151, "primary_symbol": "", "primary_kind": "", "primary_span": [77, 90], "def_symbols": [], "symbols": ["items", "map", "item", "index", "const", "className", "cursor", "pointer", "flex", "center", "gap", "return", "url", "DropdownMenuItem", "key", "asChild", "href", "target", "_blank", "rel", "noopener", "noreferrer", "text", "icons", "Icon", "iconIndex", "size", "onClick"], "doc_head": "\t\t\t{items.map((item, index) => {\n\t\t\t\tconst className = \"cursor-pointer flex items-center gap-1.5\"\n\t\t\t\treturn item.url ? (\n\t\t\t\t\t<DropdownMenuItem key={index} asChild>\n\t\t\t\t\t\t<a href={item.url} className={className} target=\"_blank\" rel=\"noopener noreferrer\">\n\t\t\t\t\t\t\t{item.text}{\" \"}\n\t\t\t\t\t\t\t{item.icons?.map((Icon, iconIndex) => (\n\t\t\t\t\t\t\t\t<Icon key={iconIndex} className=\"size-4\" />\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t) : (\n\t\t\t\t\t<DropdownMenuItem key={index} onClick={item.onClick} className={className}>\n\t\t\t\t\t\t{item.text}{\" \"}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/install-dropdowns.tsx", "rel_path": "src/site/src/components/install-dropdowns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 91, "end_line": 100, "text": "\t\t\t\t\t\t{item.icons?.map((Icon, iconIndex) => (\n\t\t\t\t\t\t\t<Icon key={iconIndex} className=\"size-4\" />\n\t\t\t\t\t\t))}\n\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t)\n\t\t\t})}\n\t\t</DropdownMenuContent>\n\t)\n})\n", "n_tokens": 56, "primary_symbol": "", "primary_kind": "", "primary_span": [91, 100], "def_symbols": [], "symbols": ["item", "icons", "map", "Icon", "iconIndex", "key", "className", "size", "DropdownMenuItem", "DropdownMenuContent"], "doc_head": "\t\t\t\t\t\t{item.icons?.map((Icon, iconIndex) => (\n\t\t\t\t\t\t\t<Icon key={iconIndex} className=\"size-4\" />\n\t\t\t\t\t\t))}\n\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t)\n\t\t\t})}\n\t\t</DropdownMenuContent>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx", "rel_path": "src/site/src/components/ui/alert-dialog.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 15, "text": "import * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>", "n_tokens": 98, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 15], "def_symbols": [], "symbols": ["import", "React", "from", "react", "AlertDialogPrimitive", "radix", "alert", "dialog", "lib", "utils", "buttonVariants", "components", "button", "const", "AlertDialog", "Root", "AlertDialogTrigger", "Trigger", "AlertDialogPortal", "Portal", "AlertDialogOverlay", "forwardRef", "ElementRef", "typeof", "Overlay", "ComponentPropsWithoutRef"], "doc_head": "import * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\nconst AlertDialog = AlertDialogPrimitive.Root\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\nconst AlertDialogOverlay = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx", "rel_path": "src/site/src/components/ui/alert-dialog.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 16, "end_line": 30, "text": ">(({ className, ...props }, ref) => (\n\t<AlertDialogPrimitive.Overlay\n\t\tclassName={cn(\n\t\t\t\"fixed inset-0 z-50 bg-black/40 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t\tref={ref}\n\t/>\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Content>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>", "n_tokens": 130, "primary_symbol": "", "primary_kind": "", "primary_span": [16, 30], "def_symbols": [], "symbols": ["className", "props", "ref", "AlertDialogPrimitive", "Overlay", "fixed", "inset", "black", "data", "state", "open", "animate", "closed", "out", "fade", "AlertDialogOverlay", "displayName", "const", "AlertDialogContent", "React", "forwardRef", "ElementRef", "typeof", "Content", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<AlertDialogPrimitive.Overlay\n\t\tclassName={cn(\n\t\t\t\"fixed inset-0 z-50 bg-black/40 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t\tref={ref}\n\t/>\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\nconst AlertDialogContent = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Content>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx", "rel_path": "src/site/src/components/ui/alert-dialog.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 31, "end_line": 45, "text": ">(({ className, ...props }, ref) => (\n\t<AlertDialogPortal>\n\t\t<AlertDialogOverlay />\n\t\t<AlertDialogPrimitive.Content\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-card p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-50% data-[state=closed]:slide-out-to-top-48% data-[state=open]:slide-in-from-left-50% data-[state=open]:slide-in-from-top-48% sm:rounded-lg\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t</AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n", "n_tokens": 228, "primary_symbol": "", "primary_kind": "", "primary_span": [31, 45], "def_symbols": [], "symbols": ["className", "props", "ref", "AlertDialogPortal", "AlertDialogOverlay", "AlertDialogPrimitive", "Content", "fixed", "left", "top", "grid", "full", "max", "translate", "gap", "border", "card", "shadow", "duration", "data", "state", "open", "animate", "closed", "out", "fade", "zoom", "slide", "from", "rounded", "AlertDialogContent", "displayName"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<AlertDialogPortal>\n\t\t<AlertDialogOverlay />\n\t\t<AlertDialogPrimitive.Content\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-card p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-50% data-[state=closed]:slide-out-to-top-48% data-[state=open]:slide-in-from-left-50% data-[state=open]:slide-in-from-top-48% sm:rounded-lg\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t</AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx", "rel_path": "src/site/src/components/ui/alert-dialog.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 46, "end_line": 58, "text": "const AlertDialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\n\t<div className={cn(\"grid gap-2 text-center sm:text-start\", className)} {...props} />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\n\t<div className={cn(\"flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-2\", className)} {...props} />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Title>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>", "n_tokens": 134, "primary_symbol": "AlertDialogHeader", "primary_kind": "function", "primary_span": [46, 58], "def_symbols": ["AlertDialogHeader", "AlertDialogFooter"], "symbols": ["AlertDialogHeader", "AlertDialogFooter", "const", "className", "props", "React", "HTMLAttributes", "HTMLDivElement", "div", "grid", "gap", "text", "center", "start", "displayName", "flex", "col", "reverse", "row", "justify", "end", "AlertDialogTitle", "forwardRef", "ElementRef", "typeof", "AlertDialogPrimitive", "Title", "ComponentPropsWithoutRef"], "doc_head": "const AlertDialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\n\t<div className={cn(\"grid gap-2 text-center sm:text-start\", className)} {...props} />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\nconst AlertDialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\n\t<div className={cn(\"flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-2\", className)} {...props} />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\nconst AlertDialogTitle = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Title>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx", "rel_path": "src/site/src/components/ui/alert-dialog.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 59, "end_line": 74, "text": ">(({ className, ...props }, ref) => (\n\t<AlertDialogPrimitive.Title ref={ref} className={cn(\"text-lg font-semibold\", className)} {...props} />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Description>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n\t<AlertDialogPrimitive.Description ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\n))\nAlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Action>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>", "n_tokens": 148, "primary_symbol": "", "primary_kind": "", "primary_span": [59, 74], "def_symbols": [], "symbols": ["className", "props", "ref", "AlertDialogPrimitive", "Title", "text", "font", "semibold", "AlertDialogTitle", "displayName", "const", "AlertDialogDescription", "React", "forwardRef", "ElementRef", "typeof", "Description", "ComponentPropsWithoutRef", "muted", "foreground", "AlertDialogAction", "Action"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<AlertDialogPrimitive.Title ref={ref} className={cn(\"text-lg font-semibold\", className)} {...props} />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\nconst AlertDialogDescription = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Description>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n\t<AlertDialogPrimitive.Description ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\n))\nAlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName\nconst AlertDialogAction = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Action>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert-dialog.tsx", "rel_path": "src/site/src/components/ui/alert-dialog.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 75, "end_line": 105, "text": ">(({ className, ...props }, ref) => (\n\t<AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n\t<AlertDialogPrimitive.Cancel\n\t\tref={ref}\n\t\tclassName={cn(buttonVariants({ variant: \"outline\" }), \"mt-2 sm:mt-0\", className)}\n\t\t{...props}\n\t/>\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n\tAlertDialog,\n\tAlertDialogPortal,\n\tAlertDialogOverlay,\n\tAlertDialogTrigger,\n\tAlertDialogContent,\n\tAlertDialogHeader,\n\tAlertDialogFooter,\n\tAlertDialogTitle,\n\tAlertDialogDescription,\n\tAlertDialogAction,\n\tAlertDialogCancel,\n}\n", "n_tokens": 183, "primary_symbol": "", "primary_kind": "", "primary_span": [75, 105], "def_symbols": [], "symbols": ["className", "props", "ref", "AlertDialogPrimitive", "Action", "buttonVariants", "AlertDialogAction", "displayName", "const", "AlertDialogCancel", "React", "forwardRef", "ElementRef", "typeof", "Cancel", "ComponentPropsWithoutRef", "variant", "outline", "export", "AlertDialog", "AlertDialogPortal", "AlertDialogOverlay", "AlertDialogTrigger", "AlertDialogContent", "AlertDialogHeader", "AlertDialogFooter", "AlertDialogTitle", "AlertDialogDescription"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\nconst AlertDialogCancel = React.forwardRef<\n\tReact.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n\tReact.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n\t<AlertDialogPrimitive.Cancel\n\t\tref={ref}\n\t\tclassName={cn(buttonVariants({ variant: \"outline\" }), \"mt-2 sm:mt-0\", className)}\n\t\t{...props}\n\t/>\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\nexport {\n\tAlertDialog,\n\tAlertDialogPortal,\n\tAlertDialogOverlay,\n\tAlertDialogTrigger,\n\tAlertDialogContent,\n\tAlertDialogHeader,\n\tAlertDialogFooter,\n\tAlertDialogTitle,\n\tAlertDialogDescription,\n\tAlertDialogAction,\n\tAlertDialogCancel,\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tabs.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tabs.tsx", "rel_path": "src/site/src/components/ui/tabs.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 25, "text": "import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Tabs = TabsPrimitive.Root\n\nconst TabsList = React.forwardRef<\n\tReact.ElementRef<typeof TabsPrimitive.List>,\n\tReact.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\n>(({ className, ...props }, ref) => (\n\t<TabsPrimitive.List\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nTabsList.displayName = TabsPrimitive.List.displayName\n\nconst TabsTrigger = React.forwardRef<\n\tReact.ElementRef<typeof TabsPrimitive.Trigger>,\n\tReact.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>", "n_tokens": 170, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 25], "def_symbols": [], "symbols": ["import", "React", "from", "react", "TabsPrimitive", "radix", "tabs", "lib", "utils", "const", "Tabs", "Root", "TabsList", "forwardRef", "ElementRef", "typeof", "List", "ComponentPropsWithoutRef", "className", "props", "ref", "inline", "flex", "items", "center", "justify", "rounded", "muted", "text", "foreground", "displayName", "TabsTrigger", "Trigger"], "doc_head": "import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\nimport { cn } from \"@/lib/utils\"\nconst Tabs = TabsPrimitive.Root\nconst TabsList = React.forwardRef<\n\tReact.ElementRef<typeof TabsPrimitive.List>,\n\tReact.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\n>(({ className, ...props }, ref) => (\n\t<TabsPrimitive.List\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nTabsList.displayName = TabsPrimitive.List.displayName\nconst TabsTrigger = React.forwardRef<\n\tReact.ElementRef<typeof TabsPrimitive.Trigger>,\n\tReact.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tabs.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tabs.tsx", "rel_path": "src/site/src/components/ui/tabs.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 26, "end_line": 40, "text": ">(({ className, ...props }, ref) => (\n\t<TabsPrimitive.Trigger\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-xs cursor-pointer\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\n\nconst TabsContent = React.forwardRef<\n\tReact.ElementRef<typeof TabsPrimitive.Content>,\n\tReact.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>", "n_tokens": 172, "primary_symbol": "", "primary_kind": "", "primary_span": [26, 40], "def_symbols": [], "symbols": ["className", "props", "ref", "TabsPrimitive", "Trigger", "inline", "flex", "items", "center", "justify", "whitespace", "nowrap", "rounded", "text", "font", "medium", "ring", "offset", "background", "transition", "all", "focus", "visible", "outline", "hidden", "disabled", "pointer", "events", "none", "opacity", "data", "state", "active", "foreground", "shadow", "cursor", "TabsTrigger", "displayName", "const", "TabsContent", "React", "forwardRef", "ElementRef", "typeof", "Content", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<TabsPrimitive.Trigger\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-xs cursor-pointer\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\nconst TabsContent = React.forwardRef<\n\tReact.ElementRef<typeof TabsPrimitive.Content>,\n\tReact.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tabs.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tabs.tsx", "rel_path": "src/site/src/components/ui/tabs.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 41, "end_line": 54, "text": ">(({ className, ...props }, ref) => (\n\t<TabsPrimitive.Content\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"mt-2 ring-offset-background focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nTabsContent.displayName = TabsPrimitive.Content.displayName\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n", "n_tokens": 97, "primary_symbol": "", "primary_kind": "", "primary_span": [41, 54], "def_symbols": [], "symbols": ["className", "props", "ref", "TabsPrimitive", "Content", "ring", "offset", "background", "focus", "visible", "outline", "hidden", "TabsContent", "displayName", "export", "Tabs", "TabsList", "TabsTrigger"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<TabsPrimitive.Content\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"mt-2 ring-offset-background focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nTabsContent.displayName = TabsPrimitive.Content.displayName\nexport { Tabs, TabsList, TabsTrigger, TabsContent }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/card.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/card.tsx", "rel_path": "src/site/src/components/ui/card.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 19, "text": "import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (\n\t<div\n\t\tref={ref}\n\t\tclassName={cn(\"rounded-lg border border-border/60 bg-card text-card-foreground shadow-xs\", className)}\n\t\t{...props}\n\t/>\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\n\t({ className, ...props }, ref) => <div ref={ref} className={cn(\"grid gap-1.5 p-6\", className)} {...props} />\n)\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(", "n_tokens": 167, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 19], "def_symbols": [], "symbols": ["import", "React", "from", "react", "lib", "utils", "const", "Card", "forwardRef", "HTMLDivElement", "HTMLAttributes", "className", "props", "ref", "div", "rounded", "border", "card", "text", "foreground", "shadow", "displayName", "CardHeader", "grid", "gap", "CardTitle", "HTMLParagraphElement", "HTMLHeadingElement"], "doc_head": "import * as React from \"react\"\nimport { cn } from \"@/lib/utils\"\nconst Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (\n\t<div\n\t\tref={ref}\n\t\tclassName={cn(\"rounded-lg border border-border/60 bg-card text-card-foreground shadow-xs\", className)}\n\t\t{...props}\n\t/>\n))\nCard.displayName = \"Card\"\nconst CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\n\t({ className, ...props }, ref) => <div ref={ref} className={cn(\"grid gap-1.5 p-6\", className)} {...props} />\n)\nCardHeader.displayName = \"CardHeader\"\nconst CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/card.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/card.tsx", "rel_path": "src/site/src/components/ui/card.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 20, "end_line": 38, "text": "\t({ className, ...props }, ref) => (\n\t\t<h3 ref={ref} className={cn(\"text-2xl font-semibold leading-none tracking-tight\", className)} {...props} />\n\t)\n)\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<p ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\n\t)\n)\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\n\t({ className, ...props }, ref) => <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n)\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(", "n_tokens": 188, "primary_symbol": "", "primary_kind": "", "primary_span": [20, 38], "def_symbols": [], "symbols": ["className", "props", "ref", "text", "font", "semibold", "leading", "none", "tracking", "tight", "CardTitle", "displayName", "const", "CardDescription", "React", "forwardRef", "HTMLParagraphElement", "HTMLAttributes", "muted", "foreground", "CardContent", "HTMLDivElement", "div", "CardFooter"], "doc_head": "\t({ className, ...props }, ref) => (\n\t\t<h3 ref={ref} className={cn(\"text-2xl font-semibold leading-none tracking-tight\", className)} {...props} />\n\t)\n)\nCardTitle.displayName = \"CardTitle\"\nconst CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<p ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\n\t)\n)\nCardDescription.displayName = \"CardDescription\"\nconst CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\n\t({ className, ...props }, ref) => <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n)\nCardContent.displayName = \"CardContent\"\nconst CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/card.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/card.tsx", "rel_path": "src/site/src/components/ui/card.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 39, "end_line": 44, "text": "\t({ className, ...props }, ref) => <div ref={ref} className={cn(\"flex items-center p-6 pt-0\", className)} {...props} />\n)\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n", "n_tokens": 64, "primary_symbol": "", "primary_kind": "", "primary_span": [39, 44], "def_symbols": [], "symbols": ["className", "props", "ref", "div", "flex", "items", "center", "CardFooter", "displayName", "export", "Card", "CardHeader", "CardTitle", "CardDescription", "CardContent"], "doc_head": "\t({ className, ...props }, ref) => <div ref={ref} className={cn(\"flex items-center p-6 pt-0\", className)} {...props} />\n)\nCardFooter.displayName = \"CardFooter\"\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/slider.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/slider.tsx", "rel_path": "src/site/src/components/ui/slider.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 8, "text": "import * as React from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Slider = React.forwardRef<\n\tReact.ElementRef<typeof SliderPrimitive.Root>,\n\tReact.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>", "n_tokens": 57, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 8], "def_symbols": [], "symbols": ["import", "React", "from", "react", "SliderPrimitive", "radix", "slider", "lib", "utils", "const", "Slider", "forwardRef", "ElementRef", "typeof", "Root", "ComponentPropsWithoutRef"], "doc_head": "import * as React from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\nimport { cn } from \"@/lib/utils\"\nconst Slider = React.forwardRef<\n\tReact.ElementRef<typeof SliderPrimitive.Root>,\n\tReact.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/slider.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/slider.tsx", "rel_path": "src/site/src/components/ui/slider.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 9, "end_line": 24, "text": ">(({ className, ...props }, ref) => (\n\t<SliderPrimitive.Root\n\t\tref={ref}\n\t\tclassName={cn(\"relative flex w-full touch-none select-none items-center\", className)}\n\t\t{...props}\n\t>\n\t\t<SliderPrimitive.Track className=\"relative h-2 w-full grow overflow-hidden rounded-full bg-secondary\">\n\t\t\t<SliderPrimitive.Range className=\"absolute h-full bg-primary\" />\n\t\t</SliderPrimitive.Track>\n\t\t<SliderPrimitive.Thumb className=\"block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\" />\n\t</SliderPrimitive.Root>\n))\nSlider.displayName = SliderPrimitive.Root.displayName\n\nexport default Slider\n", "n_tokens": 176, "primary_symbol": "", "primary_kind": "", "primary_span": [9, 24], "def_symbols": [], "symbols": ["className", "props", "ref", "SliderPrimitive", "Root", "relative", "flex", "full", "touch", "none", "select", "items", "center", "Track", "grow", "overflow", "hidden", "rounded", "secondary", "Range", "absolute", "primary", "Thumb", "block", "border", "background", "ring", "offset", "transition", "colors", "focus", "visible", "outline", "disabled", "pointer", "events", "opacity", "Slider", "displayName", "export", "default"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<SliderPrimitive.Root\n\t\tref={ref}\n\t\tclassName={cn(\"relative flex w-full touch-none select-none items-center\", className)}\n\t\t{...props}\n\t>\n\t\t<SliderPrimitive.Track className=\"relative h-2 w-full grow overflow-hidden rounded-full bg-secondary\">\n\t\t\t<SliderPrimitive.Range className=\"absolute h-full bg-primary\" />\n\t\t</SliderPrimitive.Track>\n\t\t<SliderPrimitive.Thumb className=\"block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\" />\n\t</SliderPrimitive.Root>\n))\nSlider.displayName = SliderPrimitive.Root.displayName\nexport default Slider"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-tags.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-tags.tsx", "rel_path": "src/site/src/components/ui/input-tags.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 18, "text": "import * as React from \"react\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { Button } from \"@/components/ui/button\"\nimport { XIcon } from \"lucide-react\"\nimport { type InputProps } from \"./input\"\nimport { cn } from \"@/lib/utils\"\n\ntype InputTagsProps = Omit<InputProps, \"value\" | \"onChange\"> & {\n\tvalue: string[]\n\tonChange: React.Dispatch<React.SetStateAction<string[]>>\n}\n\nconst InputTags = React.forwardRef<HTMLInputElement, InputTagsProps>(\n\t({ className, value, onChange, ...props }, ref) => {\n\t\tconst [pendingDataPoint, setPendingDataPoint] = React.useState(\"\")\n\n\t\tReact.useEffect(() => {\n\t\t\tif (pendingDataPoint.includes(\",\")) {", "n_tokens": 159, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 18], "def_symbols": [], "symbols": ["import", "React", "from", "react", "Badge", "components", "badge", "Button", "button", "XIcon", "lucide", "type", "InputProps", "input", "lib", "utils", "InputTagsProps", "Omit", "value", "onChange", "string", "Dispatch", "SetStateAction", "const", "InputTags", "forwardRef", "HTMLInputElement", "className", "props", "ref", "pendingDataPoint", "setPendingDataPoint", "useState", "useEffect", "includes"], "doc_head": "import * as React from \"react\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { Button } from \"@/components/ui/button\"\nimport { XIcon } from \"lucide-react\"\nimport { type InputProps } from \"./input\"\nimport { cn } from \"@/lib/utils\"\ntype InputTagsProps = Omit<InputProps, \"value\" | \"onChange\"> & {\n\tvalue: string[]\n\tonChange: React.Dispatch<React.SetStateAction<string[]>>\n}\nconst InputTags = React.forwardRef<HTMLInputElement, InputTagsProps>(\n\t({ className, value, onChange, ...props }, ref) => {\n\t\tconst [pendingDataPoint, setPendingDataPoint] = React.useState(\"\")\n\t\tReact.useEffect(() => {\n\t\t\tif (pendingDataPoint.includes(\",\")) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-tags.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-tags.tsx", "rel_path": "src/site/src/components/ui/input-tags.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 19, "end_line": 25, "text": "\t\t\t\tconst newDataPoints = new Set([...value, ...pendingDataPoint.split(\",\").map((chunk) => chunk.trim())])\n\t\t\t\tonChange(Array.from(newDataPoints))\n\t\t\t\tsetPendingDataPoint(\"\")\n\t\t\t}\n\t\t}, [pendingDataPoint, onChange, value])\n\n\t\tconst addPendingDataPoint = () => {", "n_tokens": 65, "primary_symbol": "addPendingDataPoint", "primary_kind": "function", "primary_span": [19, 25], "def_symbols": ["addPendingDataPoint"], "symbols": ["addPendingDataPoint", "const", "newDataPoints", "new", "Set", "value", "pendingDataPoint", "split", "map", "chunk", "trim", "onChange", "Array", "from", "setPendingDataPoint"], "doc_head": "\t\t\t\tconst newDataPoints = new Set([...value, ...pendingDataPoint.split(\",\").map((chunk) => chunk.trim())])\n\t\t\t\tonChange(Array.from(newDataPoints))\n\t\t\t\tsetPendingDataPoint(\"\")\n\t\t\t}\n\t\t}, [pendingDataPoint, onChange, value])\n\t\tconst addPendingDataPoint = () => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-tags.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-tags.tsx", "rel_path": "src/site/src/components/ui/input-tags.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 26, "end_line": 47, "text": "\t\t\tif (pendingDataPoint) {\n\t\t\t\tconst newDataPoints = new Set([...value, pendingDataPoint])\n\t\t\t\tonChange(Array.from(newDataPoints))\n\t\t\t\tsetPendingDataPoint(\"\")\n\t\t\t}\n\t\t}\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"bg-background min-h-10 flex w-full flex-wrap gap-2 rounded-md border px-3 py-2 text-sm  placeholder:text-muted-foreground has-focus-visible:outline-hidden ring-offset-background has-focus-visible:ring-2 has-focus-visible:ring-ring has-focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t>\n\t\t\t\t{value.map((item) => (\n\t\t\t\t\t<Badge key={item}>\n\t\t\t\t\t\t{item}\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\tclassName=\"ms-2 h-3 w-3\"\n\t\t\t\t\t\t\tonClick={() => {", "n_tokens": 195, "primary_symbol": "", "primary_kind": "", "primary_span": [26, 47], "def_symbols": [], "symbols": ["pendingDataPoint", "const", "newDataPoints", "new", "Set", "value", "onChange", "Array", "from", "setPendingDataPoint", "return", "div", "className", "background", "min", "flex", "full", "wrap", "gap", "rounded", "border", "text", "placeholder", "muted", "foreground", "has", "focus", "visible", "outline", "hidden", "ring", "offset", "disabled", "cursor", "not", "allowed", "opacity", "map", "item", "Badge", "key", "Button", "variant", "ghost", "size", "icon", "onClick"], "doc_head": "\t\t\tif (pendingDataPoint) {\n\t\t\t\tconst newDataPoints = new Set([...value, pendingDataPoint])\n\t\t\t\tonChange(Array.from(newDataPoints))\n\t\t\t\tsetPendingDataPoint(\"\")\n\t\t\t}\n\t\t}\n\t\treturn (\n\t\t\t<div\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"bg-background min-h-10 flex w-full flex-wrap gap-2 rounded-md border px-3 py-2 text-sm  placeholder:text-muted-foreground has-focus-visible:outline-hidden ring-offset-background has-focus-visible:ring-2 has-focus-visible:ring-ring has-focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t>\n\t\t\t\t{value.map((item) => (\n\t\t\t\t\t<Badge key={item}>\n\t\t\t\t\t\t{item}\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\tclassName=\"ms-2 h-3 w-3\"\n\t\t\t\t\t\t\tonClick={() => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-tags.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-tags.tsx", "rel_path": "src/site/src/components/ui/input-tags.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 48, "end_line": 77, "text": "\t\t\t\t\t\t\t\tonChange(value.filter((i) => i !== item))\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<XIcon className=\"w-3\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</Badge>\n\t\t\t\t))}\n\t\t\t\t<input\n\t\t\t\t\tclassName=\"flex-1 outline-hidden bg-background placeholder:text-muted-foreground\"\n\t\t\t\t\tvalue={pendingDataPoint}\n\t\t\t\t\tonChange={(e) => setPendingDataPoint(e.target.value)}\n\t\t\t\t\tonKeyDown={(e) => {\n\t\t\t\t\t\tif (e.key === \"Enter\" || e.key === \",\") {\n\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t\taddPendingDataPoint()\n\t\t\t\t\t\t} else if (e.key === \"Backspace\" && pendingDataPoint.length === 0 && value.length > 0) {\n\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t\tonChange(value.slice(0, -1))\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t\t{...props}\n\t\t\t\t\tref={ref}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t)\n\t}\n)\n\nInputTags.displayName = \"InputTags\"\n", "n_tokens": 199, "primary_symbol": "", "primary_kind": "", "primary_span": [48, 77], "def_symbols": [], "symbols": ["onChange", "value", "filter", "item", "XIcon", "className", "Button", "Badge", "input", "flex", "outline", "hidden", "background", "placeholder", "text", "muted", "foreground", "pendingDataPoint", "setPendingDataPoint", "target", "onKeyDown", "key", "Enter", "preventDefault", "addPendingDataPoint", "else", "Backspace", "length", "slice", "props", "ref", "div", "InputTags", "displayName"], "doc_head": "\t\t\t\t\t\t\t\tonChange(value.filter((i) => i !== item))\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<XIcon className=\"w-3\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</Badge>\n\t\t\t\t))}\n\t\t\t\t<input\n\t\t\t\t\tclassName=\"flex-1 outline-hidden bg-background placeholder:text-muted-foreground\"\n\t\t\t\t\tvalue={pendingDataPoint}\n\t\t\t\t\tonChange={(e) => setPendingDataPoint(e.target.value)}\n\t\t\t\t\tonKeyDown={(e) => {\n\t\t\t\t\t\tif (e.key === \"Enter\" || e.key === \",\") {\n\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t\taddPendingDataPoint()\n\t\t\t\t\t\t} else if (e.key === \"Backspace\" && pendingDataPoint.length === 0 && value.length > 0) {\n\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t\tonChange(value.slice(0, -1))\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t\t{...props}\n\t\t\t\t\tref={ref}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t)\n\t}\n)\nInputTags.displayName = \"InputTags\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-tags.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-tags.tsx", "rel_path": "src/site/src/components/ui/input-tags.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 78, "end_line": 79, "text": "export { InputTags }\n", "n_tokens": 5, "primary_symbol": "", "primary_kind": "", "primary_span": [78, 79], "def_symbols": [], "symbols": ["export", "InputTags"], "doc_head": "export { InputTags }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toaster.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toaster.tsx", "rel_path": "src/site/src/components/ui/toaster.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 25, "text": "import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from \"@/components/ui/toast\"\nimport { useToast } from \"@/components/ui/use-toast\"\n\nexport function Toaster() {\n\tconst { toasts } = useToast()\n\n\treturn (\n\t\t<ToastProvider>\n\t\t\t{toasts.map(function ({ id, title, description, action, ...props }) {\n\t\t\t\treturn (\n\t\t\t\t\t<Toast key={id} {...props}>\n\t\t\t\t\t\t<div className=\"grid gap-1\">\n\t\t\t\t\t\t\t{title && <ToastTitle>{title}</ToastTitle>}\n\t\t\t\t\t\t\t{description && <ToastDescription>{description}</ToastDescription>}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t{action}\n\t\t\t\t\t\t<ToastClose />\n\t\t\t\t\t</Toast>\n\t\t\t\t)\n\t\t\t})}\n\t\t\t<ToastViewport />\n\t\t</ToastProvider>\n\t)\n}\n", "n_tokens": 175, "primary_symbol": "Toaster", "primary_kind": "function", "primary_span": [4, 25], "def_symbols": ["Toaster"], "symbols": ["Toaster", "import", "Toast", "ToastClose", "ToastDescription", "ToastProvider", "ToastTitle", "ToastViewport", "from", "components", "toast", "useToast", "use", "export", "function", "const", "toasts", "return", "map", "title", "description", "action", "props", "key", "div", "className", "grid", "gap"], "doc_head": "import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from \"@/components/ui/toast\"\nimport { useToast } from \"@/components/ui/use-toast\"\nexport function Toaster() {\n\tconst { toasts } = useToast()\n\treturn (\n\t\t<ToastProvider>\n\t\t\t{toasts.map(function ({ id, title, description, action, ...props }) {\n\t\t\t\treturn (\n\t\t\t\t\t<Toast key={id} {...props}>\n\t\t\t\t\t\t<div className=\"grid gap-1\">\n\t\t\t\t\t\t\t{title && <ToastTitle>{title}</ToastTitle>}\n\t\t\t\t\t\t\t{description && <ToastDescription>{description}</ToastDescription>}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t{action}\n\t\t\t\t\t\t<ToastClose />\n\t\t\t\t\t</Toast>\n\t\t\t\t)\n\t\t\t})}\n\t\t\t<ToastViewport />\n\t\t</ToastProvider>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 11, "text": "import * as React from \"react\"\nimport * as RechartsPrimitive from \"recharts\"\n\nimport { chartTimeData, cn } from \"@/lib/utils\"\nimport { ChartData } from \"@/types\"\n\nimport type { JSX } from \"react\"\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: \"\", dark: \".dark\" } as const\n", "n_tokens": 77, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 11], "def_symbols": [], "symbols": ["import", "React", "from", "react", "RechartsPrimitive", "recharts", "chartTimeData", "lib", "utils", "ChartData", "types", "type", "JSX", "Format", "THEME_NAME", "CSS_SELECTOR", "const", "THEMES", "light", "dark"], "doc_head": "import * as React from \"react\"\nimport * as RechartsPrimitive from \"recharts\"\nimport { chartTimeData, cn } from \"@/lib/utils\"\nimport { ChartData } from \"@/types\"\nimport type { JSX } from \"react\"\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: \"\", dark: \".dark\" } as const"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 12, "end_line": 40, "text": "export type ChartConfig = {\n\t[k in string]: {\n\t\tlabel?: React.ReactNode\n\t\ticon?: React.ComponentType\n\t} & ({ color?: string; theme?: never } | { color?: never; theme: Record<keyof typeof THEMES, string> })\n}\n\n// type ChartContextProps = {\n// \tconfig: ChartConfig\n// }\n\n// const ChartContext = React.createContext<ChartContextProps | null>(null)\n\n// function useChart() {\n// \tconst context = React.useContext(ChartContext)\n\n// \tif (!context) {\n// \t\tthrow new Error('useChart must be used within a <ChartContainer />')\n// \t}\n\n// \treturn context\n// }\n\nconst ChartContainer = React.forwardRef<\n\tHTMLDivElement,\n\tReact.ComponentProps<\"div\"> & {\n\t\t// config: ChartConfig\n\t\tchildren: React.ComponentProps<typeof RechartsPrimitive.ResponsiveContainer>[\"children\"]\n\t}", "n_tokens": 192, "primary_symbol": "", "primary_kind": "", "primary_span": [12, 40], "def_symbols": [], "symbols": ["export", "type", "ChartConfig", "string", "label", "React", "ReactNode", "icon", "ComponentType", "color", "theme", "never", "Record", "keyof", "typeof", "THEMES", "ChartContextProps", "config", "const", "ChartContext", "createContext", "null", "function", "useChart", "context", "useContext", "throw", "new", "Error", "must", "used", "within", "ChartContainer", "return", "forwardRef", "HTMLDivElement", "ComponentProps", "div", "children", "RechartsPrimitive", "ResponsiveContainer"], "doc_head": "export type ChartConfig = {\n\t[k in string]: {\n\t\tlabel?: React.ReactNode\n\t\ticon?: React.ComponentType\n\t} & ({ color?: string; theme?: never } | { color?: never; theme: Record<keyof typeof THEMES, string> })\n}\n// type ChartContextProps = {\n// \tconfig: ChartConfig\n// }\n// const ChartContext = React.createContext<ChartContextProps | null>(null)\n// function useChart() {\n// \tconst context = React.useContext(ChartContext)\n// \tif (!context) {\n// \t\tthrow new Error('useChart must be used within a <ChartContainer />')\n// \t}\n// \treturn context\n// }\nconst ChartContainer = React.forwardRef<\n\tHTMLDivElement,\n\tReact.ComponentProps<\"div\"> & {\n\t\t// config: ChartConfig\n\t\tchildren: React.ComponentProps<typeof RechartsPrimitive.ResponsiveContainer>[\"children\"]\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 41, "end_line": 106, "text": ">(({ id, className, children, ...props }, ref) => {\n\tconst uniqueId = React.useId()\n\tconst chartId = `chart-${id || uniqueId.replace(/:/g, \"\")}`\n\n\treturn (\n\t\t//<ChartContext.Provider value={{ config }}>\n\t\t//</ChartContext.Provider>\n\t\t<div\n\t\t\tdata-chart={chartId}\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line-line]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-hidden [&_.recharts-surface]:outline-hidden\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{/* <ChartStyle id={chartId} config={config} /> */}\n\t\t\t<RechartsPrimitive.ResponsiveContainer>{children}</RechartsPrimitive.ResponsiveContainer>\n\t\t</div>\n\t)\n})\nChartContainer.displayName = \"Chart\"\n\n// const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {\n// \tconst colorConfig = Object.entries(config).filter(([_, config]) => config.theme || config.color)\n\n// \tif (!colorConfig.length) {\n// \t\treturn null\n// \t}\n\n// \treturn (\n// \t\t<style\n// \t\t\tdangerouslySetInnerHTML={{\n// \t\t\t\t__html: Object.entries(THEMES).map(\n// \t\t\t\t\t([theme, prefix]) => `\n// ${prefix} [data-chart=${id}] {\n// ${colorConfig\n// \t.map(([key, itemConfig]) => {\n// \t\tconst color = itemConfig.theme?.[theme as keyof typeof itemConfig.theme] || itemConfig.color\n// \t\treturn color ? `  --color-${key}: ${color};` : null\n// \t})\n// \t.join('\\n')}\n// }\n// `\n// \t\t\t\t),\n// \t\t\t}}\n// \t\t/>\n// \t)\n// }\n\nconst ChartTooltip = RechartsPrimitive.Tooltip\n\nconst ChartTooltipContent = React.forwardRef<\n\tHTMLDivElement,\n\tReact.ComponentProps<typeof RechartsPrimitive.Tooltip> &\n\t\tReact.ComponentProps<\"div\"> & {\n\t\t\thideLabel?: boolean\n\t\t\tindicator?: \"line\" | \"dot\" | \"dashed\"\n\t\t\tnameKey?: string\n\t\t\tlabelKey?: string\n\t\t\tunit?: string\n\t\t\tfilter?: string\n\t\t\tcontentFormatter?: (item: any, key: string) => React.ReactNode | string\n\t\t\ttruncate?: boolean\n\t\t}\n>(", "n_tokens": 624, "primary_symbol": "", "primary_kind": "", "primary_span": [41, 106], "def_symbols": [], "symbols": ["className", "children", "props", "ref", "const", "uniqueId", "React", "useId", "chartId", "chart", "replace", "return", "ChartContext", "Provider", "value", "config", "div", "data", "text", "recharts", "cartesian", "axis", "tick_text", "fill", "muted", "foreground", "grid_line", "stroke", "border", "curve", "tooltip", "cursor", "dot", "fff", "transparent", "layer", "outline", "hidden", "polar", "grid_", "ccc", "radial", "bar", "background", "sector", "rectangle", "reference", "line", "surface", "ChartStyle", "RechartsPrimitive", "ResponsiveContainer", "ChartContainer", "displayName", "Chart", "string", "ChartConfig", "colorConfig", "Object", "entries", "filter", "theme", "color", "length", "null", "style", "dangerouslySetInnerHTML", "__html", "THEMES", "map", "prefix", "key", "itemConfig", "keyof", "typeof", "join", "ChartTooltip", "Tooltip", "ChartTooltipContent", "forwardRef", "HTMLDivElement", "ComponentProps", "hideLabel", "boolean", "indicator", "dashed", "nameKey", "labelKey", "unit", "contentFormatter", "item", "any", "ReactNode", "truncate"], "doc_head": ">(({ id, className, children, ...props }, ref) => {\n\tconst uniqueId = React.useId()\n\tconst chartId = `chart-${id || uniqueId.replace(/:/g, \"\")}`\n\treturn (\n\t\t//<ChartContext.Provider value={{ config }}>\n\t\t//</ChartContext.Provider>\n\t\t<div\n\t\t\tdata-chart={chartId}\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line-line]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-hidden [&_.recharts-surface]:outline-hidden\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{/* <ChartStyle id={chartId} config={config} /> */}\n\t\t\t<RechartsPrimitive.ResponsiveContainer>{children}</RechartsPrimitive.ResponsiveContainer>\n\t\t</div>\n\t)\n})\nChartContainer.displayName = \"Chart\"\n// const ChartStyle = ({ id, config }: { id: string; "}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 107, "end_line": 142, "text": "\t(\n\t\t{\n\t\t\tactive,\n\t\t\tpayload,\n\t\t\tclassName,\n\t\t\tindicator = \"line\",\n\t\t\thideLabel = false,\n\t\t\tlabel,\n\t\t\tlabelFormatter,\n\t\t\tlabelClassName,\n\t\t\tformatter,\n\t\t\tcolor,\n\t\t\tnameKey,\n\t\t\tlabelKey,\n\t\t\tunit,\n\t\t\tfilter,\n\t\t\titemSorter,\n\t\t\tcontentFormatter: content = undefined,\n\t\t\ttruncate = false,\n\t\t},\n\t\tref\n\t) => {\n\t\t// const { config } = useChart()\n\t\tconst config = {}\n\n\t\tReact.useMemo(() => {\n\t\t\tif (filter) {\n\t\t\t\tpayload = payload?.filter((item) => (item.name as string)?.toLowerCase().includes(filter.toLowerCase()))\n\t\t\t}\n\t\t\tif (itemSorter) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tpayload?.sort(itemSorter)\n\t\t\t}\n\t\t}, [itemSorter, payload])\n\n\t\tconst tooltipLabel = React.useMemo(() => {", "n_tokens": 191, "primary_symbol": "", "primary_kind": "", "primary_span": [107, 142], "def_symbols": [], "symbols": ["active", "payload", "className", "indicator", "line", "hideLabel", "false", "label", "labelFormatter", "labelClassName", "formatter", "color", "nameKey", "labelKey", "unit", "filter", "itemSorter", "contentFormatter", "content", "undefined", "truncate", "ref", "const", "config", "useChart", "React", "useMemo", "item", "name", "string", "toLowerCase", "includes", "ignore", "sort", "tooltipLabel"], "doc_head": "\t(\n\t\t{\n\t\t\tactive,\n\t\t\tpayload,\n\t\t\tclassName,\n\t\t\tindicator = \"line\",\n\t\t\thideLabel = false,\n\t\t\tlabel,\n\t\t\tlabelFormatter,\n\t\t\tlabelClassName,\n\t\t\tformatter,\n\t\t\tcolor,\n\t\t\tnameKey,\n\t\t\tlabelKey,\n\t\t\tunit,\n\t\t\tfilter,\n\t\t\titemSorter,\n\t\t\tcontentFormatter: content = undefined,\n\t\t\ttruncate = false,\n\t\t},\n\t\tref\n\t) => {\n\t\t// const { config } = useChart()\n\t\tconst config = {}\n\t\tReact.useMemo(() => {\n\t\t\tif (filter) {\n\t\t\t\tpayload = payload?.filter((item) => (item.name as string)?.toLowerCase().includes(filter.toLowerCase()))\n\t\t\t}\n\t\t\tif (itemSorter) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tpayload?.sort(itemSorter)\n\t\t\t}\n\t\t}, [itemSorter, payload])\n\t\tconst tooltipLabel = React.useMemo(() => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 143, "end_line": 162, "text": "\t\t\tif (hideLabel || !payload?.length) {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\tconst [item] = payload\n\t\t\tconst key = `${labelKey || item.name || \"value\"}`\n\t\t\tconst itemConfig = getPayloadConfigFromPayload(config, item, key)\n\t\t\tconst value = !labelKey && typeof label === \"string\" ? label : itemConfig?.label\n\n\t\t\tif (labelFormatter) {\n\t\t\t\treturn <div className={cn(\"font-medium\", labelClassName)}>{labelFormatter(value, payload)}</div>\n\t\t\t}\n\n\t\t\tif (!value) {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\treturn <div className={cn(\"font-medium\", labelClassName)}>{value}</div>\n\t\t}, [label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey])\n", "n_tokens": 167, "primary_symbol": "", "primary_kind": "", "primary_span": [143, 162], "def_symbols": [], "symbols": ["hideLabel", "payload", "length", "return", "null", "const", "item", "key", "labelKey", "name", "value", "itemConfig", "getPayloadConfigFromPayload", "config", "typeof", "label", "string", "labelFormatter", "div", "className", "font", "medium", "labelClassName"], "doc_head": "\t\t\tif (hideLabel || !payload?.length) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tconst [item] = payload\n\t\t\tconst key = `${labelKey || item.name || \"value\"}`\n\t\t\tconst itemConfig = getPayloadConfigFromPayload(config, item, key)\n\t\t\tconst value = !labelKey && typeof label === \"string\" ? label : itemConfig?.label\n\t\t\tif (labelFormatter) {\n\t\t\t\treturn <div className={cn(\"font-medium\", labelClassName)}>{labelFormatter(value, payload)}</div>\n\t\t\t}\n\t\t\tif (!value) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\treturn <div className={cn(\"font-medium\", labelClassName)}>{value}</div>\n\t\t}, [label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 163, "end_line": 179, "text": "\t\tif (!active || !payload?.length) {\n\t\t\treturn null\n\t\t}\n\n\t\t// const nestLabel = payload.length === 1 && indicator !== 'dot'\n\t\tconst nestLabel = false\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tref={ref}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"grid min-w-28 items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl\",\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t>\n\t\t\t\t{!nestLabel ? tooltipLabel : null}\n\t\t\t\t<div className=\"grid gap-1.5\">", "n_tokens": 132, "primary_symbol": "", "primary_kind": "", "primary_span": [163, 179], "def_symbols": [], "symbols": ["active", "payload", "length", "return", "null", "const", "nestLabel", "indicator", "dot", "false", "div", "ref", "className", "grid", "min", "items", "start", "gap", "rounded", "border", "background", "text", "shadow", "tooltipLabel"], "doc_head": "\t\tif (!active || !payload?.length) {\n\t\t\treturn null\n\t\t}\n\t\t// const nestLabel = payload.length === 1 && indicator !== 'dot'\n\t\tconst nestLabel = false\n\t\treturn (\n\t\t\t<div\n\t\t\t\tref={ref}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"grid min-w-28 items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl\",\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t>\n\t\t\t\t{!nestLabel ? tooltipLabel : null}\n\t\t\t\t<div className=\"grid gap-1.5\">"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 180, "end_line": 258, "text": "\t\t\t\t\t{payload.map((item, index) => {\n\t\t\t\t\t\tconst key = `${nameKey || item.name || item.dataKey || \"value\"}`\n\t\t\t\t\t\tconst itemConfig = getPayloadConfigFromPayload(config, item, key)\n\t\t\t\t\t\tconst indicatorColor = color || item.payload.fill || item.color\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tkey={item?.name || item.dataKey}\n\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\"flex w-full items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground\",\n\t\t\t\t\t\t\t\t\tindicator === \"dot\" && \"items-center\"\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{formatter && item?.value !== undefined && item.name ? (\n\t\t\t\t\t\t\t\t\tformatter(item.value, item.name, item, index, item.payload)\n\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t{itemConfig?.icon ? (\n\t\t\t\t\t\t\t\t\t\t\t<itemConfig.icon />\n\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\t\tclassName={cn(\"shrink-0 rounded-[2px] border-border bg-(--color-bg)\", {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"h-2.5 w-2.5\": indicator === \"dot\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"w-1\": indicator === \"line\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"w-0 border-[1.5px] border-dashed bg-transparent\": indicator === \"dashed\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"my-0.5\": nestLabel && indicator === \"dashed\",\n\t\t\t\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"--color-bg\": indicatorColor,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"--color-border\": indicatorColor,\n\t\t\t\t\t\t\t\t\t\t\t\t\t} as React.CSSProperties\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t\t\"flex flex-1 justify-between leading-none gap-2\",\n\t\t\t\t\t\t\t\t\t\t\t\tnestLabel ? \"items-end\" : \"items-center\"\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{nestLabel ? tooltipLabel : null}\n\t\t\t\t\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"text-muted-foreground\",\n\t\t\t\t\t\t\t\t\t\t\t\t\ttruncate ? \"max-w-40 truncate leading-normal -my-1\" : \"\"\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t{itemConfig?.label || item.name}\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t{item.value !== undefined && (\n\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"font-medium text-foreground\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{content && typeof content === \"function\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? content(item, key)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: item.value.toLocaleString() + (unit ? unit : \"\")}\n\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)\n\t\t\t\t\t})}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t)\n\t}\n)\nChartTooltipContent.displayName = \"ChartTooltip\"\n\nconst ChartLegend = RechartsPrimitive.Legend\n\nconst ChartLegendContent = React.forwardRef<\n\tHTMLDivElement,\n\tReact.ComponentProps<\"div\"> &\n\t\tPick<RechartsPrimitive.LegendProps, \"payload\" | \"verticalAlign\"> & {\n\t\t\thideIcon?: boolean\n\t\t\tnameKey?: string\n\t\t}", "n_tokens": 634, "primary_symbol": "", "primary_kind": "", "primary_span": [180, 258], "def_symbols": [], "symbols": ["payload", "map", "item", "index", "const", "key", "nameKey", "name", "dataKey", "value", "itemConfig", "getPayloadConfigFromPayload", "config", "indicatorColor", "color", "fill", "return", "div", "className", "flex", "full", "items", "stretch", "gap", "svg", "text", "muted", "foreground", "indicator", "dot", "center", "formatter", "undefined", "icon", "shrink", "rounded", "border", "line", "dashed", "transparent", "nestLabel", "style", "React", "CSSProperties", "justify", "between", "leading", "none", "end", "tooltipLabel", "null", "span", "truncate", "max", "normal", "label", "font", "medium", "content", "typeof", "function", "toLocaleString", "unit", "ChartTooltipContent", "displayName", "ChartTooltip", "ChartLegend", "RechartsPrimitive", "Legend", "ChartLegendContent", "forwardRef", "HTMLDivElement", "ComponentProps", "Pick", "LegendProps", "verticalAlign", "hideIcon", "boolean", "string"], "doc_head": "\t\t\t\t\t{payload.map((item, index) => {\n\t\t\t\t\t\tconst key = `${nameKey || item.name || item.dataKey || \"value\"}`\n\t\t\t\t\t\tconst itemConfig = getPayloadConfigFromPayload(config, item, key)\n\t\t\t\t\t\tconst indicatorColor = color || item.payload.fill || item.color\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tkey={item?.name || item.dataKey}\n\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\"flex w-full items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground\",\n\t\t\t\t\t\t\t\t\tindicator === \"dot\" && \"items-center\"\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{formatter && item?.value !== undefined && item.name ? (\n\t\t\t\t\t\t\t\t\tformatter(item.value, item.name, item, index, item.payload)\n\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t{itemConfig?.icon ? (\n\t\t\t\t\t\t\t\t\t\t\t<itemConfig.icon />\n\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\t\tclassName={cn(\"shrink-0 rounded-[2px] border-border bg-(--color-bg)\", {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"h-2.5 w-2.5\": indicator === \"dot\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"w-1\": indicator === \"line\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"w-0 border-[1.5px] border-dashed bg-transparent\": indicator === \"dashed\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"my-0.5\": nestLabel && indicator === \"dashed\",\n\t\t\t\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"--color-bg\": indicatorColor,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"--"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 259, "end_line": 274, "text": ">(({ className, payload, verticalAlign = \"bottom\" }, ref) => {\n\t// const { config } = useChart()\n\n\tif (!payload?.length) {\n\t\treturn null\n\t}\n\n\treturn (\n\t\t<div\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"flex items-center justify-center gap-4 gap-y-1 flex-wrap ps-4\",\n\t\t\t\tverticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t>", "n_tokens": 106, "primary_symbol": "", "primary_kind": "", "primary_span": [259, 274], "def_symbols": [], "symbols": ["className", "payload", "verticalAlign", "bottom", "ref", "const", "config", "useChart", "length", "return", "null", "div", "flex", "items", "center", "justify", "gap", "wrap", "top"], "doc_head": ">(({ className, payload, verticalAlign = \"bottom\" }, ref) => {\n\t// const { config } = useChart()\n\tif (!payload?.length) {\n\t\treturn null\n\t}\n\treturn (\n\t\t<div\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"flex items-center justify-center gap-4 gap-y-1 flex-wrap ps-4\",\n\t\t\t\tverticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 275, "end_line": 306, "text": "\t\t\t{payload.map((item) => {\n\t\t\t\t// const key = `${nameKey || item.dataKey || 'value'}`\n\t\t\t\t// const itemConfig = getPayloadConfigFromPayload(config, item, key)\n\n\t\t\t\treturn (\n\t\t\t\t\t<div\n\t\t\t\t\t\tkey={item.value}\n\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t// 'flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground text-muted-foreground'\n\t\t\t\t\t\t\t\"flex items-center gap-1.5 text-muted-foreground\"\n\t\t\t\t\t\t)}\n\t\t\t\t\t>\n\t\t\t\t\t\t{/* {itemConfig?.icon && !hideIcon ? (\n\t\t\t\t\t\t\t<itemConfig.icon />\n\t\t\t\t\t\t) : ( */}\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName=\"h-2 w-2 shrink-0 rounded-[2px]\"\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\tbackgroundColor: item.color,\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t{item.value}\n\t\t\t\t\t\t{/* )} */}\n\t\t\t\t\t\t{/* {itemConfig?.label} */}\n\t\t\t\t\t</div>\n\t\t\t\t)\n\t\t\t})}\n\t\t</div>\n\t)\n})\nChartLegendContent.displayName = \"ChartLegend\"\n", "n_tokens": 239, "primary_symbol": "", "primary_kind": "", "primary_span": [275, 306], "def_symbols": [], "symbols": ["payload", "map", "item", "const", "key", "nameKey", "dataKey", "value", "itemConfig", "getPayloadConfigFromPayload", "config", "return", "div", "className", "flex", "items", "center", "gap", "svg", "text", "muted", "foreground", "icon", "hideIcon", "shrink", "rounded", "style", "backgroundColor", "color", "label", "ChartLegendContent", "displayName", "ChartLegend"], "doc_head": "\t\t\t{payload.map((item) => {\n\t\t\t\t// const key = `${nameKey || item.dataKey || 'value'}`\n\t\t\t\t// const itemConfig = getPayloadConfigFromPayload(config, item, key)\n\t\t\t\treturn (\n\t\t\t\t\t<div\n\t\t\t\t\t\tkey={item.value}\n\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t// 'flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground text-muted-foreground'\n\t\t\t\t\t\t\t\"flex items-center gap-1.5 text-muted-foreground\"\n\t\t\t\t\t\t)}\n\t\t\t\t\t>\n\t\t\t\t\t\t{/* {itemConfig?.icon && !hideIcon ? (\n\t\t\t\t\t\t\t<itemConfig.icon />\n\t\t\t\t\t\t) : ( */}\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName=\"h-2 w-2 shrink-0 rounded-[2px]\"\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\tbackgroundColor: item.color,\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t{item.value}\n\t\t\t\t\t\t{/* )} */}\n\t\t\t\t\t\t{/* {itemConfig?.label} */}\n\t\t\t\t\t</div>\n\t\t\t\t)\n\t\t\t})}\n\t\t</div>\n\t)\n})\nChartLegendContent.displayName = \"ChartLegend\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 307, "end_line": 325, "text": "// Helper to extract item config from a payload.\nfunction getPayloadConfigFromPayload(config: ChartConfig, payload: unknown, key: string) {\n\tif (typeof payload !== \"object\" || payload === null) {\n\t\treturn undefined\n\t}\n\n\tconst payloadPayload =\n\t\t\"payload\" in payload && typeof payload.payload === \"object\" && payload.payload !== null\n\t\t\t? payload.payload\n\t\t\t: undefined\n\n\tlet configLabelKey: string = key\n\n\tif (key in payload && typeof payload[key as keyof typeof payload] === \"string\") {\n\t\tconfigLabelKey = payload[key as keyof typeof payload] as string\n\t} else if (\n\t\tpayloadPayload &&\n\t\tkey in payloadPayload &&\n\t\ttypeof payloadPayload[key as keyof typeof payloadPayload] === \"string\"", "n_tokens": 160, "primary_symbol": "getPayloadConfigFromPayload", "primary_kind": "function", "primary_span": [308, 325], "def_symbols": ["getPayloadConfigFromPayload"], "symbols": ["getPayloadConfigFromPayload", "Helper", "extract", "item", "config", "from", "payload", "function", "ChartConfig", "unknown", "key", "string", "typeof", "object", "null", "return", "undefined", "const", "payloadPayload", "let", "configLabelKey", "keyof", "else"], "doc_head": "// Helper to extract item config from a payload.\nfunction getPayloadConfigFromPayload(config: ChartConfig, payload: unknown, key: string) {\n\tif (typeof payload !== \"object\" || payload === null) {\n\t\treturn undefined\n\t}\n\tconst payloadPayload =\n\t\t\"payload\" in payload && typeof payload.payload === \"object\" && payload.payload !== null\n\t\t\t? payload.payload\n\t\t\t: undefined\n\tlet configLabelKey: string = key\n\tif (key in payload && typeof payload[key as keyof typeof payload] === \"string\") {\n\t\tconfigLabelKey = payload[key as keyof typeof payload] as string\n\t} else if (\n\t\tpayloadPayload &&\n\t\tkey in payloadPayload &&\n\t\ttypeof payloadPayload[key as keyof typeof payloadPayload] === \"string\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 11, "start_line": 326, "end_line": 354, "text": "\t) {\n\t\tconfigLabelKey = payloadPayload[key as keyof typeof payloadPayload] as string\n\t}\n\n\treturn configLabelKey in config ? config[configLabelKey] : config[key as keyof typeof config]\n}\n\nlet cachedAxis: JSX.Element\nconst xAxis = function ({ domain, ticks, chartTime }: ChartData) {\n\tif (cachedAxis && domain[0] === cachedAxis.props.domain[0]) {\n\t\treturn cachedAxis\n\t}\n\tcachedAxis = (\n\t\t<RechartsPrimitive.XAxis\n\t\t\tdataKey=\"created\"\n\t\t\tdomain={domain}\n\t\t\tticks={ticks}\n\t\t\tallowDataOverflow\n\t\t\ttype=\"number\"\n\t\t\tscale=\"time\"\n\t\t\tminTickGap={12}\n\t\t\ttickMargin={8}\n\t\t\taxisLine={false}\n\t\t\ttickFormatter={chartTimeData[chartTime].format}\n\t\t/>\n\t)\n\treturn cachedAxis\n}\n", "n_tokens": 185, "primary_symbol": "", "primary_kind": "", "primary_span": [326, 354], "def_symbols": [], "symbols": ["configLabelKey", "payloadPayload", "key", "keyof", "typeof", "string", "return", "config", "let", "cachedAxis", "JSX", "Element", "const", "xAxis", "function", "domain", "ticks", "chartTime", "ChartData", "props", "RechartsPrimitive", "XAxis", "dataKey", "created", "allowDataOverflow", "type", "number", "scale", "time", "minTickGap", "tickMargin", "axisLine", "false", "tickFormatter", "chartTimeData", "format"], "doc_head": "\t) {\n\t\tconfigLabelKey = payloadPayload[key as keyof typeof payloadPayload] as string\n\t}\n\treturn configLabelKey in config ? config[configLabelKey] : config[key as keyof typeof config]\n}\nlet cachedAxis: JSX.Element\nconst xAxis = function ({ domain, ticks, chartTime }: ChartData) {\n\tif (cachedAxis && domain[0] === cachedAxis.props.domain[0]) {\n\t\treturn cachedAxis\n\t}\n\tcachedAxis = (\n\t\t<RechartsPrimitive.XAxis\n\t\t\tdataKey=\"created\"\n\t\t\tdomain={domain}\n\t\t\tticks={ticks}\n\t\t\tallowDataOverflow\n\t\t\ttype=\"number\"\n\t\t\tscale=\"time\"\n\t\t\tminTickGap={12}\n\t\t\ttickMargin={8}\n\t\t\taxisLine={false}\n\t\t\ttickFormatter={chartTimeData[chartTime].format}\n\t\t/>\n\t)\n\treturn cachedAxis\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/chart.tsx", "rel_path": "src/site/src/components/ui/chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 12, "start_line": 355, "end_line": 364, "text": "export {\n\tChartContainer,\n\tChartTooltip,\n\tChartTooltipContent,\n\tChartLegend,\n\tChartLegendContent,\n\txAxis,\n\t// ChartStyle,\n}\n", "n_tokens": 33, "primary_symbol": "", "primary_kind": "", "primary_span": [355, 364], "def_symbols": [], "symbols": ["export", "ChartContainer", "ChartTooltip", "ChartTooltipContent", "ChartLegend", "ChartLegendContent", "xAxis", "ChartStyle"], "doc_head": "export {\n\tChartContainer,\n\tChartTooltip,\n\tChartTooltipContent,\n\tChartLegend,\n\tChartLegendContent,\n\txAxis,\n\t// ChartStyle,\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/sheet.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/sheet.tsx", "rel_path": "src/site/src/components/ui/sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "import * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { XIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {\n\treturn <SheetPrimitive.Root data-slot=\"sheet\" {...props} />\n}\n\nfunction SheetTrigger({ ...props }: React.ComponentProps<typeof SheetPrimitive.Trigger>) {\n\treturn <SheetPrimitive.Trigger data-slot=\"sheet-trigger\" {...props} />\n}\n\nfunction SheetClose({ ...props }: React.ComponentProps<typeof SheetPrimitive.Close>) {\n\treturn <SheetPrimitive.Close data-slot=\"sheet-close\" {...props} />\n}\n\nfunction SheetPortal({ ...props }: React.ComponentProps<typeof SheetPrimitive.Portal>) {\n\treturn <SheetPrimitive.Portal data-slot=\"sheet-portal\" {...props} />\n}\n", "n_tokens": 173, "primary_symbol": "Sheet", "primary_kind": "function", "primary_span": [7, 22], "def_symbols": ["Sheet", "SheetTrigger", "SheetClose", "SheetPortal"], "symbols": ["Sheet", "SheetTrigger", "SheetClose", "SheetPortal", "import", "React", "from", "react", "SheetPrimitive", "radix", "dialog", "XIcon", "lucide", "lib", "utils", "function", "props", "ComponentProps", "typeof", "Root", "return", "data", "slot", "sheet", "Trigger", "trigger", "Close", "close", "Portal", "portal"], "doc_head": "import * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { XIcon } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nfunction Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {\n\treturn <SheetPrimitive.Root data-slot=\"sheet\" {...props} />\n}\nfunction SheetTrigger({ ...props }: React.ComponentProps<typeof SheetPrimitive.Trigger>) {\n\treturn <SheetPrimitive.Trigger data-slot=\"sheet-trigger\" {...props} />\n}\nfunction SheetClose({ ...props }: React.ComponentProps<typeof SheetPrimitive.Close>) {\n\treturn <SheetPrimitive.Close data-slot=\"sheet-close\" {...props} />\n}\nfunction SheetPortal({ ...props }: React.ComponentProps<typeof SheetPrimitive.Portal>) {\n\treturn <SheetPrimitive.Portal data-slot=\"sheet-portal\" {...props} />\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/sheet.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/sheet.tsx", "rel_path": "src/site/src/components/ui/sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 23, "end_line": 42, "text": "function SheetOverlay({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Overlay>) {\n\treturn (\n\t\t<SheetPrimitive.Overlay\n\t\t\tdata-slot=\"sheet-overlay\"\n\t\t\tclassName={cn(\n\t\t\t\t\"data-[state=open]:animate-in duration-500 isolate data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/40\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nfunction SheetContent({\n\tclassName,\n\tchildren,\n\tside = \"right\",\n\t...props\n}: React.ComponentProps<typeof SheetPrimitive.Content> & {\n\tside?: \"top\" | \"right\" | \"bottom\" | \"left\"", "n_tokens": 156, "primary_symbol": "SheetOverlay", "primary_kind": "function", "primary_span": [23, 42], "def_symbols": ["SheetOverlay", "SheetContent"], "symbols": ["SheetOverlay", "SheetContent", "function", "className", "props", "React", "ComponentProps", "typeof", "SheetPrimitive", "Overlay", "return", "data", "slot", "sheet", "overlay", "state", "open", "animate", "duration", "isolate", "closed", "out", "fade", "fixed", "inset", "black", "children", "side", "right", "Content", "top", "bottom", "left"], "doc_head": "function SheetOverlay({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Overlay>) {\n\treturn (\n\t\t<SheetPrimitive.Overlay\n\t\t\tdata-slot=\"sheet-overlay\"\n\t\t\tclassName={cn(\n\t\t\t\t\"data-[state=open]:animate-in duration-500 isolate data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/40\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\nfunction SheetContent({\n\tclassName,\n\tchildren,\n\tside = \"right\",\n\t...props\n}: React.ComponentProps<typeof SheetPrimitive.Content> & {\n\tside?: \"top\" | \"right\" | \"bottom\" | \"left\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/sheet.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/sheet.tsx", "rel_path": "src/site/src/components/ui/sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 43, "end_line": 72, "text": "}) {\n\treturn (\n\t\t<SheetPortal>\n\t\t\t<SheetOverlay />\n\t\t\t<SheetPrimitive.Content\n\t\t\t\tdata-slot=\"sheet-content\"\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-[400ms]\",\n\t\t\t\t\tside === \"right\" &&\n\t\t\t\t\t\t\"data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm\",\n\t\t\t\t\tside === \"left\" &&\n\t\t\t\t\t\t\"data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm\",\n\t\t\t\t\tside === \"top\" &&\n\t\t\t\t\t\t\"data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b\",\n\t\t\t\t\tside === \"bottom\" &&\n\t\t\t\t\t\t\"data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t\",\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\t{...props}\n\t\t\t>\n\t\t\t\t{children}\n\t\t\t\t<SheetPrimitive.Close className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none\">\n\t\t\t\t\t<XIcon className=\"size-4\" />\n\t\t\t\t\t<span className=\"sr-only\">Close</span>\n\t\t\t\t</SheetPrimitive.Close>\n\t\t\t</SheetPrimitive.Content>\n\t\t</SheetPortal>\n\t)\n}\n", "n_tokens": 395, "primary_symbol": "", "primary_kind": "", "primary_span": [43, 72], "def_symbols": [], "symbols": ["return", "SheetPortal", "SheetOverlay", "SheetPrimitive", "Content", "data", "slot", "sheet", "content", "className", "background", "state", "open", "animate", "closed", "out", "fixed", "flex", "col", "gap", "shadow", "transition", "ease", "duration", "side", "right", "slide", "from", "inset", "full", "border", "max", "left", "top", "auto", "bottom", "props", "children", "Close", "ring", "offset", "focus", "secondary", "absolute", "rounded", "opacity", "hover", "outline", "hidden", "disabled", "pointer", "events", "none", "XIcon", "size", "span", "only"], "doc_head": "}) {\n\treturn (\n\t\t<SheetPortal>\n\t\t\t<SheetOverlay />\n\t\t\t<SheetPrimitive.Content\n\t\t\t\tdata-slot=\"sheet-content\"\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-[400ms]\",\n\t\t\t\t\tside === \"right\" &&\n\t\t\t\t\t\t\"data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm\",\n\t\t\t\t\tside === \"left\" &&\n\t\t\t\t\t\t\"data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm\",\n\t\t\t\t\tside === \"top\" &&\n\t\t\t\t\t\t\"data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b\",\n\t\t\t\t\tside === \"bottom\" &&\n\t\t\t\t\t\t\"data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t\",\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\t{...props}\n\t\t\t>\n\t\t\t\t{children}\n\t\t\t\t<SheetPrimitive.Close className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focu"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/sheet.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/sheet.tsx", "rel_path": "src/site/src/components/ui/sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 73, "end_line": 90, "text": "function SheetHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n\treturn <div data-slot=\"sheet-header\" className={cn(\"flex flex-col gap-1.5 p-4\", className)} {...props} />\n}\n\nfunction SheetFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n\treturn <div data-slot=\"sheet-footer\" className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)} {...props} />\n}\n\nfunction SheetTitle({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Title>) {\n\treturn (\n\t\t<SheetPrimitive.Title\n\t\t\tdata-slot=\"sheet-title\"\n\t\t\tclassName={cn(\"text-foreground font-semibold\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n", "n_tokens": 157, "primary_symbol": "SheetHeader", "primary_kind": "function", "primary_span": [73, 90], "def_symbols": ["SheetHeader", "SheetFooter", "SheetTitle"], "symbols": ["SheetHeader", "SheetFooter", "SheetTitle", "function", "className", "props", "React", "ComponentProps", "div", "return", "data", "slot", "sheet", "header", "flex", "col", "gap", "footer", "auto", "typeof", "SheetPrimitive", "Title", "title", "text", "foreground", "font", "semibold"], "doc_head": "function SheetHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n\treturn <div data-slot=\"sheet-header\" className={cn(\"flex flex-col gap-1.5 p-4\", className)} {...props} />\n}\nfunction SheetFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n\treturn <div data-slot=\"sheet-footer\" className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)} {...props} />\n}\nfunction SheetTitle({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Title>) {\n\treturn (\n\t\t<SheetPrimitive.Title\n\t\t\tdata-slot=\"sheet-title\"\n\t\t\tclassName={cn(\"text-foreground font-semibold\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/sheet.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/sheet.tsx", "rel_path": "src/site/src/components/ui/sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 91, "end_line": 102, "text": "function SheetDescription({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Description>) {\n\treturn (\n\t\t<SheetPrimitive.Description\n\t\t\tdata-slot=\"sheet-description\"\n\t\t\tclassName={cn(\"text-muted-foreground text-sm\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nexport { Sheet, SheetTrigger, SheetClose, SheetContent, SheetHeader, SheetFooter, SheetTitle, SheetDescription }\n", "n_tokens": 85, "primary_symbol": "SheetDescription", "primary_kind": "function", "primary_span": [91, 102], "def_symbols": ["SheetDescription"], "symbols": ["SheetDescription", "function", "className", "props", "React", "ComponentProps", "typeof", "SheetPrimitive", "Description", "return", "data", "slot", "sheet", "description", "text", "muted", "foreground", "export", "Sheet", "SheetTrigger", "SheetClose", "SheetContent", "SheetHeader", "SheetFooter", "SheetTitle"], "doc_head": "function SheetDescription({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Description>) {\n\treturn (\n\t\t<SheetPrimitive.Description\n\t\t\tdata-slot=\"sheet-description\"\n\t\t\tclassName={cn(\"text-muted-foreground text-sm\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\nexport { Sheet, SheetTrigger, SheetClose, SheetContent, SheetHeader, SheetFooter, SheetTitle, SheetDescription }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/label.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/label.tsx", "rel_path": "src/site/src/components/ui/label.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 18, "text": "import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\")\n\nconst Label = React.forwardRef<\n\tReact.ElementRef<typeof LabelPrimitive.Root>,\n\tReact.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n\t<LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n", "n_tokens": 156, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 18], "def_symbols": [], "symbols": ["import", "React", "from", "react", "LabelPrimitive", "radix", "label", "cva", "type", "VariantProps", "class", "variance", "authority", "lib", "utils", "const", "labelVariants", "text", "font", "medium", "leading", "none", "peer", "disabled", "cursor", "not", "allowed", "opacity", "Label", "forwardRef", "ElementRef", "typeof", "Root", "ComponentPropsWithoutRef", "className", "props", "ref", "displayName", "export"], "doc_head": "import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { cn } from \"@/lib/utils\"\nconst labelVariants = cva(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\")\nconst Label = React.forwardRef<\n\tReact.ElementRef<typeof LabelPrimitive.Root>,\n\tReact.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n\t<LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\nexport { Label }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tooltip.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tooltip.tsx", "rel_path": "src/site/src/components/ui/tooltip.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 26, "text": "import * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction TooltipProvider({ delayDuration = 0, ...props }: React.ComponentProps<typeof TooltipPrimitive.Provider>) {\n\treturn <TooltipPrimitive.Provider data-slot=\"tooltip-provider\" delayDuration={delayDuration} {...props} />\n}\n\nfunction Tooltip({ ...props }: React.ComponentProps<typeof TooltipPrimitive.Root>) {\n\treturn (\n\t\t<TooltipProvider>\n\t\t\t<TooltipPrimitive.Root data-slot=\"tooltip\" {...props} />\n\t\t</TooltipProvider>\n\t)\n}\n\nfunction TooltipTrigger({ ...props }: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {\n\treturn <TooltipPrimitive.Trigger data-slot=\"tooltip-trigger\" {...props} />\n}\n\nfunction TooltipContent({\n\tclassName,\n\tsideOffset = 0,\n\tchildren,\n\t...props", "n_tokens": 172, "primary_symbol": "TooltipProvider", "primary_kind": "function", "primary_span": [6, 26], "def_symbols": ["TooltipProvider", "Tooltip", "TooltipTrigger", "TooltipContent"], "symbols": ["TooltipProvider", "Tooltip", "TooltipTrigger", "TooltipContent", "import", "React", "from", "react", "TooltipPrimitive", "radix", "tooltip", "lib", "utils", "function", "delayDuration", "props", "ComponentProps", "typeof", "Provider", "return", "data", "slot", "provider", "Root", "Trigger", "trigger", "className", "sideOffset", "children"], "doc_head": "import * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\nimport { cn } from \"@/lib/utils\"\nfunction TooltipProvider({ delayDuration = 0, ...props }: React.ComponentProps<typeof TooltipPrimitive.Provider>) {\n\treturn <TooltipPrimitive.Provider data-slot=\"tooltip-provider\" delayDuration={delayDuration} {...props} />\n}\nfunction Tooltip({ ...props }: React.ComponentProps<typeof TooltipPrimitive.Root>) {\n\treturn (\n\t\t<TooltipProvider>\n\t\t\t<TooltipPrimitive.Root data-slot=\"tooltip\" {...props} />\n\t\t</TooltipProvider>\n\t)\n}\nfunction TooltipTrigger({ ...props }: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {\n\treturn <TooltipPrimitive.Trigger data-slot=\"tooltip-trigger\" {...props} />\n}\nfunction TooltipContent({\n\tclassName,\n\tsideOffset = 0,\n\tchildren,\n\t...props"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tooltip.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tooltip.tsx", "rel_path": "src/site/src/components/ui/tooltip.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 27, "end_line": 48, "text": "}: React.ComponentProps<typeof TooltipPrimitive.Content>) {\n\treturn (\n\t\t<TooltipPrimitive.Portal>\n\t\t\t<TooltipPrimitive.Content\n\t\t\t\tdata-slot=\"tooltip-content\"\n\t\t\t\tsideOffset={sideOffset}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"bg-popover text-popover-foreground border animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-sm text-balance\",\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\t{...props}\n\t\t\t>\n\t\t\t\t{children}\n\t\t\t\t<TooltipPrimitive.Arrow\n\t\t\t\t\tclassName=\"bg-popover border z-50 fill-popover size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] will-change-transform\"\n\t\t\t\t\tstyle={{ clipPath: \"inset(25% 0 0 25%)\" }}\n\t\t\t\t/>\n\t\t\t</TooltipPrimitive.Content>\n\t\t</TooltipPrimitive.Portal>\n\t)\n}\n", "n_tokens": 285, "primary_symbol": "", "primary_kind": "", "primary_span": [27, 48], "def_symbols": [], "symbols": ["React", "ComponentProps", "typeof", "TooltipPrimitive", "Content", "return", "Portal", "data", "slot", "tooltip", "content", "sideOffset", "className", "popover", "text", "foreground", "border", "animate", "fade", "zoom", "state", "closed", "out", "side", "bottom", "slide", "from", "top", "left", "right", "fit", "origin", "radix", "transform", "rounded", "balance", "props", "children", "Arrow", "fill", "size", "translate", "calc", "_2px", "rotate", "will", "change", "style", "clipPath", "inset"], "doc_head": "}: React.ComponentProps<typeof TooltipPrimitive.Content>) {\n\treturn (\n\t\t<TooltipPrimitive.Portal>\n\t\t\t<TooltipPrimitive.Content\n\t\t\t\tdata-slot=\"tooltip-content\"\n\t\t\t\tsideOffset={sideOffset}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"bg-popover text-popover-foreground border animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-sm text-balance\",\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\t{...props}\n\t\t\t>\n\t\t\t\t{children}\n\t\t\t\t<TooltipPrimitive.Arrow\n\t\t\t\t\tclassName=\"bg-popover border z-50 fill-popover size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] will-change-transform\"\n\t\t\t\t\tstyle={{ clipPath: \"inset(25% 0 0 25%)\" }}\n\t\t\t\t/>\n\t\t\t</TooltipPrimitive.Content>\n\t\t</TooltipPrimitive.Portal>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tooltip.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/tooltip.tsx", "rel_path": "src/site/src/components/ui/tooltip.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 49, "end_line": 50, "text": "export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n", "n_tokens": 13, "primary_symbol": "", "primary_kind": "", "primary_span": [49, 50], "def_symbols": [], "symbols": ["export", "Tooltip", "TooltipTrigger", "TooltipContent", "TooltipProvider"], "doc_head": "export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/otp.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/otp.tsx", "rel_path": "src/site/src/components/ui/otp.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 27, "text": "import * as React from \"react\"\nimport { OTPInput, OTPInputContext } from \"input-otp\"\nimport { MinusIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction InputOTP({\n\tclassName,\n\tcontainerClassName,\n\t...props\n}: React.ComponentProps<typeof OTPInput> & {\n\tcontainerClassName?: string\n}) {\n\treturn (\n\t\t<OTPInput\n\t\t\tdata-slot=\"input-otp\"\n\t\t\tcontainerClassName={cn(\"flex items-center gap-2 has-disabled:opacity-50\", containerClassName)}\n\t\t\tclassName={cn(\"disabled:cursor-not-allowed\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nfunction InputOTPGroup({ className, ...props }: React.ComponentProps<\"div\">) {\n\treturn <div data-slot=\"input-otp-group\" className={cn(\"flex items-center\", className)} {...props} />\n}\n", "n_tokens": 183, "primary_symbol": "InputOTP", "primary_kind": "function", "primary_span": [7, 27], "def_symbols": ["InputOTP", "InputOTPGroup"], "symbols": ["InputOTP", "InputOTPGroup", "import", "React", "from", "react", "OTPInput", "OTPInputContext", "input", "otp", "MinusIcon", "lucide", "lib", "utils", "function", "className", "containerClassName", "props", "ComponentProps", "typeof", "string", "return", "data", "slot", "flex", "items", "center", "gap", "has", "disabled", "opacity", "cursor", "not", "allowed", "div", "group"], "doc_head": "import * as React from \"react\"\nimport { OTPInput, OTPInputContext } from \"input-otp\"\nimport { MinusIcon } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nfunction InputOTP({\n\tclassName,\n\tcontainerClassName,\n\t...props\n}: React.ComponentProps<typeof OTPInput> & {\n\tcontainerClassName?: string\n}) {\n\treturn (\n\t\t<OTPInput\n\t\t\tdata-slot=\"input-otp\"\n\t\t\tcontainerClassName={cn(\"flex items-center gap-2 has-disabled:opacity-50\", containerClassName)}\n\t\t\tclassName={cn(\"disabled:cursor-not-allowed\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\nfunction InputOTPGroup({ className, ...props }: React.ComponentProps<\"div\">) {\n\treturn <div data-slot=\"input-otp-group\" className={cn(\"flex items-center\", className)} {...props} />\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/otp.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/otp.tsx", "rel_path": "src/site/src/components/ui/otp.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 28, "end_line": 33, "text": "function InputOTPSlot({\n\tindex,\n\tclassName,\n\t...props\n}: React.ComponentProps<\"div\"> & {\n\tindex: number", "n_tokens": 26, "primary_symbol": "InputOTPSlot", "primary_kind": "function", "primary_span": [28, 33], "def_symbols": ["InputOTPSlot"], "symbols": ["InputOTPSlot", "function", "index", "className", "props", "React", "ComponentProps", "div", "number"], "doc_head": "function InputOTPSlot({\n\tindex,\n\tclassName,\n\t...props\n}: React.ComponentProps<\"div\"> & {\n\tindex: number"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/otp.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/otp.tsx", "rel_path": "src/site/src/components/ui/otp.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 34, "end_line": 57, "text": "}) {\n\tconst inputOTPContext = React.useContext(OTPInputContext)\n\tconst { char, hasFakeCaret, isActive } = inputOTPContext?.slots[index] ?? {}\n\n\treturn (\n\t\t<div\n\t\t\tdata-slot=\"input-otp-slot\"\n\t\t\tdata-active={isActive}\n\t\t\tclassName={cn(\n\t\t\t\t\"data-[active=true]:border-ring data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:ring-destructive/20 dark:data-[active=true]:aria-invalid:ring-destructive/40 aria-invalid:border-destructive data-[active=true]:aria-invalid:border-destructive dark:bg-input/30 border-input relative flex h-9 w-9 items-center justify-center border-y border-r text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md data-[active=true]:z-10 data-[active=true]:ring-[3px]\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{char}\n\t\t\t{hasFakeCaret && (\n\t\t\t\t<div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n\t\t\t\t\t<div className=\"animate-caret-blink bg-foreground h-4 w-px duration-1000\" />\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t)\n}\n", "n_tokens": 271, "primary_symbol": "", "primary_kind": "", "primary_span": [34, 57], "def_symbols": [], "symbols": ["const", "inputOTPContext", "React", "useContext", "OTPInputContext", "char", "hasFakeCaret", "isActive", "slots", "index", "return", "div", "data", "slot", "input", "otp", "active", "className", "true", "border", "ring", "aria", "invalid", "destructive", "dark", "relative", "flex", "items", "center", "justify", "text", "shadow", "transition", "all", "outline", "none", "first", "rounded", "last", "props", "pointer", "events", "absolute", "inset", "animate", "caret", "blink", "foreground", "duration"], "doc_head": "}) {\n\tconst inputOTPContext = React.useContext(OTPInputContext)\n\tconst { char, hasFakeCaret, isActive } = inputOTPContext?.slots[index] ?? {}\n\treturn (\n\t\t<div\n\t\t\tdata-slot=\"input-otp-slot\"\n\t\t\tdata-active={isActive}\n\t\t\tclassName={cn(\n\t\t\t\t\"data-[active=true]:border-ring data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:ring-destructive/20 dark:data-[active=true]:aria-invalid:ring-destructive/40 aria-invalid:border-destructive data-[active=true]:aria-invalid:border-destructive dark:bg-input/30 border-input relative flex h-9 w-9 items-center justify-center border-y border-r text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md data-[active=true]:z-10 data-[active=true]:ring-[3px]\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{char}\n\t\t\t{hasFakeCaret && (\n\t\t\t\t<div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n\t\t\t\t\t<div className=\"animate-caret-blink bg-foreground h-4 w-px duration-1000\" />\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/otp.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/otp.tsx", "rel_path": "src/site/src/components/ui/otp.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 58, "end_line": 67, "text": "function InputOTPSeparator({ ...props }: React.ComponentProps<\"div\">) {\n\treturn (\n\t\t<div data-slot=\"input-otp-separator\" role=\"separator\" {...props}>\n\t\t\t<MinusIcon />\n\t\t</div>\n\t)\n}\n\nexport { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }\n", "n_tokens": 71, "primary_symbol": "InputOTPSeparator", "primary_kind": "function", "primary_span": [58, 67], "def_symbols": ["InputOTPSeparator"], "symbols": ["InputOTPSeparator", "function", "props", "React", "ComponentProps", "div", "return", "data", "slot", "input", "otp", "separator", "role", "MinusIcon", "export", "InputOTP", "InputOTPGroup", "InputOTPSlot"], "doc_head": "function InputOTPSeparator({ ...props }: React.ComponentProps<\"div\">) {\n\treturn (\n\t\t<div data-slot=\"input-otp-separator\" role=\"separator\" {...props}>\n\t\t\t<MinusIcon />\n\t\t</div>\n\t)\n}\nexport { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert.tsx", "rel_path": "src/site/src/components/ui/alert.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 3, "text": "import * as React from \"react\"\n// import { cva, type VariantProps } from 'class-variance-authority'\n", "n_tokens": 26, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 3], "def_symbols": [], "symbols": ["import", "React", "from", "react", "cva", "type", "VariantProps", "class", "variance", "authority"], "doc_head": "import * as React from \"react\"\n// import { cva, type VariantProps } from 'class-variance-authority'"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert.tsx", "rel_path": "src/site/src/components/ui/alert.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 4, "end_line": 26, "text": "import { cn } from \"@/lib/utils\"\n\n// const alertVariants = cva(\n//   \"relative w-full rounded-lg border p-4 [&>svg~*]:ps-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground\",\n//   {\n//     variants: {\n//       variant: {\n//         default: \"bg-background text-foreground\",\n//         destructive:\n//           \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n//       },\n//     },\n//     defaultVariants: {\n//       variant: \"default\",\n//     },\n//   }\n// )\n\nconst Alert = React.forwardRef<\n\tHTMLDivElement,\n\t// React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n\t// >(({ className, variant, ...props }, ref) => (\n\tReact.HTMLAttributes<HTMLDivElement>", "n_tokens": 207, "primary_symbol": "", "primary_kind": "", "primary_span": [4, 26], "def_symbols": [], "symbols": ["import", "from", "lib", "utils", "const", "alertVariants", "cva", "relative", "full", "rounded", "border", "svg", "div", "translate", "absolute", "left", "top", "text", "foreground", "variants", "variant", "default", "background", "destructive", "dark", "defaultVariants", "Alert", "React", "forwardRef", "HTMLDivElement", "HTMLAttributes", "VariantProps", "typeof", "className", "props", "ref"], "doc_head": "import { cn } from \"@/lib/utils\"\n// const alertVariants = cva(\n//   \"relative w-full rounded-lg border p-4 [&>svg~*]:ps-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground\",\n//   {\n//     variants: {\n//       variant: {\n//         default: \"bg-background text-foreground\",\n//         destructive:\n//           \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n//       },\n//     },\n//     defaultVariants: {\n//       variant: \"default\",\n//     },\n//   }\n// )\nconst Alert = React.forwardRef<\n\tHTMLDivElement,\n\t// React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n\t// >(({ className, variant, ...props }, ref) => (\n\tReact.HTMLAttributes<HTMLDivElement>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert.tsx", "rel_path": "src/site/src/components/ui/alert.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 27, "end_line": 40, "text": ">(({ className, ...props }, ref) => (\n\t<div\n\t\tref={ref}\n\t\trole=\"alert\"\n\t\tclassName={cn(\n\t\t\t\"relative w-full rounded-lg border p-4 [&>svg~*]:ps-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground bg-background text-foreground\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(", "n_tokens": 135, "primary_symbol": "", "primary_kind": "", "primary_span": [27, 40], "def_symbols": [], "symbols": ["className", "props", "ref", "div", "role", "alert", "relative", "full", "rounded", "border", "svg", "translate", "absolute", "left", "top", "text", "foreground", "background", "Alert", "displayName", "const", "AlertTitle", "React", "forwardRef", "HTMLParagraphElement", "HTMLAttributes", "HTMLHeadingElement"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<div\n\t\tref={ref}\n\t\trole=\"alert\"\n\t\tclassName={cn(\n\t\t\t\"relative w-full rounded-lg border p-4 [&>svg~*]:ps-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground bg-background text-foreground\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nAlert.displayName = \"Alert\"\nconst AlertTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/alert.tsx", "rel_path": "src/site/src/components/ui/alert.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 41, "end_line": 55, "text": "\t({ className, ...props }, ref) => (\n\t\t<h5 ref={ref} className={cn(\"mb-1 -mt-0.5 font-medium leading-tight tracking-tight\", className)} {...props} />\n\t)\n)\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<div ref={ref} className={cn(\"text-sm [&_p]:leading-relaxed\", className)} {...props} />\n\t)\n)\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n", "n_tokens": 135, "primary_symbol": "", "primary_kind": "", "primary_span": [41, 55], "def_symbols": [], "symbols": ["className", "props", "ref", "font", "medium", "leading", "tight", "tracking", "AlertTitle", "displayName", "const", "AlertDescription", "React", "forwardRef", "HTMLParagraphElement", "HTMLAttributes", "div", "text", "relaxed", "export", "Alert"], "doc_head": "\t({ className, ...props }, ref) => (\n\t\t<h5 ref={ref} className={cn(\"mb-1 -mt-0.5 font-medium leading-tight tracking-tight\", className)} {...props} />\n\t)\n)\nAlertTitle.displayName = \"AlertTitle\"\nconst AlertDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<div ref={ref} className={cn(\"text-sm [&_p]:leading-relaxed\", className)} {...props} />\n\t)\n)\nAlertDescription.displayName = \"AlertDescription\"\nexport { Alert, AlertTitle, AlertDescription }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-copy.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-copy.tsx", "rel_path": "src/site/src/components/ui/input-copy.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 7, "text": "import { copyToClipboard } from \"@/lib/utils\"\nimport { Input } from \"./input\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from \"./tooltip\"\nimport { CopyIcon } from \"lucide-react\"\nimport { Button } from \"./button\"\n", "n_tokens": 68, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 7], "def_symbols": [], "symbols": ["import", "copyToClipboard", "from", "lib", "utils", "Input", "input", "Trans", "lingui", "react", "macro", "Tooltip", "TooltipContent", "TooltipProvider", "TooltipTrigger", "tooltip", "CopyIcon", "lucide", "Button", "button"], "doc_head": "import { copyToClipboard } from \"@/lib/utils\"\nimport { Input } from \"./input\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from \"./tooltip\"\nimport { CopyIcon } from \"lucide-react\"\nimport { Button } from \"./button\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-copy.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-copy.tsx", "rel_path": "src/site/src/components/ui/input-copy.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 8, "end_line": 23, "text": "export function InputCopy({ value, id, name }: { value: string; id: string; name: string }) {\n\treturn (\n\t\t<div className=\"relative\">\n\t\t\t<Input readOnly id={id} name={name} value={value} required></Input>\n\t\t\t<div\n\t\t\t\tclassName={\n\t\t\t\t\t\"h-6 w-24 bg-linear-to-r rtl:bg-linear-to-l from-transparent to-background to-65% absolute top-2 end-1 pointer-events-none\"\n\t\t\t\t}\n\t\t\t></div>\n\t\t\t<TooltipProvider delayDuration={100} disableHoverableContent>\n\t\t\t\t<Tooltip disableHoverableContent={true}>\n\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\tvariant={\"link\"}\n\t\t\t\t\t\t\tclassName=\"absolute end-0 top-0\"", "n_tokens": 165, "primary_symbol": "InputCopy", "primary_kind": "function", "primary_span": [8, 23], "def_symbols": ["InputCopy"], "symbols": ["InputCopy", "export", "function", "value", "name", "string", "return", "div", "className", "relative", "Input", "readOnly", "required", "linear", "rtl", "from", "transparent", "background", "absolute", "top", "end", "pointer", "events", "none", "TooltipProvider", "delayDuration", "disableHoverableContent", "Tooltip", "true", "TooltipTrigger", "asChild", "Button", "type", "button", "variant", "link"], "doc_head": "export function InputCopy({ value, id, name }: { value: string; id: string; name: string }) {\n\treturn (\n\t\t<div className=\"relative\">\n\t\t\t<Input readOnly id={id} name={name} value={value} required></Input>\n\t\t\t<div\n\t\t\t\tclassName={\n\t\t\t\t\t\"h-6 w-24 bg-linear-to-r rtl:bg-linear-to-l from-transparent to-background to-65% absolute top-2 end-1 pointer-events-none\"\n\t\t\t\t}\n\t\t\t></div>\n\t\t\t<TooltipProvider delayDuration={100} disableHoverableContent>\n\t\t\t\t<Tooltip disableHoverableContent={true}>\n\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\tvariant={\"link\"}\n\t\t\t\t\t\t\tclassName=\"absolute end-0 top-0\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-copy.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input-copy.tsx", "rel_path": "src/site/src/components/ui/input-copy.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 24, "end_line": 39, "text": "\t\t\t\t\t\t\tonClick={() => copyToClipboard(value)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<CopyIcon className=\"size-4\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t<TooltipContent>\n\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t<Trans>Click to copy</Trans>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</TooltipContent>\n\t\t\t\t</Tooltip>\n\t\t\t</TooltipProvider>\n\t\t</div>\n\t)\n}\n", "n_tokens": 86, "primary_symbol": "", "primary_kind": "", "primary_span": [24, 39], "def_symbols": [], "symbols": ["onClick", "copyToClipboard", "value", "CopyIcon", "className", "size", "Button", "TooltipTrigger", "TooltipContent", "Trans", "Click", "copy", "Tooltip", "TooltipProvider", "div"], "doc_head": "\t\t\t\t\t\t\tonClick={() => copyToClipboard(value)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<CopyIcon className=\"size-4\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t<TooltipContent>\n\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t<Trans>Click to copy</Trans>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</TooltipContent>\n\t\t\t\t</Tooltip>\n\t\t\t</TooltipProvider>\n\t\t</div>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts", "rel_path": "src/site/src/components/ui/use-toast.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 31, "text": "// Inspired by react-hot-toast library\nimport * as React from \"react\"\n\nimport type { ToastActionElement, ToastProps } from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n\tid: string\n\ttitle?: React.ReactNode\n\tdescription?: React.ReactNode\n\taction?: ToastActionElement\n}\n\nconst actionTypes = {\n\tADD_TOAST: \"ADD_TOAST\",\n\tUPDATE_TOAST: \"UPDATE_TOAST\",\n\tDISMISS_TOAST: \"DISMISS_TOAST\",\n\tREMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n\tcount = (count + 1) % Number.MAX_SAFE_INTEGER\n\treturn count.toString()\n}\n\ntype ActionType = typeof actionTypes\n", "n_tokens": 167, "primary_symbol": "genId", "primary_kind": "function", "primary_span": [25, 31], "def_symbols": ["genId"], "symbols": ["genId", "Inspired", "react", "hot", "toast", "library", "import", "React", "from", "type", "ToastActionElement", "ToastProps", "components", "const", "TOAST_LIMIT", "TOAST_REMOVE_DELAY", "ToasterToast", "string", "title", "ReactNode", "description", "action", "actionTypes", "ADD_TOAST", "UPDATE_TOAST", "DISMISS_TOAST", "REMOVE_TOAST", "let", "count", "function", "Number", "MAX_SAFE_INTEGER", "return", "toString", "ActionType", "typeof"], "doc_head": "// Inspired by react-hot-toast library\nimport * as React from \"react\"\nimport type { ToastActionElement, ToastProps } from \"@/components/ui/toast\"\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\ntype ToasterToast = ToastProps & {\n\tid: string\n\ttitle?: React.ReactNode\n\tdescription?: React.ReactNode\n\taction?: ToastActionElement\n}\nconst actionTypes = {\n\tADD_TOAST: \"ADD_TOAST\",\n\tUPDATE_TOAST: \"UPDATE_TOAST\",\n\tDISMISS_TOAST: \"DISMISS_TOAST\",\n\tREMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\nlet count = 0\nfunction genId() {\n\tcount = (count + 1) % Number.MAX_SAFE_INTEGER\n\treturn count.toString()\n}\ntype ActionType = typeof actionTypes"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts", "rel_path": "src/site/src/components/ui/use-toast.ts", "ext": "ts", "language": "typescript", "chunk_number": 2, "start_line": 32, "end_line": 60, "text": "type Action =\n\t| {\n\t\t\ttype: ActionType[\"ADD_TOAST\"]\n\t\t\ttoast: ToasterToast\n\t  }\n\t| {\n\t\t\ttype: ActionType[\"UPDATE_TOAST\"]\n\t\t\ttoast: Partial<ToasterToast>\n\t  }\n\t| {\n\t\t\ttype: ActionType[\"DISMISS_TOAST\"]\n\t\t\ttoastId?: ToasterToast[\"id\"]\n\t  }\n\t| {\n\t\t\ttype: ActionType[\"REMOVE_TOAST\"]\n\t\t\ttoastId?: ToasterToast[\"id\"]\n\t  }\n\ninterface State {\n\ttoasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n\tif (toastTimeouts.has(toastId)) {\n\t\treturn\n\t}\n", "n_tokens": 154, "primary_symbol": "addToRemoveQueue", "primary_kind": "function", "primary_span": [32, 60], "def_symbols": ["addToRemoveQueue"], "symbols": ["addToRemoveQueue", "type", "Action", "ActionType", "ADD_TOAST", "toast", "ToasterToast", "UPDATE_TOAST", "Partial", "DISMISS_TOAST", "toastId", "REMOVE_TOAST", "interface", "State", "toasts", "const", "toastTimeouts", "new", "Map", "string", "ReturnType", "typeof", "setTimeout", "has", "return"], "doc_head": "type Action =\n\t| {\n\t\t\ttype: ActionType[\"ADD_TOAST\"]\n\t\t\ttoast: ToasterToast\n\t  }\n\t| {\n\t\t\ttype: ActionType[\"UPDATE_TOAST\"]\n\t\t\ttoast: Partial<ToasterToast>\n\t  }\n\t| {\n\t\t\ttype: ActionType[\"DISMISS_TOAST\"]\n\t\t\ttoastId?: ToasterToast[\"id\"]\n\t  }\n\t| {\n\t\t\ttype: ActionType[\"REMOVE_TOAST\"]\n\t\t\ttoastId?: ToasterToast[\"id\"]\n\t  }\ninterface State {\n\ttoasts: ToasterToast[]\n}\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\nconst addToRemoveQueue = (toastId: string) => {\n\tif (toastTimeouts.has(toastId)) {\n\t\treturn\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts", "rel_path": "src/site/src/components/ui/use-toast.ts", "ext": "ts", "language": "typescript", "chunk_number": 3, "start_line": 61, "end_line": 88, "text": "\tconst timeout = setTimeout(() => {\n\t\ttoastTimeouts.delete(toastId)\n\t\tdispatch({\n\t\t\ttype: \"REMOVE_TOAST\",\n\t\t\ttoastId: toastId,\n\t\t})\n\t}, TOAST_REMOVE_DELAY)\n\n\ttoastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n\tswitch (action.type) {\n\t\tcase \"ADD_TOAST\":\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\ttoasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n\t\t\t}\n\n\t\tcase \"UPDATE_TOAST\":\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\ttoasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),\n\t\t\t}\n\n\t\tcase \"DISMISS_TOAST\": {\n\t\t\tconst { toastId } = action\n", "n_tokens": 186, "primary_symbol": "", "primary_kind": "", "primary_span": [61, 88], "def_symbols": [], "symbols": ["const", "timeout", "setTimeout", "toastTimeouts", "delete", "toastId", "dispatch", "type", "REMOVE_TOAST", "TOAST_REMOVE_DELAY", "set", "export", "reducer", "state", "State", "action", "Action", "switch", "case", "ADD_TOAST", "return", "toasts", "toast", "slice", "TOAST_LIMIT", "UPDATE_TOAST", "map", "DISMISS_TOAST"], "doc_head": "\tconst timeout = setTimeout(() => {\n\t\ttoastTimeouts.delete(toastId)\n\t\tdispatch({\n\t\t\ttype: \"REMOVE_TOAST\",\n\t\t\ttoastId: toastId,\n\t\t})\n\t}, TOAST_REMOVE_DELAY)\n\ttoastTimeouts.set(toastId, timeout)\n}\nexport const reducer = (state: State, action: Action): State => {\n\tswitch (action.type) {\n\t\tcase \"ADD_TOAST\":\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\ttoasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n\t\t\t}\n\t\tcase \"UPDATE_TOAST\":\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\ttoasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),\n\t\t\t}\n\t\tcase \"DISMISS_TOAST\": {\n\t\t\tconst { toastId } = action"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts", "rel_path": "src/site/src/components/ui/use-toast.ts", "ext": "ts", "language": "typescript", "chunk_number": 4, "start_line": 89, "end_line": 119, "text": "\t\t\t// ! Side effects ! - This could be extracted into a dismissToast() action,\n\t\t\t// but I'll keep it here for simplicity\n\t\t\tif (toastId) {\n\t\t\t\taddToRemoveQueue(toastId)\n\t\t\t} else {\n\t\t\t\tstate.toasts.forEach((toast) => {\n\t\t\t\t\taddToRemoveQueue(toast.id)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\ttoasts: state.toasts.map((t) =>\n\t\t\t\t\tt.id === toastId || toastId === undefined\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t...t,\n\t\t\t\t\t\t\t\topen: false,\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: t\n\t\t\t\t),\n\t\t\t}\n\t\t}\n\t\tcase \"REMOVE_TOAST\":\n\t\t\tif (action.toastId === undefined) {\n\t\t\t\treturn {\n\t\t\t\t\t...state,\n\t\t\t\t\ttoasts: [],\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,", "n_tokens": 181, "primary_symbol": "", "primary_kind": "", "primary_span": [89, 119], "def_symbols": [], "symbols": ["Side", "effects", "This", "could", "extracted", "into", "dismissToast", "action", "but", "keep", "here", "for", "simplicity", "toastId", "addToRemoveQueue", "else", "state", "toasts", "forEach", "toast", "return", "map", "undefined", "open", "false", "case", "REMOVE_TOAST"], "doc_head": "\t\t\t// ! Side effects ! - This could be extracted into a dismissToast() action,\n\t\t\t// but I'll keep it here for simplicity\n\t\t\tif (toastId) {\n\t\t\t\taddToRemoveQueue(toastId)\n\t\t\t} else {\n\t\t\t\tstate.toasts.forEach((toast) => {\n\t\t\t\t\taddToRemoveQueue(toast.id)\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\ttoasts: state.toasts.map((t) =>\n\t\t\t\t\tt.id === toastId || toastId === undefined\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t...t,\n\t\t\t\t\t\t\t\topen: false,\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: t\n\t\t\t\t),\n\t\t\t}\n\t\t}\n\t\tcase \"REMOVE_TOAST\":\n\t\t\tif (action.toastId === undefined) {\n\t\t\t\treturn {\n\t\t\t\t\t...state,\n\t\t\t\t\ttoasts: [],\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts", "rel_path": "src/site/src/components/ui/use-toast.ts", "ext": "ts", "language": "typescript", "chunk_number": 5, "start_line": 120, "end_line": 153, "text": "\t\t\t\ttoasts: state.toasts.filter((t) => t.id !== action.toastId),\n\t\t\t}\n\t}\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n\tmemoryState = reducer(memoryState, action)\n\tlisteners.forEach((listener) => {\n\t\tlistener(memoryState)\n\t})\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n\tconst id = genId()\n\n\tconst update = (props: ToasterToast) =>\n\t\tdispatch({\n\t\t\ttype: \"UPDATE_TOAST\",\n\t\t\ttoast: { ...props, id },\n\t\t})\n\tconst dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n\tdispatch({\n\t\ttype: \"ADD_TOAST\",\n\t\ttoast: {\n\t\t\t...props,\n\t\t\tid,\n\t\t\topen: true,", "n_tokens": 196, "primary_symbol": "dispatch", "primary_kind": "function", "primary_span": [129, 153], "def_symbols": ["dispatch", "toast", "update", "dismiss"], "symbols": ["dispatch", "toast", "update", "dismiss", "toasts", "state", "filter", "action", "toastId", "const", "listeners", "Array", "State", "void", "let", "memoryState", "function", "Action", "reducer", "forEach", "listener", "type", "Toast", "Omit", "ToasterToast", "props", "genId", "UPDATE_TOAST", "DISMISS_TOAST", "ADD_TOAST", "open", "true"], "doc_head": "\t\t\t\ttoasts: state.toasts.filter((t) => t.id !== action.toastId),\n\t\t\t}\n\t}\n}\nconst listeners: Array<(state: State) => void> = []\nlet memoryState: State = { toasts: [] }\nfunction dispatch(action: Action) {\n\tmemoryState = reducer(memoryState, action)\n\tlisteners.forEach((listener) => {\n\t\tlistener(memoryState)\n\t})\n}\ntype Toast = Omit<ToasterToast, \"id\">\nfunction toast({ ...props }: Toast) {\n\tconst id = genId()\n\tconst update = (props: ToasterToast) =>\n\t\tdispatch({\n\t\t\ttype: \"UPDATE_TOAST\",\n\t\t\ttoast: { ...props, id },\n\t\t})\n\tconst dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\tdispatch({\n\t\ttype: \"ADD_TOAST\",\n\t\ttoast: {\n\t\t\t...props,\n\t\t\tid,\n\t\t\topen: true,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/use-toast.ts", "rel_path": "src/site/src/components/ui/use-toast.ts", "ext": "ts", "language": "typescript", "chunk_number": 6, "start_line": 154, "end_line": 188, "text": "\t\t\tonOpenChange: (open) => {\n\t\t\t\tif (!open) dismiss()\n\t\t\t},\n\t\t},\n\t})\n\n\treturn {\n\t\tid: id,\n\t\tdismiss,\n\t\tupdate,\n\t}\n}\n\nfunction useToast() {\n\tconst [state, setState] = React.useState<State>(memoryState)\n\n\tReact.useEffect(() => {\n\t\tlisteners.push(setState)\n\t\treturn () => {\n\t\t\tconst index = listeners.indexOf(setState)\n\t\t\tif (index > -1) {\n\t\t\t\tlisteners.splice(index, 1)\n\t\t\t}\n\t\t}\n\t}, [state])\n\n\treturn {\n\t\t...state,\n\t\ttoast,\n\t\tdismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n\t}\n}\n\nexport { useToast, toast }\n", "n_tokens": 163, "primary_symbol": "useToast", "primary_kind": "function", "primary_span": [167, 188], "def_symbols": ["useToast"], "symbols": ["useToast", "onOpenChange", "open", "dismiss", "return", "update", "function", "const", "state", "setState", "React", "useState", "State", "memoryState", "useEffect", "listeners", "push", "index", "indexOf", "splice", "toast", "toastId", "string", "dispatch", "type", "DISMISS_TOAST", "export"], "doc_head": "\t\t\tonOpenChange: (open) => {\n\t\t\t\tif (!open) dismiss()\n\t\t\t},\n\t\t},\n\t})\n\treturn {\n\t\tid: id,\n\t\tdismiss,\n\t\tupdate,\n\t}\n}\nfunction useToast() {\n\tconst [state, setState] = React.useState<State>(memoryState)\n\tReact.useEffect(() => {\n\t\tlisteners.push(setState)\n\t\treturn () => {\n\t\t\tconst index = listeners.indexOf(setState)\n\t\t\tif (index > -1) {\n\t\t\t\tlisteners.splice(index, 1)\n\t\t\t}\n\t\t}\n\t}, [state])\n\treturn {\n\t\t...state,\n\t\ttoast,\n\t\tdismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n\t}\n}\nexport { useToast, toast }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/switch.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/switch.tsx", "rel_path": "src/site/src/components/ui/switch.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 8, "text": "import * as React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Switch = React.forwardRef<\n\tReact.ElementRef<typeof SwitchPrimitives.Root>,\n\tReact.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>", "n_tokens": 60, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 8], "def_symbols": [], "symbols": ["import", "React", "from", "react", "SwitchPrimitives", "radix", "switch", "lib", "utils", "const", "Switch", "forwardRef", "ElementRef", "typeof", "Root", "ComponentPropsWithoutRef"], "doc_head": "import * as React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\nimport { cn } from \"@/lib/utils\"\nconst Switch = React.forwardRef<\n\tReact.ElementRef<typeof SwitchPrimitives.Root>,\n\tReact.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/switch.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/switch.tsx", "rel_path": "src/site/src/components/ui/switch.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 9, "end_line": 26, "text": ">(({ className, ...props }, ref) => (\n\t<SwitchPrimitives.Root\n\t\tclassName={cn(\n\t\t\t\"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t\tref={ref}\n\t>\n\t\t<SwitchPrimitives.Thumb\n\t\t\tclassName={cn(\n\t\t\t\t\"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=checked]:rtl:-translate-x-5 data-[state=unchecked]:translate-x-0\"\n\t\t\t)}\n\t\t/>\n\t</SwitchPrimitives.Root>\n))\nSwitch.displayName = SwitchPrimitives.Root.displayName\n", "n_tokens": 222, "primary_symbol": "", "primary_kind": "", "primary_span": [9, 26], "def_symbols": [], "symbols": ["className", "props", "ref", "SwitchPrimitives", "Root", "peer", "inline", "flex", "shrink", "cursor", "pointer", "items", "center", "rounded", "full", "border", "transparent", "transition", "colors", "focus", "visible", "outline", "hidden", "ring", "offset", "background", "disabled", "not", "allowed", "opacity", "data", "state", "checked", "primary", "unchecked", "input", "Thumb", "events", "none", "block", "shadow", "transform", "translate", "rtl", "Switch", "displayName"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<SwitchPrimitives.Root\n\t\tclassName={cn(\n\t\t\t\"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t\tref={ref}\n\t>\n\t\t<SwitchPrimitives.Thumb\n\t\t\tclassName={cn(\n\t\t\t\t\"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=checked]:rtl:-translate-x-5 data-[state=unchecked]:translate-x-0\"\n\t\t\t)}\n\t\t/>\n\t</SwitchPrimitives.Root>\n))\nSwitch.displayName = SwitchPrimitives.Root.displayName"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/switch.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/switch.tsx", "rel_path": "src/site/src/components/ui/switch.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 27, "end_line": 28, "text": "export { Switch }\n", "n_tokens": 4, "primary_symbol": "", "primary_kind": "", "primary_span": [27, 28], "def_symbols": [], "symbols": ["export", "Switch"], "doc_head": "export { Switch }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx", "rel_path": "src/site/src/components/ui/command.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 29, "text": "import * as React from \"react\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { SearchIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from \"@/components/ui/dialog\"\n\nfunction Command({ className, ...props }: React.ComponentProps<typeof CommandPrimitive>) {\n\treturn (\n\t\t<CommandPrimitive\n\t\t\tdata-slot=\"command\"\n\t\t\tclassName={cn(\"bg-card flex h-full w-full flex-col overflow-hidden rounded-md\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nfunction CommandDialog({\n\ttitle = \"Command Palette\",\n\tdescription = \"Search for a command to run...\",\n\tchildren,\n\tclassName,\n\tshowCloseButton = true,\n\t...props\n}: React.ComponentProps<typeof Dialog> & {\n\ttitle?: string\n\tdescription?: string\n\tclassName?: string\n\tshowCloseButton?: boolean", "n_tokens": 186, "primary_symbol": "Command", "primary_kind": "function", "primary_span": [8, 29], "def_symbols": ["Command", "CommandDialog"], "symbols": ["Command", "CommandDialog", "import", "React", "from", "react", "CommandPrimitive", "cmdk", "SearchIcon", "lucide", "lib", "utils", "Dialog", "DialogContent", "DialogDescription", "DialogHeader", "DialogTitle", "components", "dialog", "function", "className", "props", "ComponentProps", "typeof", "return", "data", "slot", "command", "card", "flex", "full", "col", "overflow", "hidden", "rounded", "title", "Palette", "description", "Search", "for", "run", "children", "showCloseButton", "true", "string", "boolean"], "doc_head": "import * as React from \"react\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { SearchIcon } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from \"@/components/ui/dialog\"\nfunction Command({ className, ...props }: React.ComponentProps<typeof CommandPrimitive>) {\n\treturn (\n\t\t<CommandPrimitive\n\t\t\tdata-slot=\"command\"\n\t\t\tclassName={cn(\"bg-card flex h-full w-full flex-col overflow-hidden rounded-md\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\nfunction CommandDialog({\n\ttitle = \"Command Palette\",\n\tdescription = \"Search for a command to run...\",\n\tchildren,\n\tclassName,\n\tshowCloseButton = true,\n\t...props\n}: React.ComponentProps<typeof Dialog> & {\n\ttitle?: string\n\tdescription?: string\n\tclassName?: string\n\tshowCloseButton?: boolean"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx", "rel_path": "src/site/src/components/ui/command.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 30, "end_line": 45, "text": "}) {\n\treturn (\n\t\t<Dialog {...props}>\n\t\t\t<DialogHeader className=\"sr-only\">\n\t\t\t\t<DialogTitle>{title}</DialogTitle>\n\t\t\t\t<DialogDescription>{description}</DialogDescription>\n\t\t\t</DialogHeader>\n\t\t\t<DialogContent className={cn(\"overflow-hidden p-0\", className)}>\n\t\t\t\t<Command className=\"[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n\t\t\t\t\t{children}\n\t\t\t\t</Command>\n\t\t\t</DialogContent>\n\t\t</Dialog>\n\t)\n}\n", "n_tokens": 250, "primary_symbol": "", "primary_kind": "", "primary_span": [30, 45], "def_symbols": [], "symbols": ["return", "Dialog", "props", "DialogHeader", "className", "only", "DialogTitle", "title", "DialogDescription", "description", "DialogContent", "overflow", "hidden", "Command", "cmdk", "group", "heading", "text", "muted", "foreground", "data", "slot", "command", "input", "wrapper", "font", "medium", "not", "_svg", "item", "children"], "doc_head": "}) {\n\treturn (\n\t\t<Dialog {...props}>\n\t\t\t<DialogHeader className=\"sr-only\">\n\t\t\t\t<DialogTitle>{title}</DialogTitle>\n\t\t\t\t<DialogDescription>{description}</DialogDescription>\n\t\t\t</DialogHeader>\n\t\t\t<DialogContent className={cn(\"overflow-hidden p-0\", className)}>\n\t\t\t\t<Command className=\"[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n\t\t\t\t\t{children}\n\t\t\t\t</Command>\n\t\t\t</DialogContent>\n\t\t</Dialog>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx", "rel_path": "src/site/src/components/ui/command.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 46, "end_line": 61, "text": "function CommandInput({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Input>) {\n\treturn (\n\t\t<div data-slot=\"command-input-wrapper\" className=\"flex h-9 items-center gap-2 border-b px-3\">\n\t\t\t<SearchIcon className=\"size-4 shrink-0 opacity-50\" />\n\t\t\t<CommandPrimitive.Input\n\t\t\t\tdata-slot=\"command-input\"\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50\",\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t</div>\n\t)\n}\n", "n_tokens": 144, "primary_symbol": "CommandInput", "primary_kind": "function", "primary_span": [46, 61], "def_symbols": ["CommandInput"], "symbols": ["CommandInput", "function", "className", "props", "React", "ComponentProps", "typeof", "CommandPrimitive", "Input", "return", "div", "data", "slot", "command", "input", "wrapper", "flex", "items", "center", "gap", "border", "SearchIcon", "size", "shrink", "opacity", "placeholder", "text", "muted", "foreground", "full", "rounded", "transparent", "outline", "hidden", "disabled", "cursor", "not", "allowed"], "doc_head": "function CommandInput({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Input>) {\n\treturn (\n\t\t<div data-slot=\"command-input-wrapper\" className=\"flex h-9 items-center gap-2 border-b px-3\">\n\t\t\t<SearchIcon className=\"size-4 shrink-0 opacity-50\" />\n\t\t\t<CommandPrimitive.Input\n\t\t\t\tdata-slot=\"command-input\"\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50\",\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t</div>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx", "rel_path": "src/site/src/components/ui/command.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 62, "end_line": 75, "text": "function CommandList({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.List>) {\n\treturn (\n\t\t<CommandPrimitive.List\n\t\t\tdata-slot=\"command-list\"\n\t\t\tclassName={cn(\"max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nfunction CommandEmpty({ ...props }: React.ComponentProps<typeof CommandPrimitive.Empty>) {\n\treturn <CommandPrimitive.Empty data-slot=\"command-empty\" className=\"py-6 text-center text-sm\" {...props} />\n}\n", "n_tokens": 113, "primary_symbol": "CommandList", "primary_kind": "function", "primary_span": [62, 75], "def_symbols": ["CommandList", "CommandEmpty"], "symbols": ["CommandList", "CommandEmpty", "function", "className", "props", "React", "ComponentProps", "typeof", "CommandPrimitive", "List", "return", "data", "slot", "command", "list", "max", "scroll", "overflow", "hidden", "auto", "Empty", "empty", "text", "center"], "doc_head": "function CommandList({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.List>) {\n\treturn (\n\t\t<CommandPrimitive.List\n\t\t\tdata-slot=\"command-list\"\n\t\t\tclassName={cn(\"max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\nfunction CommandEmpty({ ...props }: React.ComponentProps<typeof CommandPrimitive.Empty>) {\n\treturn <CommandPrimitive.Empty data-slot=\"command-empty\" className=\"py-6 text-center text-sm\" {...props} />\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx", "rel_path": "src/site/src/components/ui/command.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 76, "end_line": 98, "text": "function CommandGroup({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Group>) {\n\treturn (\n\t\t<CommandPrimitive.Group\n\t\t\tdata-slot=\"command-group\"\n\t\t\tclassName={cn(\n\t\t\t\t\"text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nfunction CommandSeparator({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Separator>) {\n\treturn (\n\t\t<CommandPrimitive.Separator\n\t\t\tdata-slot=\"command-separator\"\n\t\t\tclassName={cn(\"bg-border -mx-1 h-px\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n", "n_tokens": 190, "primary_symbol": "CommandGroup", "primary_kind": "function", "primary_span": [76, 98], "def_symbols": ["CommandGroup", "CommandSeparator"], "symbols": ["CommandGroup", "CommandSeparator", "function", "className", "props", "React", "ComponentProps", "typeof", "CommandPrimitive", "Group", "return", "data", "slot", "command", "group", "text", "foreground", "cmdk", "heading", "muted", "overflow", "hidden", "font", "medium", "Separator", "separator", "border"], "doc_head": "function CommandGroup({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Group>) {\n\treturn (\n\t\t<CommandPrimitive.Group\n\t\t\tdata-slot=\"command-group\"\n\t\t\tclassName={cn(\n\t\t\t\t\"text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\nfunction CommandSeparator({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Separator>) {\n\treturn (\n\t\t<CommandPrimitive.Separator\n\t\t\tdata-slot=\"command-separator\"\n\t\t\tclassName={cn(\"bg-border -mx-1 h-px\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx", "rel_path": "src/site/src/components/ui/command.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 99, "end_line": 111, "text": "function CommandItem({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Item>) {\n\treturn (\n\t\t<CommandPrimitive.Item\n\t\t\tdata-slot=\"command-item\"\n\t\t\tclassName={cn(\n\t\t\t\t\"data-[selected=true]:bg-accent/70 data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n", "n_tokens": 167, "primary_symbol": "CommandItem", "primary_kind": "function", "primary_span": [99, 111], "def_symbols": ["CommandItem"], "symbols": ["CommandItem", "function", "className", "props", "React", "ComponentProps", "typeof", "CommandPrimitive", "Item", "return", "data", "slot", "command", "item", "selected", "true", "accent", "text", "foreground", "_svg", "not", "class", "muted", "relative", "flex", "cursor", "default", "items", "center", "gap", "rounded", "outline", "hidden", "select", "none", "disabled", "pointer", "events", "opacity", "shrink", "size"], "doc_head": "function CommandItem({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Item>) {\n\treturn (\n\t\t<CommandPrimitive.Item\n\t\t\tdata-slot=\"command-item\"\n\t\t\tclassName={cn(\n\t\t\t\t\"data-[selected=true]:bg-accent/70 data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/command.tsx", "rel_path": "src/site/src/components/ui/command.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 112, "end_line": 133, "text": "function CommandShortcut({ className, ...props }: React.ComponentProps<\"span\">) {\n\treturn (\n\t\t<span\n\t\t\tdata-slot=\"command-shortcut\"\n\t\t\tclassName={cn(\"text-muted-foreground ml-auto text-xs tracking-wide\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nexport {\n\tCommand,\n\tCommandDialog,\n\tCommandInput,\n\tCommandList,\n\tCommandEmpty,\n\tCommandGroup,\n\tCommandItem,\n\tCommandShortcut,\n\tCommandSeparator,\n}\n", "n_tokens": 90, "primary_symbol": "CommandShortcut", "primary_kind": "function", "primary_span": [112, 133], "def_symbols": ["CommandShortcut"], "symbols": ["CommandShortcut", "function", "className", "props", "React", "ComponentProps", "span", "return", "data", "slot", "command", "shortcut", "text", "muted", "foreground", "auto", "tracking", "wide", "export", "Command", "CommandDialog", "CommandInput", "CommandList", "CommandEmpty", "CommandGroup", "CommandItem", "CommandSeparator"], "doc_head": "function CommandShortcut({ className, ...props }: React.ComponentProps<\"span\">) {\n\treturn (\n\t\t<span\n\t\t\tdata-slot=\"command-shortcut\"\n\t\t\tclassName={cn(\"text-muted-foreground ml-auto text-xs tracking-wide\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\nexport {\n\tCommand,\n\tCommandDialog,\n\tCommandInput,\n\tCommandList,\n\tCommandEmpty,\n\tCommandGroup,\n\tCommandItem,\n\tCommandShortcut,\n\tCommandSeparator,\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 2, "text": "import { SVGProps } from \"react\"\n", "n_tokens": 9, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 2], "def_symbols": [], "symbols": ["import", "SVGProps", "from", "react"], "doc_head": "import { SVGProps } from \"react\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 3, "end_line": 14, "text": "// linux-logo-bold from https://github.com/phosphor-icons/core (MIT license)\nexport function TuxIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 256 256\" {...props}>\n\t\t\t<path\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\td=\"M231 217a12 12 0 0 1-16-2c-2-1-35-44-35-127a52 52 0 1 0-104 0c0 83-33 126-35 127a12 12 0 0 1-18-14c0-1 29-39 29-113a76 76 0 1 1 152 0c0 74 29 112 29 113a12 12 0 0 1-2 16m-127-97a16 16 0 1 0-16-16 16 16 0 0 0 16 16m64-16a16 16 0 1 0-16 16 16 16 0 0 0 16-16m-73 51 28 12a12 12 0 0 0 10 0l28-12a12 12 0 0 0-10-22l-23 10-23-10a12 12 0 0 0-10 22m33 29a57 57 0 0 0-39 15 12 12 0 0 0 17 18 33 33 0 0 1 44 0 12 12 0 1 0 17-18 57 57 0 0 0-39-15\"\n\t\t\t/>\n\t\t</svg>\n\t)\n}\n", "n_tokens": 403, "primary_symbol": "TuxIcon", "primary_kind": "function", "primary_span": [4, 14], "def_symbols": ["TuxIcon"], "symbols": ["TuxIcon", "linux", "logo", "bold", "from", "https", "github", "com", "phosphor", "icons", "core", "MIT", "license", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "viewBox", "path", "fill", "currentColor", "M231"], "doc_head": "// linux-logo-bold from https://github.com/phosphor-icons/core (MIT license)\nexport function TuxIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 256 256\" {...props}>\n\t\t\t<path\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\td=\"M231 217a12 12 0 0 1-16-2c-2-1-35-44-35-127a52 52 0 1 0-104 0c0 83-33 126-35 127a12 12 0 0 1-18-14c0-1 29-39 29-113a76 76 0 1 1 152 0c0 74 29 112 29 113a12 12 0 0 1-2 16m-127-97a16 16 0 1 0-16-16 16 16 0 0 0 16 16m64-16a16 16 0 1 0-16 16 16 16 0 0 0 16-16m-73 51 28 12a12 12 0 0 0 10 0l28-12a12 12 0 0 0-10-22l-23 10-23-10a12 12 0 0 0-10 22m33 29a57 57 0 0 0-39 15 12 12 0 0 0 17 18 33 33 0 0 1 44 0 12 12 0 1 0 17-18 57 57 0 0 0-39-15\"\n\t\t\t/>\n\t\t</svg>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 15, "end_line": 28, "text": "// icon park (Apache 2.0) https://github.com/bytedance/IconPark/blob/master/LICENSE\nexport function WindowsIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg {...props} viewBox=\"0 0 48 48\">\n\t\t\t<path\n\t\t\t\tfill=\"none\"\n\t\t\t\tstroke=\"currentColor\"\n\t\t\t\tstrokeWidth=\"3.8\"\n\t\t\t\td=\"m6.8 11 12.9-1.7v12.1h-13zm18-2.2 16.4-2v14.6H25zm0 18.6 16.4.4v13.4L25 38.6zm-18-.8 12.9.3v10.9l-13-2.2z\"\n\t\t\t/>\n\t\t</svg>\n\t)\n}\n", "n_tokens": 181, "primary_symbol": "WindowsIcon", "primary_kind": "function", "primary_span": [16, 28], "def_symbols": ["WindowsIcon"], "symbols": ["WindowsIcon", "icon", "park", "Apache", "https", "github", "com", "bytedance", "IconPark", "blob", "master", "LICENSE", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "viewBox", "path", "fill", "none", "stroke", "currentColor", "strokeWidth"], "doc_head": "// icon park (Apache 2.0) https://github.com/bytedance/IconPark/blob/master/LICENSE\nexport function WindowsIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg {...props} viewBox=\"0 0 48 48\">\n\t\t\t<path\n\t\t\t\tfill=\"none\"\n\t\t\t\tstroke=\"currentColor\"\n\t\t\t\tstrokeWidth=\"3.8\"\n\t\t\t\td=\"m6.8 11 12.9-1.7v12.1h-13zm18-2.2 16.4-2v14.6H25zm0 18.6 16.4.4v13.4L25 38.6zm-18-.8 12.9.3v10.9l-13-2.2z\"\n\t\t\t/>\n\t\t</svg>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 29, "end_line": 40, "text": "// teenyicons (MIT) https://github.com/teenyicons/teenyicons/blob/master/LICENSE\nexport function AppleIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 20 20\" {...props}>\n\t\t\t<path\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\td=\"M14.1 4.7a5 5 0 0 1 3.8 2c-3.3 1.9-2.8 6.7.6 8L17.2 17c-.8 1.3-2 2.9-3.5 2.9-1.2 0-1.6-.9-3.3-.8s-2.2.8-3.5.8c-1.4 0-2.5-1.5-3.4-2.7-2.3-3.6-2.5-7.9-1.1-10 1-1.7 2.6-2.6 4.1-2.6 1.6 0 2.6.8 3.8.8 1.3 0 2-.8 3.8-.8M13.7 0c.2 1.2-.3 2.4-1 3.2a4 4 0 0 1-3 1.6c-.2-1.2.3-2.3 1-3.2.7-.8 2-1.5 3-1.6\"\n\t\t\t/>\n\t\t</svg>\n\t)\n}\n", "n_tokens": 361, "primary_symbol": "AppleIcon", "primary_kind": "function", "primary_span": [30, 40], "def_symbols": ["AppleIcon"], "symbols": ["AppleIcon", "teenyicons", "MIT", "https", "github", "com", "blob", "master", "LICENSE", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "viewBox", "path", "fill", "currentColor", "M14"], "doc_head": "// teenyicons (MIT) https://github.com/teenyicons/teenyicons/blob/master/LICENSE\nexport function AppleIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 20 20\" {...props}>\n\t\t\t<path\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\td=\"M14.1 4.7a5 5 0 0 1 3.8 2c-3.3 1.9-2.8 6.7.6 8L17.2 17c-.8 1.3-2 2.9-3.5 2.9-1.2 0-1.6-.9-3.3-.8s-2.2.8-3.5.8c-1.4 0-2.5-1.5-3.4-2.7-2.3-3.6-2.5-7.9-1.1-10 1-1.7 2.6-2.6 4.1-2.6 1.6 0 2.6.8 3.8.8 1.3 0 2-.8 3.8-.8M13.7 0c.2 1.2-.3 2.4-1 3.2a4 4 0 0 1-3 1.6c-.2-1.2.3-2.3 1-3.2.7-.8 2-1.5 3-1.6\"\n\t\t\t/>\n\t\t</svg>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 41, "end_line": 52, "text": "// Apache 2.0 https://github.com/Templarian/MaterialDesign/blob/master/LICENSE\nexport function FreeBsdIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 24 24\" {...props}>\n\t\t\t<path\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\td=\"M2.7 2C3.5 2 6 3.2 6 3.2 4.8 4 3.7 5 3 6.4 2.1 4.8 1.3 2.9 2 2.2l.7-.2m18.1.1c.4 0 .8 0 1 .2 1 1.1-2 5.8-2.4 6.4-.5.5-1.8 0-2.9-1-1-1.2-1.5-2.4-1-3 .4-.4 3.6-2.4 5.3-2.6m-8.8.5c1.3 0 2.5.2 3.7.7l-1 .7c-1 1-.6 2.8 1 4.4 1 1 2.1 1.6 3 1.6a2 2 0 0 0 1.5-.6l.7-1a9.7 9.7 0 1 1-18.6 3.8A9.7 9.7 0 0 1 12 2.7\"\n\t\t\t/>\n\t\t</svg>\n\t)\n}\n", "n_tokens": 370, "primary_symbol": "FreeBsdIcon", "primary_kind": "function", "primary_span": [42, 52], "def_symbols": ["FreeBsdIcon"], "symbols": ["FreeBsdIcon", "Apache", "https", "github", "com", "Templarian", "MaterialDesign", "blob", "master", "LICENSE", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "viewBox", "path", "fill", "currentColor"], "doc_head": "// Apache 2.0 https://github.com/Templarian/MaterialDesign/blob/master/LICENSE\nexport function FreeBsdIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 24 24\" {...props}>\n\t\t\t<path\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\td=\"M2.7 2C3.5 2 6 3.2 6 3.2 4.8 4 3.7 5 3 6.4 2.1 4.8 1.3 2.9 2 2.2l.7-.2m18.1.1c.4 0 .8 0 1 .2 1 1.1-2 5.8-2.4 6.4-.5.5-1.8 0-2.9-1-1-1.2-1.5-2.4-1-3 .4-.4 3.6-2.4 5.3-2.6m-8.8.5c1.3 0 2.5.2 3.7.7l-1 .7c-1 1-.6 2.8 1 4.4 1 1 2.1 1.6 3 1.6a2 2 0 0 0 1.5-.6l.7-1a9.7 9.7 0 1 1-18.6 3.8A9.7 9.7 0 0 1 12 2.7\"\n\t\t\t/>\n\t\t</svg>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 53, "end_line": 62, "text": "// ion icons (MIT) https://github.com/ionic-team/ionicons/blob/main/LICENSE\nexport function DockerIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg {...props} viewBox=\"0 0 512 512\" fill=\"currentColor\">\n\t\t\t<path d=\"M507 211c-1-1-14-11-42-11a133 133 0 0 0-21 2c-6-36-36-54-37-55l-7-4-5 7a102 102 0 0 0-13 30c-5 21-2 40 8 57-12 7-33 9-37 9H16a16 16 0 0 0-16 16 241 241 0 0 0 15 87c11 30 29 53 51 67 25 15 66 24 113 24a344 344 0 0 0 62-6 257 257 0 0 0 82-29 224 224 0 0 0 55-46c27-30 43-64 55-94h4c30 0 48-12 58-22a63 63 0 0 0 15-22l2-6Z\" />\n\t\t\t<path d=\"M47 236h45a4 4 0 0 0 4-4v-40a4 4 0 0 0-4-4H47a4 4 0 0 0-4 4v40a4 4 0 0 0 4 4m63 0h45a4 4 0 0 0 4-4v-40a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v40a4 4 0 0 0 4 4m63 0h45a4 4 0 0 0 4-4v-40a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v40a4 4 0 0 0 4 4m62 0h45a4 4 0 0 0 4-4v-40a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v40a4 4 0 0 0 4 4m-125-57h45a4 4 0 0 0 4-4v-41a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v41a4 4 0 0 0 4 4m63 0h45a4 4 0 0 0 4-4v-41a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v41a4 4 0 0 0 4 4m62 0h45a4 4 0 0 0 4-4v-41a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v41a4 4 0 0 0 4 4m0-58h45a4 4 0 0 0 4-4V76a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v40a4 4 0 0 0 4 4m63 116h45a4 4 0 0 0 4-4v-40a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v40a4 4 0 0 0 4 4\" />\n\t\t</svg>\n\t)\n}\n", "n_tokens": 941, "primary_symbol": "DockerIcon", "primary_kind": "function", "primary_span": [54, 62], "def_symbols": ["DockerIcon"], "symbols": ["DockerIcon", "ion", "icons", "MIT", "https", "github", "com", "ionic", "team", "ionicons", "blob", "main", "LICENSE", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "viewBox", "fill", "currentColor", "path", "M507", "M47"], "doc_head": "// ion icons (MIT) https://github.com/ionic-team/ionicons/blob/main/LICENSE\nexport function DockerIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg {...props} viewBox=\"0 0 512 512\" fill=\"currentColor\">\n\t\t\t<path d=\"M507 211c-1-1-14-11-42-11a133 133 0 0 0-21 2c-6-36-36-54-37-55l-7-4-5 7a102 102 0 0 0-13 30c-5 21-2 40 8 57-12 7-33 9-37 9H16a16 16 0 0 0-16 16 241 241 0 0 0 15 87c11 30 29 53 51 67 25 15 66 24 113 24a344 344 0 0 0 62-6 257 257 0 0 0 82-29 224 224 0 0 0 55-46c27-30 43-64 55-94h4c30 0 48-12 58-22a63 63 0 0 0 15-22l2-6Z\" />\n\t\t\t<path d=\"M47 236h45a4 4 0 0 0 4-4v-40a4 4 0 0 0-4-4H47a4 4 0 0 0-4 4v40a4 4 0 0 0 4 4m63 0h45a4 4 0 0 0 4-4v-40a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v40a4 4 0 0 0 4 4m63 0h45a4 4 0 0 0 4-4v-40a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v40a4 4 0 0 0 4 4m62 0h45a4 4 0 0 0 4-4v-40a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v40a4 4 0 0 0 4 4m-125-57h45a4 4 0 0 0 4-4v-41a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v41a4 4 0 0 0 4 4m63 0h45a4 4 0 0 0 4-4v-41a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v41a4 4 0 0 0 4 4m62 0h45a4 4 0 0 0 4-4v-41a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v41a4 4 0 0 0 4 4m0-58h45a4 4 0 0 0 4-4V76a4 4 0 0 0-4-4h-45a4 4 0 0 0-4 4v40a4 4 0 0 0 4 4m63 116h45a4 4 0 0 0 4-4v-40a4 4 0 0 0-4-"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 63, "end_line": 74, "text": "// MingCute Apache License 2.0 https://github.com/Richard9394/MingCute\nexport function Rows(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 24 24\" {...props}>\n\t\t\t<path\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\td=\"M5 3a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2zm0 2h14v4H5zm0 8a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 2h14v4H5z\"\n\t\t\t/>\n\t\t</svg>\n\t)\n}\n", "n_tokens": 235, "primary_symbol": "Rows", "primary_kind": "function", "primary_span": [64, 74], "def_symbols": ["Rows"], "symbols": ["Rows", "MingCute", "Apache", "License", "https", "github", "com", "Richard9394", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "viewBox", "path", "fill", "currentColor"], "doc_head": "// MingCute Apache License 2.0 https://github.com/Richard9394/MingCute\nexport function Rows(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 24 24\" {...props}>\n\t\t\t<path\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\td=\"M5 3a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2zm0 2h14v4H5zm0 8a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 2h14v4H5z\"\n\t\t\t/>\n\t\t</svg>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 75, "end_line": 85, "text": "// IconPark Apache License 2.0 https://github.com/bytedance/IconPark\nexport function ChartAverage(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg fill=\"none\" viewBox=\"0 0 48 48\" stroke=\"currentColor\" {...props}>\n\t\t\t<path strokeWidth=\"3\" d=\"M4 4v40h40\" />\n\t\t\t<path strokeWidth=\"3\" d=\"M10 38S15.3 4 27 4s17 34 17 34\" />\n\t\t\t<path strokeWidth=\"4\" d=\"M10 24h34\" />\n\t\t</svg>\n\t)\n}\n", "n_tokens": 139, "primary_symbol": "ChartAverage", "primary_kind": "function", "primary_span": [76, 85], "def_symbols": ["ChartAverage"], "symbols": ["ChartAverage", "IconPark", "Apache", "License", "https", "github", "com", "bytedance", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "fill", "none", "viewBox", "stroke", "currentColor", "path", "strokeWidth", "M10"], "doc_head": "// IconPark Apache License 2.0 https://github.com/bytedance/IconPark\nexport function ChartAverage(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg fill=\"none\" viewBox=\"0 0 48 48\" stroke=\"currentColor\" {...props}>\n\t\t\t<path strokeWidth=\"3\" d=\"M4 4v40h40\" />\n\t\t\t<path strokeWidth=\"3\" d=\"M10 38S15.3 4 27 4s17 34 17 34\" />\n\t\t\t<path strokeWidth=\"4\" d=\"M10 24h34\" />\n\t\t</svg>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 86, "end_line": 96, "text": "// IconPark Apache License 2.0 https://github.com/bytedance/IconPark\nexport function ChartMax(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg fill=\"none\" viewBox=\"0 0 48 48\" stroke=\"currentColor\" {...props}>\n\t\t\t<path strokeWidth=\"3\" d=\"M4 4v40h40\" />\n\t\t\t<path strokeWidth=\"3\" d=\"M10 38S15.3 4 27 4s17 34 17 34\" />\n\t\t\t<path strokeWidth=\"4\" d=\"M10 4h34\" />\n\t\t</svg>\n\t)\n}\n", "n_tokens": 139, "primary_symbol": "ChartMax", "primary_kind": "function", "primary_span": [87, 96], "def_symbols": ["ChartMax"], "symbols": ["ChartMax", "IconPark", "Apache", "License", "https", "github", "com", "bytedance", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "fill", "none", "viewBox", "stroke", "currentColor", "path", "strokeWidth", "M10"], "doc_head": "// IconPark Apache License 2.0 https://github.com/bytedance/IconPark\nexport function ChartMax(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg fill=\"none\" viewBox=\"0 0 48 48\" stroke=\"currentColor\" {...props}>\n\t\t\t<path strokeWidth=\"3\" d=\"M4 4v40h40\" />\n\t\t\t<path strokeWidth=\"3\" d=\"M10 38S15.3 4 27 4s17 34 17 34\" />\n\t\t\t<path strokeWidth=\"4\" d=\"M10 4h34\" />\n\t\t</svg>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 97, "end_line": 105, "text": "// Lucide https://github.com/lucide-icons/lucide (not in package for some reason)\nexport function EthernetIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg fill=\"none\" stroke=\"currentColor\" strokeLinecap=\"round\" strokeWidth=\"2\" viewBox=\"0 0 24 24\" {...props}>\n\t\t\t<path d=\"m15 20 3-3h2a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h2l3 3zM6 8v1m4-1v1m4-1v1m4-1v1\" />\n\t\t</svg>\n\t)\n}\n", "n_tokens": 190, "primary_symbol": "EthernetIcon", "primary_kind": "function", "primary_span": [98, 105], "def_symbols": ["EthernetIcon"], "symbols": ["EthernetIcon", "Lucide", "https", "github", "com", "lucide", "icons", "not", "package", "for", "some", "reason", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "fill", "none", "stroke", "currentColor", "strokeLinecap", "round", "strokeWidth", "viewBox", "path", "m15"], "doc_head": "// Lucide https://github.com/lucide-icons/lucide (not in package for some reason)\nexport function EthernetIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg fill=\"none\" stroke=\"currentColor\" strokeLinecap=\"round\" strokeWidth=\"2\" viewBox=\"0 0 24 24\" {...props}>\n\t\t\t<path d=\"m15 20 3-3h2a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h2l3 3zM6 8v1m4-1v1m4-1v1m4-1v1\" />\n\t\t</svg>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 11, "start_line": 106, "end_line": 114, "text": "// Phosphor MIT https://github.com/phosphor-icons/core\nexport function ThermometerIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 256 256\" {...props} fill=\"currentColor\">\n\t\t\t<path d=\"M212 56a28 28 0 1 0 28 28 28 28 0 0 0-28-28m0 40a12 12 0 1 1 12-12 12 12 0 0 1-12 12m-60 50V40a32 32 0 0 0-64 0v106a56 56 0 1 0 64 0m-16-42h-32V40a16 16 0 0 1 32 0Z\" />\n\t\t</svg>\n\t)\n}\n", "n_tokens": 195, "primary_symbol": "ThermometerIcon", "primary_kind": "function", "primary_span": [107, 114], "def_symbols": ["ThermometerIcon"], "symbols": ["ThermometerIcon", "Phosphor", "MIT", "https", "github", "com", "phosphor", "icons", "core", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "viewBox", "fill", "currentColor", "path", "M212"], "doc_head": "// Phosphor MIT https://github.com/phosphor-icons/core\nexport function ThermometerIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 256 256\" {...props} fill=\"currentColor\">\n\t\t\t<path d=\"M212 56a28 28 0 1 0 28 28 28 28 0 0 0-28-28m0 40a12 12 0 1 1 12-12 12 12 0 0 1-12 12m-60 50V40a32 32 0 0 0-64 0v106a56 56 0 1 0 64 0m-16-42h-32V40a16 16 0 0 1 32 0Z\" />\n\t\t</svg>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 12, "start_line": 115, "end_line": 124, "text": "// Huge icons (MIT)\nexport function GpuIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 24 24\" {...props} stroke=\"currentColor\" fill=\"none\" strokeWidth=\"2\">\n\t\t\t<path d=\"M4 21V4.1a1.5 1.5 0 0 0-1.1-1L2 3m2 2h13c2.4 0 3.5 0 4.3.7s.7 2 .7 4.3v4.5c0 2.4 0 3.5-.7 4.3-.8.7-2 .7-4.3.7h-4.9a1.8 1.8 0 0 1-1.6-1c-.3-.6-1-1-1.6-1H4\" />\n\t\t\t<path d=\"M19 11.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0m-11.5-3h2m-2 3h2m-2 3h2\" />\n\t\t</svg>\n\t)\n}\n", "n_tokens": 277, "primary_symbol": "GpuIcon", "primary_kind": "function", "primary_span": [116, 124], "def_symbols": ["GpuIcon"], "symbols": ["GpuIcon", "Huge", "icons", "MIT", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "viewBox", "stroke", "currentColor", "fill", "none", "strokeWidth", "path", "M19"], "doc_head": "// Huge icons (MIT)\nexport function GpuIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 24 24\" {...props} stroke=\"currentColor\" fill=\"none\" strokeWidth=\"2\">\n\t\t\t<path d=\"M4 21V4.1a1.5 1.5 0 0 0-1.1-1L2 3m2 2h13c2.4 0 3.5 0 4.3.7s.7 2 .7 4.3v4.5c0 2.4 0 3.5-.7 4.3-.8.7-2 .7-4.3.7h-4.9a1.8 1.8 0 0 1-1.6-1c-.3-.6-1-1-1.6-1H4\" />\n\t\t\t<path d=\"M19 11.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0m-11.5-3h2m-2 3h2m-2 3h2\" />\n\t\t</svg>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/icons.tsx", "rel_path": "src/site/src/components/ui/icons.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 13, "start_line": 125, "end_line": 133, "text": "// Remix icons (Apache 2.0) https://github.com/Remix-Design/RemixIcon/blob/master/License\nexport function HourglassIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 24 24\" {...props} fill=\"currentColor\">\n\t\t\t<path d=\"M4 2h16v4.5L13.5 12l6.5 5.5V22H4v-4.5l6.5-5.5L4 6.5zm12.3 5L18 5.5V4H6v1.5L7.7 7zM12 13.3l-6 5.2V20h1l5-3 5 3h1v-1.5z\" />\n\t\t</svg>\n\t)\n}\n", "n_tokens": 188, "primary_symbol": "HourglassIcon", "primary_kind": "function", "primary_span": [126, 133], "def_symbols": ["HourglassIcon"], "symbols": ["HourglassIcon", "Remix", "icons", "Apache", "https", "github", "com", "Design", "RemixIcon", "blob", "master", "License", "export", "function", "props", "SVGProps", "SVGSVGElement", "return", "svg", "viewBox", "fill", "currentColor", "path"], "doc_head": "// Remix icons (Apache 2.0) https://github.com/Remix-Design/RemixIcon/blob/master/License\nexport function HourglassIcon(props: SVGProps<SVGSVGElement>) {\n\treturn (\n\t\t<svg viewBox=\"0 0 24 24\" {...props} fill=\"currentColor\">\n\t\t\t<path d=\"M4 2h16v4.5L13.5 12l6.5 5.5V22H4v-4.5l6.5-5.5L4 6.5zm12.3 5L18 5.5V4H6v1.5L7.7 7zM12 13.3l-6 5.2V20h1l5-3 5 3h1v-1.5z\" />\n\t\t</svg>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dialog.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dialog.tsx", "rel_path": "src/site/src/components/ui/dialog.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 17, "text": "import * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n\tReact.ElementRef<typeof DialogPrimitive.Overlay>,\n\tReact.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>", "n_tokens": 104, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 17], "def_symbols": [], "symbols": ["import", "React", "from", "react", "DialogPrimitive", "radix", "dialog", "lucide", "lib", "utils", "const", "Dialog", "Root", "DialogTrigger", "Trigger", "DialogPortal", "Portal", "DialogClose", "Close", "DialogOverlay", "forwardRef", "ElementRef", "typeof", "Overlay", "ComponentPropsWithoutRef"], "doc_head": "import * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nconst Dialog = DialogPrimitive.Root\nconst DialogTrigger = DialogPrimitive.Trigger\nconst DialogPortal = DialogPrimitive.Portal\nconst DialogClose = DialogPrimitive.Close\nconst DialogOverlay = React.forwardRef<\n\tReact.ElementRef<typeof DialogPrimitive.Overlay>,\n\tReact.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dialog.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dialog.tsx", "rel_path": "src/site/src/components/ui/dialog.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 18, "end_line": 32, "text": ">(({ className, ...props }, ref) => (\n\t<DialogPrimitive.Overlay\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"fixed inset-0 z-50 bg-black/40 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n\tReact.ElementRef<typeof DialogPrimitive.Content>,\n\tReact.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>", "n_tokens": 130, "primary_symbol": "", "primary_kind": "", "primary_span": [18, 32], "def_symbols": [], "symbols": ["className", "props", "ref", "DialogPrimitive", "Overlay", "fixed", "inset", "black", "data", "state", "open", "animate", "closed", "out", "fade", "DialogOverlay", "displayName", "const", "DialogContent", "React", "forwardRef", "ElementRef", "typeof", "Content", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<DialogPrimitive.Overlay\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"fixed inset-0 z-50 bg-black/40 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\nconst DialogContent = React.forwardRef<\n\tReact.ElementRef<typeof DialogPrimitive.Content>,\n\tReact.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dialog.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dialog.tsx", "rel_path": "src/site/src/components/ui/dialog.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 33, "end_line": 53, "text": ">(({ className, children, ...props }, ref) => (\n\t<DialogPortal>\n\t\t<DialogOverlay />\n\t\t<DialogPrimitive.Content\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-card p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-50% data-[state=closed]:slide-out-to-top-48% data-[state=open]:slide-in-from-left-50% data-[state=open]:slide-in-from-top-48% sm:rounded-lg\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{children}\n\t\t\t<DialogPrimitive.Close className=\"absolute end-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n\t\t\t\t<X className=\"h-4 w-4\" />\n\t\t\t\t<span className=\"sr-only\">Close</span>\n\t\t\t</DialogPrimitive.Close>\n\t\t</DialogPrimitive.Content>\n\t</DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n", "n_tokens": 344, "primary_symbol": "", "primary_kind": "", "primary_span": [33, 53], "def_symbols": [], "symbols": ["className", "children", "props", "ref", "DialogPortal", "DialogOverlay", "DialogPrimitive", "Content", "fixed", "left", "top", "grid", "full", "max", "translate", "gap", "border", "card", "shadow", "duration", "data", "state", "open", "animate", "closed", "out", "fade", "zoom", "slide", "from", "rounded", "Close", "absolute", "end", "opacity", "ring", "offset", "background", "transition", "hover", "focus", "outline", "hidden", "disabled", "pointer", "events", "none", "accent", "text", "muted", "foreground", "span", "only", "DialogContent", "displayName"], "doc_head": ">(({ className, children, ...props }, ref) => (\n\t<DialogPortal>\n\t\t<DialogOverlay />\n\t\t<DialogPrimitive.Content\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-card p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-50% data-[state=closed]:slide-out-to-top-48% data-[state=open]:slide-in-from-left-50% data-[state=open]:slide-in-from-top-48% sm:rounded-lg\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{children}\n\t\t\t<DialogPrimitive.Close className=\"absolute end-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n\t\t\t\t<X className=\"h-4 w-4\" />\n\t\t\t\t<span className=\"sr-only\">Close</span>\n\t\t\t</DialogPrimitive.Close>\n\t\t</DialogPrimitive.Content>\n\t</DialogPortal>\n))\nDialogContent.displayName = DialogPrimitiv"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dialog.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dialog.tsx", "rel_path": "src/site/src/components/ui/dialog.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 54, "end_line": 66, "text": "const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\n\t<div className={cn(\"grid gap-1.5 text-center sm:text-start\", className)} {...props} />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\n\t<div className={cn(\"flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-3.5\", className)} {...props} />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n\tReact.ElementRef<typeof DialogPrimitive.Title>,\n\tReact.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>", "n_tokens": 138, "primary_symbol": "DialogHeader", "primary_kind": "function", "primary_span": [54, 66], "def_symbols": ["DialogHeader", "DialogFooter"], "symbols": ["DialogHeader", "DialogFooter", "const", "className", "props", "React", "HTMLAttributes", "HTMLDivElement", "div", "grid", "gap", "text", "center", "start", "displayName", "flex", "col", "reverse", "row", "justify", "end", "DialogTitle", "forwardRef", "ElementRef", "typeof", "DialogPrimitive", "Title", "ComponentPropsWithoutRef"], "doc_head": "const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\n\t<div className={cn(\"grid gap-1.5 text-center sm:text-start\", className)} {...props} />\n)\nDialogHeader.displayName = \"DialogHeader\"\nconst DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\n\t<div className={cn(\"flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-3.5\", className)} {...props} />\n)\nDialogFooter.displayName = \"DialogFooter\"\nconst DialogTitle = React.forwardRef<\n\tReact.ElementRef<typeof DialogPrimitive.Title>,\n\tReact.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dialog.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dialog.tsx", "rel_path": "src/site/src/components/ui/dialog.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 67, "end_line": 96, "text": ">(({ className, ...props }, ref) => (\n\t<DialogPrimitive.Title\n\t\tref={ref}\n\t\tclassName={cn(\"text-lg font-semibold leading-none tracking-tight\", className)}\n\t\t{...props}\n\t/>\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n\tReact.ElementRef<typeof DialogPrimitive.Description>,\n\tReact.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n\t<DialogPrimitive.Description ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n\tDialog,\n\tDialogPortal,\n\tDialogOverlay,\n\tDialogClose,\n\tDialogTrigger,\n\tDialogContent,\n\tDialogHeader,\n\tDialogFooter,\n\tDialogTitle,\n\tDialogDescription,\n}\n", "n_tokens": 171, "primary_symbol": "", "primary_kind": "", "primary_span": [67, 96], "def_symbols": [], "symbols": ["className", "props", "ref", "DialogPrimitive", "Title", "text", "font", "semibold", "leading", "none", "tracking", "tight", "DialogTitle", "displayName", "const", "DialogDescription", "React", "forwardRef", "ElementRef", "typeof", "Description", "ComponentPropsWithoutRef", "muted", "foreground", "export", "Dialog", "DialogPortal", "DialogOverlay", "DialogClose", "DialogTrigger", "DialogContent", "DialogHeader", "DialogFooter"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<DialogPrimitive.Title\n\t\tref={ref}\n\t\tclassName={cn(\"text-lg font-semibold leading-none tracking-tight\", className)}\n\t\t{...props}\n\t/>\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\nconst DialogDescription = React.forwardRef<\n\tReact.ElementRef<typeof DialogPrimitive.Description>,\n\tReact.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n\t<DialogPrimitive.Description ref={ref} className={cn(\"text-sm text-muted-foreground\", className)} {...props} />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\nexport {\n\tDialog,\n\tDialogPortal,\n\tDialogOverlay,\n\tDialogClose,\n\tDialogTrigger,\n\tDialogContent,\n\tDialogHeader,\n\tDialogFooter,\n\tDialogTitle,\n\tDialogDescription,\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/badge.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/badge.tsx", "rel_path": "src/site/src/components/ui/badge.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n\t\"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n\t{\n\t\tvariants: {\n\t\t\tvariant: {\n\t\t\t\tdefault: \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n\t\t\t\tsecondary: \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n\t\t\t\tdestructive: \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n\t\t\t\toutline: \"text-foreground\",\n\t\t\t},\n\t\t},\n\t\tdefaultVariants: {\n\t\t\tvariant: \"default\",\n\t\t},\n\t}\n)\n", "n_tokens": 194, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 22], "def_symbols": [], "symbols": ["import", "React", "from", "react", "cva", "type", "VariantProps", "class", "variance", "authority", "lib", "utils", "const", "badgeVariants", "inline", "flex", "items", "center", "rounded", "full", "border", "text", "font", "semibold", "transition", "colors", "focus", "outline", "hidden", "ring", "offset", "variants", "variant", "default", "transparent", "primary", "foreground", "hover", "secondary", "destructive", "defaultVariants"], "doc_head": "import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { cn } from \"@/lib/utils\"\nconst badgeVariants = cva(\n\t\"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n\t{\n\t\tvariants: {\n\t\t\tvariant: {\n\t\t\t\tdefault: \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n\t\t\t\tsecondary: \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n\t\t\t\tdestructive: \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n\t\t\t\toutline: \"text-foreground\",\n\t\t\t},\n\t\t},\n\t\tdefaultVariants: {\n\t\t\tvariant: \"default\",\n\t\t},\n\t}\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/badge.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/badge.tsx", "rel_path": "src/site/src/components/ui/badge.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 23, "end_line": 30, "text": "export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n\treturn <div className={cn(badgeVariants({ variant }), className)} {...props} />\n}\n\nexport { Badge, badgeVariants }\n", "n_tokens": 61, "primary_symbol": "Badge", "primary_kind": "function", "primary_span": [23, 30], "def_symbols": ["Badge"], "symbols": ["Badge", "export", "interface", "BadgeProps", "extends", "React", "HTMLAttributes", "HTMLDivElement", "VariantProps", "typeof", "badgeVariants", "function", "className", "variant", "props", "return", "div"], "doc_head": "export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n\treturn <div className={cn(badgeVariants({ variant }), className)} {...props} />\n}\nexport { Badge, badgeVariants }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/table.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/table.tsx", "rel_path": "src/site/src/components/ui/table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 25, "text": "import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<HTMLTableElement, React.HTMLAttributes<HTMLTableElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<div className=\"relative w-full overflow-auto\">\n\t\t\t<table ref={ref} className={cn(\"w-full caption-bottom text-sm\", className)} {...props} />\n\t\t</div>\n\t)\n)\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<thead\n\t\t\tref={ref}\n\t\t\tclassName={cn(\"bg-table-header border-b border-border/50 [&_tr]:border-b\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n)\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(", "n_tokens": 197, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 25], "def_symbols": [], "symbols": ["import", "React", "from", "react", "lib", "utils", "const", "Table", "forwardRef", "HTMLTableElement", "HTMLAttributes", "className", "props", "ref", "div", "relative", "full", "overflow", "auto", "table", "caption", "bottom", "text", "displayName", "TableHeader", "HTMLTableSectionElement", "thead", "header", "border", "_tr", "TableBody"], "doc_head": "import * as React from \"react\"\nimport { cn } from \"@/lib/utils\"\nconst Table = React.forwardRef<HTMLTableElement, React.HTMLAttributes<HTMLTableElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<div className=\"relative w-full overflow-auto\">\n\t\t\t<table ref={ref} className={cn(\"w-full caption-bottom text-sm\", className)} {...props} />\n\t\t</div>\n\t)\n)\nTable.displayName = \"Table\"\nconst TableHeader = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<thead\n\t\t\tref={ref}\n\t\t\tclassName={cn(\"bg-table-header border-b border-border/50 [&_tr]:border-b\", className)}\n\t\t\t{...props}\n\t\t/>\n\t)\n)\nTableHeader.displayName = \"TableHeader\"\nconst TableBody = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/table.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/table.tsx", "rel_path": "src/site/src/components/ui/table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 26, "end_line": 39, "text": "\t({ className, ...props }, ref) => (\n\t\t<tbody ref={ref} className={cn(\"[&_tr:last-child]:border-0\", className)} {...props} />\n\t)\n)\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<tfoot ref={ref} className={cn(\"border-t bg-muted/50 font-medium last:[&>tr]:border-b-0\", className)} {...props} />\n\t)\n)\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<HTMLTableRowElement, React.HTMLAttributes<HTMLTableRowElement>>(", "n_tokens": 144, "primary_symbol": "", "primary_kind": "", "primary_span": [26, 39], "def_symbols": [], "symbols": ["className", "props", "ref", "tbody", "_tr", "last", "child", "border", "TableBody", "displayName", "const", "TableFooter", "React", "forwardRef", "HTMLTableSectionElement", "HTMLAttributes", "tfoot", "muted", "font", "medium", "TableRow", "HTMLTableRowElement"], "doc_head": "\t({ className, ...props }, ref) => (\n\t\t<tbody ref={ref} className={cn(\"[&_tr:last-child]:border-0\", className)} {...props} />\n\t)\n)\nTableBody.displayName = \"TableBody\"\nconst TableFooter = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<tfoot ref={ref} className={cn(\"border-t bg-muted/50 font-medium last:[&>tr]:border-b-0\", className)} {...props} />\n\t)\n)\nTableFooter.displayName = \"TableFooter\"\nconst TableRow = React.forwardRef<HTMLTableRowElement, React.HTMLAttributes<HTMLTableRowElement>>("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/table.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/table.tsx", "rel_path": "src/site/src/components/ui/table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 40, "end_line": 67, "text": "\t({ className, ...props }, ref) => (\n\t\t<tr\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"border-b border-border/60 hover:bg-muted/40 dark:hover:bg-muted/20 data-[state=selected]:bg-muted!\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n)\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<HTMLTableCellElement, React.ThHTMLAttributes<HTMLTableCellElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<th\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"h-12 px-4 text-start align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pe-0\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n)\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<HTMLTableCellElement, React.TdHTMLAttributes<HTMLTableCellElement>>(", "n_tokens": 198, "primary_symbol": "", "primary_kind": "", "primary_span": [40, 67], "def_symbols": [], "symbols": ["className", "props", "ref", "border", "hover", "muted", "dark", "data", "state", "selected", "TableRow", "displayName", "const", "TableHead", "React", "forwardRef", "HTMLTableCellElement", "ThHTMLAttributes", "text", "start", "align", "middle", "font", "medium", "foreground", "has", "role", "checkbox", "TableCell", "TdHTMLAttributes"], "doc_head": "\t({ className, ...props }, ref) => (\n\t\t<tr\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"border-b border-border/60 hover:bg-muted/40 dark:hover:bg-muted/20 data-[state=selected]:bg-muted!\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n)\nTableRow.displayName = \"TableRow\"\nconst TableHead = React.forwardRef<HTMLTableCellElement, React.ThHTMLAttributes<HTMLTableCellElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<th\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"h-12 px-4 text-start align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pe-0\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n)\nTableHead.displayName = \"TableHead\"\nconst TableCell = React.forwardRef<HTMLTableCellElement, React.TdHTMLAttributes<HTMLTableCellElement>>("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/table.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/table.tsx", "rel_path": "src/site/src/components/ui/table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 68, "end_line": 82, "text": "\t({ className, ...props }, ref) => (\n\t\t<td ref={ref} className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pe-0\", className)} {...props} />\n\t)\n)\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<HTMLTableCaptionElement, React.HTMLAttributes<HTMLTableCaptionElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<caption ref={ref} className={cn(\"mt-4 text-sm text-muted-foreground\", className)} {...props} />\n\t)\n)\nTableCaption.displayName = \"TableCaption\"\n\nexport { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption }\n", "n_tokens": 148, "primary_symbol": "", "primary_kind": "", "primary_span": [68, 82], "def_symbols": [], "symbols": ["className", "props", "ref", "align", "middle", "has", "role", "checkbox", "TableCell", "displayName", "const", "TableCaption", "React", "forwardRef", "HTMLTableCaptionElement", "HTMLAttributes", "caption", "text", "muted", "foreground", "export", "Table", "TableHeader", "TableBody", "TableFooter", "TableHead", "TableRow"], "doc_head": "\t({ className, ...props }, ref) => (\n\t\t<td ref={ref} className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pe-0\", className)} {...props} />\n\t)\n)\nTableCell.displayName = \"TableCell\"\nconst TableCaption = React.forwardRef<HTMLTableCaptionElement, React.HTMLAttributes<HTMLTableCaptionElement>>(\n\t({ className, ...props }, ref) => (\n\t\t<caption ref={ref} className={cn(\"mt-4 text-sm text-muted-foreground\", className)} {...props} />\n\t)\n)\nTableCaption.displayName = \"TableCaption\"\nexport { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/separator.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/separator.tsx", "rel_path": "src/site/src/components/ui/separator.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 21, "text": "import * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Separator = React.forwardRef<\n\tReact.ElementRef<typeof SeparatorPrimitive.Root>,\n\tReact.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(({ className, orientation = \"horizontal\", decorative = true, ...props }, ref) => (\n\t<SeparatorPrimitive.Root\n\t\tref={ref}\n\t\tdecorative={decorative}\n\t\torientation={orientation}\n\t\tclassName={cn(\"shrink-0 bg-border\", orientation === \"horizontal\" ? \"h-px w-full\" : \"h-full w-px\", className)}\n\t\t{...props}\n\t/>\n))\nSeparator.displayName = SeparatorPrimitive.Root.displayName\n\nexport { Separator }\n", "n_tokens": 159, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 21], "def_symbols": [], "symbols": ["import", "React", "from", "react", "SeparatorPrimitive", "radix", "separator", "lib", "utils", "const", "Separator", "forwardRef", "ElementRef", "typeof", "Root", "ComponentPropsWithoutRef", "className", "orientation", "horizontal", "decorative", "true", "props", "ref", "shrink", "border", "full", "displayName", "export"], "doc_head": "import * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\nimport { cn } from \"@/lib/utils\"\nconst Separator = React.forwardRef<\n\tReact.ElementRef<typeof SeparatorPrimitive.Root>,\n\tReact.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(({ className, orientation = \"horizontal\", decorative = true, ...props }, ref) => (\n\t<SeparatorPrimitive.Root\n\t\tref={ref}\n\t\tdecorative={decorative}\n\t\torientation={orientation}\n\t\tclassName={cn(\"shrink-0 bg-border\", orientation === \"horizontal\" ? \"h-px w-full\" : \"h-full w-px\", className)}\n\t\t{...props}\n\t/>\n))\nSeparator.displayName = SeparatorPrimitive.Root.displayName\nexport { Separator }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/button.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/button.tsx", "rel_path": "src/site/src/components/ui/button.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 4, "text": "import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n", "n_tokens": 37, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 4], "def_symbols": [], "symbols": ["import", "React", "from", "react", "Slot", "radix", "slot", "cva", "type", "VariantProps", "class", "variance", "authority"], "doc_head": "import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/button.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/button.tsx", "rel_path": "src/site/src/components/ui/button.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 5, "end_line": 32, "text": "import { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n\t\"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 cursor-pointer\",\n\t{\n\t\tvariants: {\n\t\t\tvariant: {\n\t\t\t\tdefault: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n\t\t\t\tdestructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n\t\t\t\toutline: \"border bg-background hover:bg-accent/70 dark:hover:bg-accent/50 hover:text-accent-foreground\",\n\t\t\t\tsecondary: \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n\t\t\t\tghost: \"hover:bg-accent/70 hover:text-accent-foreground\",\n\t\t\t\tlink: \"text-primary underline-offset-4 hover:underline\",\n\t\t\t},\n\t\t\tsize: {\n\t\t\t\tdefault: \"h-10 px-4 py-2\",\n\t\t\t\tsm: \"h-9 rounded-md px-3\",\n\t\t\t\tlg: \"h-11 rounded-md px-8\",\n\t\t\t\ticon: \"h-10 w-10\",\n\t\t\t},\n\t\t},\n\t\tdefaultVariants: {\n\t\t\tvariant: \"default\",\n\t\t\tsize: \"default\",\n\t\t},\n\t}\n)\n", "n_tokens": 291, "primary_symbol": "", "primary_kind": "", "primary_span": [5, 32], "def_symbols": [], "symbols": ["import", "from", "lib", "utils", "const", "buttonVariants", "cva", "inline", "flex", "items", "center", "justify", "whitespace", "nowrap", "rounded", "text", "font", "medium", "ring", "offset", "background", "transition", "colors", "focus", "visible", "outline", "hidden", "disabled", "pointer", "events", "none", "opacity", "cursor", "variants", "variant", "default", "primary", "foreground", "hover", "destructive", "border", "accent", "dark", "secondary", "ghost", "link", "underline", "size", "icon", "defaultVariants"], "doc_head": "import { cn } from \"@/lib/utils\"\nconst buttonVariants = cva(\n\t\"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 cursor-pointer\",\n\t{\n\t\tvariants: {\n\t\t\tvariant: {\n\t\t\t\tdefault: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n\t\t\t\tdestructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n\t\t\t\toutline: \"border bg-background hover:bg-accent/70 dark:hover:bg-accent/50 hover:text-accent-foreground\",\n\t\t\t\tsecondary: \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n\t\t\t\tghost: \"hover:bg-accent/70 hover:text-accent-foreground\",\n\t\t\t\tlink: \"text-primary underline-offset-4 hover:underline\",\n\t\t\t},\n\t\t\tsize: {\n\t\t\t\tdefault: \"h-10 px-4 py-2\",\n\t\t\t\tsm: \"h-9 rounded-md px-3\",\n\t\t\t\tlg: \"h-11 rounded-md px-8\",\n\t\t\t\ticon: \"h-10 w-10\",\n\t\t\t},\n\t\t},\n\t\tdefaultVariants: {\n\t\t\tvariant: \"default\",\n\t\t\tsize: \"default\",\n\t\t},\n\t}\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/button.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/button.tsx", "rel_path": "src/site/src/components/ui/button.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 33, "end_line": 48, "text": "export interface ButtonProps\n\textends React.ButtonHTMLAttributes<HTMLButtonElement>,\n\t\tVariantProps<typeof buttonVariants> {\n\tasChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n\t({ className, variant, size, asChild = false, ...props }, ref) => {\n\t\tconst Comp = asChild ? Slot : \"button\"\n\t\treturn <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />\n\t}\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n", "n_tokens": 119, "primary_symbol": "", "primary_kind": "", "primary_span": [33, 48], "def_symbols": [], "symbols": ["export", "interface", "ButtonProps", "extends", "React", "ButtonHTMLAttributes", "HTMLButtonElement", "VariantProps", "typeof", "buttonVariants", "asChild", "boolean", "const", "Button", "forwardRef", "className", "variant", "size", "false", "props", "ref", "Comp", "Slot", "button", "return", "displayName"], "doc_head": "export interface ButtonProps\n\textends React.ButtonHTMLAttributes<HTMLButtonElement>,\n\t\tVariantProps<typeof buttonVariants> {\n\tasChild?: boolean\n}\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n\t({ className, variant, size, asChild = false, ...props }, ref) => {\n\t\tconst Comp = asChild ? Slot : \"button\"\n\t\treturn <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />\n\t}\n)\nButton.displayName = \"Button\"\nexport { Button, buttonVariants }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx", "rel_path": "src/site/src/components/ui/toast.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 12, "text": "import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n\tReact.ElementRef<typeof ToastPrimitives.Viewport>,\n\tReact.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>", "n_tokens": 100, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 12], "def_symbols": [], "symbols": ["import", "React", "from", "react", "ToastPrimitives", "radix", "toast", "cva", "type", "VariantProps", "class", "variance", "authority", "lucide", "lib", "utils", "const", "ToastProvider", "Provider", "ToastViewport", "forwardRef", "ElementRef", "typeof", "Viewport", "ComponentPropsWithoutRef"], "doc_head": "import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nconst ToastProvider = ToastPrimitives.Provider\nconst ToastViewport = React.forwardRef<\n\tReact.ElementRef<typeof ToastPrimitives.Viewport>,\n\tReact.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx", "rel_path": "src/site/src/components/ui/toast.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 13, "end_line": 42, "text": ">(({ className, ...props }, ref) => (\n\t<ToastPrimitives.Viewport\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"fixed top-0 z-100 flex max-h-dvh w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n\t\"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pe-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-(--radix-toast-swipe-end-x) data-[swipe=move]:translate-x-(--radix-toast-swipe-move-x) data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full sm:data-[state=open]:slide-in-from-bottom-full\",\n\t{\n\t\tvariants: {\n\t\t\tvariant: {\n\t\t\t\tdefault: \"border bg-background text-foreground\",\n\t\t\t\tdestructive: \"destructive group border-destructive bg-destructive text-destructive-foreground\",\n\t\t\t},\n\t\t},\n\t\tdefaultVariants: {\n\t\t\tvariant: \"default\",\n\t\t},\n\t}\n)\n\nconst Toast = React.forwardRef<\n\tReact.ElementRef<typeof ToastPrimitives.Root>,\n\tReact.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & VariantProps<typeof toastVariants>", "n_tokens": 371, "primary_symbol": "", "primary_kind": "", "primary_span": [13, 42], "def_symbols": [], "symbols": ["className", "props", "ref", "ToastPrimitives", "Viewport", "fixed", "top", "flex", "max", "dvh", "full", "col", "reverse", "bottom", "right", "auto", "ToastViewport", "displayName", "const", "toastVariants", "cva", "group", "pointer", "events", "relative", "items", "center", "justify", "between", "space", "overflow", "hidden", "rounded", "border", "shadow", "transition", "all", "data", "swipe", "cancel", "translate", "end", "radix", "toast", "move", "none", "state", "open", "animate", "closed", "out", "fade", "slide", "from", "variants", "variant", "default", "background", "text", "foreground", "destructive", "defaultVariants", "Toast", "React", "forwardRef", "ElementRef", "typeof", "Root", "ComponentPropsWithoutRef", "VariantProps"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<ToastPrimitives.Viewport\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"fixed top-0 z-100 flex max-h-dvh w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\nconst toastVariants = cva(\n\t\"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pe-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-(--radix-toast-swipe-end-x) data-[swipe=move]:translate-x-(--radix-toast-swipe-move-x) data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full sm:data-[state=open]:slide-in-from-bottom-full\",\n\t{\n\t\tvariants: {\n\t\t\tvariant: {\n\t\t\t\tdefault: \"border bg-background text-foreground\",\n\t\t\t\tdestructive: \"destructive group border-destructive bg-destructive text-destructive-foreground\",\n\t\t\t},\n\t\t},\n\t\tdefaultVariants: {\n\t\t\tvariant: \"default\",\n\t\t},\n\t}\n)\n"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx", "rel_path": "src/site/src/components/ui/toast.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 43, "end_line": 50, "text": ">(({ className, variant, ...props }, ref) => {\n\treturn <ToastPrimitives.Root ref={ref} className={cn(toastVariants({ variant }), className)} {...props} />\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n\tReact.ElementRef<typeof ToastPrimitives.Action>,\n\tReact.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>", "n_tokens": 79, "primary_symbol": "", "primary_kind": "", "primary_span": [43, 50], "def_symbols": [], "symbols": ["className", "variant", "props", "ref", "return", "ToastPrimitives", "Root", "toastVariants", "Toast", "displayName", "const", "ToastAction", "React", "forwardRef", "ElementRef", "typeof", "Action", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, variant, ...props }, ref) => {\n\treturn <ToastPrimitives.Root ref={ref} className={cn(toastVariants({ variant }), className)} {...props} />\n})\nToast.displayName = ToastPrimitives.Root.displayName\nconst ToastAction = React.forwardRef<\n\tReact.ElementRef<typeof ToastPrimitives.Action>,\n\tReact.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx", "rel_path": "src/site/src/components/ui/toast.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 51, "end_line": 65, "text": ">(({ className, ...props }, ref) => (\n\t<ToastPrimitives.Action\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 hover:group-[.destructive]:border-destructive/30 hover:group-[.destructive]:bg-destructive hover:group-[.destructive]:text-destructive-foreground focus:group-[.destructive]:ring-destructive\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n\tReact.ElementRef<typeof ToastPrimitives.Close>,\n\tReact.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>", "n_tokens": 206, "primary_symbol": "", "primary_kind": "", "primary_span": [51, 65], "def_symbols": [], "symbols": ["className", "props", "ref", "ToastPrimitives", "Action", "inline", "flex", "shrink", "items", "center", "justify", "rounded", "border", "transparent", "text", "font", "medium", "ring", "offset", "background", "transition", "colors", "hover", "secondary", "focus", "outline", "hidden", "disabled", "pointer", "events", "none", "opacity", "group", "destructive", "muted", "foreground", "ToastAction", "displayName", "const", "ToastClose", "React", "forwardRef", "ElementRef", "typeof", "Close", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<ToastPrimitives.Action\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 hover:group-[.destructive]:border-destructive/30 hover:group-[.destructive]:bg-destructive hover:group-[.destructive]:text-destructive-foreground focus:group-[.destructive]:ring-destructive\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\nconst ToastClose = React.forwardRef<\n\tReact.ElementRef<typeof ToastPrimitives.Close>,\n\tReact.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx", "rel_path": "src/site/src/components/ui/toast.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 66, "end_line": 83, "text": ">(({ className, ...props }, ref) => (\n\t<ToastPrimitives.Close\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-hidden focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 hover:group-[.destructive]:text-red-50 focus:group-[.destructive]:ring-red-400 focus:group-[.destructive]:ring-offset-red-600\",\n\t\t\tclassName\n\t\t)}\n\t\ttoast-close=\"\"\n\t\t{...props}\n\t>\n\t\t<X className=\"h-4 w-4\" />\n\t</ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n\tReact.ElementRef<typeof ToastPrimitives.Title>,\n\tReact.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>", "n_tokens": 205, "primary_symbol": "", "primary_kind": "", "primary_span": [66, 83], "def_symbols": [], "symbols": ["className", "props", "ref", "ToastPrimitives", "Close", "absolute", "right", "top", "rounded", "text", "foreground", "opacity", "transition", "hover", "focus", "outline", "hidden", "ring", "group", "destructive", "red", "offset", "toast", "close", "ToastClose", "displayName", "const", "ToastTitle", "React", "forwardRef", "ElementRef", "typeof", "Title", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<ToastPrimitives.Close\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-hidden focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 hover:group-[.destructive]:text-red-50 focus:group-[.destructive]:ring-red-400 focus:group-[.destructive]:ring-offset-red-600\",\n\t\t\tclassName\n\t\t)}\n\t\ttoast-close=\"\"\n\t\t{...props}\n\t>\n\t\t<X className=\"h-4 w-4\" />\n\t</ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\nconst ToastTitle = React.forwardRef<\n\tReact.ElementRef<typeof ToastPrimitives.Title>,\n\tReact.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/toast.tsx", "rel_path": "src/site/src/components/ui/toast.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 84, "end_line": 112, "text": ">(({ className, ...props }, ref) => (\n\t<ToastPrimitives.Title ref={ref} className={cn(\"text-sm font-semibold\", className)} {...props} />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n\tReact.ElementRef<typeof ToastPrimitives.Description>,\n\tReact.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n\t<ToastPrimitives.Description ref={ref} className={cn(\"text-sm opacity-90\", className)} {...props} />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n\ttype ToastProps,\n\ttype ToastActionElement,\n\tToastProvider,\n\tToastViewport,\n\tToast,\n\tToastTitle,\n\tToastDescription,\n\tToastClose,\n\tToastAction,\n}\n", "n_tokens": 181, "primary_symbol": "", "primary_kind": "", "primary_span": [84, 112], "def_symbols": [], "symbols": ["className", "props", "ref", "ToastPrimitives", "Title", "text", "font", "semibold", "ToastTitle", "displayName", "const", "ToastDescription", "React", "forwardRef", "ElementRef", "typeof", "Description", "ComponentPropsWithoutRef", "opacity", "type", "ToastProps", "Toast", "ToastActionElement", "ReactElement", "ToastAction", "export", "ToastProvider", "ToastViewport", "ToastClose"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<ToastPrimitives.Title ref={ref} className={cn(\"text-sm font-semibold\", className)} {...props} />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\nconst ToastDescription = React.forwardRef<\n\tReact.ElementRef<typeof ToastPrimitives.Description>,\n\tReact.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n\t<ToastPrimitives.Description ref={ref} className={cn(\"text-sm opacity-90\", className)} {...props} />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\nexport {\n\ttype ToastProps,\n\ttype ToastActionElement,\n\tToastProvider,\n\tToastViewport,\n\tToast,\n\tToastTitle,\n\tToastDescription,\n\tToastClose,\n\tToastAction,\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/checkbox.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/checkbox.tsx", "rel_path": "src/site/src/components/ui/checkbox.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 11, "text": "\"use client\"\n\nimport * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n\tReact.ElementRef<typeof CheckboxPrimitive.Root>,\n\tReact.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>", "n_tokens": 71, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 11], "def_symbols": [], "symbols": ["use", "client", "import", "React", "from", "react", "CheckboxPrimitive", "radix", "checkbox", "Check", "lucide", "lib", "utils", "const", "Checkbox", "forwardRef", "ElementRef", "typeof", "Root", "ComponentPropsWithoutRef"], "doc_head": "\"use client\"\nimport * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nconst Checkbox = React.forwardRef<\n\tReact.ElementRef<typeof CheckboxPrimitive.Root>,\n\tReact.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/checkbox.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/checkbox.tsx", "rel_path": "src/site/src/components/ui/checkbox.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 12, "end_line": 30, "text": ">(({ className, ...props }, ref) => (\n\t<CheckboxPrimitive.Root\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"peer size-4 flex items-center justify-center shrink-0 rounded-[.3em] border border-input ring-offset-background focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t>\n\t\t<CheckboxPrimitive.Indicator className={cn(\"flex items-center justify-center text-current\")}>\n\t\t\t<Check className=\"size-4\" />\n\t\t</CheckboxPrimitive.Indicator>\n\t</CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }\n", "n_tokens": 179, "primary_symbol": "", "primary_kind": "", "primary_span": [12, 30], "def_symbols": [], "symbols": ["className", "props", "ref", "CheckboxPrimitive", "Root", "peer", "size", "flex", "items", "center", "justify", "shrink", "rounded", "border", "input", "ring", "offset", "background", "focus", "visible", "outline", "hidden", "disabled", "cursor", "not", "allowed", "opacity", "data", "state", "checked", "primary", "text", "foreground", "Indicator", "current", "Check", "Checkbox", "displayName", "export"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<CheckboxPrimitive.Root\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"peer size-4 flex items-center justify-center shrink-0 rounded-[.3em] border border-input ring-offset-background focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t>\n\t\t<CheckboxPrimitive.Indicator className={cn(\"flex items-center justify-center text-current\")}>\n\t\t\t<Check className=\"size-4\" />\n\t\t</CheckboxPrimitive.Indicator>\n\t</CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\nexport { Checkbox }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/collapsible.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/collapsible.tsx", "rel_path": "src/site/src/components/ui/collapsible.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "import * as React from \"react\"\nimport { ChevronDownIcon, HourglassIcon } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"./button\"\n\ninterface CollapsibleProps {\n\ttitle: string\n\tchildren: React.ReactNode\n\tdescription?: React.ReactNode\n\tdefaultOpen?: boolean\n\tclassName?: string\n\ticon?: React.ReactNode\n}\n\nexport function Collapsible({ title, children, description, defaultOpen = false, className, icon }: CollapsibleProps) {\n\tconst [isOpen, setIsOpen] = React.useState(defaultOpen)\n\n\treturn (\n\t\t<div className={cn(\"border rounded-lg\", className)}>\n\t\t\t<Button\n\t\t\t\tvariant=\"ghost\"\n\t\t\t\tclassName=\"w-full justify-between p-4 font-semibold\"", "n_tokens": 152, "primary_symbol": "Collapsible", "primary_kind": "function", "primary_span": [15, 22], "def_symbols": ["Collapsible"], "symbols": ["Collapsible", "import", "React", "from", "react", "ChevronDownIcon", "HourglassIcon", "lucide", "lib", "utils", "Button", "button", "interface", "CollapsibleProps", "title", "string", "children", "ReactNode", "description", "defaultOpen", "boolean", "className", "icon", "export", "function", "false", "const", "isOpen", "setIsOpen", "useState", "return", "div", "border", "rounded", "variant", "ghost", "full", "justify", "between", "font", "semibold"], "doc_head": "import * as React from \"react\"\nimport { ChevronDownIcon, HourglassIcon } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"./button\"\ninterface CollapsibleProps {\n\ttitle: string\n\tchildren: React.ReactNode\n\tdescription?: React.ReactNode\n\tdefaultOpen?: boolean\n\tclassName?: string\n\ticon?: React.ReactNode\n}\nexport function Collapsible({ title, children, description, defaultOpen = false, className, icon }: CollapsibleProps) {\n\tconst [isOpen, setIsOpen] = React.useState(defaultOpen)\n\treturn (\n\t\t<div className={cn(\"border rounded-lg\", className)}>\n\t\t\t<Button\n\t\t\t\tvariant=\"ghost\"\n\t\t\t\tclassName=\"w-full justify-between p-4 font-semibold\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/collapsible.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/collapsible.tsx", "rel_path": "src/site/src/components/ui/collapsible.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 23, "end_line": 49, "text": "\t\t\t\tonClick={() => setIsOpen(!isOpen)}\n\t\t\t>\n\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t{icon}\n\t\t\t\t\t{title}\n\t\t\t\t</div>\n\t\t\t\t<ChevronDownIcon\n\t\t\t\t\tclassName={cn(\"h-4 w-4 transition-transform duration-200\", {\n\t\t\t\t\t\t\"rotate-180\": isOpen,\n\t\t\t\t\t})}\n\t\t\t\t/>\n\t\t\t</Button>\n\t\t\t{description && (\n\t\t\t\t<div className=\"px-4 pb-2 text-sm text-muted-foreground\">\n\t\t\t\t\t{description}\n\t\t\t\t</div>\n\t\t\t)}\n\t\t\t{isOpen && (\n\t\t\t\t<div className=\"px-4 pb-4\">\n\t\t\t\t\t<div className=\"grid gap-3\">\n\t\t\t\t\t\t{children}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t)\n} ", "n_tokens": 177, "primary_symbol": "", "primary_kind": "", "primary_span": [23, 49], "def_symbols": [], "symbols": ["onClick", "setIsOpen", "isOpen", "div", "className", "flex", "items", "center", "gap", "icon", "title", "ChevronDownIcon", "transition", "transform", "duration", "rotate", "Button", "description", "text", "muted", "foreground", "grid", "children"], "doc_head": "\t\t\t\tonClick={() => setIsOpen(!isOpen)}\n\t\t\t>\n\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t{icon}\n\t\t\t\t\t{title}\n\t\t\t\t</div>\n\t\t\t\t<ChevronDownIcon\n\t\t\t\t\tclassName={cn(\"h-4 w-4 transition-transform duration-200\", {\n\t\t\t\t\t\t\"rotate-180\": isOpen,\n\t\t\t\t\t})}\n\t\t\t\t/>\n\t\t\t</Button>\n\t\t\t{description && (\n\t\t\t\t<div className=\"px-4 pb-2 text-sm text-muted-foreground\">\n\t\t\t\t\t{description}\n\t\t\t\t</div>\n\t\t\t)}\n\t\t\t{isOpen && (\n\t\t\t\t<div className=\"px-4 pb-4\">\n\t\t\t\t\t<div className=\"grid gap-3\">\n\t\t\t\t\t\t{children}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t)\n} "}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx", "rel_path": "src/site/src/components/ui/dropdown-menu.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 23, "text": "import * as React from \"react\"\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst DropdownMenu = DropdownMenuPrimitive.Root\n\nconst DropdownMenuTrigger = DropdownMenuPrimitive.Trigger\n\nconst DropdownMenuGroup = DropdownMenuPrimitive.Group\n\nconst DropdownMenuPortal = DropdownMenuPrimitive.Portal\n\nconst DropdownMenuSub = DropdownMenuPrimitive.Sub\n\nconst DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {\n\t\tinset?: boolean\n\t}", "n_tokens": 156, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 23], "def_symbols": [], "symbols": ["import", "React", "from", "react", "DropdownMenuPrimitive", "radix", "dropdown", "menu", "Check", "ChevronRight", "Circle", "lucide", "lib", "utils", "const", "DropdownMenu", "Root", "DropdownMenuTrigger", "Trigger", "DropdownMenuGroup", "Group", "DropdownMenuPortal", "Portal", "DropdownMenuSub", "Sub", "DropdownMenuRadioGroup", "RadioGroup", "DropdownMenuSubTrigger", "forwardRef", "ElementRef", "typeof", "SubTrigger", "ComponentPropsWithoutRef", "inset", "boolean"], "doc_head": "import * as React from \"react\"\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nconst DropdownMenu = DropdownMenuPrimitive.Root\nconst DropdownMenuTrigger = DropdownMenuPrimitive.Trigger\nconst DropdownMenuGroup = DropdownMenuPrimitive.Group\nconst DropdownMenuPortal = DropdownMenuPrimitive.Portal\nconst DropdownMenuSub = DropdownMenuPrimitive.Sub\nconst DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup\nconst DropdownMenuSubTrigger = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {\n\t\tinset?: boolean\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx", "rel_path": "src/site/src/components/ui/dropdown-menu.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 24, "end_line": 42, "text": ">(({ className, inset, children, ...props }, ref) => (\n\t<DropdownMenuPrimitive.SubTrigger\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"flex select-none items-center rounded-sm px-2.5 py-1.5 text-sm outline-hidden focus:bg-accent/70 data-[state=open]:bg-accent/70\",\n\t\t\tinset && \"ps-8\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t>\n\t\t{children}\n\t\t<ChevronRight className=\"ms-auto h-4 w-4\" />\n\t</DropdownMenuPrimitive.SubTrigger>\n))\nDropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName\n\nconst DropdownMenuSubContent = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>", "n_tokens": 176, "primary_symbol": "", "primary_kind": "", "primary_span": [24, 42], "def_symbols": [], "symbols": ["className", "inset", "children", "props", "ref", "DropdownMenuPrimitive", "SubTrigger", "flex", "select", "none", "items", "center", "rounded", "text", "outline", "hidden", "focus", "accent", "data", "state", "open", "ChevronRight", "auto", "DropdownMenuSubTrigger", "displayName", "const", "DropdownMenuSubContent", "React", "forwardRef", "ElementRef", "typeof", "SubContent", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, inset, children, ...props }, ref) => (\n\t<DropdownMenuPrimitive.SubTrigger\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"flex select-none items-center rounded-sm px-2.5 py-1.5 text-sm outline-hidden focus:bg-accent/70 data-[state=open]:bg-accent/70\",\n\t\t\tinset && \"ps-8\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t>\n\t\t{children}\n\t\t<ChevronRight className=\"ms-auto h-4 w-4\" />\n\t</DropdownMenuPrimitive.SubTrigger>\n))\nDropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName\nconst DropdownMenuSubContent = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx", "rel_path": "src/site/src/components/ui/dropdown-menu.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 43, "end_line": 57, "text": ">(({ className, ...props }, ref) => (\n\t<DropdownMenuPrimitive.SubContent\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nDropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName\n\nconst DropdownMenuContent = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.Content>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>", "n_tokens": 217, "primary_symbol": "", "primary_kind": "", "primary_span": [43, 57], "def_symbols": [], "symbols": ["className", "props", "ref", "DropdownMenuPrimitive", "SubContent", "min", "overflow", "hidden", "rounded", "border", "popover", "text", "foreground", "shadow", "data", "state", "open", "animate", "closed", "out", "fade", "zoom", "side", "bottom", "slide", "from", "top", "left", "right", "DropdownMenuSubContent", "displayName", "const", "DropdownMenuContent", "React", "forwardRef", "ElementRef", "typeof", "Content", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<DropdownMenuPrimitive.SubContent\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nDropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName\nconst DropdownMenuContent = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.Content>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx", "rel_path": "src/site/src/components/ui/dropdown-menu.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 58, "end_line": 77, "text": ">(({ className, sideOffset = 4, ...props }, ref) => (\n\t<DropdownMenuPrimitive.Portal>\n\t\t<DropdownMenuPrimitive.Content\n\t\t\tref={ref}\n\t\t\tsideOffset={sideOffset}\n\t\t\tclassName={cn(\n\t\t\t\t\"z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t</DropdownMenuPrimitive.Portal>\n))\nDropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName\n\nconst DropdownMenuItem = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.Item>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {\n\t\tinset?: boolean\n\t}", "n_tokens": 254, "primary_symbol": "", "primary_kind": "", "primary_span": [58, 77], "def_symbols": [], "symbols": ["className", "sideOffset", "props", "ref", "DropdownMenuPrimitive", "Portal", "Content", "min", "overflow", "hidden", "rounded", "border", "popover", "text", "foreground", "shadow", "data", "state", "open", "animate", "closed", "out", "fade", "zoom", "side", "bottom", "slide", "from", "top", "left", "right", "DropdownMenuContent", "displayName", "const", "DropdownMenuItem", "React", "forwardRef", "ElementRef", "typeof", "Item", "ComponentPropsWithoutRef", "inset", "boolean"], "doc_head": ">(({ className, sideOffset = 4, ...props }, ref) => (\n\t<DropdownMenuPrimitive.Portal>\n\t\t<DropdownMenuPrimitive.Content\n\t\t\tref={ref}\n\t\t\tsideOffset={sideOffset}\n\t\t\tclassName={cn(\n\t\t\t\t\"z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t</DropdownMenuPrimitive.Portal>\n))\nDropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName\nconst DropdownMenuItem = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.Item>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {\n\t\tinset?: boolean\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx", "rel_path": "src/site/src/components/ui/dropdown-menu.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 78, "end_line": 93, "text": ">(({ className, inset, ...props }, ref) => (\n\t<DropdownMenuPrimitive.Item\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"cursor-pointer relative flex select-none items-center rounded-sm px-2.5 py-1.5 text-sm outline-hidden focus:bg-accent/70 focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50\",\n\t\t\tinset && \"ps-8\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nDropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>", "n_tokens": 151, "primary_symbol": "", "primary_kind": "", "primary_span": [78, 93], "def_symbols": [], "symbols": ["className", "inset", "props", "ref", "DropdownMenuPrimitive", "Item", "cursor", "pointer", "relative", "flex", "select", "none", "items", "center", "rounded", "text", "outline", "hidden", "focus", "accent", "foreground", "data", "disabled", "events", "opacity", "DropdownMenuItem", "displayName", "const", "DropdownMenuCheckboxItem", "React", "forwardRef", "ElementRef", "typeof", "CheckboxItem", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, inset, ...props }, ref) => (\n\t<DropdownMenuPrimitive.Item\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"cursor-pointer relative flex select-none items-center rounded-sm px-2.5 py-1.5 text-sm outline-hidden focus:bg-accent/70 focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50\",\n\t\t\tinset && \"ps-8\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t/>\n))\nDropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName\nconst DropdownMenuCheckboxItem = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx", "rel_path": "src/site/src/components/ui/dropdown-menu.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 94, "end_line": 116, "text": ">(({ className, children, checked, ...props }, ref) => (\n\t<DropdownMenuPrimitive.CheckboxItem\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"relative flex cursor-pointer select-none items-center rounded-sm py-1.5 ps-8 pe-2.5 text-sm outline-hidden focus:bg-accent/70 focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50\",\n\t\t\tclassName\n\t\t)}\n\t\tchecked={checked}\n\t\t{...props}\n\t>\n\t\t<span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n\t\t\t<DropdownMenuPrimitive.ItemIndicator>\n\t\t\t\t<Check className=\"h-4 w-4\" />\n\t\t\t</DropdownMenuPrimitive.ItemIndicator>\n\t\t</span>\n\t\t{children}\n\t</DropdownMenuPrimitive.CheckboxItem>\n))\nDropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName\n\nconst DropdownMenuRadioItem = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>", "n_tokens": 235, "primary_symbol": "", "primary_kind": "", "primary_span": [94, 116], "def_symbols": [], "symbols": ["className", "children", "checked", "props", "ref", "DropdownMenuPrimitive", "CheckboxItem", "relative", "flex", "cursor", "pointer", "select", "none", "items", "center", "rounded", "text", "outline", "hidden", "focus", "accent", "foreground", "data", "disabled", "events", "opacity", "span", "absolute", "left", "justify", "ItemIndicator", "Check", "DropdownMenuCheckboxItem", "displayName", "const", "DropdownMenuRadioItem", "React", "forwardRef", "ElementRef", "typeof", "RadioItem", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, children, checked, ...props }, ref) => (\n\t<DropdownMenuPrimitive.CheckboxItem\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"relative flex cursor-pointer select-none items-center rounded-sm py-1.5 ps-8 pe-2.5 text-sm outline-hidden focus:bg-accent/70 focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50\",\n\t\t\tclassName\n\t\t)}\n\t\tchecked={checked}\n\t\t{...props}\n\t>\n\t\t<span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n\t\t\t<DropdownMenuPrimitive.ItemIndicator>\n\t\t\t\t<Check className=\"h-4 w-4\" />\n\t\t\t</DropdownMenuPrimitive.ItemIndicator>\n\t\t</span>\n\t\t{children}\n\t</DropdownMenuPrimitive.CheckboxItem>\n))\nDropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName\nconst DropdownMenuRadioItem = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx", "rel_path": "src/site/src/components/ui/dropdown-menu.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 117, "end_line": 140, "text": ">(({ className, children, ...props }, ref) => (\n\t<DropdownMenuPrimitive.RadioItem\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"relative flex cursor-pointer select-none items-center rounded-sm py-1.5 ps-8 pe-2.5 text-sm outline-hidden focus:bg-accent/70 focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t>\n\t\t<span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n\t\t\t<DropdownMenuPrimitive.ItemIndicator>\n\t\t\t\t<Circle className=\"h-2 w-2 fill-current\" />\n\t\t\t</DropdownMenuPrimitive.ItemIndicator>\n\t\t</span>\n\t\t{children}\n\t</DropdownMenuPrimitive.RadioItem>\n))\nDropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName\n\nconst DropdownMenuLabel = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.Label>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {\n\t\tinset?: boolean\n\t}", "n_tokens": 234, "primary_symbol": "", "primary_kind": "", "primary_span": [117, 140], "def_symbols": [], "symbols": ["className", "children", "props", "ref", "DropdownMenuPrimitive", "RadioItem", "relative", "flex", "cursor", "pointer", "select", "none", "items", "center", "rounded", "text", "outline", "hidden", "focus", "accent", "foreground", "data", "disabled", "events", "opacity", "span", "absolute", "left", "justify", "ItemIndicator", "Circle", "fill", "current", "DropdownMenuRadioItem", "displayName", "const", "DropdownMenuLabel", "React", "forwardRef", "ElementRef", "typeof", "Label", "ComponentPropsWithoutRef", "inset", "boolean"], "doc_head": ">(({ className, children, ...props }, ref) => (\n\t<DropdownMenuPrimitive.RadioItem\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"relative flex cursor-pointer select-none items-center rounded-sm py-1.5 ps-8 pe-2.5 text-sm outline-hidden focus:bg-accent/70 focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t>\n\t\t<span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n\t\t\t<DropdownMenuPrimitive.ItemIndicator>\n\t\t\t\t<Circle className=\"h-2 w-2 fill-current\" />\n\t\t\t</DropdownMenuPrimitive.ItemIndicator>\n\t\t</span>\n\t\t{children}\n\t</DropdownMenuPrimitive.RadioItem>\n))\nDropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName\nconst DropdownMenuLabel = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.Label>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {\n\t\tinset?: boolean\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx", "rel_path": "src/site/src/components/ui/dropdown-menu.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 141, "end_line": 157, "text": ">(({ className, inset, ...props }, ref) => (\n\t<DropdownMenuPrimitive.Label\n\t\tref={ref}\n\t\tclassName={cn(\"px-2.5 py-1.5 text-sm font-semibold\", inset && \"ps-8\", className)}\n\t\t{...props}\n\t/>\n))\nDropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName\n\nconst DropdownMenuSeparator = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n\t<DropdownMenuPrimitive.Separator ref={ref} className={cn(\"-mx-1 my-1 h-px bg-muted\", className)} {...props} />\n))\nDropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName\n", "n_tokens": 164, "primary_symbol": "", "primary_kind": "", "primary_span": [141, 157], "def_symbols": [], "symbols": ["className", "inset", "props", "ref", "DropdownMenuPrimitive", "Label", "text", "font", "semibold", "DropdownMenuLabel", "displayName", "const", "DropdownMenuSeparator", "React", "forwardRef", "ElementRef", "typeof", "Separator", "ComponentPropsWithoutRef", "muted"], "doc_head": ">(({ className, inset, ...props }, ref) => (\n\t<DropdownMenuPrimitive.Label\n\t\tref={ref}\n\t\tclassName={cn(\"px-2.5 py-1.5 text-sm font-semibold\", inset && \"ps-8\", className)}\n\t\t{...props}\n\t/>\n))\nDropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName\nconst DropdownMenuSeparator = React.forwardRef<\n\tReact.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n\tReact.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n\t<DropdownMenuPrimitive.Separator ref={ref} className={cn(\"-mx-1 my-1 h-px bg-muted\", className)} {...props} />\n))\nDropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/dropdown-menu.tsx", "rel_path": "src/site/src/components/ui/dropdown-menu.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 158, "end_line": 180, "text": "const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {\n\treturn <span className={cn(\"ms-auto text-xs tracking-widest opacity-60\", className)} {...props} />\n}\nDropdownMenuShortcut.displayName = \"DropdownMenuShortcut\"\n\nexport {\n\tDropdownMenu,\n\tDropdownMenuTrigger,\n\tDropdownMenuContent,\n\tDropdownMenuItem,\n\tDropdownMenuCheckboxItem,\n\tDropdownMenuRadioItem,\n\tDropdownMenuLabel,\n\tDropdownMenuSeparator,\n\tDropdownMenuShortcut,\n\tDropdownMenuGroup,\n\tDropdownMenuPortal,\n\tDropdownMenuSub,\n\tDropdownMenuSubContent,\n\tDropdownMenuSubTrigger,\n\tDropdownMenuRadioGroup,\n}\n", "n_tokens": 137, "primary_symbol": "DropdownMenuShortcut", "primary_kind": "function", "primary_span": [158, 180], "def_symbols": ["DropdownMenuShortcut"], "symbols": ["DropdownMenuShortcut", "const", "className", "props", "React", "HTMLAttributes", "HTMLSpanElement", "return", "span", "auto", "text", "tracking", "widest", "opacity", "displayName", "export", "DropdownMenu", "DropdownMenuTrigger", "DropdownMenuContent", "DropdownMenuItem", "DropdownMenuCheckboxItem", "DropdownMenuRadioItem", "DropdownMenuLabel", "DropdownMenuSeparator", "DropdownMenuGroup", "DropdownMenuPortal", "DropdownMenuSub", "DropdownMenuSubContent", "DropdownMenuSubTrigger", "DropdownMenuRadioGroup"], "doc_head": "const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {\n\treturn <span className={cn(\"ms-auto text-xs tracking-widest opacity-60\", className)} {...props} />\n}\nDropdownMenuShortcut.displayName = \"DropdownMenuShortcut\"\nexport {\n\tDropdownMenu,\n\tDropdownMenuTrigger,\n\tDropdownMenuContent,\n\tDropdownMenuItem,\n\tDropdownMenuCheckboxItem,\n\tDropdownMenuRadioItem,\n\tDropdownMenuLabel,\n\tDropdownMenuSeparator,\n\tDropdownMenuShortcut,\n\tDropdownMenuGroup,\n\tDropdownMenuPortal,\n\tDropdownMenuSub,\n\tDropdownMenuSubContent,\n\tDropdownMenuSubTrigger,\n\tDropdownMenuRadioGroup,\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx", "rel_path": "src/site/src/components/ui/select.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 15, "text": "import * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.Trigger>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>", "n_tokens": 100, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 15], "def_symbols": [], "symbols": ["import", "React", "from", "react", "SelectPrimitive", "radix", "select", "Check", "ChevronDown", "ChevronUp", "lucide", "lib", "utils", "const", "Select", "Root", "SelectGroup", "Group", "SelectValue", "Value", "SelectTrigger", "forwardRef", "ElementRef", "typeof", "Trigger", "ComponentPropsWithoutRef"], "doc_head": "import * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nconst Select = SelectPrimitive.Root\nconst SelectGroup = SelectPrimitive.Group\nconst SelectValue = SelectPrimitive.Value\nconst SelectTrigger = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.Trigger>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx", "rel_path": "src/site/src/components/ui/select.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 16, "end_line": 35, "text": ">(({ className, children, ...props }, ref) => (\n\t<SelectPrimitive.Trigger\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"flex h-10 w-full items-center justify-between rounded-md border bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t>\n\t\t{children}\n\t\t<SelectPrimitive.Icon asChild>\n\t\t\t<ChevronDown className=\"h-4 w-4 opacity-50\" />\n\t\t</SelectPrimitive.Icon>\n\t</SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>", "n_tokens": 208, "primary_symbol": "", "primary_kind": "", "primary_span": [16, 35], "def_symbols": [], "symbols": ["className", "children", "props", "ref", "SelectPrimitive", "Trigger", "flex", "full", "items", "center", "justify", "between", "rounded", "border", "background", "text", "ring", "offset", "placeholder", "muted", "foreground", "focus", "outline", "hidden", "disabled", "cursor", "not", "allowed", "opacity", "span", "line", "clamp", "Icon", "asChild", "ChevronDown", "SelectTrigger", "displayName", "const", "SelectScrollUpButton", "React", "forwardRef", "ElementRef", "typeof", "ScrollUpButton", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, children, ...props }, ref) => (\n\t<SelectPrimitive.Trigger\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"flex h-10 w-full items-center justify-between rounded-md border bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t>\n\t\t{children}\n\t\t<SelectPrimitive.Icon asChild>\n\t\t\t<ChevronDown className=\"h-4 w-4 opacity-50\" />\n\t\t</SelectPrimitive.Icon>\n\t</SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\nconst SelectScrollUpButton = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx", "rel_path": "src/site/src/components/ui/select.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 36, "end_line": 49, "text": ">(({ className, ...props }, ref) => (\n\t<SelectPrimitive.ScrollUpButton\n\t\tref={ref}\n\t\tclassName={cn(\"flex cursor-default items-center justify-center py-1\", className)}\n\t\t{...props}\n\t>\n\t\t<ChevronUp className=\"h-4 w-4\" />\n\t</SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>", "n_tokens": 121, "primary_symbol": "", "primary_kind": "", "primary_span": [36, 49], "def_symbols": [], "symbols": ["className", "props", "ref", "SelectPrimitive", "ScrollUpButton", "flex", "cursor", "default", "items", "center", "justify", "ChevronUp", "SelectScrollUpButton", "displayName", "const", "SelectScrollDownButton", "React", "forwardRef", "ElementRef", "typeof", "ScrollDownButton", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<SelectPrimitive.ScrollUpButton\n\t\tref={ref}\n\t\tclassName={cn(\"flex cursor-default items-center justify-center py-1\", className)}\n\t\t{...props}\n\t>\n\t\t<ChevronUp className=\"h-4 w-4\" />\n\t</SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\nconst SelectScrollDownButton = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx", "rel_path": "src/site/src/components/ui/select.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 50, "end_line": 63, "text": ">(({ className, ...props }, ref) => (\n\t<SelectPrimitive.ScrollDownButton\n\t\tref={ref}\n\t\tclassName={cn(\"flex cursor-default items-center justify-center py-1\", className)}\n\t\t{...props}\n\t>\n\t\t<ChevronDown className=\"h-4 w-4\" />\n\t</SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.Content>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>", "n_tokens": 115, "primary_symbol": "", "primary_kind": "", "primary_span": [50, 63], "def_symbols": [], "symbols": ["className", "props", "ref", "SelectPrimitive", "ScrollDownButton", "flex", "cursor", "default", "items", "center", "justify", "ChevronDown", "SelectScrollDownButton", "displayName", "const", "SelectContent", "React", "forwardRef", "ElementRef", "typeof", "Content", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<SelectPrimitive.ScrollDownButton\n\t\tref={ref}\n\t\tclassName={cn(\"flex cursor-default items-center justify-center py-1\", className)}\n\t\t{...props}\n\t>\n\t\t<ChevronDown className=\"h-4 w-4\" />\n\t</SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName\nconst SelectContent = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.Content>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx", "rel_path": "src/site/src/components/ui/select.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 64, "end_line": 95, "text": ">(({ className, children, position = \"popper\", ...props }, ref) => (\n\t<SelectPrimitive.Portal>\n\t\t<SelectPrimitive.Content\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n\t\t\t\tposition === \"popper\" &&\n\t\t\t\t\t\"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tposition={position}\n\t\t\t{...props}\n\t\t>\n\t\t\t<SelectScrollUpButton />\n\t\t\t<SelectPrimitive.Viewport\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"p-1\",\n\t\t\t\t\tposition === \"popper\" &&\n\t\t\t\t\t\t\"h-(--radix-select-trigger-height) w-full min-w-(--radix-select-trigger-width)\"\n\t\t\t\t)}\n\t\t\t>\n\t\t\t\t{children}\n\t\t\t</SelectPrimitive.Viewport>\n\t\t\t<SelectScrollDownButton />\n\t\t</SelectPrimitive.Content>\n\t</SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.Label>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>", "n_tokens": 379, "primary_symbol": "", "primary_kind": "", "primary_span": [64, 95], "def_symbols": [], "symbols": ["className", "children", "position", "popper", "props", "ref", "SelectPrimitive", "Portal", "Content", "relative", "max", "min", "overflow", "hidden", "rounded", "border", "popover", "text", "foreground", "shadow", "data", "state", "open", "animate", "closed", "out", "fade", "zoom", "side", "bottom", "slide", "from", "top", "left", "right", "translate", "SelectScrollUpButton", "Viewport", "radix", "select", "trigger", "height", "full", "width", "SelectScrollDownButton", "SelectContent", "displayName", "const", "SelectLabel", "React", "forwardRef", "ElementRef", "typeof", "Label", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, children, position = \"popper\", ...props }, ref) => (\n\t<SelectPrimitive.Portal>\n\t\t<SelectPrimitive.Content\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t\"relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n\t\t\t\tposition === \"popper\" &&\n\t\t\t\t\t\"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tposition={position}\n\t\t\t{...props}\n\t\t>\n\t\t\t<SelectScrollUpButton />\n\t\t\t<SelectPrimitive.Viewport\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"p-1\",\n\t\t\t\t\tposition === \"popper\" &&\n\t\t\t\t\t\t\"h-(--radix-select-trigger-height) w-full min-w-(--radix-select-trigger-width)\"\n\t\t\t\t)}\n\t\t\t>\n\t\t\t\t{children}\n\t\t\t</SelectPrimitive.Viewport>\n\t\t\t<SelectScrollDownButton />\n\t\t</SelectPrimitive.Content>\n\t</SelectPrimitive.Portal>\n))\nSelectContent.d"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx", "rel_path": "src/site/src/components/ui/select.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 96, "end_line": 103, "text": ">(({ className, ...props }, ref) => (\n\t<SelectPrimitive.Label ref={ref} className={cn(\"py-1.5 ps-8 pe-2 text-sm font-semibold\", className)} {...props} />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.Item>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>", "n_tokens": 83, "primary_symbol": "", "primary_kind": "", "primary_span": [96, 103], "def_symbols": [], "symbols": ["className", "props", "ref", "SelectPrimitive", "Label", "text", "font", "semibold", "SelectLabel", "displayName", "const", "SelectItem", "React", "forwardRef", "ElementRef", "typeof", "Item", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<SelectPrimitive.Label ref={ref} className={cn(\"py-1.5 ps-8 pe-2 text-sm font-semibold\", className)} {...props} />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\nconst SelectItem = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.Item>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx", "rel_path": "src/site/src/components/ui/select.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 104, "end_line": 126, "text": ">(({ className, children, ...props }, ref) => (\n\t<SelectPrimitive.Item\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 ps-8 pe-2 text-sm outline-hidden focus:bg-accent/70 focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t>\n\t\t<span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n\t\t\t<SelectPrimitive.ItemIndicator>\n\t\t\t\t<Check className=\"h-4 w-4\" />\n\t\t\t</SelectPrimitive.ItemIndicator>\n\t\t</span>\n\n\t\t<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n\t</SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.Separator>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>", "n_tokens": 215, "primary_symbol": "", "primary_kind": "", "primary_span": [104, 126], "def_symbols": [], "symbols": ["className", "children", "props", "ref", "SelectPrimitive", "Item", "relative", "flex", "full", "cursor", "default", "select", "none", "items", "center", "rounded", "text", "outline", "hidden", "focus", "accent", "foreground", "data", "disabled", "pointer", "events", "opacity", "span", "absolute", "left", "justify", "ItemIndicator", "Check", "ItemText", "SelectItem", "displayName", "const", "SelectSeparator", "React", "forwardRef", "ElementRef", "typeof", "Separator", "ComponentPropsWithoutRef"], "doc_head": ">(({ className, children, ...props }, ref) => (\n\t<SelectPrimitive.Item\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 ps-8 pe-2 text-sm outline-hidden focus:bg-accent/70 focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50\",\n\t\t\tclassName\n\t\t)}\n\t\t{...props}\n\t>\n\t\t<span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n\t\t\t<SelectPrimitive.ItemIndicator>\n\t\t\t\t<Check className=\"h-4 w-4\" />\n\t\t\t</SelectPrimitive.ItemIndicator>\n\t\t</span>\n\t\t<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n\t</SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\nconst SelectSeparator = React.forwardRef<\n\tReact.ElementRef<typeof SelectPrimitive.Separator>,\n\tReact.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/select.tsx", "rel_path": "src/site/src/components/ui/select.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 127, "end_line": 144, "text": ">(({ className, ...props }, ref) => (\n\t<SelectPrimitive.Separator ref={ref} className={cn(\"-mx-1 my-1 h-px bg-muted\", className)} {...props} />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n\tSelect,\n\tSelectGroup,\n\tSelectValue,\n\tSelectTrigger,\n\tSelectContent,\n\tSelectLabel,\n\tSelectItem,\n\tSelectSeparator,\n\tSelectScrollUpButton,\n\tSelectScrollDownButton,\n}\n", "n_tokens": 99, "primary_symbol": "", "primary_kind": "", "primary_span": [127, 144], "def_symbols": [], "symbols": ["className", "props", "ref", "SelectPrimitive", "Separator", "muted", "SelectSeparator", "displayName", "export", "Select", "SelectGroup", "SelectValue", "SelectTrigger", "SelectContent", "SelectLabel", "SelectItem", "SelectScrollUpButton", "SelectScrollDownButton"], "doc_head": ">(({ className, ...props }, ref) => (\n\t<SelectPrimitive.Separator ref={ref} className={cn(\"-mx-1 my-1 h-px bg-muted\", className)} {...props} />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\nexport {\n\tSelect,\n\tSelectGroup,\n\tSelectValue,\n\tSelectTrigger,\n\tSelectContent,\n\tSelectLabel,\n\tSelectItem,\n\tSelectSeparator,\n\tSelectScrollUpButton,\n\tSelectScrollDownButton,\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/textarea.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/textarea.tsx", "rel_path": "src/site/src/components/ui/textarea.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\n\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(({ className, ...props }, ref) => {\n\treturn (\n\t\t<textarea\n\t\t\tclassName={cn(\n\t\t\t\t\"flex min-h-14 w-full rounded-md border bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tref={ref}\n\t\t\t{...props}\n\t\t/>\n\t)\n})\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n", "n_tokens": 169, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 22], "def_symbols": [], "symbols": ["import", "React", "from", "react", "lib", "utils", "export", "interface", "TextareaProps", "extends", "TextareaHTMLAttributes", "HTMLTextAreaElement", "const", "Textarea", "forwardRef", "className", "props", "ref", "return", "textarea", "flex", "min", "full", "rounded", "border", "background", "text", "ring", "offset", "placeholder", "muted", "foreground", "focus", "visible", "outline", "hidden", "disabled", "cursor", "not", "allowed", "opacity", "displayName"], "doc_head": "import * as React from \"react\"\nimport { cn } from \"@/lib/utils\"\nexport interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(({ className, ...props }, ref) => {\n\treturn (\n\t\t<textarea\n\t\t\tclassName={cn(\n\t\t\t\t\"flex min-h-14 w-full rounded-md border bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tref={ref}\n\t\t\t{...props}\n\t\t/>\n\t)\n})\nTextarea.displayName = \"Textarea\"\nexport { Textarea }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/ui/input.tsx", "rel_path": "src/site/src/components/ui/input.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 21, "text": "import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n\treturn (\n\t\t<input\n\t\t\ttype={type}\n\t\t\tdata-slot=\"input\"\n\t\t\tclassName={cn(\n\t\t\t\t\"flex h-10 w-full rounded-md border bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n\t\t\t\t\"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nexport { Input }\n", "n_tokens": 185, "primary_symbol": "Input", "primary_kind": "function", "primary_span": [5, 21], "def_symbols": ["Input"], "symbols": ["Input", "import", "React", "from", "react", "lib", "utils", "function", "className", "type", "props", "ComponentProps", "input", "return", "data", "slot", "flex", "full", "rounded", "border", "background", "text", "ring", "offset", "file", "transparent", "font", "medium", "placeholder", "muted", "foreground", "focus", "visible", "outline", "hidden", "disabled", "cursor", "not", "allowed", "opacity", "aria", "invalid", "destructive", "dark", "export"], "doc_head": "import * as React from \"react\"\nimport { cn } from \"@/lib/utils\"\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n\treturn (\n\t\t<input\n\t\t\ttype={type}\n\t\t\tdata-slot=\"input\"\n\t\t\tclassName={cn(\n\t\t\t\t\"flex h-10 w-full rounded-md border bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n\t\t\t\t\"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\nexport { Input }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 30, "text": "import { SystemRecord } from \"@/types\"\nimport { CellContext, ColumnDef, HeaderContext } from \"@tanstack/react-table\"\nimport { ClassValue } from \"clsx\"\nimport {\n\tArrowUpDownIcon,\n\tCopyIcon,\n\tCpuIcon,\n\tHardDriveIcon,\n\tMemoryStickIcon,\n\tMoreHorizontalIcon,\n\tPauseCircleIcon,\n\tPenBoxIcon,\n\tPlayCircleIcon,\n\tServerIcon,\n\tTrash2Icon,\n\tWifiIcon,\n} from \"lucide-react\"\nimport { Button } from \"../ui/button\"\nimport {\n\tcn,\n\tcopyToClipboard,\n\tdecimalString,\n\tformatBytes,\n\tformatTemperature,\n\tgetMeterState,\n\tparseSemVer,\n} from \"@/lib/utils\"\nimport { EthernetIcon, GpuIcon, HourglassIcon, ThermometerIcon } from \"../ui/icons\"\nimport { useStore } from \"@nanostores/react\"\nimport { $longestSystemNameLen, $userSettings } from \"@/lib/stores\"", "n_tokens": 197, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 30], "def_symbols": [], "symbols": ["import", "SystemRecord", "from", "types", "CellContext", "ColumnDef", "HeaderContext", "tanstack", "react", "table", "ClassValue", "clsx", "ArrowUpDownIcon", "CopyIcon", "CpuIcon", "HardDriveIcon", "MemoryStickIcon", "MoreHorizontalIcon", "PauseCircleIcon", "PenBoxIcon", "PlayCircleIcon", "ServerIcon", "Trash2Icon", "WifiIcon", "lucide", "Button", "button", "copyToClipboard", "decimalString", "formatBytes", "formatTemperature", "getMeterState", "parseSemVer", "lib", "utils", "EthernetIcon", "GpuIcon", "HourglassIcon", "ThermometerIcon", "icons", "useStore", "nanostores", "longestSystemNameLen", "userSettings", "stores"], "doc_head": "import { SystemRecord } from \"@/types\"\nimport { CellContext, ColumnDef, HeaderContext } from \"@tanstack/react-table\"\nimport { ClassValue } from \"clsx\"\nimport {\n\tArrowUpDownIcon,\n\tCopyIcon,\n\tCpuIcon,\n\tHardDriveIcon,\n\tMemoryStickIcon,\n\tMoreHorizontalIcon,\n\tPauseCircleIcon,\n\tPenBoxIcon,\n\tPlayCircleIcon,\n\tServerIcon,\n\tTrash2Icon,\n\tWifiIcon,\n} from \"lucide-react\"\nimport { Button } from \"../ui/button\"\nimport {\n\tcn,\n\tcopyToClipboard,\n\tdecimalString,\n\tformatBytes,\n\tformatTemperature,\n\tgetMeterState,\n\tparseSemVer,\n} from \"@/lib/utils\"\nimport { EthernetIcon, GpuIcon, HourglassIcon, ThermometerIcon } from \"../ui/icons\"\nimport { useStore } from \"@nanostores/react\"\nimport { $longestSystemNameLen, $userSettings } from \"@/lib/stores\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 31, "end_line": 57, "text": "import { Trans, useLingui } from \"@lingui/react/macro\"\nimport { useMemo, useRef, useState } from \"react\"\nimport { memo } from \"react\"\nimport {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuItem,\n\tDropdownMenuSeparator,\n\tDropdownMenuTrigger,\n} from \"../ui/dropdown-menu\"\nimport AlertButton from \"../alerts/alert-button\"\nimport { Dialog } from \"../ui/dialog\"\nimport { SystemDialog } from \"../add-system\"\nimport { AlertDialog } from \"../ui/alert-dialog\"\nimport {\n\tAlertDialogAction,\n\tAlertDialogCancel,\n\tAlertDialogContent,\n\tAlertDialogDescription,\n\tAlertDialogFooter,\n\tAlertDialogHeader,\n\tAlertDialogTitle,\n} from \"../ui/alert-dialog\"\nimport { buttonVariants } from \"../ui/button\"\nimport { t } from \"@lingui/core/macro\"\nimport { MeterState, SystemStatus } from \"@/lib/enums\"\nimport { $router, Link } from \"../router\"", "n_tokens": 193, "primary_symbol": "", "primary_kind": "", "primary_span": [31, 57], "def_symbols": [], "symbols": ["import", "Trans", "useLingui", "from", "lingui", "react", "macro", "useMemo", "useRef", "useState", "memo", "DropdownMenu", "DropdownMenuContent", "DropdownMenuItem", "DropdownMenuSeparator", "DropdownMenuTrigger", "dropdown", "menu", "AlertButton", "alerts", "alert", "button", "Dialog", "dialog", "SystemDialog", "add", "system", "AlertDialog", "AlertDialogAction", "AlertDialogCancel", "AlertDialogContent", "AlertDialogDescription", "AlertDialogFooter", "AlertDialogHeader", "AlertDialogTitle", "buttonVariants", "core", "MeterState", "SystemStatus", "lib", "enums", "router", "Link"], "doc_head": "import { Trans, useLingui } from \"@lingui/react/macro\"\nimport { useMemo, useRef, useState } from \"react\"\nimport { memo } from \"react\"\nimport {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuItem,\n\tDropdownMenuSeparator,\n\tDropdownMenuTrigger,\n} from \"../ui/dropdown-menu\"\nimport AlertButton from \"../alerts/alert-button\"\nimport { Dialog } from \"../ui/dialog\"\nimport { SystemDialog } from \"../add-system\"\nimport { AlertDialog } from \"../ui/alert-dialog\"\nimport {\n\tAlertDialogAction,\n\tAlertDialogCancel,\n\tAlertDialogContent,\n\tAlertDialogDescription,\n\tAlertDialogFooter,\n\tAlertDialogHeader,\n\tAlertDialogTitle,\n} from \"../ui/alert-dialog\"\nimport { buttonVariants } from \"../ui/button\"\nimport { t } from \"@lingui/core/macro\"\nimport { MeterState, SystemStatus } from \"@/lib/enums\"\nimport { $router, Link } from \"../router\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 58, "end_line": 80, "text": "import { getPagePath } from \"@nanostores/router\"\nimport { isReadOnlyUser, pb } from \"@/lib/api\"\n\nconst STATUS_COLORS = {\n\t[SystemStatus.Up]: \"bg-green-500\",\n\t[SystemStatus.Down]: \"bg-red-500\",\n\t[SystemStatus.Paused]: \"bg-primary/40\",\n\t[SystemStatus.Pending]: \"bg-yellow-500\",\n} as const\n\n/**\n * @param viewMode - \"table\" or \"grid\"\n * @returns - Column definitions for the systems table\n */\nexport default function SystemsTableColumns(viewMode: \"table\" | \"grid\"): ColumnDef<SystemRecord>[] {\n\treturn [\n\t\t{\n\t\t\t// size: 200,\n\t\t\tsize: 100,\n\t\t\tminSize: 0,\n\t\t\taccessorKey: \"name\",\n\t\t\tid: \"system\",\n\t\t\tname: () => t`System`,", "n_tokens": 178, "primary_symbol": "", "primary_kind": "", "primary_span": [58, 80], "def_symbols": [], "symbols": ["import", "getPagePath", "from", "nanostores", "router", "isReadOnlyUser", "lib", "api", "const", "STATUS_COLORS", "SystemStatus", "green", "Down", "red", "Paused", "primary", "Pending", "yellow", "param", "viewMode", "table", "grid", "returns", "Column", "definitions", "for", "the", "systems", "export", "default", "function", "SystemsTableColumns", "ColumnDef", "SystemRecord", "return", "size", "minSize", "accessorKey", "name", "system", "System"], "doc_head": "import { getPagePath } from \"@nanostores/router\"\nimport { isReadOnlyUser, pb } from \"@/lib/api\"\nconst STATUS_COLORS = {\n\t[SystemStatus.Up]: \"bg-green-500\",\n\t[SystemStatus.Down]: \"bg-red-500\",\n\t[SystemStatus.Paused]: \"bg-primary/40\",\n\t[SystemStatus.Pending]: \"bg-yellow-500\",\n} as const\n/**\n * @param viewMode - \"table\" or \"grid\"\n * @returns - Column definitions for the systems table\n */\nexport default function SystemsTableColumns(viewMode: \"table\" | \"grid\"): ColumnDef<SystemRecord>[] {\n\treturn [\n\t\t{\n\t\t\t// size: 200,\n\t\t\tsize: 100,\n\t\t\tminSize: 0,\n\t\t\taccessorKey: \"name\",\n\t\t\tid: \"system\",\n\t\t\tname: () => t`System`,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 81, "end_line": 102, "text": "\t\t\tfilterFn: (() => {\n\t\t\t\tlet filterInput = \"\"\n\t\t\t\tlet filterInputLower = \"\"\n\t\t\t\tconst nameCache = new Map<string, string>()\n\t\t\t\tconst statusTranslations = {\n\t\t\t\t\t[SystemStatus.Up]: t`Up`.toLowerCase(),\n\t\t\t\t\t[SystemStatus.Down]: t`Down`.toLowerCase(),\n\t\t\t\t\t[SystemStatus.Paused]: t`Paused`.toLowerCase(),\n\t\t\t\t} as const\n\n\t\t\t\t// match filter value against name or translated status\n\t\t\t\treturn (row, _, newFilterInput) => {\n\t\t\t\t\tconst { name, status } = row.original\n\t\t\t\t\tif (newFilterInput !== filterInput) {\n\t\t\t\t\t\tfilterInput = newFilterInput\n\t\t\t\t\t\tfilterInputLower = newFilterInput.toLowerCase()\n\t\t\t\t\t}\n\t\t\t\t\tlet nameLower = nameCache.get(name)\n\t\t\t\t\tif (nameLower === undefined) {\n\t\t\t\t\t\tnameLower = name.toLowerCase()\n\t\t\t\t\t\tnameCache.set(name, nameLower)\n\t\t\t\t\t}", "n_tokens": 186, "primary_symbol": "", "primary_kind": "", "primary_span": [81, 102], "def_symbols": [], "symbols": ["filterFn", "let", "filterInput", "filterInputLower", "const", "nameCache", "new", "Map", "string", "statusTranslations", "SystemStatus", "toLowerCase", "Down", "Paused", "match", "filter", "value", "against", "name", "translated", "status", "return", "row", "newFilterInput", "original", "nameLower", "get", "undefined", "set"], "doc_head": "\t\t\tfilterFn: (() => {\n\t\t\t\tlet filterInput = \"\"\n\t\t\t\tlet filterInputLower = \"\"\n\t\t\t\tconst nameCache = new Map<string, string>()\n\t\t\t\tconst statusTranslations = {\n\t\t\t\t\t[SystemStatus.Up]: t`Up`.toLowerCase(),\n\t\t\t\t\t[SystemStatus.Down]: t`Down`.toLowerCase(),\n\t\t\t\t\t[SystemStatus.Paused]: t`Paused`.toLowerCase(),\n\t\t\t\t} as const\n\t\t\t\t// match filter value against name or translated status\n\t\t\t\treturn (row, _, newFilterInput) => {\n\t\t\t\t\tconst { name, status } = row.original\n\t\t\t\t\tif (newFilterInput !== filterInput) {\n\t\t\t\t\t\tfilterInput = newFilterInput\n\t\t\t\t\t\tfilterInputLower = newFilterInput.toLowerCase()\n\t\t\t\t\t}\n\t\t\t\t\tlet nameLower = nameCache.get(name)\n\t\t\t\t\tif (nameLower === undefined) {\n\t\t\t\t\t\tnameLower = name.toLowerCase()\n\t\t\t\t\t\tnameCache.set(name, nameLower)\n\t\t\t\t\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 103, "end_line": 112, "text": "\t\t\t\t\tif (nameLower.includes(filterInputLower)) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t\tconst statusLower = statusTranslations[status as keyof typeof statusTranslations]\n\t\t\t\t\treturn statusLower?.includes(filterInputLower) || false\n\t\t\t\t}\n\t\t\t})(),\n\t\t\tenableHiding: false,\n\t\t\tinvertSorting: false,\n\t\t\tIcon: ServerIcon,", "n_tokens": 75, "primary_symbol": "", "primary_kind": "", "primary_span": [103, 112], "def_symbols": [], "symbols": ["nameLower", "includes", "filterInputLower", "return", "true", "const", "statusLower", "statusTranslations", "status", "keyof", "typeof", "false", "enableHiding", "invertSorting", "Icon", "ServerIcon"], "doc_head": "\t\t\t\t\tif (nameLower.includes(filterInputLower)) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t\tconst statusLower = statusTranslations[status as keyof typeof statusTranslations]\n\t\t\t\t\treturn statusLower?.includes(filterInputLower) || false\n\t\t\t\t}\n\t\t\t})(),\n\t\t\tenableHiding: false,\n\t\t\tinvertSorting: false,\n\t\t\tIcon: ServerIcon,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 113, "end_line": 135, "text": "\t\t\tcell: (info) => {\n\t\t\t\tconst { name } = info.row.original\n\t\t\t\tconst longestName = useStore($longestSystemNameLen)\n\t\t\t\treturn (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<span className=\"flex gap-2 items-center font-medium text-sm text-nowrap md:ps-1\">\n\t\t\t\t\t\t\t<IndicatorDot system={info.row.original} />\n\t\t\t\t\t\t\t{/* NOTE: change to 1 ch if switching to monospace font */}\n\t\t\t\t\t\t\t<span className=\"truncate\" style={{ width: `${longestName / 1.1}ch` }}>\n\t\t\t\t\t\t\t\t{name}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\thref={getPagePath($router, \"system\", { name })}\n\t\t\t\t\t\t\tclassName=\"inset-0 absolute size-full\"\n\t\t\t\t\t\t\taria-label={name}\n\t\t\t\t\t\t></Link>\n\t\t\t\t\t</>\n\t\t\t\t)\n\t\t\t},\n\t\t\theader: sortableHeader,\n\t\t},\n\t\t{", "n_tokens": 193, "primary_symbol": "", "primary_kind": "", "primary_span": [113, 135], "def_symbols": [], "symbols": ["cell", "info", "const", "name", "row", "original", "longestName", "useStore", "longestSystemNameLen", "return", "span", "className", "flex", "gap", "items", "center", "font", "medium", "text", "nowrap", "IndicatorDot", "system", "NOTE", "change", "switching", "monospace", "truncate", "style", "width", "Link", "href", "getPagePath", "router", "inset", "absolute", "size", "full", "aria", "label", "header", "sortableHeader"], "doc_head": "\t\t\tcell: (info) => {\n\t\t\t\tconst { name } = info.row.original\n\t\t\t\tconst longestName = useStore($longestSystemNameLen)\n\t\t\t\treturn (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<span className=\"flex gap-2 items-center font-medium text-sm text-nowrap md:ps-1\">\n\t\t\t\t\t\t\t<IndicatorDot system={info.row.original} />\n\t\t\t\t\t\t\t{/* NOTE: change to 1 ch if switching to monospace font */}\n\t\t\t\t\t\t\t<span className=\"truncate\" style={{ width: `${longestName / 1.1}ch` }}>\n\t\t\t\t\t\t\t\t{name}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\thref={getPagePath($router, \"system\", { name })}\n\t\t\t\t\t\t\tclassName=\"inset-0 absolute size-full\"\n\t\t\t\t\t\t\taria-label={name}\n\t\t\t\t\t\t></Link>\n\t\t\t\t\t</>\n\t\t\t\t)\n\t\t\t},\n\t\t\theader: sortableHeader,\n\t\t},\n\t\t{"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 136, "end_line": 162, "text": "\t\t\taccessorFn: ({ info }) => info.cpu,\n\t\t\tid: \"cpu\",\n\t\t\tname: () => t`CPU`,\n\t\t\tcell: TableCellWithMeter,\n\t\t\tIcon: CpuIcon,\n\t\t\theader: sortableHeader,\n\t\t},\n\t\t{\n\t\t\t// accessorKey: \"info.mp\",\n\t\t\taccessorFn: ({ info }) => info.mp,\n\t\t\tid: \"memory\",\n\t\t\tname: () => t`Memory`,\n\t\t\tcell: TableCellWithMeter,\n\t\t\tIcon: MemoryStickIcon,\n\t\t\theader: sortableHeader,\n\t\t},\n\t\t{\n\t\t\taccessorFn: ({ info }) => info.dp,\n\t\t\tid: \"disk\",\n\t\t\tname: () => t`Disk`,\n\t\t\tcell: TableCellWithMeter,\n\t\t\tIcon: HardDriveIcon,\n\t\t\theader: sortableHeader,\n\t\t},\n\t\t{\n\t\t\taccessorFn: ({ info }) => info.g,\n\t\t\tid: \"gpu\",", "n_tokens": 194, "primary_symbol": "", "primary_kind": "", "primary_span": [136, 162], "def_symbols": [], "symbols": ["accessorFn", "info", "cpu", "name", "CPU", "cell", "TableCellWithMeter", "Icon", "CpuIcon", "header", "sortableHeader", "accessorKey", "memory", "Memory", "MemoryStickIcon", "disk", "Disk", "HardDriveIcon", "gpu"], "doc_head": "\t\t\taccessorFn: ({ info }) => info.cpu,\n\t\t\tid: \"cpu\",\n\t\t\tname: () => t`CPU`,\n\t\t\tcell: TableCellWithMeter,\n\t\t\tIcon: CpuIcon,\n\t\t\theader: sortableHeader,\n\t\t},\n\t\t{\n\t\t\t// accessorKey: \"info.mp\",\n\t\t\taccessorFn: ({ info }) => info.mp,\n\t\t\tid: \"memory\",\n\t\t\tname: () => t`Memory`,\n\t\t\tcell: TableCellWithMeter,\n\t\t\tIcon: MemoryStickIcon,\n\t\t\theader: sortableHeader,\n\t\t},\n\t\t{\n\t\t\taccessorFn: ({ info }) => info.dp,\n\t\t\tid: \"disk\",\n\t\t\tname: () => t`Disk`,\n\t\t\tcell: TableCellWithMeter,\n\t\t\tIcon: HardDriveIcon,\n\t\t\theader: sortableHeader,\n\t\t},\n\t\t{\n\t\t\taccessorFn: ({ info }) => info.g,\n\t\t\tid: \"gpu\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 163, "end_line": 181, "text": "\t\t\tname: () => \"GPU\",\n\t\t\tcell: TableCellWithMeter,\n\t\t\tIcon: GpuIcon,\n\t\t\theader: sortableHeader,\n\t\t},\n\t\t{\n\t\t\tid: \"loadAverage\",\n\t\t\taccessorFn: ({ info }) => {\n\t\t\t\tconst sum = info.la?.reduce((acc, curr) => acc + curr, 0)\n\t\t\t\t// TODO: remove this in future release in favor of la array\n\t\t\t\tif (!sum) {\n\t\t\t\t\treturn (info.l1 ?? 0) + (info.l5 ?? 0) + (info.l15 ?? 0)\n\t\t\t\t}\n\t\t\t\treturn sum\n\t\t\t},\n\t\t\tname: () => t({ message: \"Load Avg\", comment: \"Short label for load average\" }),\n\t\t\tsize: 0,\n\t\t\tIcon: HourglassIcon,\n\t\t\theader: sortableHeader,", "n_tokens": 178, "primary_symbol": "", "primary_kind": "", "primary_span": [163, 181], "def_symbols": [], "symbols": ["name", "GPU", "cell", "TableCellWithMeter", "Icon", "GpuIcon", "header", "sortableHeader", "loadAverage", "accessorFn", "info", "const", "sum", "reduce", "acc", "curr", "TODO", "remove", "this", "future", "release", "favor", "array", "return", "l15", "message", "Load", "Avg", "comment", "Short", "label", "for", "load", "average", "size", "HourglassIcon"], "doc_head": "\t\t\tname: () => \"GPU\",\n\t\t\tcell: TableCellWithMeter,\n\t\t\tIcon: GpuIcon,\n\t\t\theader: sortableHeader,\n\t\t},\n\t\t{\n\t\t\tid: \"loadAverage\",\n\t\t\taccessorFn: ({ info }) => {\n\t\t\t\tconst sum = info.la?.reduce((acc, curr) => acc + curr, 0)\n\t\t\t\t// TODO: remove this in future release in favor of la array\n\t\t\t\tif (!sum) {\n\t\t\t\t\treturn (info.l1 ?? 0) + (info.l5 ?? 0) + (info.l15 ?? 0)\n\t\t\t\t}\n\t\t\t\treturn sum\n\t\t\t},\n\t\t\tname: () => t({ message: \"Load Avg\", comment: \"Short label for load average\" }),\n\t\t\tsize: 0,\n\t\t\tIcon: HourglassIcon,\n\t\t\theader: sortableHeader,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 182, "end_line": 193, "text": "\t\t\tcell(info: CellContext<SystemRecord, unknown>) {\n\t\t\t\tconst { info: sysInfo, status } = info.row.original\n\t\t\t\t// agent version\n\t\t\t\tconst { minor, patch } = parseSemVer(sysInfo.v)\n\t\t\t\tlet loadAverages = sysInfo.la\n\n\t\t\t\t// use legacy load averages if agent version is less than 12.1.0\n\t\t\t\tif (!loadAverages || (minor === 12 && patch < 1)) {\n\t\t\t\t\tloadAverages = [sysInfo.l1 ?? 0, sysInfo.l5 ?? 0, sysInfo.l15 ?? 0]\n\t\t\t\t}\n\n\t\t\t\tconst max = Math.max(...loadAverages)", "n_tokens": 142, "primary_symbol": "", "primary_kind": "", "primary_span": [182, 193], "def_symbols": [], "symbols": ["cell", "info", "CellContext", "SystemRecord", "unknown", "const", "sysInfo", "status", "row", "original", "agent", "version", "minor", "patch", "parseSemVer", "let", "loadAverages", "use", "legacy", "load", "averages", "less", "than", "l15", "max", "Math"], "doc_head": "\t\t\tcell(info: CellContext<SystemRecord, unknown>) {\n\t\t\t\tconst { info: sysInfo, status } = info.row.original\n\t\t\t\t// agent version\n\t\t\t\tconst { minor, patch } = parseSemVer(sysInfo.v)\n\t\t\t\tlet loadAverages = sysInfo.la\n\t\t\t\t// use legacy load averages if agent version is less than 12.1.0\n\t\t\t\tif (!loadAverages || (minor === 12 && patch < 1)) {\n\t\t\t\t\tloadAverages = [sysInfo.l1 ?? 0, sysInfo.l5 ?? 0, sysInfo.l15 ?? 0]\n\t\t\t\t}\n\t\t\t\tconst max = Math.max(...loadAverages)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 194, "end_line": 210, "text": "\t\t\t\tif (max === 0 && (status === SystemStatus.Paused || minor < 12)) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\n\t\t\t\tconst normalizedLoad = max / (sysInfo.t ?? 1)\n\t\t\t\tconst threshold = getMeterState(normalizedLoad * 100)\n\n\t\t\t\treturn (\n\t\t\t\t\t<div className=\"flex items-center gap-[.35em] w-full tabular-nums tracking-tight\">\n\t\t\t\t\t\t<span\n\t\t\t\t\t\t\tclassName={cn(\"inline-block size-2 rounded-full me-0.5\", {\n\t\t\t\t\t\t\t\t[STATUS_COLORS[SystemStatus.Up]]: threshold === MeterState.Good,\n\t\t\t\t\t\t\t\t[STATUS_COLORS[SystemStatus.Pending]]: threshold === MeterState.Warn,\n\t\t\t\t\t\t\t\t[STATUS_COLORS[SystemStatus.Down]]: threshold === MeterState.Crit,\n\t\t\t\t\t\t\t\t[STATUS_COLORS[SystemStatus.Paused]]: status !== SystemStatus.Up,\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t/>", "n_tokens": 183, "primary_symbol": "", "primary_kind": "", "primary_span": [194, 210], "def_symbols": [], "symbols": ["max", "status", "SystemStatus", "Paused", "minor", "return", "null", "const", "normalizedLoad", "sysInfo", "threshold", "getMeterState", "div", "className", "flex", "items", "center", "gap", "full", "tabular", "nums", "tracking", "tight", "span", "inline", "block", "size", "rounded", "STATUS_COLORS", "MeterState", "Good", "Pending", "Warn", "Down", "Crit"], "doc_head": "\t\t\t\tif (max === 0 && (status === SystemStatus.Paused || minor < 12)) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst normalizedLoad = max / (sysInfo.t ?? 1)\n\t\t\t\tconst threshold = getMeterState(normalizedLoad * 100)\n\t\t\t\treturn (\n\t\t\t\t\t<div className=\"flex items-center gap-[.35em] w-full tabular-nums tracking-tight\">\n\t\t\t\t\t\t<span\n\t\t\t\t\t\t\tclassName={cn(\"inline-block size-2 rounded-full me-0.5\", {\n\t\t\t\t\t\t\t\t[STATUS_COLORS[SystemStatus.Up]]: threshold === MeterState.Good,\n\t\t\t\t\t\t\t\t[STATUS_COLORS[SystemStatus.Pending]]: threshold === MeterState.Warn,\n\t\t\t\t\t\t\t\t[STATUS_COLORS[SystemStatus.Down]]: threshold === MeterState.Crit,\n\t\t\t\t\t\t\t\t[STATUS_COLORS[SystemStatus.Paused]]: status !== SystemStatus.Up,\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t/>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 11, "start_line": 211, "end_line": 227, "text": "\t\t\t\t\t\t{loadAverages?.map((la, i) => (\n\t\t\t\t\t\t\t<span key={i}>{decimalString(la, la >= 10 ? 1 : 2)}</span>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\taccessorFn: ({ info }) => info.bb || (info.b || 0) * 1024 * 1024,\n\t\t\tid: \"net\",\n\t\t\tname: () => t`Net`,\n\t\t\tsize: 0,\n\t\t\tIcon: EthernetIcon,\n\t\t\theader: sortableHeader,\n\t\t\tcell(info) {\n\t\t\t\tconst sys = info.row.original\n\t\t\t\tconst userSettings = useStore($userSettings, { keys: [\"unitNet\"] })", "n_tokens": 155, "primary_symbol": "", "primary_kind": "", "primary_span": [211, 227], "def_symbols": [], "symbols": ["loadAverages", "map", "span", "key", "decimalString", "div", "accessorFn", "info", "net", "name", "Net", "size", "Icon", "EthernetIcon", "header", "sortableHeader", "cell", "const", "sys", "row", "original", "userSettings", "useStore", "keys", "unitNet"], "doc_head": "\t\t\t\t\t\t{loadAverages?.map((la, i) => (\n\t\t\t\t\t\t\t<span key={i}>{decimalString(la, la >= 10 ? 1 : 2)}</span>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\taccessorFn: ({ info }) => info.bb || (info.b || 0) * 1024 * 1024,\n\t\t\tid: \"net\",\n\t\t\tname: () => t`Net`,\n\t\t\tsize: 0,\n\t\t\tIcon: EthernetIcon,\n\t\t\theader: sortableHeader,\n\t\t\tcell(info) {\n\t\t\t\tconst sys = info.row.original\n\t\t\t\tconst userSettings = useStore($userSettings, { keys: [\"unitNet\"] })"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 12, "start_line": 228, "end_line": 249, "text": "\t\t\t\tif (sys.status === SystemStatus.Paused) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst { value, unit } = formatBytes(info.getValue() as number, true, userSettings.unitNet, false)\n\t\t\t\treturn (\n\t\t\t\t\t<span className=\"tabular-nums whitespace-nowrap\">\n\t\t\t\t\t\t{decimalString(value, value >= 100 ? 1 : 2)} {unit}\n\t\t\t\t\t</span>\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\taccessorFn: ({ info }) => info.dt,\n\t\t\tid: \"temp\",\n\t\t\tname: () => t({ message: \"Temp\", comment: \"Temperature label in systems table\" }),\n\t\t\tsize: 50,\n\t\t\thideSort: true,\n\t\t\tIcon: ThermometerIcon,\n\t\t\theader: sortableHeader,\n\t\t\tcell(info) {\n\t\t\t\tconst val = info.getValue() as number\n\t\t\t\tconst userSettings = useStore($userSettings, { keys: [\"unitTemp\"] })", "n_tokens": 201, "primary_symbol": "", "primary_kind": "", "primary_span": [228, 249], "def_symbols": [], "symbols": ["sys", "status", "SystemStatus", "Paused", "return", "null", "const", "value", "unit", "formatBytes", "info", "getValue", "number", "true", "userSettings", "unitNet", "false", "span", "className", "tabular", "nums", "whitespace", "nowrap", "decimalString", "accessorFn", "temp", "name", "message", "Temp", "comment", "Temperature", "label", "systems", "table", "size", "hideSort", "Icon", "ThermometerIcon", "header", "sortableHeader", "cell", "val", "useStore", "keys", "unitTemp"], "doc_head": "\t\t\t\tif (sys.status === SystemStatus.Paused) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst { value, unit } = formatBytes(info.getValue() as number, true, userSettings.unitNet, false)\n\t\t\t\treturn (\n\t\t\t\t\t<span className=\"tabular-nums whitespace-nowrap\">\n\t\t\t\t\t\t{decimalString(value, value >= 100 ? 1 : 2)} {unit}\n\t\t\t\t\t</span>\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\taccessorFn: ({ info }) => info.dt,\n\t\t\tid: \"temp\",\n\t\t\tname: () => t({ message: \"Temp\", comment: \"Temperature label in systems table\" }),\n\t\t\tsize: 50,\n\t\t\thideSort: true,\n\t\t\tIcon: ThermometerIcon,\n\t\t\theader: sortableHeader,\n\t\t\tcell(info) {\n\t\t\t\tconst val = info.getValue() as number\n\t\t\t\tconst userSettings = useStore($userSettings, { keys: [\"unitTemp\"] })"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 13, "start_line": 250, "end_line": 271, "text": "\t\t\t\tif (!val) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst { value, unit } = formatTemperature(val, userSettings.unitTemp)\n\t\t\t\treturn (\n\t\t\t\t\t<span className={cn(\"tabular-nums whitespace-nowrap\", viewMode === \"table\" && \"ps-0.5\")}>\n\t\t\t\t\t\t{decimalString(value, value >= 100 ? 1 : 2)} {unit}\n\t\t\t\t\t</span>\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\taccessorFn: ({ info }) => info.v,\n\t\t\tid: \"agent\",\n\t\t\tname: () => t`Agent`,\n\t\t\t// invertSorting: true,\n\t\t\tsize: 50,\n\t\t\tIcon: WifiIcon,\n\t\t\thideSort: true,\n\t\t\theader: sortableHeader,\n\t\t\tcell(info) {\n\t\t\t\tconst version = info.getValue() as string", "n_tokens": 177, "primary_symbol": "", "primary_kind": "", "primary_span": [250, 271], "def_symbols": [], "symbols": ["val", "return", "null", "const", "value", "unit", "formatTemperature", "userSettings", "unitTemp", "span", "className", "tabular", "nums", "whitespace", "nowrap", "viewMode", "table", "decimalString", "accessorFn", "info", "agent", "name", "Agent", "invertSorting", "true", "size", "Icon", "WifiIcon", "hideSort", "header", "sortableHeader", "cell", "version", "getValue", "string"], "doc_head": "\t\t\t\tif (!val) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst { value, unit } = formatTemperature(val, userSettings.unitTemp)\n\t\t\t\treturn (\n\t\t\t\t\t<span className={cn(\"tabular-nums whitespace-nowrap\", viewMode === \"table\" && \"ps-0.5\")}>\n\t\t\t\t\t\t{decimalString(value, value >= 100 ? 1 : 2)} {unit}\n\t\t\t\t\t</span>\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\taccessorFn: ({ info }) => info.v,\n\t\t\tid: \"agent\",\n\t\t\tname: () => t`Agent`,\n\t\t\t// invertSorting: true,\n\t\t\tsize: 50,\n\t\t\tIcon: WifiIcon,\n\t\t\thideSort: true,\n\t\t\theader: sortableHeader,\n\t\t\tcell(info) {\n\t\t\t\tconst version = info.getValue() as string"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 14, "start_line": 272, "end_line": 292, "text": "\t\t\t\tif (!version) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst system = info.row.original\n\t\t\t\treturn (\n\t\t\t\t\t<span className={cn(\"flex gap-1.5 items-center md:pe-5 tabular-nums\", viewMode === \"table\" && \"ps-0.5\")}>\n\t\t\t\t\t\t<IndicatorDot\n\t\t\t\t\t\t\tsystem={system}\n\t\t\t\t\t\t\tclassName={\n\t\t\t\t\t\t\t\t(system.status !== SystemStatus.Up && STATUS_COLORS[SystemStatus.Paused]) ||\n\t\t\t\t\t\t\t\t(version === globalThis.BESZEL.HUB_VERSION && STATUS_COLORS[SystemStatus.Up]) ||\n\t\t\t\t\t\t\t\tSTATUS_COLORS[SystemStatus.Pending]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<span className=\"truncate max-w-14\">{info.getValue() as string}</span>\n\t\t\t\t\t</span>\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: \"actions\",", "n_tokens": 173, "primary_symbol": "", "primary_kind": "", "primary_span": [272, 292], "def_symbols": [], "symbols": ["version", "return", "null", "const", "system", "info", "row", "original", "span", "className", "flex", "gap", "items", "center", "tabular", "nums", "viewMode", "table", "IndicatorDot", "status", "SystemStatus", "STATUS_COLORS", "Paused", "globalThis", "BESZEL", "HUB_VERSION", "Pending", "truncate", "max", "getValue", "string", "actions"], "doc_head": "\t\t\t\tif (!version) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst system = info.row.original\n\t\t\t\treturn (\n\t\t\t\t\t<span className={cn(\"flex gap-1.5 items-center md:pe-5 tabular-nums\", viewMode === \"table\" && \"ps-0.5\")}>\n\t\t\t\t\t\t<IndicatorDot\n\t\t\t\t\t\t\tsystem={system}\n\t\t\t\t\t\t\tclassName={\n\t\t\t\t\t\t\t\t(system.status !== SystemStatus.Up && STATUS_COLORS[SystemStatus.Paused]) ||\n\t\t\t\t\t\t\t\t(version === globalThis.BESZEL.HUB_VERSION && STATUS_COLORS[SystemStatus.Up]) ||\n\t\t\t\t\t\t\t\tSTATUS_COLORS[SystemStatus.Pending]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<span className=\"truncate max-w-14\">{info.getValue() as string}</span>\n\t\t\t\t\t</span>\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: \"actions\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 15, "start_line": 293, "end_line": 313, "text": "\t\t\t// @ts-ignore\n\t\t\tname: () => t({ message: \"Actions\", comment: \"Table column\" }),\n\t\t\tsize: 50,\n\t\t\tcell: ({ row }) => (\n\t\t\t\t<div className=\"relative z-10 flex justify-end items-center gap-1 -ms-3\">\n\t\t\t\t\t<AlertButton system={row.original} />\n\t\t\t\t\t<ActionsButton system={row.original} />\n\t\t\t\t</div>\n\t\t\t),\n\t\t},\n\t] as ColumnDef<SystemRecord>[]\n}\n\nfunction sortableHeader(context: HeaderContext<SystemRecord, unknown>) {\n\tconst { column } = context\n\t// @ts-ignore\n\tconst { Icon, hideSort, name }: { Icon: React.ElementType; name: () => string; hideSort: boolean } = column.columnDef\n\treturn (\n\t\t<Button\n\t\t\tvariant=\"ghost\"\n\t\t\tclassName=\"h-9 px-3 flex\"", "n_tokens": 186, "primary_symbol": "sortableHeader", "primary_kind": "function", "primary_span": [306, 313], "def_symbols": ["sortableHeader"], "symbols": ["sortableHeader", "ignore", "name", "message", "Actions", "comment", "Table", "column", "size", "cell", "row", "div", "className", "relative", "flex", "justify", "end", "items", "center", "gap", "AlertButton", "system", "original", "ActionsButton", "ColumnDef", "SystemRecord", "function", "context", "HeaderContext", "unknown", "const", "Icon", "hideSort", "React", "ElementType", "string", "boolean", "columnDef", "return", "Button", "variant", "ghost"], "doc_head": "\t\t\t// @ts-ignore\n\t\t\tname: () => t({ message: \"Actions\", comment: \"Table column\" }),\n\t\t\tsize: 50,\n\t\t\tcell: ({ row }) => (\n\t\t\t\t<div className=\"relative z-10 flex justify-end items-center gap-1 -ms-3\">\n\t\t\t\t\t<AlertButton system={row.original} />\n\t\t\t\t\t<ActionsButton system={row.original} />\n\t\t\t\t</div>\n\t\t\t),\n\t\t},\n\t] as ColumnDef<SystemRecord>[]\n}\nfunction sortableHeader(context: HeaderContext<SystemRecord, unknown>) {\n\tconst { column } = context\n\t// @ts-ignore\n\tconst { Icon, hideSort, name }: { Icon: React.ElementType; name: () => string; hideSort: boolean } = column.columnDef\n\treturn (\n\t\t<Button\n\t\t\tvariant=\"ghost\"\n\t\t\tclassName=\"h-9 px-3 flex\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#16", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 16, "start_line": 314, "end_line": 322, "text": "\t\t\tonClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}\n\t\t>\n\t\t\t{Icon && <Icon className=\"me-2 size-4\" />}\n\t\t\t{name()}\n\t\t\t{hideSort || <ArrowUpDownIcon className=\"ms-2 size-4\" />}\n\t\t</Button>\n\t)\n}\n", "n_tokens": 68, "primary_symbol": "", "primary_kind": "", "primary_span": [314, 322], "def_symbols": [], "symbols": ["onClick", "column", "toggleSorting", "getIsSorted", "asc", "Icon", "className", "size", "name", "hideSort", "ArrowUpDownIcon", "Button"], "doc_head": "\t\t\tonClick={() => column.toggleSorting(column.getIsSorted() === \"asc\")}\n\t\t>\n\t\t\t{Icon && <Icon className=\"me-2 size-4\" />}\n\t\t\t{name()}\n\t\t\t{hideSort || <ArrowUpDownIcon className=\"ms-2 size-4\" />}\n\t\t</Button>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#17", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 17, "start_line": 323, "end_line": 342, "text": "function TableCellWithMeter(info: CellContext<SystemRecord, unknown>) {\n\tconst val = Number(info.getValue()) || 0\n\tconst threshold = getMeterState(val)\n\tconst meterClass = cn(\n\t\t\"h-full\",\n\t\t(info.row.original.status !== SystemStatus.Up && STATUS_COLORS.paused) ||\n\t\t\t(threshold === MeterState.Good && STATUS_COLORS.up) ||\n\t\t\t(threshold === MeterState.Warn && STATUS_COLORS.pending) ||\n\t\t\tSTATUS_COLORS.down\n\t)\n\treturn (\n\t\t<div className=\"flex gap-2 items-center tabular-nums tracking-tight w-full\">\n\t\t\t<span className=\"min-w-8 shrink-0\">{decimalString(val, val >= 10 ? 1 : 2)}%</span>\n\t\t\t<span className=\"flex-1 min-w-8 grid bg-muted h-[1em] rounded-sm overflow-hidden\">\n\t\t\t\t<span className={meterClass} style={{ width: `${val}%` }}></span>\n\t\t\t</span>\n\t\t</div>\n\t)\n}\n", "n_tokens": 209, "primary_symbol": "TableCellWithMeter", "primary_kind": "function", "primary_span": [323, 342], "def_symbols": ["TableCellWithMeter"], "symbols": ["TableCellWithMeter", "function", "info", "CellContext", "SystemRecord", "unknown", "const", "val", "Number", "getValue", "threshold", "getMeterState", "meterClass", "full", "row", "original", "status", "SystemStatus", "STATUS_COLORS", "paused", "MeterState", "Good", "Warn", "pending", "down", "return", "div", "className", "flex", "gap", "items", "center", "tabular", "nums", "tracking", "tight", "span", "min", "shrink", "decimalString", "grid", "muted", "rounded", "overflow", "hidden", "style", "width"], "doc_head": "function TableCellWithMeter(info: CellContext<SystemRecord, unknown>) {\n\tconst val = Number(info.getValue()) || 0\n\tconst threshold = getMeterState(val)\n\tconst meterClass = cn(\n\t\t\"h-full\",\n\t\t(info.row.original.status !== SystemStatus.Up && STATUS_COLORS.paused) ||\n\t\t\t(threshold === MeterState.Good && STATUS_COLORS.up) ||\n\t\t\t(threshold === MeterState.Warn && STATUS_COLORS.pending) ||\n\t\t\tSTATUS_COLORS.down\n\t)\n\treturn (\n\t\t<div className=\"flex gap-2 items-center tabular-nums tracking-tight w-full\">\n\t\t\t<span className=\"min-w-8 shrink-0\">{decimalString(val, val >= 10 ? 1 : 2)}%</span>\n\t\t\t<span className=\"flex-1 min-w-8 grid bg-muted h-[1em] rounded-sm overflow-hidden\">\n\t\t\t\t<span className={meterClass} style={{ width: `${val}%` }}></span>\n\t\t\t</span>\n\t\t</div>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#18", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 18, "start_line": 343, "end_line": 359, "text": "export function IndicatorDot({ system, className }: { system: SystemRecord; className?: ClassValue }) {\n\tclassName ||= STATUS_COLORS[system.status as keyof typeof STATUS_COLORS] || \"\"\n\treturn (\n\t\t<span\n\t\t\tclassName={cn(\"shrink-0 size-2 rounded-full\", className)}\n\t\t\t// style={{ marginBottom: \"-1px\" }}\n\t\t/>\n\t)\n}\n\nexport const ActionsButton = memo(({ system }: { system: SystemRecord }) => {\n\tconst [deleteOpen, setDeleteOpen] = useState(false)\n\tconst [editOpen, setEditOpen] = useState(false)\n\tlet editOpened = useRef(false)\n\tconst { t } = useLingui()\n\tconst { id, status, host, name } = system\n", "n_tokens": 150, "primary_symbol": "IndicatorDot", "primary_kind": "function", "primary_span": [343, 359], "def_symbols": ["IndicatorDot"], "symbols": ["IndicatorDot", "export", "function", "system", "className", "SystemRecord", "ClassValue", "STATUS_COLORS", "status", "keyof", "typeof", "return", "span", "shrink", "size", "rounded", "full", "style", "marginBottom", "const", "ActionsButton", "memo", "deleteOpen", "setDeleteOpen", "useState", "false", "editOpen", "setEditOpen", "let", "editOpened", "useRef", "useLingui", "host", "name"], "doc_head": "export function IndicatorDot({ system, className }: { system: SystemRecord; className?: ClassValue }) {\n\tclassName ||= STATUS_COLORS[system.status as keyof typeof STATUS_COLORS] || \"\"\n\treturn (\n\t\t<span\n\t\t\tclassName={cn(\"shrink-0 size-2 rounded-full\", className)}\n\t\t\t// style={{ marginBottom: \"-1px\" }}\n\t\t/>\n\t)\n}\nexport const ActionsButton = memo(({ system }: { system: SystemRecord }) => {\n\tconst [deleteOpen, setDeleteOpen] = useState(false)\n\tconst [editOpen, setEditOpen] = useState(false)\n\tlet editOpened = useRef(false)\n\tconst { t } = useLingui()\n\tconst { id, status, host, name } = system"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#19", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 19, "start_line": 360, "end_line": 385, "text": "\treturn useMemo(() => {\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<DropdownMenu>\n\t\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t\t<Button variant=\"ghost\" size={\"icon\"}>\n\t\t\t\t\t\t\t<span className=\"sr-only\">\n\t\t\t\t\t\t\t\t<Trans>Open menu</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<MoreHorizontalIcon className=\"w-5\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t\t<DropdownMenuContent align=\"end\">\n\t\t\t\t\t\t{!isReadOnlyUser() && (\n\t\t\t\t\t\t\t<DropdownMenuItem\n\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\teditOpened.current = true\n\t\t\t\t\t\t\t\t\tsetEditOpen(true)\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<PenBoxIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t\t<Trans>Edit</Trans>\n\t\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t<DropdownMenuItem\n\t\t\t\t\t\t\tclassName={cn(isReadOnlyUser() && \"hidden\")}", "n_tokens": 189, "primary_symbol": "", "primary_kind": "", "primary_span": [360, 385], "def_symbols": [], "symbols": ["return", "useMemo", "DropdownMenu", "DropdownMenuTrigger", "asChild", "Button", "variant", "ghost", "size", "icon", "span", "className", "only", "Trans", "Open", "menu", "MoreHorizontalIcon", "DropdownMenuContent", "align", "end", "isReadOnlyUser", "DropdownMenuItem", "onSelect", "editOpened", "current", "true", "setEditOpen", "PenBoxIcon", "Edit", "hidden"], "doc_head": "\treturn useMemo(() => {\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<DropdownMenu>\n\t\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t\t<Button variant=\"ghost\" size={\"icon\"}>\n\t\t\t\t\t\t\t<span className=\"sr-only\">\n\t\t\t\t\t\t\t\t<Trans>Open menu</Trans>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<MoreHorizontalIcon className=\"w-5\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t\t<DropdownMenuContent align=\"end\">\n\t\t\t\t\t\t{!isReadOnlyUser() && (\n\t\t\t\t\t\t\t<DropdownMenuItem\n\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\teditOpened.current = true\n\t\t\t\t\t\t\t\t\tsetEditOpen(true)\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<PenBoxIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t\t<Trans>Edit</Trans>\n\t\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t<DropdownMenuItem\n\t\t\t\t\t\t\tclassName={cn(isReadOnlyUser() && \"hidden\")}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#20", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 20, "start_line": 386, "end_line": 407, "text": "\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\tpb.collection(\"systems\").update(id, {\n\t\t\t\t\t\t\t\t\tstatus: status === SystemStatus.Paused ? SystemStatus.Pending : SystemStatus.Paused,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{status === SystemStatus.Paused ? (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<PlayCircleIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t\t\t<Trans>Resume</Trans>\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<PauseCircleIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t\t\t<Trans>Pause</Trans>\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t<DropdownMenuItem onClick={() => copyToClipboard(name)}>\n\t\t\t\t\t\t\t<CopyIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t<Trans>Copy name</Trans>\n\t\t\t\t\t\t</DropdownMenuItem>", "n_tokens": 186, "primary_symbol": "", "primary_kind": "", "primary_span": [386, 407], "def_symbols": [], "symbols": ["onClick", "collection", "systems", "update", "status", "SystemStatus", "Paused", "Pending", "PlayCircleIcon", "className", "size", "Trans", "Resume", "PauseCircleIcon", "Pause", "DropdownMenuItem", "copyToClipboard", "name", "CopyIcon", "Copy"], "doc_head": "\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\tpb.collection(\"systems\").update(id, {\n\t\t\t\t\t\t\t\t\tstatus: status === SystemStatus.Paused ? SystemStatus.Pending : SystemStatus.Paused,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{status === SystemStatus.Paused ? (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<PlayCircleIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t\t\t<Trans>Resume</Trans>\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<PauseCircleIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t\t\t<Trans>Pause</Trans>\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t<DropdownMenuItem onClick={() => copyToClipboard(name)}>\n\t\t\t\t\t\t\t<CopyIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t<Trans>Copy name</Trans>\n\t\t\t\t\t\t</DropdownMenuItem>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#21", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 21, "start_line": 408, "end_line": 422, "text": "\t\t\t\t\t\t<DropdownMenuItem onClick={() => copyToClipboard(host)}>\n\t\t\t\t\t\t\t<CopyIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t<Trans>Copy host</Trans>\n\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t<DropdownMenuSeparator className={cn(isReadOnlyUser() && \"hidden\")} />\n\t\t\t\t\t\t<DropdownMenuItem className={cn(isReadOnlyUser() && \"hidden\")} onSelect={() => setDeleteOpen(true)}>\n\t\t\t\t\t\t\t<Trash2Icon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t<Trans>Delete</Trans>\n\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t</DropdownMenuContent>\n\t\t\t\t</DropdownMenu>\n\t\t\t\t{/* edit dialog */}\n\t\t\t\t<Dialog open={editOpen} onOpenChange={setEditOpen}>\n\t\t\t\t\t{editOpened.current && <SystemDialog system={system} setOpen={setEditOpen} />}\n\t\t\t\t</Dialog>", "n_tokens": 182, "primary_symbol": "", "primary_kind": "", "primary_span": [408, 422], "def_symbols": [], "symbols": ["DropdownMenuItem", "onClick", "copyToClipboard", "host", "CopyIcon", "className", "size", "Trans", "Copy", "DropdownMenuSeparator", "isReadOnlyUser", "hidden", "onSelect", "setDeleteOpen", "true", "Trash2Icon", "Delete", "DropdownMenuContent", "DropdownMenu", "edit", "dialog", "Dialog", "open", "editOpen", "onOpenChange", "setEditOpen", "editOpened", "current", "SystemDialog", "system", "setOpen"], "doc_head": "\t\t\t\t\t\t<DropdownMenuItem onClick={() => copyToClipboard(host)}>\n\t\t\t\t\t\t\t<CopyIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t<Trans>Copy host</Trans>\n\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t<DropdownMenuSeparator className={cn(isReadOnlyUser() && \"hidden\")} />\n\t\t\t\t\t\t<DropdownMenuItem className={cn(isReadOnlyUser() && \"hidden\")} onSelect={() => setDeleteOpen(true)}>\n\t\t\t\t\t\t\t<Trash2Icon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t\t<Trans>Delete</Trans>\n\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t</DropdownMenuContent>\n\t\t\t\t</DropdownMenu>\n\t\t\t\t{/* edit dialog */}\n\t\t\t\t<Dialog open={editOpen} onOpenChange={setEditOpen}>\n\t\t\t\t\t{editOpened.current && <SystemDialog system={system} setOpen={setEditOpen} />}\n\t\t\t\t</Dialog>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#22", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 22, "start_line": 423, "end_line": 442, "text": "\t\t\t\t{/* deletion dialog */}\n\t\t\t\t<AlertDialog open={deleteOpen} onOpenChange={(open) => setDeleteOpen(open)}>\n\t\t\t\t\t<AlertDialogContent>\n\t\t\t\t\t\t<AlertDialogHeader>\n\t\t\t\t\t\t\t<AlertDialogTitle>\n\t\t\t\t\t\t\t\t<Trans>Are you sure you want to delete {name}?</Trans>\n\t\t\t\t\t\t\t</AlertDialogTitle>\n\t\t\t\t\t\t\t<AlertDialogDescription>\n\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\tThis action cannot be undone. This will permanently delete all current records for {name} from the\n\t\t\t\t\t\t\t\t\tdatabase.\n\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t</AlertDialogDescription>\n\t\t\t\t\t\t</AlertDialogHeader>\n\t\t\t\t\t\t<AlertDialogFooter>\n\t\t\t\t\t\t\t<AlertDialogCancel>\n\t\t\t\t\t\t\t\t<Trans>Cancel</Trans>\n\t\t\t\t\t\t\t</AlertDialogCancel>\n\t\t\t\t\t\t\t<AlertDialogAction\n\t\t\t\t\t\t\t\tclassName={cn(buttonVariants({ variant: \"destructive\" }))}", "n_tokens": 171, "primary_symbol": "", "primary_kind": "", "primary_span": [423, 442], "def_symbols": [], "symbols": ["deletion", "dialog", "AlertDialog", "open", "deleteOpen", "onOpenChange", "setDeleteOpen", "AlertDialogContent", "AlertDialogHeader", "AlertDialogTitle", "Trans", "Are", "you", "sure", "want", "delete", "name", "AlertDialogDescription", "This", "action", "cannot", "undone", "will", "permanently", "all", "current", "records", "for", "from", "the", "database", "AlertDialogFooter", "AlertDialogCancel", "Cancel", "AlertDialogAction", "className", "buttonVariants", "variant", "destructive"], "doc_head": "\t\t\t\t{/* deletion dialog */}\n\t\t\t\t<AlertDialog open={deleteOpen} onOpenChange={(open) => setDeleteOpen(open)}>\n\t\t\t\t\t<AlertDialogContent>\n\t\t\t\t\t\t<AlertDialogHeader>\n\t\t\t\t\t\t\t<AlertDialogTitle>\n\t\t\t\t\t\t\t\t<Trans>Are you sure you want to delete {name}?</Trans>\n\t\t\t\t\t\t\t</AlertDialogTitle>\n\t\t\t\t\t\t\t<AlertDialogDescription>\n\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\tThis action cannot be undone. This will permanently delete all current records for {name} from the\n\t\t\t\t\t\t\t\t\tdatabase.\n\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t</AlertDialogDescription>\n\t\t\t\t\t\t</AlertDialogHeader>\n\t\t\t\t\t\t<AlertDialogFooter>\n\t\t\t\t\t\t\t<AlertDialogCancel>\n\t\t\t\t\t\t\t\t<Trans>Cancel</Trans>\n\t\t\t\t\t\t\t</AlertDialogCancel>\n\t\t\t\t\t\t\t<AlertDialogAction\n\t\t\t\t\t\t\t\tclassName={cn(buttonVariants({ variant: \"destructive\" }))}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx#23", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table-columns.tsx", "rel_path": "src/site/src/components/systems-table/systems-table-columns.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 23, "start_line": 443, "end_line": 454, "text": "\t\t\t\t\t\t\t\tonClick={() => pb.collection(\"systems\").delete(id)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<Trans>Continue</Trans>\n\t\t\t\t\t\t\t</AlertDialogAction>\n\t\t\t\t\t\t</AlertDialogFooter>\n\t\t\t\t\t</AlertDialogContent>\n\t\t\t\t</AlertDialog>\n\t\t\t</>\n\t\t)\n\t}, [id, status, host, name, t, deleteOpen, editOpen])\n})\n", "n_tokens": 74, "primary_symbol": "", "primary_kind": "", "primary_span": [443, 454], "def_symbols": [], "symbols": ["onClick", "collection", "systems", "delete", "Trans", "Continue", "AlertDialogAction", "AlertDialogFooter", "AlertDialogContent", "AlertDialog", "status", "host", "name", "deleteOpen", "editOpen"], "doc_head": "\t\t\t\t\t\t\t\tonClick={() => pb.collection(\"systems\").delete(id)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<Trans>Continue</Trans>\n\t\t\t\t\t\t\t</AlertDialogAction>\n\t\t\t\t\t\t</AlertDialogFooter>\n\t\t\t\t\t</AlertDialogContent>\n\t\t\t\t</AlertDialog>\n\t\t\t</>\n\t\t)\n\t}, [id, status, host, name, t, deleteOpen, editOpen])\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 27, "text": "import {\n\tColumnDef,\n\tColumnFiltersState,\n\tgetFilteredRowModel,\n\tSortingState,\n\tgetSortedRowModel,\n\tflexRender,\n\tVisibilityState,\n\tgetCoreRowModel,\n\tuseReactTable,\n\tRow,\n\tTable as TableType,\n} from \"@tanstack/react-table\"\nimport { TableBody, TableCell, TableHead, TableHeader, TableRow } from \"@/components/ui/table\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n\tDropdownMenu,\n\tDropdownMenuCheckboxItem,\n\tDropdownMenuContent,\n\tDropdownMenuItem,\n\tDropdownMenuLabel,\n\tDropdownMenuRadioGroup,\n\tDropdownMenuRadioItem,\n\tDropdownMenuSeparator,\n\tDropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\nimport { SystemRecord } from \"@/types\"", "n_tokens": 155, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 27], "def_symbols": [], "symbols": ["import", "ColumnDef", "ColumnFiltersState", "getFilteredRowModel", "SortingState", "getSortedRowModel", "flexRender", "VisibilityState", "getCoreRowModel", "useReactTable", "Row", "Table", "TableType", "from", "tanstack", "react", "table", "TableBody", "TableCell", "TableHead", "TableHeader", "TableRow", "components", "Button", "button", "DropdownMenu", "DropdownMenuCheckboxItem", "DropdownMenuContent", "DropdownMenuItem", "DropdownMenuLabel", "DropdownMenuRadioGroup", "DropdownMenuRadioItem", "DropdownMenuSeparator", "DropdownMenuTrigger", "dropdown", "menu", "SystemRecord", "types"], "doc_head": "import {\n\tColumnDef,\n\tColumnFiltersState,\n\tgetFilteredRowModel,\n\tSortingState,\n\tgetSortedRowModel,\n\tflexRender,\n\tVisibilityState,\n\tgetCoreRowModel,\n\tuseReactTable,\n\tRow,\n\tTable as TableType,\n} from \"@tanstack/react-table\"\nimport { TableBody, TableCell, TableHead, TableHeader, TableRow } from \"@/components/ui/table\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n\tDropdownMenu,\n\tDropdownMenuCheckboxItem,\n\tDropdownMenuContent,\n\tDropdownMenuItem,\n\tDropdownMenuLabel,\n\tDropdownMenuRadioGroup,\n\tDropdownMenuRadioItem,\n\tDropdownMenuSeparator,\n\tDropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\nimport { SystemRecord } from \"@/types\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 28, "end_line": 46, "text": "import {\n\tArrowUpDownIcon,\n\tLayoutGridIcon,\n\tLayoutListIcon,\n\tArrowDownIcon,\n\tArrowUpIcon,\n\tSettings2Icon,\n\tEyeIcon,\n\tFilterIcon,\n} from \"lucide-react\"\nimport { memo, useEffect, useMemo, useRef, useState } from \"react\"\nimport { $pausedSystems, $downSystems, $upSystems, $systems } from \"@/lib/stores\"\nimport { useStore } from \"@nanostores/react\"\nimport { cn, runOnce, useBrowserStorage } from \"@/lib/utils\"\nimport { $router, Link } from \"../router\"\nimport { useLingui, Trans } from \"@lingui/react/macro\"\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"../ui/card\"\nimport { Input } from \"@/components/ui/input\"\nimport { getPagePath } from \"@nanostores/router\"", "n_tokens": 186, "primary_symbol": "", "primary_kind": "", "primary_span": [28, 46], "def_symbols": [], "symbols": ["import", "ArrowUpDownIcon", "LayoutGridIcon", "LayoutListIcon", "ArrowDownIcon", "ArrowUpIcon", "Settings2Icon", "EyeIcon", "FilterIcon", "from", "lucide", "react", "memo", "useEffect", "useMemo", "useRef", "useState", "pausedSystems", "downSystems", "upSystems", "systems", "lib", "stores", "useStore", "nanostores", "runOnce", "useBrowserStorage", "utils", "router", "Link", "useLingui", "Trans", "lingui", "macro", "Card", "CardContent", "CardDescription", "CardHeader", "CardTitle", "card", "Input", "components", "input", "getPagePath"], "doc_head": "import {\n\tArrowUpDownIcon,\n\tLayoutGridIcon,\n\tLayoutListIcon,\n\tArrowDownIcon,\n\tArrowUpIcon,\n\tSettings2Icon,\n\tEyeIcon,\n\tFilterIcon,\n} from \"lucide-react\"\nimport { memo, useEffect, useMemo, useRef, useState } from \"react\"\nimport { $pausedSystems, $downSystems, $upSystems, $systems } from \"@/lib/stores\"\nimport { useStore } from \"@nanostores/react\"\nimport { cn, runOnce, useBrowserStorage } from \"@/lib/utils\"\nimport { $router, Link } from \"../router\"\nimport { useLingui, Trans } from \"@lingui/react/macro\"\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"../ui/card\"\nimport { Input } from \"@/components/ui/input\"\nimport { getPagePath } from \"@nanostores/router\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 47, "end_line": 56, "text": "import SystemsTableColumns, { ActionsButton, IndicatorDot } from \"./systems-table-columns\"\nimport AlertButton from \"../alerts/alert-button\"\nimport { SystemStatus } from \"@/lib/enums\"\nimport { useVirtualizer, VirtualItem } from \"@tanstack/react-virtual\"\n\ntype ViewMode = \"table\" | \"grid\"\ntype StatusFilter = \"all\" | SystemRecord[\"status\"]\n\nconst preloadSystemDetail = runOnce(() => import(\"@/components/routes/system.tsx\"))\n", "n_tokens": 97, "primary_symbol": "", "primary_kind": "", "primary_span": [47, 56], "def_symbols": [], "symbols": ["import", "SystemsTableColumns", "ActionsButton", "IndicatorDot", "from", "systems", "table", "columns", "AlertButton", "alerts", "alert", "button", "SystemStatus", "lib", "enums", "useVirtualizer", "VirtualItem", "tanstack", "react", "virtual", "type", "ViewMode", "grid", "StatusFilter", "all", "SystemRecord", "status", "const", "preloadSystemDetail", "runOnce", "components", "routes", "system", "tsx"], "doc_head": "import SystemsTableColumns, { ActionsButton, IndicatorDot } from \"./systems-table-columns\"\nimport AlertButton from \"../alerts/alert-button\"\nimport { SystemStatus } from \"@/lib/enums\"\nimport { useVirtualizer, VirtualItem } from \"@tanstack/react-virtual\"\ntype ViewMode = \"table\" | \"grid\"\ntype StatusFilter = \"all\" | SystemRecord[\"status\"]\nconst preloadSystemDetail = runOnce(() => import(\"@/components/routes/system.tsx\"))"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 57, "end_line": 79, "text": "export default function SystemsTable() {\n\tconst data = useStore($systems)\n\tconst downSystems = $downSystems.get()\n\tconst upSystems = $upSystems.get()\n\tconst pausedSystems = $pausedSystems.get()\n\tconst { i18n, t } = useLingui()\n\tconst [filter, setFilter] = useState<string>()\n\tconst [statusFilter, setStatusFilter] = useState<StatusFilter>(\"all\")\n\tconst [sorting, setSorting] = useBrowserStorage<SortingState>(\n\t\t\"sortMode\",\n\t\t[{ id: \"system\", desc: false }],\n\t\tsessionStorage\n\t)\n\tconst [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([])\n\tconst [columnVisibility, setColumnVisibility] = useBrowserStorage<VisibilityState>(\"cols\", {})\n\n\tconst locale = i18n.locale\n\n\t// Filter data based on status filter\n\tconst filteredData = useMemo(() => {\n\t\tif (statusFilter === \"all\") {\n\t\t\treturn data\n\t\t}", "n_tokens": 202, "primary_symbol": "", "primary_kind": "", "primary_span": [57, 79], "def_symbols": [], "symbols": ["export", "default", "function", "SystemsTable", "const", "data", "useStore", "systems", "downSystems", "get", "upSystems", "pausedSystems", "i18n", "useLingui", "filter", "setFilter", "useState", "string", "statusFilter", "setStatusFilter", "StatusFilter", "all", "sorting", "setSorting", "useBrowserStorage", "SortingState", "sortMode", "system", "desc", "false", "sessionStorage", "columnFilters", "setColumnFilters", "ColumnFiltersState", "columnVisibility", "setColumnVisibility", "VisibilityState", "cols", "locale", "Filter", "based", "status", "filteredData", "useMemo", "return"], "doc_head": "export default function SystemsTable() {\n\tconst data = useStore($systems)\n\tconst downSystems = $downSystems.get()\n\tconst upSystems = $upSystems.get()\n\tconst pausedSystems = $pausedSystems.get()\n\tconst { i18n, t } = useLingui()\n\tconst [filter, setFilter] = useState<string>()\n\tconst [statusFilter, setStatusFilter] = useState<StatusFilter>(\"all\")\n\tconst [sorting, setSorting] = useBrowserStorage<SortingState>(\n\t\t\"sortMode\",\n\t\t[{ id: \"system\", desc: false }],\n\t\tsessionStorage\n\t)\n\tconst [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([])\n\tconst [columnVisibility, setColumnVisibility] = useBrowserStorage<VisibilityState>(\"cols\", {})\n\tconst locale = i18n.locale\n\t// Filter data based on status filter\n\tconst filteredData = useMemo(() => {\n\t\tif (statusFilter === \"all\") {\n\t\t\treturn data\n\t\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 80, "end_line": 100, "text": "\t\tif (statusFilter === SystemStatus.Up) {\n\t\t\treturn Object.values(upSystems) ?? []\n\t\t}\n\t\tif (statusFilter === SystemStatus.Down) {\n\t\t\treturn Object.values(downSystems) ?? []\n\t\t}\n\t\treturn Object.values(pausedSystems) ?? []\n\t}, [data, statusFilter])\n\n\tconst [viewMode, setViewMode] = useBrowserStorage<ViewMode>(\n\t\t\"viewMode\",\n\t\t// show grid view on mobile if there are less than 200 systems (looks better but table is more efficient)\n\t\twindow.innerWidth < 1024 && filteredData.length < 200 ? \"grid\" : \"table\"\n\t)\n\n\tuseEffect(() => {\n\t\tif (filter !== undefined) {\n\t\t\ttable.getColumn(\"system\")?.setFilterValue(filter)\n\t\t}\n\t}, [filter])\n", "n_tokens": 168, "primary_symbol": "", "primary_kind": "", "primary_span": [80, 100], "def_symbols": [], "symbols": ["statusFilter", "SystemStatus", "return", "Object", "values", "upSystems", "Down", "downSystems", "pausedSystems", "data", "const", "viewMode", "setViewMode", "useBrowserStorage", "ViewMode", "show", "grid", "view", "mobile", "there", "are", "less", "than", "systems", "looks", "better", "but", "table", "more", "efficient", "window", "innerWidth", "filteredData", "length", "useEffect", "filter", "undefined", "getColumn", "system", "setFilterValue"], "doc_head": "\t\tif (statusFilter === SystemStatus.Up) {\n\t\t\treturn Object.values(upSystems) ?? []\n\t\t}\n\t\tif (statusFilter === SystemStatus.Down) {\n\t\t\treturn Object.values(downSystems) ?? []\n\t\t}\n\t\treturn Object.values(pausedSystems) ?? []\n\t}, [data, statusFilter])\n\tconst [viewMode, setViewMode] = useBrowserStorage<ViewMode>(\n\t\t\"viewMode\",\n\t\t// show grid view on mobile if there are less than 200 systems (looks better but table is more efficient)\n\t\twindow.innerWidth < 1024 && filteredData.length < 200 ? \"grid\" : \"table\"\n\t)\n\tuseEffect(() => {\n\t\tif (filter !== undefined) {\n\t\t\ttable.getColumn(\"system\")?.setFilterValue(filter)\n\t\t}\n\t}, [filter])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 101, "end_line": 129, "text": "\tconst columnDefs = useMemo(() => SystemsTableColumns(viewMode), [viewMode])\n\n\tconst table = useReactTable({\n\t\tdata: filteredData,\n\t\tcolumns: columnDefs,\n\t\tgetCoreRowModel: getCoreRowModel(),\n\t\tonSortingChange: setSorting,\n\t\tgetSortedRowModel: getSortedRowModel(),\n\t\tonColumnFiltersChange: setColumnFilters,\n\t\tgetFilteredRowModel: getFilteredRowModel(),\n\t\tonColumnVisibilityChange: setColumnVisibility,\n\t\tstate: {\n\t\t\tsorting,\n\t\t\tcolumnFilters,\n\t\t\tcolumnVisibility,\n\t\t},\n\t\tdefaultColumn: {\n\t\t\tinvertSorting: true,\n\t\t\tsortUndefined: \"last\",\n\t\t\tminSize: 0,\n\t\t\tsize: 900,\n\t\t\tmaxSize: 900,\n\t\t},\n\t})\n\n\tconst rows = table.getRowModel().rows\n\tconst columns = table.getAllColumns()\n\tconst visibleColumns = table.getVisibleLeafColumns()\n", "n_tokens": 187, "primary_symbol": "", "primary_kind": "", "primary_span": [101, 129], "def_symbols": [], "symbols": ["const", "columnDefs", "useMemo", "SystemsTableColumns", "viewMode", "table", "useReactTable", "data", "filteredData", "columns", "getCoreRowModel", "onSortingChange", "setSorting", "getSortedRowModel", "onColumnFiltersChange", "setColumnFilters", "getFilteredRowModel", "onColumnVisibilityChange", "setColumnVisibility", "state", "sorting", "columnFilters", "columnVisibility", "defaultColumn", "invertSorting", "true", "sortUndefined", "last", "minSize", "size", "maxSize", "rows", "getRowModel", "getAllColumns", "visibleColumns", "getVisibleLeafColumns"], "doc_head": "\tconst columnDefs = useMemo(() => SystemsTableColumns(viewMode), [viewMode])\n\tconst table = useReactTable({\n\t\tdata: filteredData,\n\t\tcolumns: columnDefs,\n\t\tgetCoreRowModel: getCoreRowModel(),\n\t\tonSortingChange: setSorting,\n\t\tgetSortedRowModel: getSortedRowModel(),\n\t\tonColumnFiltersChange: setColumnFilters,\n\t\tgetFilteredRowModel: getFilteredRowModel(),\n\t\tonColumnVisibilityChange: setColumnVisibility,\n\t\tstate: {\n\t\t\tsorting,\n\t\t\tcolumnFilters,\n\t\t\tcolumnVisibility,\n\t\t},\n\t\tdefaultColumn: {\n\t\t\tinvertSorting: true,\n\t\t\tsortUndefined: \"last\",\n\t\t\tminSize: 0,\n\t\t\tsize: 900,\n\t\t\tmaxSize: 900,\n\t\t},\n\t})\n\tconst rows = table.getRowModel().rows\n\tconst columns = table.getAllColumns()\n\tconst visibleColumns = table.getVisibleLeafColumns()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 130, "end_line": 133, "text": "\tconst [upSystemsLength, downSystemsLength, pausedSystemsLength] = useMemo(() => {\n\t\treturn [Object.values(upSystems).length, Object.values(downSystems).length, Object.values(pausedSystems).length]\n\t}, [upSystems, downSystems, pausedSystems])\n", "n_tokens": 56, "primary_symbol": "", "primary_kind": "", "primary_span": [130, 133], "def_symbols": [], "symbols": ["const", "upSystemsLength", "downSystemsLength", "pausedSystemsLength", "useMemo", "return", "Object", "values", "upSystems", "length", "downSystems", "pausedSystems"], "doc_head": "\tconst [upSystemsLength, downSystemsLength, pausedSystemsLength] = useMemo(() => {\n\t\treturn [Object.values(upSystems).length, Object.values(downSystems).length, Object.values(pausedSystems).length]\n\t}, [upSystems, downSystems, pausedSystems])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 134, "end_line": 148, "text": "\t// TODO: hiding temp then gpu messes up table headers\n\tconst CardHead = useMemo(() => {\n\t\treturn (\n\t\t\t<CardHeader className=\"pb-4.5 px-2 sm:px-6 max-sm:pt-5 max-sm:pb-1\">\n\t\t\t\t<div className=\"grid md:flex gap-5 w-full items-end\">\n\t\t\t\t\t<div className=\"px-2 sm:px-1\">\n\t\t\t\t\t\t<CardTitle className=\"mb-2\">\n\t\t\t\t\t\t\t<Trans>All Systems</Trans>\n\t\t\t\t\t\t</CardTitle>\n\t\t\t\t\t\t<CardDescription className=\"flex\">\n\t\t\t\t\t\t\t<Trans>Click on a system to view more information.</Trans>\n\t\t\t\t\t\t</CardDescription>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div className=\"flex gap-2 ms-auto w-full md:w-80\">", "n_tokens": 165, "primary_symbol": "", "primary_kind": "", "primary_span": [134, 148], "def_symbols": [], "symbols": ["TODO", "hiding", "temp", "then", "gpu", "messes", "table", "headers", "const", "CardHead", "useMemo", "return", "CardHeader", "className", "max", "div", "grid", "flex", "gap", "full", "items", "end", "CardTitle", "Trans", "All", "Systems", "CardDescription", "Click", "system", "view", "more", "information", "auto"], "doc_head": "\t// TODO: hiding temp then gpu messes up table headers\n\tconst CardHead = useMemo(() => {\n\t\treturn (\n\t\t\t<CardHeader className=\"pb-4.5 px-2 sm:px-6 max-sm:pt-5 max-sm:pb-1\">\n\t\t\t\t<div className=\"grid md:flex gap-5 w-full items-end\">\n\t\t\t\t\t<div className=\"px-2 sm:px-1\">\n\t\t\t\t\t\t<CardTitle className=\"mb-2\">\n\t\t\t\t\t\t\t<Trans>All Systems</Trans>\n\t\t\t\t\t\t</CardTitle>\n\t\t\t\t\t\t<CardDescription className=\"flex\">\n\t\t\t\t\t\t\t<Trans>Click on a system to view more information.</Trans>\n\t\t\t\t\t\t</CardDescription>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"flex gap-2 ms-auto w-full md:w-80\">"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 149, "end_line": 167, "text": "\t\t\t\t\t\t<Input placeholder={t`Filter...`} onChange={(e) => setFilter(e.target.value)} className=\"px-4\" />\n\t\t\t\t\t\t<DropdownMenu>\n\t\t\t\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t\t\t\t<Button variant=\"outline\">\n\t\t\t\t\t\t\t\t\t<Settings2Icon className=\"me-1.5 size-4 opacity-80\" />\n\t\t\t\t\t\t\t\t\t<Trans>View</Trans>\n\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t\t\t\t<DropdownMenuContent align=\"end\" className=\"h-72 md:h-auto min-w-48 md:min-w-auto overflow-y-auto\">\n\t\t\t\t\t\t\t\t<div className=\"grid grid-cols-1 md:grid-cols-4 divide-y md:divide-s md:divide-y-0\">\n\t\t\t\t\t\t\t\t\t<div className=\"border-r\">\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuLabel className=\"pt-2 px-3.5 flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t<LayoutGridIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Layout</Trans>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuLabel>\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioGroup\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"px-1 pb-1\"\n\t\t\t\t\t\t\t\t\t\t\tvalue={viewMode}", "n_tokens": 242, "primary_symbol": "", "primary_kind": "", "primary_span": [149, 167], "def_symbols": [], "symbols": ["Input", "placeholder", "Filter", "onChange", "setFilter", "target", "value", "className", "DropdownMenu", "DropdownMenuTrigger", "asChild", "Button", "variant", "outline", "Settings2Icon", "size", "opacity", "Trans", "View", "DropdownMenuContent", "align", "end", "auto", "min", "overflow", "div", "grid", "cols", "divide", "border", "DropdownMenuLabel", "flex", "items", "center", "gap", "LayoutGridIcon", "Layout", "DropdownMenuSeparator", "DropdownMenuRadioGroup", "viewMode"], "doc_head": "\t\t\t\t\t\t<Input placeholder={t`Filter...`} onChange={(e) => setFilter(e.target.value)} className=\"px-4\" />\n\t\t\t\t\t\t<DropdownMenu>\n\t\t\t\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t\t\t\t<Button variant=\"outline\">\n\t\t\t\t\t\t\t\t\t<Settings2Icon className=\"me-1.5 size-4 opacity-80\" />\n\t\t\t\t\t\t\t\t\t<Trans>View</Trans>\n\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t\t\t\t<DropdownMenuContent align=\"end\" className=\"h-72 md:h-auto min-w-48 md:min-w-auto overflow-y-auto\">\n\t\t\t\t\t\t\t\t<div className=\"grid grid-cols-1 md:grid-cols-4 divide-y md:divide-s md:divide-y-0\">\n\t\t\t\t\t\t\t\t\t<div className=\"border-r\">\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuLabel className=\"pt-2 px-3.5 flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t<LayoutGridIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Layout</Trans>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuLabel>\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioGroup\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"px-1 pb-1\"\n\t\t\t\t\t\t\t\t\t\t\tvalue={viewMode}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 168, "end_line": 173, "text": "\t\t\t\t\t\t\t\t\t\t\tonValueChange={(view) => setViewMode(view as ViewMode)}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"table\" onSelect={(e) => e.preventDefault()} className=\"gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t\t<LayoutListIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Table</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>", "n_tokens": 74, "primary_symbol": "", "primary_kind": "", "primary_span": [168, 173], "def_symbols": [], "symbols": ["onValueChange", "view", "setViewMode", "ViewMode", "DropdownMenuRadioItem", "value", "table", "onSelect", "preventDefault", "className", "gap", "LayoutListIcon", "size", "Trans", "Table"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\tonValueChange={(view) => setViewMode(view as ViewMode)}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"table\" onSelect={(e) => e.preventDefault()} className=\"gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t\t<LayoutListIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Table</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 11, "start_line": 174, "end_line": 191, "text": "\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"grid\" onSelect={(e) => e.preventDefault()} className=\"gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t\t<LayoutGridIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Grid</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioGroup>\n\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t<div className=\"border-r\">\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuLabel className=\"pt-2 px-3.5 flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t<FilterIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Status</Trans>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuLabel>\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioGroup\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"px-1 pb-1\"\n\t\t\t\t\t\t\t\t\t\t\tvalue={statusFilter}\n\t\t\t\t\t\t\t\t\t\t\tonValueChange={(value) => setStatusFilter(value as StatusFilter)}\n\t\t\t\t\t\t\t\t\t\t>", "n_tokens": 175, "primary_symbol": "", "primary_kind": "", "primary_span": [174, 191], "def_symbols": [], "symbols": ["DropdownMenuRadioItem", "value", "grid", "onSelect", "preventDefault", "className", "gap", "LayoutGridIcon", "size", "Trans", "Grid", "DropdownMenuRadioGroup", "div", "border", "DropdownMenuLabel", "flex", "items", "center", "FilterIcon", "Status", "DropdownMenuSeparator", "statusFilter", "onValueChange", "setStatusFilter", "StatusFilter"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"grid\" onSelect={(e) => e.preventDefault()} className=\"gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t\t<LayoutGridIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Grid</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioGroup>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div className=\"border-r\">\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuLabel className=\"pt-2 px-3.5 flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t<FilterIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Status</Trans>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuLabel>\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioGroup\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"px-1 pb-1\"\n\t\t\t\t\t\t\t\t\t\t\tvalue={statusFilter}\n\t\t\t\t\t\t\t\t\t\t\tonValueChange={(value) => setStatusFilter(value as StatusFilter)}\n\t\t\t\t\t\t\t\t\t\t>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 12, "start_line": 192, "end_line": 200, "text": "\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"all\" onSelect={(e) => e.preventDefault()}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>All Systems</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>\n\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"up\" onSelect={(e) => e.preventDefault()}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Up ({upSystemsLength})</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>\n\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"down\" onSelect={(e) => e.preventDefault()}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Down ({downSystemsLength})</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>", "n_tokens": 118, "primary_symbol": "", "primary_kind": "", "primary_span": [192, 200], "def_symbols": [], "symbols": ["DropdownMenuRadioItem", "value", "all", "onSelect", "preventDefault", "Trans", "All", "Systems", "upSystemsLength", "down", "Down", "downSystemsLength"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"all\" onSelect={(e) => e.preventDefault()}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>All Systems</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>\n\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"up\" onSelect={(e) => e.preventDefault()}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Up ({upSystemsLength})</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>\n\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"down\" onSelect={(e) => e.preventDefault()}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Down ({downSystemsLength})</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 13, "start_line": 201, "end_line": 218, "text": "\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"paused\" onSelect={(e) => e.preventDefault()}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Paused ({pausedSystemsLength})</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioGroup>\n\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t<div className=\"border-r\">\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuLabel className=\"pt-2 px-3.5 flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t<ArrowUpDownIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Sort By</Trans>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuLabel>\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t\t\t\t\t<div className=\"px-1 pb-1\">\n\t\t\t\t\t\t\t\t\t\t\t{columns.map((column) => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (!column.getCanSort()) return null\n\t\t\t\t\t\t\t\t\t\t\t\tlet Icon = <span className=\"w-6\"></span>\n\t\t\t\t\t\t\t\t\t\t\t\t// if current sort column, show sort direction\n\t\t\t\t\t\t\t\t\t\t\t\tif (sorting[0]?.id === column.id) {", "n_tokens": 194, "primary_symbol": "", "primary_kind": "", "primary_span": [201, 218], "def_symbols": [], "symbols": ["DropdownMenuRadioItem", "value", "paused", "onSelect", "preventDefault", "Trans", "Paused", "pausedSystemsLength", "DropdownMenuRadioGroup", "div", "className", "border", "DropdownMenuLabel", "flex", "items", "center", "gap", "ArrowUpDownIcon", "size", "Sort", "DropdownMenuSeparator", "columns", "map", "column", "getCanSort", "return", "null", "let", "Icon", "span", "current", "sort", "show", "direction", "sorting"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuRadioItem value=\"paused\" onSelect={(e) => e.preventDefault()}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Paused ({pausedSystemsLength})</Trans>\n\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioItem>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuRadioGroup>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div className=\"border-r\">\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuLabel className=\"pt-2 px-3.5 flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t<ArrowUpDownIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Sort By</Trans>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuLabel>\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t\t\t\t\t<div className=\"px-1 pb-1\">\n\t\t\t\t\t\t\t\t\t\t\t{columns.map((column) => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (!column.getCanSort()) return null\n\t\t\t\t\t\t\t\t\t\t\t\tlet Icon = <span className=\"w-6\"></span>\n\t\t\t\t\t\t\t\t\t\t\t\t// if current sort column, show sort direction\n\t\t\t\t\t\t\t\t\t\t\t\tif (sorting[0]?.id === column.id) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 14, "start_line": 219, "end_line": 226, "text": "\t\t\t\t\t\t\t\t\t\t\t\t\tif (sorting[0]?.desc) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tIcon = <ArrowUpIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tIcon = <ArrowDownIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuItem", "n_tokens": 65, "primary_symbol": "", "primary_kind": "", "primary_span": [219, 226], "def_symbols": [], "symbols": ["sorting", "desc", "Icon", "ArrowUpIcon", "className", "size", "else", "ArrowDownIcon", "return", "DropdownMenuItem"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\t\t\tif (sorting[0]?.desc) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tIcon = <ArrowUpIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tIcon = <ArrowDownIcon className=\"me-2 size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuItem"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 15, "start_line": 227, "end_line": 250, "text": "\t\t\t\t\t\t\t\t\t\t\t\t\t\tonSelect={(e) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetSorting([{ id: column.id, desc: sorting[0]?.id === column.id && !sorting[0]?.desc }])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey={column.id}\n\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{Icon}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/* @ts-ignore */}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{column.columnDef.name()}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuLabel className=\"pt-2 px-3.5 flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t<EyeIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Visible Fields</Trans>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuLabel>\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t\t\t\t\t<div className=\"px-1.5 pb-1\">\n\t\t\t\t\t\t\t\t\t\t\t{columns\n\t\t\t\t\t\t\t\t\t\t\t\t.filter((column) => column.getCanHide())", "n_tokens": 187, "primary_symbol": "", "primary_kind": "", "primary_span": [227, 250], "def_symbols": [], "symbols": ["onSelect", "preventDefault", "setSorting", "column", "desc", "sorting", "key", "Icon", "ignore", "columnDef", "name", "DropdownMenuItem", "div", "DropdownMenuLabel", "className", "flex", "items", "center", "gap", "EyeIcon", "size", "Trans", "Visible", "Fields", "DropdownMenuSeparator", "columns", "filter", "getCanHide"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\t\t\t\tonSelect={(e) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetSorting([{ id: column.id, desc: sorting[0]?.id === column.id && !sorting[0]?.desc }])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey={column.id}\n\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{Icon}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/* @ts-ignore */}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{column.columnDef.name()}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuLabel className=\"pt-2 px-3.5 flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t<EyeIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Visible Fields</Trans>\n\t\t\t\t\t\t\t\t\t\t</DropdownMenuLabel>\n\t\t\t\t\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t\t\t\t\t<div className=\"px-1.5 pb-1\">\n\t\t\t\t\t\t\t\t\t\t\t{columns\n\t\t\t\t\t\t\t\t\t\t\t\t.filter((column) => column.getCanHide())"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#16", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 16, "start_line": 251, "end_line": 256, "text": "\t\t\t\t\t\t\t\t\t\t\t\t.map((column) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuCheckboxItem\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey={column.id}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonSelect={(e) => e.preventDefault()}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchecked={column.getIsVisible()}", "n_tokens": 44, "primary_symbol": "", "primary_kind": "", "primary_span": [251, 256], "def_symbols": [], "symbols": ["map", "column", "return", "DropdownMenuCheckboxItem", "key", "onSelect", "preventDefault", "checked", "getIsVisible"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\t\t.map((column) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuCheckboxItem\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey={column.id}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonSelect={(e) => e.preventDefault()}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchecked={column.getIsVisible()}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#17", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 17, "start_line": 257, "end_line": 296, "text": "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonCheckedChange={(value) => column.toggleVisibility(!!value)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/* @ts-ignore */}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{column.columnDef.name()}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuCheckboxItem>\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</DropdownMenuContent>\n\t\t\t\t\t\t</DropdownMenu>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</CardHeader>\n\t\t)\n\t}, [\n\t\tvisibleColumns.length,\n\t\tsorting,\n\t\tviewMode,\n\t\tlocale,\n\t\tstatusFilter,\n\t\tupSystemsLength,\n\t\tdownSystemsLength,\n\t\tpausedSystemsLength,\n\t])\n\n\treturn (\n\t\t<Card>\n\t\t\t{CardHead}\n\t\t\t<div className=\"p-6 pt-0 max-sm:py-3 max-sm:px-2\">\n\t\t\t\t{viewMode === \"table\" ? (\n\t\t\t\t\t// table layout\n\t\t\t\t\t<div className=\"rounded-md\">\n\t\t\t\t\t\t<AllSystemsTable table={table} rows={rows} colLength={visibleColumns.length} />\n\t\t\t\t\t</div>\n\t\t\t\t) : (\n\t\t\t\t\t// grid layout\n\t\t\t\t\t<div className=\"grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3\">\n\t\t\t\t\t\t{rows?.length ? (", "n_tokens": 272, "primary_symbol": "", "primary_kind": "", "primary_span": [257, 296], "def_symbols": [], "symbols": ["onCheckedChange", "value", "column", "toggleVisibility", "ignore", "columnDef", "name", "DropdownMenuCheckboxItem", "div", "DropdownMenuContent", "DropdownMenu", "CardHeader", "visibleColumns", "length", "sorting", "viewMode", "locale", "statusFilter", "upSystemsLength", "downSystemsLength", "pausedSystemsLength", "return", "Card", "CardHead", "className", "max", "table", "layout", "rounded", "AllSystemsTable", "rows", "colLength", "grid", "gap", "cols"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonCheckedChange={(value) => column.toggleVisibility(!!value)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/* @ts-ignore */}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{column.columnDef.name()}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuCheckboxItem>\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</DropdownMenuContent>\n\t\t\t\t\t\t</DropdownMenu>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</CardHeader>\n\t\t)\n\t}, [\n\t\tvisibleColumns.length,\n\t\tsorting,\n\t\tviewMode,\n\t\tlocale,\n\t\tstatusFilter,\n\t\tupSystemsLength,\n\t\tdownSystemsLength,\n\t\tpausedSystemsLength,\n\t])\n\treturn (\n\t\t<Card>\n\t\t\t{CardHead}\n\t\t\t<div className=\"p-6 pt-0 max-sm:py-3 max-sm:px-2\">\n\t\t\t\t{viewMode === \"table\" ? (\n\t\t\t\t\t// table layout\n\t\t\t\t\t<div className=\"rounded-md\">\n\t\t\t\t\t\t<AllSystemsTable table={table} rows={rows} colLength={visibleColumns.length} />\n\t\t\t\t\t</div>\n\t\t\t\t) : (\n\t\t\t\t\t// grid layout\n\t\t\t\t\t<div className=\"grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3\">\n\t\t\t\t\t\t{rows?.length ? ("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#18", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 18, "start_line": 297, "end_line": 326, "text": "\t\t\t\t\t\t\trows.map((row) => {\n\t\t\t\t\t\t\t\treturn <SystemCard key={row.original.id} row={row} table={table} colLength={visibleColumns.length} />\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<div className=\"col-span-full text-center py-8\">\n\t\t\t\t\t\t\t\t<Trans>No systems found.</Trans>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</Card>\n\t)\n}\n\nconst AllSystemsTable = memo(function ({\n\ttable,\n\trows,\n\tcolLength,\n}: {\n\ttable: TableType<SystemRecord>\n\trows: Row<SystemRecord>[]\n\tcolLength: number\n}) {\n\t// The virtualizer will need a reference to the scrollable container element\n\tconst scrollRef = useRef<HTMLDivElement>(null)\n\n\tconst virtualizer = useVirtualizer<HTMLDivElement, HTMLTableRowElement>({\n\t\tcount: rows.length,\n\t\testimateSize: () => (rows.length > 10 ? 56 : 60),", "n_tokens": 200, "primary_symbol": "", "primary_kind": "", "primary_span": [297, 326], "def_symbols": [], "symbols": ["rows", "map", "row", "return", "SystemCard", "key", "original", "table", "colLength", "visibleColumns", "length", "div", "className", "col", "span", "full", "text", "center", "Trans", "systems", "found", "Card", "const", "AllSystemsTable", "memo", "function", "TableType", "SystemRecord", "Row", "number", "The", "virtualizer", "will", "need", "reference", "the", "scrollable", "container", "element", "scrollRef", "useRef", "HTMLDivElement", "null", "useVirtualizer", "HTMLTableRowElement", "count", "estimateSize"], "doc_head": "\t\t\t\t\t\t\trows.map((row) => {\n\t\t\t\t\t\t\t\treturn <SystemCard key={row.original.id} row={row} table={table} colLength={visibleColumns.length} />\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<div className=\"col-span-full text-center py-8\">\n\t\t\t\t\t\t\t\t<Trans>No systems found.</Trans>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</Card>\n\t)\n}\nconst AllSystemsTable = memo(function ({\n\ttable,\n\trows,\n\tcolLength,\n}: {\n\ttable: TableType<SystemRecord>\n\trows: Row<SystemRecord>[]\n\tcolLength: number\n}) {\n\t// The virtualizer will need a reference to the scrollable container element\n\tconst scrollRef = useRef<HTMLDivElement>(null)\n\tconst virtualizer = useVirtualizer<HTMLDivElement, HTMLTableRowElement>({\n\t\tcount: rows.length,\n\t\testimateSize: () => (rows.length > 10 ? 56 : 60),"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#19", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 19, "start_line": 327, "end_line": 349, "text": "\t\tgetScrollElement: () => scrollRef.current,\n\t\toverscan: 5,\n\t})\n\tconst virtualRows = virtualizer.getVirtualItems()\n\n\tconst paddingTop = Math.max(0, virtualRows[0]?.start ?? 0 - virtualizer.options.scrollMargin)\n\tconst paddingBottom = Math.max(0, virtualizer.getTotalSize() - (virtualRows[virtualRows.length - 1]?.end ?? 0))\n\n\treturn (\n\t\t<div\n\t\t\tclassName={cn(\n\t\t\t\t\"h-min max-h-[calc(100dvh-17rem)] max-w-full relative overflow-auto border rounded-md\",\n\t\t\t\t// don't set min height if there are less than 2 rows, do set if we need to display the empty state\n\t\t\t\t(!rows.length || rows.length > 2) && \"min-h-50\"\n\t\t\t)}\n\t\t\tref={scrollRef}\n\t\t>\n\t\t\t{/* add header height to table size */}\n\t\t\t<div style={{ height: `${virtualizer.getTotalSize() + 50}px`, paddingTop, paddingBottom }}>\n\t\t\t\t<table className=\"text-sm w-full h-full\">\n\t\t\t\t\t<SystemsTableHead table={table} colLength={colLength} />\n\t\t\t\t\t<TableBody onMouseEnter={preloadSystemDetail}>\n\t\t\t\t\t\t{rows.length ? (", "n_tokens": 261, "primary_symbol": "", "primary_kind": "", "primary_span": [327, 349], "def_symbols": [], "symbols": ["getScrollElement", "scrollRef", "current", "overscan", "const", "virtualRows", "virtualizer", "getVirtualItems", "paddingTop", "Math", "max", "start", "options", "scrollMargin", "paddingBottom", "getTotalSize", "length", "end", "return", "div", "className", "min", "calc", "full", "relative", "overflow", "auto", "border", "rounded", "don", "set", "height", "there", "are", "less", "than", "rows", "need", "display", "the", "empty", "state", "ref", "add", "header", "table", "size", "style", "text", "SystemsTableHead", "colLength", "TableBody", "onMouseEnter", "preloadSystemDetail"], "doc_head": "\t\tgetScrollElement: () => scrollRef.current,\n\t\toverscan: 5,\n\t})\n\tconst virtualRows = virtualizer.getVirtualItems()\n\tconst paddingTop = Math.max(0, virtualRows[0]?.start ?? 0 - virtualizer.options.scrollMargin)\n\tconst paddingBottom = Math.max(0, virtualizer.getTotalSize() - (virtualRows[virtualRows.length - 1]?.end ?? 0))\n\treturn (\n\t\t<div\n\t\t\tclassName={cn(\n\t\t\t\t\"h-min max-h-[calc(100dvh-17rem)] max-w-full relative overflow-auto border rounded-md\",\n\t\t\t\t// don't set min height if there are less than 2 rows, do set if we need to display the empty state\n\t\t\t\t(!rows.length || rows.length > 2) && \"min-h-50\"\n\t\t\t)}\n\t\t\tref={scrollRef}\n\t\t>\n\t\t\t{/* add header height to table size */}\n\t\t\t<div style={{ height: `${virtualizer.getTotalSize() + 50}px`, paddingTop, paddingBottom }}>\n\t\t\t\t<table className=\"text-sm w-full h-full\">\n\t\t\t\t\t<SystemsTableHead table={table} colLength={colLength} />\n\t\t\t\t\t<TableBody onMouseEnter={preloadSystemDetail}>\n\t\t\t\t\t\t{rows.length ? ("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#20", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 20, "start_line": 350, "end_line": 378, "text": "\t\t\t\t\t\t\tvirtualRows.map((virtualRow) => {\n\t\t\t\t\t\t\t\tconst row = rows[virtualRow.index] as Row<SystemRecord>\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<SystemTableRow\n\t\t\t\t\t\t\t\t\t\tkey={row.id}\n\t\t\t\t\t\t\t\t\t\trow={row}\n\t\t\t\t\t\t\t\t\t\tvirtualRow={virtualRow}\n\t\t\t\t\t\t\t\t\t\tlength={rows.length}\n\t\t\t\t\t\t\t\t\t\tcolLength={colLength}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<TableRow>\n\t\t\t\t\t\t\t\t<TableCell colSpan={colLength} className=\"h-37 text-center pointer-events-none\">\n\t\t\t\t\t\t\t\t\t<Trans>No systems found.</Trans>\n\t\t\t\t\t\t\t\t</TableCell>\n\t\t\t\t\t\t\t</TableRow>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</TableBody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t</div>\n\t)\n})\n\nfunction SystemsTableHead({ table, colLength }: { table: TableType<SystemRecord>; colLength: number }) {\n\tconst { i18n } = useLingui()\n", "n_tokens": 187, "primary_symbol": "SystemsTableHead", "primary_kind": "function", "primary_span": [376, 378], "def_symbols": ["SystemsTableHead"], "symbols": ["SystemsTableHead", "virtualRows", "map", "virtualRow", "const", "row", "rows", "index", "Row", "SystemRecord", "return", "SystemTableRow", "key", "length", "colLength", "TableRow", "TableCell", "colSpan", "className", "text", "center", "pointer", "events", "none", "Trans", "systems", "found", "TableBody", "table", "div", "function", "TableType", "number", "i18n", "useLingui"], "doc_head": "\t\t\t\t\t\t\tvirtualRows.map((virtualRow) => {\n\t\t\t\t\t\t\t\tconst row = rows[virtualRow.index] as Row<SystemRecord>\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<SystemTableRow\n\t\t\t\t\t\t\t\t\t\tkey={row.id}\n\t\t\t\t\t\t\t\t\t\trow={row}\n\t\t\t\t\t\t\t\t\t\tvirtualRow={virtualRow}\n\t\t\t\t\t\t\t\t\t\tlength={rows.length}\n\t\t\t\t\t\t\t\t\t\tcolLength={colLength}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<TableRow>\n\t\t\t\t\t\t\t\t<TableCell colSpan={colLength} className=\"h-37 text-center pointer-events-none\">\n\t\t\t\t\t\t\t\t\t<Trans>No systems found.</Trans>\n\t\t\t\t\t\t\t\t</TableCell>\n\t\t\t\t\t\t\t</TableRow>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</TableBody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t</div>\n\t)\n})\nfunction SystemsTableHead({ table, colLength }: { table: TableType<SystemRecord>; colLength: number }) {\n\tconst { i18n } = useLingui()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#21", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 21, "start_line": 379, "end_line": 409, "text": "\treturn useMemo(() => {\n\t\treturn (\n\t\t\t<TableHeader className=\"sticky top-0 z-20 w-full border-b-2\">\n\t\t\t\t{table.getHeaderGroups().map((headerGroup) => (\n\t\t\t\t\t<tr key={headerGroup.id}>\n\t\t\t\t\t\t{headerGroup.headers.map((header) => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<TableHead className=\"px-1.5\" key={header.id}>\n\t\t\t\t\t\t\t\t\t{flexRender(header.column.columnDef.header, header.getContext())}\n\t\t\t\t\t\t\t\t</TableHead>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t</tr>\n\t\t\t\t))}\n\t\t\t</TableHeader>\n\t\t)\n\t}, [i18n.locale, colLength])\n}\n\nconst SystemTableRow = memo(function ({\n\trow,\n\tvirtualRow,\n\tcolLength,\n}: {\n\trow: Row<SystemRecord>\n\tvirtualRow: VirtualItem\n\tlength: number\n\tcolLength: number\n}) {\n\tconst system = row.original\n\tconst { t } = useLingui()", "n_tokens": 197, "primary_symbol": "", "primary_kind": "", "primary_span": [379, 409], "def_symbols": [], "symbols": ["return", "useMemo", "TableHeader", "className", "sticky", "top", "full", "border", "table", "getHeaderGroups", "map", "headerGroup", "key", "headers", "header", "TableHead", "flexRender", "column", "columnDef", "getContext", "i18n", "locale", "colLength", "const", "SystemTableRow", "memo", "function", "row", "virtualRow", "Row", "SystemRecord", "VirtualItem", "length", "number", "system", "original", "useLingui"], "doc_head": "\treturn useMemo(() => {\n\t\treturn (\n\t\t\t<TableHeader className=\"sticky top-0 z-20 w-full border-b-2\">\n\t\t\t\t{table.getHeaderGroups().map((headerGroup) => (\n\t\t\t\t\t<tr key={headerGroup.id}>\n\t\t\t\t\t\t{headerGroup.headers.map((header) => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<TableHead className=\"px-1.5\" key={header.id}>\n\t\t\t\t\t\t\t\t\t{flexRender(header.column.columnDef.header, header.getContext())}\n\t\t\t\t\t\t\t\t</TableHead>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t</tr>\n\t\t\t\t))}\n\t\t\t</TableHeader>\n\t\t)\n\t}, [i18n.locale, colLength])\n}\nconst SystemTableRow = memo(function ({\n\trow,\n\tvirtualRow,\n\tcolLength,\n}: {\n\trow: Row<SystemRecord>\n\tvirtualRow: VirtualItem\n\tlength: number\n\tcolLength: number\n}) {\n\tconst system = row.original\n\tconst { t } = useLingui()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#22", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 22, "start_line": 410, "end_line": 435, "text": "\treturn useMemo(() => {\n\t\treturn (\n\t\t\t<TableRow\n\t\t\t\t// data-state={row.getIsSelected() && \"selected\"}\n\t\t\t\tclassName={cn(\"cursor-pointer transition-opacity relative safari:transform-3d\", {\n\t\t\t\t\t\"opacity-50\": system.status === SystemStatus.Paused,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t{row.getVisibleCells().map((cell) => (\n\t\t\t\t\t<TableCell\n\t\t\t\t\t\tkey={cell.id}\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\twidth: cell.column.getSize(),\n\t\t\t\t\t\t\theight: virtualRow.size,\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tclassName=\"py-0\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{flexRender(cell.column.columnDef.cell, cell.getContext())}\n\t\t\t\t\t</TableCell>\n\t\t\t\t))}\n\t\t\t</TableRow>\n\t\t)\n\t}, [system, system.status, colLength, t])\n})\n\nconst SystemCard = memo(", "n_tokens": 174, "primary_symbol": "", "primary_kind": "", "primary_span": [410, 435], "def_symbols": [], "symbols": ["return", "useMemo", "TableRow", "data", "state", "row", "getIsSelected", "selected", "className", "cursor", "pointer", "transition", "opacity", "relative", "safari", "transform", "system", "status", "SystemStatus", "Paused", "getVisibleCells", "map", "cell", "TableCell", "key", "style", "width", "column", "getSize", "height", "virtualRow", "size", "flexRender", "columnDef", "getContext", "colLength", "const", "SystemCard", "memo"], "doc_head": "\treturn useMemo(() => {\n\t\treturn (\n\t\t\t<TableRow\n\t\t\t\t// data-state={row.getIsSelected() && \"selected\"}\n\t\t\t\tclassName={cn(\"cursor-pointer transition-opacity relative safari:transform-3d\", {\n\t\t\t\t\t\"opacity-50\": system.status === SystemStatus.Paused,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t{row.getVisibleCells().map((cell) => (\n\t\t\t\t\t<TableCell\n\t\t\t\t\t\tkey={cell.id}\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\twidth: cell.column.getSize(),\n\t\t\t\t\t\t\theight: virtualRow.size,\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tclassName=\"py-0\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{flexRender(cell.column.columnDef.cell, cell.getContext())}\n\t\t\t\t\t</TableCell>\n\t\t\t\t))}\n\t\t\t</TableRow>\n\t\t)\n\t}, [system, system.status, colLength, t])\n})\nconst SystemCard = memo("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#23", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 23, "start_line": 436, "end_line": 439, "text": "\t({ row, table, colLength }: { row: Row<SystemRecord>; table: TableType<SystemRecord>; colLength: number }) => {\n\t\tconst system = row.original\n\t\tconst { t } = useLingui()\n", "n_tokens": 48, "primary_symbol": "", "primary_kind": "", "primary_span": [436, 439], "def_symbols": [], "symbols": ["row", "table", "colLength", "Row", "SystemRecord", "TableType", "number", "const", "system", "original", "useLingui"], "doc_head": "\t({ row, table, colLength }: { row: Row<SystemRecord>; table: TableType<SystemRecord>; colLength: number }) => {\n\t\tconst system = row.original\n\t\tconst { t } = useLingui()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#24", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 24, "start_line": 440, "end_line": 469, "text": "\t\treturn useMemo(() => {\n\t\t\treturn (\n\t\t\t\t<Card\n\t\t\t\t\tonMouseEnter={preloadSystemDetail}\n\t\t\t\t\tkey={system.id}\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"cursor-pointer hover:shadow-md transition-all bg-transparent w-full dark:border-border duration-200 relative\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"opacity-50\": system.status === SystemStatus.Paused,\n\t\t\t\t\t\t}\n\t\t\t\t\t)}\n\t\t\t\t>\n\t\t\t\t\t<CardHeader className=\"py-1 ps-5 pe-3 bg-muted/30 border-b border-border/60\">\n\t\t\t\t\t\t<div className=\"flex items-center gap-2 w-full overflow-hidden\">\n\t\t\t\t\t\t\t<CardTitle className=\"text-base tracking-normal text-primary/90 flex items-center min-w-0 flex-1 gap-2.5\">\n\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-2.5 min-w-0 flex-1\">\n\t\t\t\t\t\t\t\t\t<IndicatorDot system={system} />\n\t\t\t\t\t\t\t\t\t<span className=\"text-[.95em]/normal tracking-normal text-primary/90 truncate\">{system.name}</span>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</CardTitle>\n\t\t\t\t\t\t\t{table.getColumn(\"actions\")?.getIsVisible() && (\n\t\t\t\t\t\t\t\t<div className=\"flex gap-1 shrink-0 relative z-10\">\n\t\t\t\t\t\t\t\t\t<AlertButton system={system} />\n\t\t\t\t\t\t\t\t\t<ActionsButton system={system} />\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</CardHeader>\n\t\t\t\t\t<CardContent className=\"text-sm px-5 pt-3.5 pb-4\">\n\t\t\t\t\t\t<div className=\"grid gap-2.5\" style={{ gridTemplateColumns: \"24px minmax(80px, max-content) 1fr\" }}>", "n_tokens": 349, "primary_symbol": "", "primary_kind": "", "primary_span": [440, 469], "def_symbols": [], "symbols": ["return", "useMemo", "Card", "onMouseEnter", "preloadSystemDetail", "key", "system", "className", "cursor", "pointer", "hover", "shadow", "transition", "all", "transparent", "full", "dark", "border", "duration", "relative", "opacity", "status", "SystemStatus", "Paused", "CardHeader", "muted", "div", "flex", "items", "center", "gap", "overflow", "hidden", "CardTitle", "text", "base", "tracking", "normal", "primary", "min", "IndicatorDot", "span", "truncate", "name", "table", "getColumn", "actions", "getIsVisible", "shrink", "AlertButton", "ActionsButton", "CardContent", "grid", "style", "gridTemplateColumns", "minmax", "max", "content"], "doc_head": "\t\treturn useMemo(() => {\n\t\t\treturn (\n\t\t\t\t<Card\n\t\t\t\t\tonMouseEnter={preloadSystemDetail}\n\t\t\t\t\tkey={system.id}\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"cursor-pointer hover:shadow-md transition-all bg-transparent w-full dark:border-border duration-200 relative\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"opacity-50\": system.status === SystemStatus.Paused,\n\t\t\t\t\t\t}\n\t\t\t\t\t)}\n\t\t\t\t>\n\t\t\t\t\t<CardHeader className=\"py-1 ps-5 pe-3 bg-muted/30 border-b border-border/60\">\n\t\t\t\t\t\t<div className=\"flex items-center gap-2 w-full overflow-hidden\">\n\t\t\t\t\t\t\t<CardTitle className=\"text-base tracking-normal text-primary/90 flex items-center min-w-0 flex-1 gap-2.5\">\n\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-2.5 min-w-0 flex-1\">\n\t\t\t\t\t\t\t\t\t<IndicatorDot system={system} />\n\t\t\t\t\t\t\t\t\t<span className=\"text-[.95em]/normal tracking-normal text-primary/90 truncate\">{system.name}</span>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</CardTitle>\n\t\t\t\t\t\t\t{table.getColumn(\"actions\")?.getIsVisible() && (\n\t\t\t\t\t\t\t\t<div className=\"flex gap-1 shrink-0 relative z-10\">\n\t\t\t\t\t\t\t\t\t<AlertButton system={system} />\n\t\t\t\t\t\t\t\t\t<ActionsButton system={system} />\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</CardHeader>\n\t\t\t\t\t<CardContent className=\"text-sm px-5 pt-3.5 pb-4\">\n\t\t\t\t\t\t<div className=\"grid gap"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#25", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 25, "start_line": 470, "end_line": 471, "text": "\t\t\t\t\t\t\t{table.getAllColumns().map((column) => {\n\t\t\t\t\t\t\t\tif (!column.getIsVisible() || column.id === \"system\" || column.id === \"actions\") return null", "n_tokens": 37, "primary_symbol": "", "primary_kind": "", "primary_span": [470, 471], "def_symbols": [], "symbols": ["table", "getAllColumns", "map", "column", "getIsVisible", "system", "actions", "return", "null"], "doc_head": "\t\t\t\t\t\t\t{table.getAllColumns().map((column) => {\n\t\t\t\t\t\t\t\tif (!column.getIsVisible() || column.id === \"system\" || column.id === \"actions\") return null"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx#26", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/systems-table/systems-table.tsx", "rel_path": "src/site/src/components/systems-table/systems-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 26, "start_line": 472, "end_line": 507, "text": "\t\t\t\t\t\t\t\tconst cell = row.getAllCells().find((cell) => cell.column.id === column.id)\n\t\t\t\t\t\t\t\tif (!cell) return null\n\t\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\t\tconst { Icon, name } = column.columnDef as ColumnDef<SystemRecord, unknown>\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t<div key={`${column.id}-icon`} className=\"flex items-center\">\n\t\t\t\t\t\t\t\t\t\t\t{column.id === \"lastSeen\" ? (\n\t\t\t\t\t\t\t\t\t\t\t\t<EyeIcon className=\"size-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t\tIcon && <Icon className=\"size-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div key={`${column.id}-label`} className=\"flex items-center text-muted-foreground pr-3\">\n\t\t\t\t\t\t\t\t\t\t\t{name()}:\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div key={`${column.id}-value`} className=\"flex items-center\">\n\t\t\t\t\t\t\t\t\t\t\t{flexRender(cell.column.columnDef.cell, cell.getContext())}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</CardContent>\n\t\t\t\t\t<Link\n\t\t\t\t\t\thref={getPagePath($router, \"system\", { name: row.original.name })}\n\t\t\t\t\t\tclassName=\"inset-0 absolute w-full h-full\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span className=\"sr-only\">{row.original.name}</span>\n\t\t\t\t\t</Link>\n\t\t\t\t</Card>\n\t\t\t)\n\t\t}, [system, colLength, t])\n\t}\n)\n", "n_tokens": 303, "primary_symbol": "", "primary_kind": "", "primary_span": [472, 507], "def_symbols": [], "symbols": ["const", "cell", "row", "getAllCells", "find", "column", "return", "null", "ignore", "Icon", "name", "columnDef", "ColumnDef", "SystemRecord", "unknown", "div", "key", "icon", "className", "flex", "items", "center", "lastSeen", "EyeIcon", "size", "text", "muted", "foreground", "label", "value", "flexRender", "getContext", "CardContent", "Link", "href", "getPagePath", "router", "system", "original", "inset", "absolute", "full", "span", "only", "Card", "colLength"], "doc_head": "\t\t\t\t\t\t\t\tconst cell = row.getAllCells().find((cell) => cell.column.id === column.id)\n\t\t\t\t\t\t\t\tif (!cell) return null\n\t\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\t\tconst { Icon, name } = column.columnDef as ColumnDef<SystemRecord, unknown>\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t<div key={`${column.id}-icon`} className=\"flex items-center\">\n\t\t\t\t\t\t\t\t\t\t\t{column.id === \"lastSeen\" ? (\n\t\t\t\t\t\t\t\t\t\t\t\t<EyeIcon className=\"size-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t\tIcon && <Icon className=\"size-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div key={`${column.id}-label`} className=\"flex items-center text-muted-foreground pr-3\">\n\t\t\t\t\t\t\t\t\t\t\t{name()}:\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div key={`${column.id}-value`} className=\"flex items-center\">\n\t\t\t\t\t\t\t\t\t\t\t{flexRender(cell.column.columnDef.cell, cell.getContext())}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</CardContent>\n\t\t\t\t\t<Link\n\t\t\t\t\t\thref={getPagePath($router, \"system\", { name: row.original.name })}\n\t\t\t\t\t\tclassName=\"inset-0 absolute w-full h-full\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span className=\"sr-only\">{row.original.name}</span>\n\t\t\t\t\t</Link>\n\t\t\t\t</Card>\n\t\t\t)\n\t\t}, [system, colLength, t])\n\t}\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx", "rel_path": "src/site/src/components/charts/temperature-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "import { CartesianGrid, Line, LineChart, YAxis } from \"recharts\"\n\nimport {\n\tChartContainer,\n\tChartLegend,\n\tChartLegendContent,\n\tChartTooltip,\n\tChartTooltipContent,\n\txAxis,\n} from \"@/components/ui/chart\"\nimport { cn, formatShortDate, toFixedFloat, chartMargin, formatTemperature, decimalString } from \"@/lib/utils\"\nimport { ChartData } from \"@/types\"\nimport { memo, useMemo } from \"react\"\nimport { $temperatureFilter, $userSettings } from \"@/lib/stores\"\nimport { useStore } from \"@nanostores/react\"\nimport { useYAxisWidth } from \"./hooks\"\n\nexport default memo(function TemperatureChart({ chartData }: { chartData: ChartData }) {\n\tconst filter = useStore($temperatureFilter)\n\tconst userSettings = useStore($userSettings)\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n", "n_tokens": 189, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 22], "def_symbols": [], "symbols": ["import", "CartesianGrid", "Line", "LineChart", "YAxis", "from", "recharts", "ChartContainer", "ChartLegend", "ChartLegendContent", "ChartTooltip", "ChartTooltipContent", "xAxis", "components", "chart", "formatShortDate", "toFixedFloat", "chartMargin", "formatTemperature", "decimalString", "lib", "utils", "ChartData", "types", "memo", "useMemo", "react", "temperatureFilter", "userSettings", "stores", "useStore", "nanostores", "useYAxisWidth", "hooks", "export", "default", "function", "TemperatureChart", "chartData", "const", "filter", "yAxisWidth", "updateYAxisWidth"], "doc_head": "import { CartesianGrid, Line, LineChart, YAxis } from \"recharts\"\nimport {\n\tChartContainer,\n\tChartLegend,\n\tChartLegendContent,\n\tChartTooltip,\n\tChartTooltipContent,\n\txAxis,\n} from \"@/components/ui/chart\"\nimport { cn, formatShortDate, toFixedFloat, chartMargin, formatTemperature, decimalString } from \"@/lib/utils\"\nimport { ChartData } from \"@/types\"\nimport { memo, useMemo } from \"react\"\nimport { $temperatureFilter, $userSettings } from \"@/lib/stores\"\nimport { useStore } from \"@nanostores/react\"\nimport { useYAxisWidth } from \"./hooks\"\nexport default memo(function TemperatureChart({ chartData }: { chartData: ChartData }) {\n\tconst filter = useStore($temperatureFilter)\n\tconst userSettings = useStore($userSettings)\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx", "rel_path": "src/site/src/components/charts/temperature-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 23, "end_line": 43, "text": "\tif (chartData.systemStats.length === 0) {\n\t\treturn null\n\t}\n\n\t/** Format temperature data for chart and assign colors */\n\tconst newChartData = useMemo(() => {\n\t\tconst newChartData = { data: [], colors: {} } as {\n\t\t\tdata: Record<string, number | string>[]\n\t\t\tcolors: Record<string, string>\n\t\t}\n\t\tconst tempSums = {} as Record<string, number>\n\t\tfor (let data of chartData.systemStats) {\n\t\t\tlet newData = { created: data.created } as Record<string, number | string>\n\t\t\tlet keys = Object.keys(data.stats?.t ?? {})\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tlet key = keys[i]\n\t\t\t\tnewData[key] = data.stats.t![key]\n\t\t\t\ttempSums[key] = (tempSums[key] ?? 0) + newData[key]\n\t\t\t}\n\t\t\tnewChartData.data.push(newData)\n\t\t}", "n_tokens": 201, "primary_symbol": "", "primary_kind": "", "primary_span": [23, 43], "def_symbols": [], "symbols": ["chartData", "systemStats", "length", "return", "null", "Format", "temperature", "data", "for", "chart", "and", "assign", "colors", "const", "newChartData", "useMemo", "Record", "string", "number", "tempSums", "let", "newData", "created", "keys", "Object", "stats", "key", "push"], "doc_head": "\tif (chartData.systemStats.length === 0) {\n\t\treturn null\n\t}\n\t/** Format temperature data for chart and assign colors */\n\tconst newChartData = useMemo(() => {\n\t\tconst newChartData = { data: [], colors: {} } as {\n\t\t\tdata: Record<string, number | string>[]\n\t\t\tcolors: Record<string, string>\n\t\t}\n\t\tconst tempSums = {} as Record<string, number>\n\t\tfor (let data of chartData.systemStats) {\n\t\t\tlet newData = { created: data.created } as Record<string, number | string>\n\t\t\tlet keys = Object.keys(data.stats?.t ?? {})\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tlet key = keys[i]\n\t\t\t\tnewData[key] = data.stats.t![key]\n\t\t\t\ttempSums[key] = (tempSums[key] ?? 0) + newData[key]\n\t\t\t}\n\t\t\tnewChartData.data.push(newData)\n\t\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx", "rel_path": "src/site/src/components/charts/temperature-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 44, "end_line": 44, "text": "\t\tconst keys = Object.keys(tempSums).sort((a, b) => tempSums[b] - tempSums[a])", "n_tokens": 28, "primary_symbol": "", "primary_kind": "", "primary_span": [44, 44], "def_symbols": [], "symbols": ["const", "keys", "Object", "tempSums", "sort"], "doc_head": "\t\tconst keys = Object.keys(tempSums).sort((a, b) => tempSums[b] - tempSums[a])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx", "rel_path": "src/site/src/components/charts/temperature-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 45, "end_line": 69, "text": "\t\tfor (let key of keys) {\n\t\t\tnewChartData.colors[key] = `hsl(${((keys.indexOf(key) * 360) / keys.length) % 360}, 60%, 55%)`\n\t\t}\n\t\treturn newChartData\n\t}, [chartData])\n\n\tconst colors = Object.keys(newChartData.colors)\n\n\t// console.log('rendered at', new Date())\n\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<LineChart accessibilityLayer data={newChartData.data} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\tdomain={[0, \"auto\"]}\n\t\t\t\t\t\twidth={yAxisWidth}", "n_tokens": 199, "primary_symbol": "", "primary_kind": "", "primary_span": [45, 69], "def_symbols": [], "symbols": ["for", "let", "key", "keys", "newChartData", "colors", "hsl", "indexOf", "length", "return", "chartData", "const", "Object", "console", "log", "rendered", "new", "Date", "div", "ChartContainer", "className", "full", "absolute", "aspect", "auto", "card", "opacity", "transition", "yAxisWidth", "LineChart", "accessibilityLayer", "data", "margin", "chartMargin", "CartesianGrid", "vertical", "false", "YAxis", "direction", "ltr", "orientation", "tracking", "tighter", "domain", "width"], "doc_head": "\t\tfor (let key of keys) {\n\t\t\tnewChartData.colors[key] = `hsl(${((keys.indexOf(key) * 360) / keys.length) % 360}, 60%, 55%)`\n\t\t}\n\t\treturn newChartData\n\t}, [chartData])\n\tconst colors = Object.keys(newChartData.colors)\n\t// console.log('rendered at', new Date())\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<LineChart accessibilityLayer data={newChartData.data} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\tdomain={[0, \"auto\"]}\n\t\t\t\t\t\twidth={yAxisWidth}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx", "rel_path": "src/site/src/components/charts/temperature-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 70, "end_line": 93, "text": "\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\tconst { value, unit } = formatTemperature(val, userSettings.unitTemp)\n\t\t\t\t\t\t\treturn updateYAxisWidth(toFixedFloat(value, 2) + \" \" + unit)\n\t\t\t\t\t\t}}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\titemSorter={(a, b) => b.value - a.value}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}\n\t\t\t\t\t\t\t\tcontentFormatter={(item) => {\n\t\t\t\t\t\t\t\t\tconst { value, unit } = formatTemperature(item.value, userSettings.unitTemp)\n\t\t\t\t\t\t\t\t\treturn decimalString(value) + \" \" + unit\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tfilter={filter}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>", "n_tokens": 199, "primary_symbol": "", "primary_kind": "", "primary_span": [70, 93], "def_symbols": [], "symbols": ["tickFormatter", "val", "const", "value", "unit", "formatTemperature", "userSettings", "unitTemp", "return", "updateYAxisWidth", "toFixedFloat", "tickLine", "false", "axisLine", "xAxis", "chartData", "ChartTooltip", "animationEasing", "ease", "out", "animationDuration", "ignore", "itemSorter", "content", "ChartTooltipContent", "labelFormatter", "data", "formatShortDate", "payload", "created", "contentFormatter", "item", "decimalString", "filter"], "doc_head": "\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\tconst { value, unit } = formatTemperature(val, userSettings.unitTemp)\n\t\t\t\t\t\t\treturn updateYAxisWidth(toFixedFloat(value, 2) + \" \" + unit)\n\t\t\t\t\t\t}}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\titemSorter={(a, b) => b.value - a.value}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}\n\t\t\t\t\t\t\t\tcontentFormatter={(item) => {\n\t\t\t\t\t\t\t\t\tconst { value, unit } = formatTemperature(item.value, userSettings.unitTemp)\n\t\t\t\t\t\t\t\t\treturn decimalString(value) + \" \" + unit\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tfilter={filter}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/temperature-chart.tsx", "rel_path": "src/site/src/components/charts/temperature-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 94, "end_line": 118, "text": "\t\t\t\t\t{colors.map((key) => {\n\t\t\t\t\t\tconst filtered = filter && !key.toLowerCase().includes(filter.toLowerCase())\n\t\t\t\t\t\tlet strokeOpacity = filtered ? 0.1 : 1\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<Line\n\t\t\t\t\t\t\t\tkey={key}\n\t\t\t\t\t\t\t\tdataKey={key}\n\t\t\t\t\t\t\t\tname={key}\n\t\t\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\t\t\tdot={false}\n\t\t\t\t\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t\t\t\t\tstroke={newChartData.colors[key]}\n\t\t\t\t\t\t\t\tstrokeOpacity={strokeOpacity}\n\t\t\t\t\t\t\t\tactiveDot={{ opacity: filtered ? 0 : 1 }}\n\t\t\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t})}\n\t\t\t\t\t{colors.length < 12 && <ChartLegend content={<ChartLegendContent />} />}\n\t\t\t\t</LineChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})\n", "n_tokens": 172, "primary_symbol": "", "primary_kind": "", "primary_span": [94, 118], "def_symbols": [], "symbols": ["colors", "map", "key", "const", "filtered", "filter", "toLowerCase", "includes", "let", "strokeOpacity", "return", "Line", "dataKey", "name", "type", "monotoneX", "dot", "false", "strokeWidth", "stroke", "newChartData", "activeDot", "opacity", "isAnimationActive", "length", "ChartLegend", "content", "ChartLegendContent", "LineChart", "ChartContainer", "div"], "doc_head": "\t\t\t\t\t{colors.map((key) => {\n\t\t\t\t\t\tconst filtered = filter && !key.toLowerCase().includes(filter.toLowerCase())\n\t\t\t\t\t\tlet strokeOpacity = filtered ? 0.1 : 1\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<Line\n\t\t\t\t\t\t\t\tkey={key}\n\t\t\t\t\t\t\t\tdataKey={key}\n\t\t\t\t\t\t\t\tname={key}\n\t\t\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\t\t\tdot={false}\n\t\t\t\t\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t\t\t\t\tstroke={newChartData.colors[key]}\n\t\t\t\t\t\t\t\tstrokeOpacity={strokeOpacity}\n\t\t\t\t\t\t\t\tactiveDot={{ opacity: filtered ? 0 : 1 }}\n\t\t\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t})}\n\t\t\t\t\t{colors.length < 12 && <ChartLegend content={<ChartLegendContent />} />}\n\t\t\t\t</LineChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/area-chart.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/area-chart.tsx", "rel_path": "src/site/src/components/charts/area-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 14, "text": "import { Area, AreaChart, CartesianGrid, YAxis } from \"recharts\"\nimport { ChartContainer, ChartTooltip, ChartTooltipContent, xAxis } from \"@/components/ui/chart\"\nimport { cn, formatShortDate, chartMargin } from \"@/lib/utils\"\nimport { useYAxisWidth } from \"./hooks\"\nimport { ChartData, SystemStatsRecord } from \"@/types\"\nimport { useMemo } from \"react\"\n\nexport type DataPoint = {\n\tlabel: string\n\tdataKey: (data: SystemStatsRecord) => number | undefined\n\tcolor: number | string\n\topacity: number\n}\n", "n_tokens": 123, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 14], "def_symbols": [], "symbols": ["import", "Area", "AreaChart", "CartesianGrid", "YAxis", "from", "recharts", "ChartContainer", "ChartTooltip", "ChartTooltipContent", "xAxis", "components", "chart", "formatShortDate", "chartMargin", "lib", "utils", "useYAxisWidth", "hooks", "ChartData", "SystemStatsRecord", "types", "useMemo", "react", "export", "type", "DataPoint", "label", "string", "dataKey", "data", "number", "undefined", "color", "opacity"], "doc_head": "import { Area, AreaChart, CartesianGrid, YAxis } from \"recharts\"\nimport { ChartContainer, ChartTooltip, ChartTooltipContent, xAxis } from \"@/components/ui/chart\"\nimport { cn, formatShortDate, chartMargin } from \"@/lib/utils\"\nimport { useYAxisWidth } from \"./hooks\"\nimport { ChartData, SystemStatsRecord } from \"@/types\"\nimport { useMemo } from \"react\"\nexport type DataPoint = {\n\tlabel: string\n\tdataKey: (data: SystemStatsRecord) => number | undefined\n\tcolor: number | string\n\topacity: number\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/area-chart.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/area-chart.tsx", "rel_path": "src/site/src/components/charts/area-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 15, "end_line": 36, "text": "export default function AreaChartDefault({\n\tchartData,\n\tmax,\n\tmaxToggled,\n\ttickFormatter,\n\tcontentFormatter,\n\tdataPoints,\n\tdomain,\n}: // logRender = false,\n{\n\tchartData: ChartData\n\tmax?: number\n\tmaxToggled?: boolean\n\ttickFormatter: (value: number, index: number) => string\n\tcontentFormatter: ({ value, payload }: { value: number; payload: SystemStatsRecord }) => string\n\tdataPoints?: DataPoint[]\n\tdomain?: [number, number]\n\t// logRender?: boolean\n}) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\n\treturn useMemo(() => {", "n_tokens": 137, "primary_symbol": "", "primary_kind": "", "primary_span": [15, 36], "def_symbols": [], "symbols": ["export", "default", "function", "AreaChartDefault", "chartData", "max", "maxToggled", "tickFormatter", "contentFormatter", "dataPoints", "domain", "logRender", "false", "ChartData", "number", "boolean", "value", "index", "string", "payload", "SystemStatsRecord", "DataPoint", "const", "yAxisWidth", "updateYAxisWidth", "useYAxisWidth", "return", "useMemo"], "doc_head": "export default function AreaChartDefault({\n\tchartData,\n\tmax,\n\tmaxToggled,\n\ttickFormatter,\n\tcontentFormatter,\n\tdataPoints,\n\tdomain,\n}: // logRender = false,\n{\n\tchartData: ChartData\n\tmax?: number\n\tmaxToggled?: boolean\n\ttickFormatter: (value: number, index: number) => string\n\tcontentFormatter: ({ value, payload }: { value: number; payload: SystemStatsRecord }) => string\n\tdataPoints?: DataPoint[]\n\tdomain?: [number, number]\n\t// logRender?: boolean\n}) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\treturn useMemo(() => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/area-chart.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/area-chart.tsx", "rel_path": "src/site/src/components/charts/area-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 37, "end_line": 57, "text": "\t\tif (chartData.systemStats.length === 0) {\n\t\t\treturn null\n\t\t}\n\t\t// if (logRender) {\n\t\t// \tconsole.log(\"Rendered at\", new Date())\n\t\t// }\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<ChartContainer\n\t\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t\t})}\n\t\t\t\t>\n\t\t\t\t\t<AreaChart accessibilityLayer data={chartData.systemStats} margin={chartMargin}>\n\t\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t\t<YAxis\n\t\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\t\twidth={yAxisWidth}\n\t\t\t\t\t\t\tdomain={domain ?? [0, max ?? \"auto\"]}", "n_tokens": 174, "primary_symbol": "", "primary_kind": "", "primary_span": [37, 57], "def_symbols": [], "symbols": ["chartData", "systemStats", "length", "return", "null", "logRender", "console", "log", "Rendered", "new", "Date", "div", "ChartContainer", "className", "full", "absolute", "aspect", "auto", "card", "opacity", "transition", "yAxisWidth", "AreaChart", "accessibilityLayer", "data", "margin", "chartMargin", "CartesianGrid", "vertical", "false", "YAxis", "direction", "ltr", "orientation", "tracking", "tighter", "width", "domain", "max"], "doc_head": "\t\tif (chartData.systemStats.length === 0) {\n\t\t\treturn null\n\t\t}\n\t\t// if (logRender) {\n\t\t// \tconsole.log(\"Rendered at\", new Date())\n\t\t// }\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<ChartContainer\n\t\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t\t})}\n\t\t\t\t>\n\t\t\t\t\t<AreaChart accessibilityLayer data={chartData.systemStats} margin={chartMargin}>\n\t\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t\t<YAxis\n\t\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\t\twidth={yAxisWidth}\n\t\t\t\t\t\t\tdomain={domain ?? [0, max ?? \"auto\"]}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/area-chart.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/area-chart.tsx", "rel_path": "src/site/src/components/charts/area-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 58, "end_line": 72, "text": "\t\t\t\t\t\t\ttickFormatter={(value, index) => updateYAxisWidth(tickFormatter(value, index))}\n\t\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\t\taxisLine={false}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}\n\t\t\t\t\t\t\t\t\tcontentFormatter={contentFormatter}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t/>", "n_tokens": 109, "primary_symbol": "", "primary_kind": "", "primary_span": [58, 72], "def_symbols": [], "symbols": ["tickFormatter", "value", "index", "updateYAxisWidth", "tickLine", "false", "axisLine", "xAxis", "chartData", "ChartTooltip", "animationEasing", "ease", "out", "animationDuration", "content", "ChartTooltipContent", "labelFormatter", "data", "formatShortDate", "payload", "created", "contentFormatter"], "doc_head": "\t\t\t\t\t\t\ttickFormatter={(value, index) => updateYAxisWidth(tickFormatter(value, index))}\n\t\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\t\taxisLine={false}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}\n\t\t\t\t\t\t\t\t\tcontentFormatter={contentFormatter}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t/>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/area-chart.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/area-chart.tsx", "rel_path": "src/site/src/components/charts/area-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 73, "end_line": 95, "text": "\t\t\t\t\t\t{dataPoints?.map((dataPoint, i) => {\n\t\t\t\t\t\t\tconst color = `var(--chart-${dataPoint.color})`\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Area\n\t\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\t\tdataKey={dataPoint.dataKey}\n\t\t\t\t\t\t\t\t\tname={dataPoint.label}\n\t\t\t\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\t\t\t\tfill={color}\n\t\t\t\t\t\t\t\t\tfillOpacity={dataPoint.opacity}\n\t\t\t\t\t\t\t\t\tstroke={color}\n\t\t\t\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t\t{/* <ChartLegend content={<ChartLegendContent />} /> */}\n\t\t\t\t\t</AreaChart>\n\t\t\t\t</ChartContainer>\n\t\t\t</div>\n\t\t)\n\t}, [chartData.systemStats.at(-1), yAxisWidth, maxToggled])\n}\n", "n_tokens": 154, "primary_symbol": "", "primary_kind": "", "primary_span": [73, 95], "def_symbols": [], "symbols": ["dataPoints", "map", "dataPoint", "const", "color", "var", "chart", "return", "Area", "key", "dataKey", "name", "label", "type", "monotoneX", "fill", "fillOpacity", "opacity", "stroke", "isAnimationActive", "false", "ChartLegend", "content", "ChartLegendContent", "AreaChart", "ChartContainer", "div", "chartData", "systemStats", "yAxisWidth", "maxToggled"], "doc_head": "\t\t\t\t\t\t{dataPoints?.map((dataPoint, i) => {\n\t\t\t\t\t\t\tconst color = `var(--chart-${dataPoint.color})`\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Area\n\t\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\t\tdataKey={dataPoint.dataKey}\n\t\t\t\t\t\t\t\t\tname={dataPoint.label}\n\t\t\t\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\t\t\t\tfill={color}\n\t\t\t\t\t\t\t\t\tfillOpacity={dataPoint.opacity}\n\t\t\t\t\t\t\t\t\tstroke={color}\n\t\t\t\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t\t{/* <ChartLegend content={<ChartLegendContent />} /> */}\n\t\t\t\t\t</AreaChart>\n\t\t\t\t</ChartContainer>\n\t\t\t</div>\n\t\t)\n\t}, [chartData.systemStats.at(-1), yAxisWidth, maxToggled])\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/disk-chart.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/disk-chart.tsx", "rel_path": "src/site/src/components/charts/disk-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 21, "text": "import { Area, AreaChart, CartesianGrid, YAxis } from \"recharts\"\nimport { ChartContainer, ChartTooltip, ChartTooltipContent, xAxis } from \"@/components/ui/chart\"\nimport { cn, formatShortDate, decimalString, chartMargin, formatBytes, toFixedFloat } from \"@/lib/utils\"\nimport { ChartData } from \"@/types\"\nimport { memo } from \"react\"\nimport { useLingui } from \"@lingui/react/macro\"\nimport { Unit } from \"@/lib/enums\"\nimport { useYAxisWidth } from \"./hooks\"\n\nexport default memo(function DiskChart({\n\tdataKey,\n\tdiskSize,\n\tchartData,\n}: {\n\tdataKey: string\n\tdiskSize: number\n\tchartData: ChartData\n}) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\tconst { t } = useLingui()\n", "n_tokens": 183, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 21], "def_symbols": [], "symbols": ["import", "Area", "AreaChart", "CartesianGrid", "YAxis", "from", "recharts", "ChartContainer", "ChartTooltip", "ChartTooltipContent", "xAxis", "components", "chart", "formatShortDate", "decimalString", "chartMargin", "formatBytes", "toFixedFloat", "lib", "utils", "ChartData", "types", "memo", "react", "useLingui", "lingui", "macro", "Unit", "enums", "useYAxisWidth", "hooks", "export", "default", "function", "DiskChart", "dataKey", "diskSize", "chartData", "string", "number", "const", "yAxisWidth", "updateYAxisWidth"], "doc_head": "import { Area, AreaChart, CartesianGrid, YAxis } from \"recharts\"\nimport { ChartContainer, ChartTooltip, ChartTooltipContent, xAxis } from \"@/components/ui/chart\"\nimport { cn, formatShortDate, decimalString, chartMargin, formatBytes, toFixedFloat } from \"@/lib/utils\"\nimport { ChartData } from \"@/types\"\nimport { memo } from \"react\"\nimport { useLingui } from \"@lingui/react/macro\"\nimport { Unit } from \"@/lib/enums\"\nimport { useYAxisWidth } from \"./hooks\"\nexport default memo(function DiskChart({\n\tdataKey,\n\tdiskSize,\n\tchartData,\n}: {\n\tdataKey: string\n\tdiskSize: number\n\tchartData: ChartData\n}) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\tconst { t } = useLingui()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/disk-chart.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/disk-chart.tsx", "rel_path": "src/site/src/components/charts/disk-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 22, "end_line": 49, "text": "\t// round to nearest GB\n\tif (diskSize >= 100) {\n\t\tdiskSize = Math.round(diskSize)\n\t}\n\n\tif (chartData.systemStats.length === 0) {\n\t\treturn null\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<AreaChart accessibilityLayer data={chartData.systemStats} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\twidth={yAxisWidth}\n\t\t\t\t\t\tdomain={[0, diskSize]}\n\t\t\t\t\t\ttickCount={9}\n\t\t\t\t\t\tminTickGap={6}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}", "n_tokens": 196, "primary_symbol": "", "primary_kind": "", "primary_span": [22, 49], "def_symbols": [], "symbols": ["round", "nearest", "diskSize", "Math", "chartData", "systemStats", "length", "return", "null", "div", "ChartContainer", "className", "full", "absolute", "aspect", "auto", "card", "opacity", "transition", "yAxisWidth", "AreaChart", "accessibilityLayer", "data", "margin", "chartMargin", "CartesianGrid", "vertical", "false", "YAxis", "direction", "ltr", "orientation", "tracking", "tighter", "width", "domain", "tickCount", "minTickGap", "tickLine", "axisLine"], "doc_head": "\t// round to nearest GB\n\tif (diskSize >= 100) {\n\t\tdiskSize = Math.round(diskSize)\n\t}\n\tif (chartData.systemStats.length === 0) {\n\t\treturn null\n\t}\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<AreaChart accessibilityLayer data={chartData.systemStats} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\twidth={yAxisWidth}\n\t\t\t\t\t\tdomain={[0, diskSize]}\n\t\t\t\t\t\ttickCount={9}\n\t\t\t\t\t\tminTickGap={6}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/disk-chart.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/disk-chart.tsx", "rel_path": "src/site/src/components/charts/disk-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 50, "end_line": 61, "text": "\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\tconst { value, unit } = formatBytes(val * 1024, false, Unit.Bytes, true)\n\t\t\t\t\t\t\treturn updateYAxisWidth(toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit)\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}", "n_tokens": 121, "primary_symbol": "", "primary_kind": "", "primary_span": [50, 61], "def_symbols": [], "symbols": ["tickFormatter", "val", "const", "value", "unit", "formatBytes", "false", "Unit", "Bytes", "true", "return", "updateYAxisWidth", "toFixedFloat", "xAxis", "chartData", "ChartTooltip", "animationEasing", "ease", "out", "animationDuration", "content", "ChartTooltipContent", "labelFormatter", "data", "formatShortDate", "payload", "created"], "doc_head": "\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\tconst { value, unit } = formatBytes(val * 1024, false, Unit.Bytes, true)\n\t\t\t\t\t\t\treturn updateYAxisWidth(toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit)\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/disk-chart.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/disk-chart.tsx", "rel_path": "src/site/src/components/charts/disk-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 62, "end_line": 84, "text": "\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value * 1024, false, Unit.Bytes, true)\n\t\t\t\t\t\t\t\t\treturn decimalString(convertedValue) + \" \" + unit\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t\t<Area\n\t\t\t\t\t\tdataKey={dataKey}\n\t\t\t\t\t\tname={t`Disk Usage`}\n\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\tfill=\"var(--chart-4)\"\n\t\t\t\t\t\tfillOpacity={0.4}\n\t\t\t\t\t\tstroke=\"var(--chart-4)\"\n\t\t\t\t\t\t// animationDuration={1200}\n\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t/>\n\t\t\t\t</AreaChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})\n", "n_tokens": 154, "primary_symbol": "", "primary_kind": "", "primary_span": [62, 84], "def_symbols": [], "symbols": ["contentFormatter", "value", "const", "convertedValue", "unit", "formatBytes", "false", "Unit", "Bytes", "true", "return", "decimalString", "Area", "dataKey", "name", "Disk", "Usage", "type", "monotoneX", "fill", "var", "chart", "fillOpacity", "stroke", "animationDuration", "isAnimationActive", "AreaChart", "ChartContainer", "div"], "doc_head": "\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value * 1024, false, Unit.Bytes, true)\n\t\t\t\t\t\t\t\t\treturn decimalString(convertedValue) + \" \" + unit\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t\t<Area\n\t\t\t\t\t\tdataKey={dataKey}\n\t\t\t\t\t\tname={t`Disk Usage`}\n\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\tfill=\"var(--chart-4)\"\n\t\t\t\t\t\tfillOpacity={0.4}\n\t\t\t\t\t\tstroke=\"var(--chart-4)\"\n\t\t\t\t\t\t// animationDuration={1200}\n\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t/>\n\t\t\t\t</AreaChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/swap-chart.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/swap-chart.tsx", "rel_path": "src/site/src/components/charts/swap-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 15, "text": "import { t } from \"@lingui/core/macro\"\n\nimport { Area, AreaChart, CartesianGrid, YAxis } from \"recharts\"\nimport { ChartContainer, ChartTooltip, ChartTooltipContent, xAxis } from \"@/components/ui/chart\"\nimport { cn, formatShortDate, decimalString, chartMargin, formatBytes, toFixedFloat } from \"@/lib/utils\"\nimport { ChartData } from \"@/types\"\nimport { memo } from \"react\"\nimport { $userSettings } from \"@/lib/stores\"\nimport { useStore } from \"@nanostores/react\"\nimport { useYAxisWidth } from \"./hooks\"\n\nexport default memo(function SwapChart({ chartData }: { chartData: ChartData }) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\tconst userSettings = useStore($userSettings)\n", "n_tokens": 172, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 15], "def_symbols": [], "symbols": ["import", "from", "lingui", "core", "macro", "Area", "AreaChart", "CartesianGrid", "YAxis", "recharts", "ChartContainer", "ChartTooltip", "ChartTooltipContent", "xAxis", "components", "chart", "formatShortDate", "decimalString", "chartMargin", "formatBytes", "toFixedFloat", "lib", "utils", "ChartData", "types", "memo", "react", "userSettings", "stores", "useStore", "nanostores", "useYAxisWidth", "hooks", "export", "default", "function", "SwapChart", "chartData", "const", "yAxisWidth", "updateYAxisWidth"], "doc_head": "import { t } from \"@lingui/core/macro\"\nimport { Area, AreaChart, CartesianGrid, YAxis } from \"recharts\"\nimport { ChartContainer, ChartTooltip, ChartTooltipContent, xAxis } from \"@/components/ui/chart\"\nimport { cn, formatShortDate, decimalString, chartMargin, formatBytes, toFixedFloat } from \"@/lib/utils\"\nimport { ChartData } from \"@/types\"\nimport { memo } from \"react\"\nimport { $userSettings } from \"@/lib/stores\"\nimport { useStore } from \"@nanostores/react\"\nimport { useYAxisWidth } from \"./hooks\"\nexport default memo(function SwapChart({ chartData }: { chartData: ChartData }) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\tconst userSettings = useStore($userSettings)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/swap-chart.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/swap-chart.tsx", "rel_path": "src/site/src/components/charts/swap-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 16, "end_line": 36, "text": "\tif (chartData.systemStats.length === 0) {\n\t\treturn null\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<AreaChart accessibilityLayer data={chartData.systemStats} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\tdomain={[0, () => toFixedFloat(chartData.systemStats.at(-1)?.stats.s ?? 0.04, 2)]}\n\t\t\t\t\t\twidth={yAxisWidth}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}", "n_tokens": 175, "primary_symbol": "", "primary_kind": "", "primary_span": [16, 36], "def_symbols": [], "symbols": ["chartData", "systemStats", "length", "return", "null", "div", "ChartContainer", "className", "full", "absolute", "aspect", "auto", "card", "opacity", "transition", "yAxisWidth", "AreaChart", "accessibilityLayer", "data", "margin", "chartMargin", "CartesianGrid", "vertical", "false", "YAxis", "direction", "ltr", "orientation", "tracking", "tighter", "domain", "toFixedFloat", "stats", "width", "tickLine", "axisLine"], "doc_head": "\tif (chartData.systemStats.length === 0) {\n\t\treturn null\n\t}\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<AreaChart accessibilityLayer data={chartData.systemStats} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\tdomain={[0, () => toFixedFloat(chartData.systemStats.at(-1)?.stats.s ?? 0.04, 2)]}\n\t\t\t\t\t\twidth={yAxisWidth}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/swap-chart.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/swap-chart.tsx", "rel_path": "src/site/src/components/charts/swap-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 37, "end_line": 48, "text": "\t\t\t\t\t\ttickFormatter={(value) => {\n\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value * 1024, false, userSettings.unitDisk, true)\n\t\t\t\t\t\t\treturn updateYAxisWidth(toFixedFloat(convertedValue, value >= 10 ? 0 : 1) + \" \" + unit)\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}", "n_tokens": 128, "primary_symbol": "", "primary_kind": "", "primary_span": [37, 48], "def_symbols": [], "symbols": ["tickFormatter", "value", "const", "convertedValue", "unit", "formatBytes", "false", "userSettings", "unitDisk", "true", "return", "updateYAxisWidth", "toFixedFloat", "xAxis", "chartData", "ChartTooltip", "animationEasing", "ease", "out", "animationDuration", "content", "ChartTooltipContent", "labelFormatter", "data", "formatShortDate", "payload", "created"], "doc_head": "\t\t\t\t\t\ttickFormatter={(value) => {\n\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value * 1024, false, userSettings.unitDisk, true)\n\t\t\t\t\t\t\treturn updateYAxisWidth(toFixedFloat(convertedValue, value >= 10 ? 0 : 1) + \" \" + unit)\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/swap-chart.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/swap-chart.tsx", "rel_path": "src/site/src/components/charts/swap-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 49, "end_line": 72, "text": "\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\t\t// mem values are supplied as GB\n\t\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value * 1024, false, userSettings.unitDisk, true)\n\t\t\t\t\t\t\t\t\treturn decimalString(convertedValue, convertedValue >= 100 ? 1 : 2) + \" \" + unit\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t// indicator=\"line\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t\t<Area\n\t\t\t\t\t\tdataKey=\"stats.su\"\n\t\t\t\t\t\tname={t`Used`}\n\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\tfill=\"var(--chart-2)\"\n\t\t\t\t\t\tfillOpacity={0.4}\n\t\t\t\t\t\tstroke=\"var(--chart-2)\"\n\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t/>\n\t\t\t\t</AreaChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})\n", "n_tokens": 176, "primary_symbol": "", "primary_kind": "", "primary_span": [49, 72], "def_symbols": [], "symbols": ["contentFormatter", "value", "mem", "values", "are", "supplied", "const", "convertedValue", "unit", "formatBytes", "false", "userSettings", "unitDisk", "true", "return", "decimalString", "indicator", "line", "Area", "dataKey", "stats", "name", "Used", "type", "monotoneX", "fill", "var", "chart", "fillOpacity", "stroke", "isAnimationActive", "AreaChart", "ChartContainer", "div"], "doc_head": "\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\t\t// mem values are supplied as GB\n\t\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value * 1024, false, userSettings.unitDisk, true)\n\t\t\t\t\t\t\t\t\treturn decimalString(convertedValue, convertedValue >= 100 ? 1 : 2) + \" \" + unit\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t// indicator=\"line\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t\t<Area\n\t\t\t\t\t\tdataKey=\"stats.su\"\n\t\t\t\t\t\tname={t`Used`}\n\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\tfill=\"var(--chart-2)\"\n\t\t\t\t\t\tfillOpacity={0.4}\n\t\t\t\t\t\tstroke=\"var(--chart-2)\"\n\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t/>\n\t\t\t\t</AreaChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx", "rel_path": "src/site/src/components/charts/container-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 12, "text": "import { Area, AreaChart, CartesianGrid, YAxis } from \"recharts\"\nimport { ChartConfig, ChartContainer, ChartTooltip, ChartTooltipContent, xAxis } from \"@/components/ui/chart\"\nimport { memo, useMemo } from \"react\"\nimport { cn, formatShortDate, chartMargin, toFixedFloat, formatBytes, decimalString } from \"@/lib/utils\"\n// import Spinner from '../spinner'\nimport { useStore } from \"@nanostores/react\"\nimport { $containerFilter, $userSettings } from \"@/lib/stores\"\nimport { ChartData } from \"@/types\"\nimport { Separator } from \"../ui/separator\"\nimport { ChartType, Unit } from \"@/lib/enums\"\nimport { useYAxisWidth } from \"./hooks\"\n", "n_tokens": 155, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 12], "def_symbols": [], "symbols": ["import", "Area", "AreaChart", "CartesianGrid", "YAxis", "from", "recharts", "ChartConfig", "ChartContainer", "ChartTooltip", "ChartTooltipContent", "xAxis", "components", "chart", "memo", "useMemo", "react", "formatShortDate", "chartMargin", "toFixedFloat", "formatBytes", "decimalString", "lib", "utils", "Spinner", "spinner", "useStore", "nanostores", "containerFilter", "userSettings", "stores", "ChartData", "types", "Separator", "separator", "ChartType", "Unit", "enums", "useYAxisWidth", "hooks"], "doc_head": "import { Area, AreaChart, CartesianGrid, YAxis } from \"recharts\"\nimport { ChartConfig, ChartContainer, ChartTooltip, ChartTooltipContent, xAxis } from \"@/components/ui/chart\"\nimport { memo, useMemo } from \"react\"\nimport { cn, formatShortDate, chartMargin, toFixedFloat, formatBytes, decimalString } from \"@/lib/utils\"\n// import Spinner from '../spinner'\nimport { useStore } from \"@nanostores/react\"\nimport { $containerFilter, $userSettings } from \"@/lib/stores\"\nimport { ChartData } from \"@/types\"\nimport { Separator } from \"../ui/separator\"\nimport { ChartType, Unit } from \"@/lib/enums\"\nimport { useYAxisWidth } from \"./hooks\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx", "rel_path": "src/site/src/components/charts/container-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 13, "end_line": 39, "text": "export default memo(function ContainerChart({\n\tdataKey,\n\tchartData,\n\tchartType,\n\tchartConfig,\n\tunit = \"%\",\n}: {\n\tdataKey: string\n\tchartData: ChartData\n\tchartType: ChartType\n\tchartConfig: ChartConfig\n\tunit?: string\n}) {\n\tconst filter = useStore($containerFilter)\n\tconst userSettings = useStore($userSettings)\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\n\tconst { containerData } = chartData\n\n\tconst isNetChart = chartType === ChartType.Network\n\n\tconst { toolTipFormatter, dataFunction, tickFormatter } = useMemo(() => {\n\t\tconst obj = {} as {\n\t\t\ttoolTipFormatter: (item: any, key: string) => React.ReactNode | string\n\t\t\tdataFunction: (key: string, data: any) => number | null\n\t\t\ttickFormatter: (value: any) => string\n\t\t}", "n_tokens": 195, "primary_symbol": "", "primary_kind": "", "primary_span": [13, 39], "def_symbols": [], "symbols": ["export", "default", "memo", "function", "ContainerChart", "dataKey", "chartData", "chartType", "chartConfig", "unit", "string", "ChartData", "ChartType", "ChartConfig", "const", "filter", "useStore", "containerFilter", "userSettings", "yAxisWidth", "updateYAxisWidth", "useYAxisWidth", "containerData", "isNetChart", "Network", "toolTipFormatter", "dataFunction", "tickFormatter", "useMemo", "obj", "item", "any", "key", "React", "ReactNode", "data", "number", "null", "value"], "doc_head": "export default memo(function ContainerChart({\n\tdataKey,\n\tchartData,\n\tchartType,\n\tchartConfig,\n\tunit = \"%\",\n}: {\n\tdataKey: string\n\tchartData: ChartData\n\tchartType: ChartType\n\tchartConfig: ChartConfig\n\tunit?: string\n}) {\n\tconst filter = useStore($containerFilter)\n\tconst userSettings = useStore($userSettings)\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\tconst { containerData } = chartData\n\tconst isNetChart = chartType === ChartType.Network\n\tconst { toolTipFormatter, dataFunction, tickFormatter } = useMemo(() => {\n\t\tconst obj = {} as {\n\t\t\ttoolTipFormatter: (item: any, key: string) => React.ReactNode | string\n\t\t\tdataFunction: (key: string, data: any) => number | null\n\t\t\ttickFormatter: (value: any) => string\n\t\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx", "rel_path": "src/site/src/components/charts/container-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 40, "end_line": 55, "text": "\t\t// tick formatter\n\t\tif (chartType === ChartType.CPU) {\n\t\t\tobj.tickFormatter = (value) => {\n\t\t\t\tconst val = toFixedFloat(value, 2) + unit\n\t\t\t\treturn updateYAxisWidth(val)\n\t\t\t}\n\t\t} else {\n\t\t\tconst chartUnit = isNetChart ? userSettings.unitNet : Unit.Bytes\n\t\t\tobj.tickFormatter = (val) => {\n\t\t\t\tconst { value, unit } = formatBytes(val, isNetChart, chartUnit, true)\n\t\t\t\treturn updateYAxisWidth(toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit)\n\t\t\t}\n\t\t}\n\t\t// tooltip formatter\n\t\tif (isNetChart) {\n\t\t\tobj.toolTipFormatter = (item: any, key: string) => {", "n_tokens": 172, "primary_symbol": "", "primary_kind": "", "primary_span": [40, 55], "def_symbols": [], "symbols": ["tick", "formatter", "chartType", "ChartType", "CPU", "obj", "tickFormatter", "value", "const", "val", "toFixedFloat", "unit", "return", "updateYAxisWidth", "else", "chartUnit", "isNetChart", "userSettings", "unitNet", "Unit", "Bytes", "formatBytes", "true", "tooltip", "toolTipFormatter", "item", "any", "key", "string"], "doc_head": "\t\t// tick formatter\n\t\tif (chartType === ChartType.CPU) {\n\t\t\tobj.tickFormatter = (value) => {\n\t\t\t\tconst val = toFixedFloat(value, 2) + unit\n\t\t\t\treturn updateYAxisWidth(val)\n\t\t\t}\n\t\t} else {\n\t\t\tconst chartUnit = isNetChart ? userSettings.unitNet : Unit.Bytes\n\t\t\tobj.tickFormatter = (val) => {\n\t\t\t\tconst { value, unit } = formatBytes(val, isNetChart, chartUnit, true)\n\t\t\t\treturn updateYAxisWidth(toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit)\n\t\t\t}\n\t\t}\n\t\t// tooltip formatter\n\t\tif (isNetChart) {\n\t\t\tobj.toolTipFormatter = (item: any, key: string) => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx", "rel_path": "src/site/src/components/charts/container-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 56, "end_line": 69, "text": "\t\t\t\ttry {\n\t\t\t\t\tconst sent = item?.payload?.[key]?.ns ?? 0\n\t\t\t\t\tconst received = item?.payload?.[key]?.nr ?? 0\n\t\t\t\t\tconst { value: receivedValue, unit: receivedUnit } = formatBytes(received, true, userSettings.unitNet, true)\n\t\t\t\t\tconst { value: sentValue, unit: sentUnit } = formatBytes(sent, true, userSettings.unitNet, true)\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<span className=\"flex\">\n\t\t\t\t\t\t\t{decimalString(receivedValue)} {receivedUnit}\n\t\t\t\t\t\t\t<span className=\"opacity-70 ms-0.5\"> rx </span>\n\t\t\t\t\t\t\t<Separator orientation=\"vertical\" className=\"h-3 mx-1.5 bg-primary/40\" />\n\t\t\t\t\t\t\t{decimalString(sentValue)} {sentUnit}\n\t\t\t\t\t\t\t<span className=\"opacity-70 ms-0.5\"> tx</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t)", "n_tokens": 193, "primary_symbol": "", "primary_kind": "", "primary_span": [56, 69], "def_symbols": [], "symbols": ["try", "const", "sent", "item", "payload", "key", "received", "value", "receivedValue", "unit", "receivedUnit", "formatBytes", "true", "userSettings", "unitNet", "sentValue", "sentUnit", "return", "span", "className", "flex", "decimalString", "opacity", "Separator", "orientation", "vertical", "primary"], "doc_head": "\t\t\t\ttry {\n\t\t\t\t\tconst sent = item?.payload?.[key]?.ns ?? 0\n\t\t\t\t\tconst received = item?.payload?.[key]?.nr ?? 0\n\t\t\t\t\tconst { value: receivedValue, unit: receivedUnit } = formatBytes(received, true, userSettings.unitNet, true)\n\t\t\t\t\tconst { value: sentValue, unit: sentUnit } = formatBytes(sent, true, userSettings.unitNet, true)\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<span className=\"flex\">\n\t\t\t\t\t\t\t{decimalString(receivedValue)} {receivedUnit}\n\t\t\t\t\t\t\t<span className=\"opacity-70 ms-0.5\"> rx </span>\n\t\t\t\t\t\t\t<Separator orientation=\"vertical\" className=\"h-3 mx-1.5 bg-primary/40\" />\n\t\t\t\t\t\t\t{decimalString(sentValue)} {sentUnit}\n\t\t\t\t\t\t\t<span className=\"opacity-70 ms-0.5\"> tx</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx", "rel_path": "src/site/src/components/charts/container-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 70, "end_line": 90, "text": "\t\t\t\t} catch (e) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (chartType === ChartType.Memory) {\n\t\t\tobj.toolTipFormatter = (item: any) => {\n\t\t\t\tconst { value, unit } = formatBytes(item.value, false, Unit.Bytes, true)\n\t\t\t\treturn decimalString(value) + \" \" + unit\n\t\t\t}\n\t\t} else {\n\t\t\tobj.toolTipFormatter = (item: any) => decimalString(item.value) + unit\n\t\t}\n\t\t// data function\n\t\tif (isNetChart) {\n\t\t\tobj.dataFunction = (key: string, data: any) => (data[key] ? data[key].nr + data[key].ns : null)\n\t\t} else {\n\t\t\tobj.dataFunction = (key: string, data: any) => data[key]?.[dataKey] ?? null\n\t\t}\n\t\treturn obj\n\t}, [])\n", "n_tokens": 194, "primary_symbol": "", "primary_kind": "", "primary_span": [70, 90], "def_symbols": [], "symbols": ["catch", "return", "null", "else", "chartType", "ChartType", "Memory", "obj", "toolTipFormatter", "item", "any", "const", "value", "unit", "formatBytes", "false", "Unit", "Bytes", "true", "decimalString", "data", "function", "isNetChart", "dataFunction", "key", "string", "dataKey"], "doc_head": "\t\t\t\t} catch (e) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (chartType === ChartType.Memory) {\n\t\t\tobj.toolTipFormatter = (item: any) => {\n\t\t\t\tconst { value, unit } = formatBytes(item.value, false, Unit.Bytes, true)\n\t\t\t\treturn decimalString(value) + \" \" + unit\n\t\t\t}\n\t\t} else {\n\t\t\tobj.toolTipFormatter = (item: any) => decimalString(item.value) + unit\n\t\t}\n\t\t// data function\n\t\tif (isNetChart) {\n\t\t\tobj.dataFunction = (key: string, data: any) => (data[key] ? data[key].nr + data[key].ns : null)\n\t\t} else {\n\t\t\tobj.dataFunction = (key: string, data: any) => data[key]?.[dataKey] ?? null\n\t\t}\n\t\treturn obj\n\t}, [])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx", "rel_path": "src/site/src/components/charts/container-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 91, "end_line": 101, "text": "\t// Filter with set lookup\n\tconst filteredKeys = useMemo(() => {\n\t\tif (!filter) {\n\t\t\treturn new Set<string>()\n\t\t}\n\t\tconst filterLower = filter.toLowerCase()\n\t\treturn new Set(Object.keys(chartConfig).filter((key) => !key.toLowerCase().includes(filterLower)))\n\t}, [chartConfig, filter])\n\n\t// console.log('rendered at', new Date())\n", "n_tokens": 80, "primary_symbol": "", "primary_kind": "", "primary_span": [91, 101], "def_symbols": [], "symbols": ["Filter", "with", "set", "lookup", "const", "filteredKeys", "useMemo", "filter", "return", "new", "Set", "string", "filterLower", "toLowerCase", "Object", "keys", "chartConfig", "key", "includes", "console", "log", "rendered", "Date"], "doc_head": "\t// Filter with set lookup\n\tconst filteredKeys = useMemo(() => {\n\t\tif (!filter) {\n\t\t\treturn new Set<string>()\n\t\t}\n\t\tconst filterLower = filter.toLowerCase()\n\t\treturn new Set(Object.keys(chartConfig).filter((key) => !key.toLowerCase().includes(filterLower)))\n\t}, [chartConfig, filter])\n\t// console.log('rendered at', new Date())"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx", "rel_path": "src/site/src/components/charts/container-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 102, "end_line": 134, "text": "\tif (containerData.length === 0) {\n\t\treturn null\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<AreaChart\n\t\t\t\t\taccessibilityLayer\n\t\t\t\t\t// syncId={'cpu'}\n\t\t\t\t\tdata={containerData}\n\t\t\t\t\tmargin={chartMargin}\n\t\t\t\t\treverseStackOrder={true}\n\t\t\t\t>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\twidth={yAxisWidth}\n\t\t\t\t\t\ttickFormatter={tickFormatter}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\ttruncate={true}", "n_tokens": 210, "primary_symbol": "", "primary_kind": "", "primary_span": [102, 134], "def_symbols": [], "symbols": ["containerData", "length", "return", "null", "div", "ChartContainer", "className", "full", "absolute", "aspect", "auto", "card", "opacity", "transition", "yAxisWidth", "AreaChart", "accessibilityLayer", "syncId", "cpu", "data", "margin", "chartMargin", "reverseStackOrder", "true", "CartesianGrid", "vertical", "false", "YAxis", "direction", "ltr", "orientation", "chartData", "tracking", "tighter", "width", "tickFormatter", "tickLine", "axisLine", "xAxis", "ChartTooltip", "animationEasing", "ease", "out", "animationDuration", "truncate"], "doc_head": "\tif (containerData.length === 0) {\n\t\treturn null\n\t}\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<AreaChart\n\t\t\t\t\taccessibilityLayer\n\t\t\t\t\t// syncId={'cpu'}\n\t\t\t\t\tdata={containerData}\n\t\t\t\t\tmargin={chartMargin}\n\t\t\t\t\treverseStackOrder={true}\n\t\t\t\t>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\twidth={yAxisWidth}\n\t\t\t\t\t\ttickFormatter={tickFormatter}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\ttruncate={true}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx", "rel_path": "src/site/src/components/charts/container-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 135, "end_line": 139, "text": "\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\titemSorter={(a, b) => b.value - a.value}\n\t\t\t\t\t\tcontent={<ChartTooltipContent filter={filter} contentFormatter={toolTipFormatter} />}\n\t\t\t\t\t/>", "n_tokens": 62, "primary_symbol": "", "primary_kind": "", "primary_span": [135, 139], "def_symbols": [], "symbols": ["labelFormatter", "data", "formatShortDate", "payload", "created", "ignore", "itemSorter", "value", "content", "ChartTooltipContent", "filter", "contentFormatter", "toolTipFormatter"], "doc_head": "\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\titemSorter={(a, b) => b.value - a.value}\n\t\t\t\t\t\tcontent={<ChartTooltipContent filter={filter} contentFormatter={toolTipFormatter} />}\n\t\t\t\t\t/>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/container-chart.tsx", "rel_path": "src/site/src/components/charts/container-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 140, "end_line": 165, "text": "\t\t\t\t\t{Object.keys(chartConfig).map((key) => {\n\t\t\t\t\t\tconst filtered = filteredKeys.has(key)\n\t\t\t\t\t\tconst fillOpacity = filtered ? 0.05 : 0.4\n\t\t\t\t\t\tconst strokeOpacity = filtered ? 0.1 : 1\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<Area\n\t\t\t\t\t\t\t\tkey={key}\n\t\t\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t\t\t\tdataKey={dataFunction.bind(null, key)}\n\t\t\t\t\t\t\t\tname={key}\n\t\t\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\t\t\tfill={chartConfig[key].color}\n\t\t\t\t\t\t\t\tfillOpacity={fillOpacity}\n\t\t\t\t\t\t\t\tstroke={chartConfig[key].color}\n\t\t\t\t\t\t\t\tstrokeOpacity={strokeOpacity}\n\t\t\t\t\t\t\t\tactiveDot={{ opacity: filtered ? 0 : 1 }}\n\t\t\t\t\t\t\t\tstackId=\"a\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t})}\n\t\t\t\t</AreaChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})\n", "n_tokens": 182, "primary_symbol": "", "primary_kind": "", "primary_span": [140, 165], "def_symbols": [], "symbols": ["Object", "keys", "chartConfig", "map", "key", "const", "filtered", "filteredKeys", "has", "fillOpacity", "strokeOpacity", "return", "Area", "isAnimationActive", "false", "dataKey", "dataFunction", "bind", "null", "name", "type", "monotoneX", "fill", "color", "stroke", "activeDot", "opacity", "stackId", "AreaChart", "ChartContainer", "div"], "doc_head": "\t\t\t\t\t{Object.keys(chartConfig).map((key) => {\n\t\t\t\t\t\tconst filtered = filteredKeys.has(key)\n\t\t\t\t\t\tconst fillOpacity = filtered ? 0.05 : 0.4\n\t\t\t\t\t\tconst strokeOpacity = filtered ? 0.1 : 1\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<Area\n\t\t\t\t\t\t\t\tkey={key}\n\t\t\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t\t\t\tdataKey={dataFunction.bind(null, key)}\n\t\t\t\t\t\t\t\tname={key}\n\t\t\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\t\t\tfill={chartConfig[key].color}\n\t\t\t\t\t\t\t\tfillOpacity={fillOpacity}\n\t\t\t\t\t\t\t\tstroke={chartConfig[key].color}\n\t\t\t\t\t\t\t\tstrokeOpacity={strokeOpacity}\n\t\t\t\t\t\t\t\tactiveDot={{ opacity: filtered ? 0 : 1 }}\n\t\t\t\t\t\t\t\tstackId=\"a\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t})}\n\t\t\t\t</AreaChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/load-average-chart.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/load-average-chart.tsx", "rel_path": "src/site/src/components/charts/load-average-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 16, "text": "import { CartesianGrid, Line, LineChart, YAxis } from \"recharts\"\n\nimport {\n\tChartContainer,\n\tChartLegend,\n\tChartLegendContent,\n\tChartTooltip,\n\tChartTooltipContent,\n\txAxis,\n} from \"@/components/ui/chart\"\nimport { cn, formatShortDate, toFixedFloat, decimalString, chartMargin } from \"@/lib/utils\"\nimport { ChartData, SystemStats } from \"@/types\"\nimport { memo } from \"react\"\nimport { t } from \"@lingui/core/macro\"\nimport { useYAxisWidth } from \"./hooks\"\n", "n_tokens": 118, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 16], "def_symbols": [], "symbols": ["import", "CartesianGrid", "Line", "LineChart", "YAxis", "from", "recharts", "ChartContainer", "ChartLegend", "ChartLegendContent", "ChartTooltip", "ChartTooltipContent", "xAxis", "components", "chart", "formatShortDate", "toFixedFloat", "decimalString", "chartMargin", "lib", "utils", "ChartData", "SystemStats", "types", "memo", "react", "lingui", "core", "macro", "useYAxisWidth", "hooks"], "doc_head": "import { CartesianGrid, Line, LineChart, YAxis } from \"recharts\"\nimport {\n\tChartContainer,\n\tChartLegend,\n\tChartLegendContent,\n\tChartTooltip,\n\tChartTooltipContent,\n\txAxis,\n} from \"@/components/ui/chart\"\nimport { cn, formatShortDate, toFixedFloat, decimalString, chartMargin } from \"@/lib/utils\"\nimport { ChartData, SystemStats } from \"@/types\"\nimport { memo } from \"react\"\nimport { t } from \"@lingui/core/macro\"\nimport { useYAxisWidth } from \"./hooks\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/load-average-chart.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/load-average-chart.tsx", "rel_path": "src/site/src/components/charts/load-average-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 17, "end_line": 52, "text": "export default memo(function LoadAverageChart({ chartData }: { chartData: ChartData }) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\n\tconst keys: { legacy: keyof SystemStats; color: string; label: string }[] = [\n\t\t{\n\t\t\tlegacy: \"l1\",\n\t\t\tcolor: \"hsl(271, 81%, 60%)\", // Purple\n\t\t\tlabel: t({ message: `1 min`, comment: \"Load average\" }),\n\t\t},\n\t\t{\n\t\t\tlegacy: \"l5\",\n\t\t\tcolor: \"hsl(217, 91%, 60%)\", // Blue\n\t\t\tlabel: t({ message: `5 min`, comment: \"Load average\" }),\n\t\t},\n\t\t{\n\t\t\tlegacy: \"l15\",\n\t\t\tcolor: \"hsl(25, 95%, 53%)\", // Orange\n\t\t\tlabel: t({ message: `15 min`, comment: \"Load average\" }),\n\t\t},\n\t]\n\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<LineChart accessibilityLayer data={chartData.systemStats} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\tdomain={[0, \"auto\"]}\n\t\t\t\t\t\twidth={yAxisWidth}", "n_tokens": 332, "primary_symbol": "", "primary_kind": "", "primary_span": [17, 52], "def_symbols": [], "symbols": ["export", "default", "memo", "function", "LoadAverageChart", "chartData", "ChartData", "const", "yAxisWidth", "updateYAxisWidth", "useYAxisWidth", "keys", "legacy", "keyof", "SystemStats", "color", "string", "label", "hsl", "Purple", "message", "min", "comment", "Load", "average", "Blue", "l15", "Orange", "return", "div", "ChartContainer", "className", "full", "absolute", "aspect", "auto", "card", "opacity", "transition", "LineChart", "accessibilityLayer", "data", "systemStats", "margin", "chartMargin", "CartesianGrid", "vertical", "false", "YAxis", "direction", "ltr", "orientation", "tracking", "tighter", "domain", "width"], "doc_head": "export default memo(function LoadAverageChart({ chartData }: { chartData: ChartData }) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\tconst keys: { legacy: keyof SystemStats; color: string; label: string }[] = [\n\t\t{\n\t\t\tlegacy: \"l1\",\n\t\t\tcolor: \"hsl(271, 81%, 60%)\", // Purple\n\t\t\tlabel: t({ message: `1 min`, comment: \"Load average\" }),\n\t\t},\n\t\t{\n\t\t\tlegacy: \"l5\",\n\t\t\tcolor: \"hsl(217, 91%, 60%)\", // Blue\n\t\t\tlabel: t({ message: `5 min`, comment: \"Load average\" }),\n\t\t},\n\t\t{\n\t\t\tlegacy: \"l15\",\n\t\t\tcolor: \"hsl(25, 95%, 53%)\", // Orange\n\t\t\tlabel: t({ message: `15 min`, comment: \"Load average\" }),\n\t\t},\n\t]\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<LineChart accessibilityLayer data={chartData.systemStats} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\tdomain={[0, \"auto\"]}\n\t\t\t\t\t\twidth={yAxisWidth}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/load-average-chart.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/load-average-chart.tsx", "rel_path": "src/site/src/components/charts/load-average-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 53, "end_line": 73, "text": "\t\t\t\t\t\ttickFormatter={(value) => {\n\t\t\t\t\t\t\treturn updateYAxisWidth(String(toFixedFloat(value, 2)))\n\t\t\t\t\t\t}}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t// itemSorter={(a, b) => b.value - a.value}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}\n\t\t\t\t\t\t\t\tcontentFormatter={(item) => decimalString(item.value)}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t\t{keys.map(({ legacy, color, label }, i) => {\n\t\t\t\t\t\tconst dataKey = (value: { stats: SystemStats }) => {", "n_tokens": 177, "primary_symbol": "dataKey", "primary_kind": "function", "primary_span": [53, 73], "def_symbols": ["dataKey"], "symbols": ["dataKey", "tickFormatter", "value", "return", "updateYAxisWidth", "String", "toFixedFloat", "tickLine", "false", "axisLine", "xAxis", "chartData", "ChartTooltip", "animationEasing", "ease", "out", "animationDuration", "ignore", "itemSorter", "content", "ChartTooltipContent", "labelFormatter", "data", "formatShortDate", "payload", "created", "contentFormatter", "item", "decimalString", "keys", "map", "legacy", "color", "label", "const", "stats", "SystemStats"], "doc_head": "\t\t\t\t\t\ttickFormatter={(value) => {\n\t\t\t\t\t\t\treturn updateYAxisWidth(String(toFixedFloat(value, 2)))\n\t\t\t\t\t\t}}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t// itemSorter={(a, b) => b.value - a.value}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}\n\t\t\t\t\t\t\t\tcontentFormatter={(item) => decimalString(item.value)}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t\t{keys.map(({ legacy, color, label }, i) => {\n\t\t\t\t\t\tconst dataKey = (value: { stats: SystemStats }) => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/load-average-chart.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/load-average-chart.tsx", "rel_path": "src/site/src/components/charts/load-average-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 74, "end_line": 98, "text": "\t\t\t\t\t\t\tif (chartData.agentVersion.patch < 1) {\n\t\t\t\t\t\t\t\treturn value.stats?.[legacy]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value.stats?.la?.[i] ?? value.stats?.[legacy]\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<Line\n\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\tdataKey={dataKey}\n\t\t\t\t\t\t\t\tname={label}\n\t\t\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\t\t\tdot={false}\n\t\t\t\t\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t\t\t\t\tstroke={color}\n\t\t\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t})}\n\t\t\t\t\t<ChartLegend content={<ChartLegendContent />} />\n\t\t\t\t</LineChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})\n", "n_tokens": 146, "primary_symbol": "", "primary_kind": "", "primary_span": [74, 98], "def_symbols": [], "symbols": ["chartData", "agentVersion", "patch", "return", "value", "stats", "legacy", "Line", "key", "dataKey", "name", "label", "type", "monotoneX", "dot", "false", "strokeWidth", "stroke", "color", "isAnimationActive", "ChartLegend", "content", "ChartLegendContent", "LineChart", "ChartContainer", "div"], "doc_head": "\t\t\t\t\t\t\tif (chartData.agentVersion.patch < 1) {\n\t\t\t\t\t\t\t\treturn value.stats?.[legacy]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value.stats?.la?.[i] ?? value.stats?.[legacy]\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<Line\n\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\tdataKey={dataKey}\n\t\t\t\t\t\t\t\tname={label}\n\t\t\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\t\t\tdot={false}\n\t\t\t\t\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t\t\t\t\tstroke={color}\n\t\t\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t})}\n\t\t\t\t\t<ChartLegend content={<ChartLegendContent />} />\n\t\t\t\t</LineChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx", "rel_path": "src/site/src/components/charts/mem-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 9, "text": "import { Area, AreaChart, CartesianGrid, YAxis } from \"recharts\"\nimport { ChartContainer, ChartTooltip, ChartTooltipContent, xAxis } from \"@/components/ui/chart\"\nimport { cn, decimalString, formatShortDate, chartMargin, formatBytes, toFixedFloat } from \"@/lib/utils\"\nimport { memo } from \"react\"\nimport { ChartData } from \"@/types\"\nimport { useLingui } from \"@lingui/react/macro\"\nimport { Unit } from \"@/lib/enums\"\nimport { useYAxisWidth } from \"./hooks\"\n", "n_tokens": 117, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 9], "def_symbols": [], "symbols": ["import", "Area", "AreaChart", "CartesianGrid", "YAxis", "from", "recharts", "ChartContainer", "ChartTooltip", "ChartTooltipContent", "xAxis", "components", "chart", "decimalString", "formatShortDate", "chartMargin", "formatBytes", "toFixedFloat", "lib", "utils", "memo", "react", "ChartData", "types", "useLingui", "lingui", "macro", "Unit", "enums", "useYAxisWidth", "hooks"], "doc_head": "import { Area, AreaChart, CartesianGrid, YAxis } from \"recharts\"\nimport { ChartContainer, ChartTooltip, ChartTooltipContent, xAxis } from \"@/components/ui/chart\"\nimport { cn, decimalString, formatShortDate, chartMargin, formatBytes, toFixedFloat } from \"@/lib/utils\"\nimport { memo } from \"react\"\nimport { ChartData } from \"@/types\"\nimport { useLingui } from \"@lingui/react/macro\"\nimport { Unit } from \"@/lib/enums\"\nimport { useYAxisWidth } from \"./hooks\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx", "rel_path": "src/site/src/components/charts/mem-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 10, "end_line": 17, "text": "export default memo(function MemChart({ chartData, showMax }: { chartData: ChartData; showMax: boolean }) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\tconst { t } = useLingui()\n\n\tconst totalMem = toFixedFloat(chartData.systemStats.at(-1)?.stats.m ?? 0, 1)\n\n\t// console.log('rendered at', new Date())\n", "n_tokens": 88, "primary_symbol": "", "primary_kind": "", "primary_span": [10, 17], "def_symbols": [], "symbols": ["export", "default", "memo", "function", "MemChart", "chartData", "showMax", "ChartData", "boolean", "const", "yAxisWidth", "updateYAxisWidth", "useYAxisWidth", "useLingui", "totalMem", "toFixedFloat", "systemStats", "stats", "console", "log", "rendered", "new", "Date"], "doc_head": "export default memo(function MemChart({ chartData, showMax }: { chartData: ChartData; showMax: boolean }) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\tconst { t } = useLingui()\n\tconst totalMem = toFixedFloat(chartData.systemStats.at(-1)?.stats.m ?? 0, 1)\n\t// console.log('rendered at', new Date())"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx", "rel_path": "src/site/src/components/charts/mem-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 18, "end_line": 42, "text": "\tif (chartData.systemStats.length === 0) {\n\t\treturn null\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t{/* {!yAxisSet && <Spinner />} */}\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<AreaChart accessibilityLayer data={chartData.systemStats} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t{totalMem && (\n\t\t\t\t\t\t<YAxis\n\t\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\t\t// use \"ticks\" instead of domain / tickcount if need more control\n\t\t\t\t\t\t\tdomain={[0, totalMem]}\n\t\t\t\t\t\t\ttickCount={9}\n\t\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\t\twidth={yAxisWidth}\n\t\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\t\taxisLine={false}", "n_tokens": 197, "primary_symbol": "", "primary_kind": "", "primary_span": [18, 42], "def_symbols": [], "symbols": ["chartData", "systemStats", "length", "return", "null", "div", "yAxisSet", "Spinner", "ChartContainer", "className", "full", "absolute", "aspect", "auto", "card", "opacity", "transition", "yAxisWidth", "AreaChart", "accessibilityLayer", "data", "margin", "chartMargin", "CartesianGrid", "vertical", "false", "totalMem", "YAxis", "direction", "ltr", "orientation", "use", "ticks", "instead", "domain", "tickcount", "need", "more", "control", "tickCount", "tracking", "tighter", "width", "tickLine", "axisLine"], "doc_head": "\tif (chartData.systemStats.length === 0) {\n\t\treturn null\n\t}\n\treturn (\n\t\t<div>\n\t\t\t{/* {!yAxisSet && <Spinner />} */}\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<AreaChart accessibilityLayer data={chartData.systemStats} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t{totalMem && (\n\t\t\t\t\t\t<YAxis\n\t\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\t\t// use \"ticks\" instead of domain / tickcount if need more control\n\t\t\t\t\t\t\tdomain={[0, totalMem]}\n\t\t\t\t\t\t\ttickCount={9}\n\t\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\t\twidth={yAxisWidth}\n\t\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\t\taxisLine={false}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx", "rel_path": "src/site/src/components/charts/mem-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 43, "end_line": 58, "text": "\t\t\t\t\t\t\ttickFormatter={(value) => {\n\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value * 1024, false, Unit.Bytes, true)\n\t\t\t\t\t\t\t\treturn updateYAxisWidth(toFixedFloat(convertedValue, value >= 10 ? 0 : 1) + \" \" + unit)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\t// cursor={false}\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\t\titemSorter={(a, b) => a.order - b.order}\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}", "n_tokens": 159, "primary_symbol": "", "primary_kind": "", "primary_span": [43, 58], "def_symbols": [], "symbols": ["tickFormatter", "value", "const", "convertedValue", "unit", "formatBytes", "false", "Unit", "Bytes", "true", "return", "updateYAxisWidth", "toFixedFloat", "xAxis", "chartData", "ChartTooltip", "cursor", "animationEasing", "ease", "out", "animationDuration", "content", "ChartTooltipContent", "ignore", "itemSorter", "order", "labelFormatter", "data", "formatShortDate", "payload", "created"], "doc_head": "\t\t\t\t\t\t\ttickFormatter={(value) => {\n\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value * 1024, false, Unit.Bytes, true)\n\t\t\t\t\t\t\t\treturn updateYAxisWidth(toFixedFloat(convertedValue, value >= 10 ? 0 : 1) + \" \" + unit)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\t// cursor={false}\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\t\titemSorter={(a, b) => a.order - b.order}\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx", "rel_path": "src/site/src/components/charts/mem-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 59, "end_line": 69, "text": "\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\t\t// mem values are supplied as GB\n\t\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value * 1024, false, Unit.Bytes, true)\n\t\t\t\t\t\t\t\t\treturn decimalString(convertedValue, convertedValue >= 100 ? 1 : 2) + \" \" + unit\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t\t<Area\n\t\t\t\t\t\tname={t`Used`}\n\t\t\t\t\t\torder={3}", "n_tokens": 99, "primary_symbol": "", "primary_kind": "", "primary_span": [59, 69], "def_symbols": [], "symbols": ["contentFormatter", "value", "mem", "values", "are", "supplied", "const", "convertedValue", "unit", "formatBytes", "false", "Unit", "Bytes", "true", "return", "decimalString", "Area", "name", "Used", "order"], "doc_head": "\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\t\t// mem values are supplied as GB\n\t\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value * 1024, false, Unit.Bytes, true)\n\t\t\t\t\t\t\t\t\treturn decimalString(convertedValue, convertedValue >= 100 ? 1 : 2) + \" \" + unit\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t\t<Area\n\t\t\t\t\t\tname={t`Used`}\n\t\t\t\t\t\torder={3}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx", "rel_path": "src/site/src/components/charts/mem-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 70, "end_line": 81, "text": "\t\t\t\t\t\tdataKey={({ stats }) => (showMax ? stats?.mm : stats?.mu)}\n\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\tfill=\"var(--chart-2)\"\n\t\t\t\t\t\tfillOpacity={0.4}\n\t\t\t\t\t\tstroke=\"var(--chart-2)\"\n\t\t\t\t\t\tstackId=\"1\"\n\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{/* {chartData.systemStats.at(-1)?.stats.mz && ( */}\n\t\t\t\t\t<Area\n\t\t\t\t\t\tname=\"ZFS ARC\"\n\t\t\t\t\t\torder={2}", "n_tokens": 105, "primary_symbol": "", "primary_kind": "", "primary_span": [70, 81], "def_symbols": [], "symbols": ["dataKey", "stats", "showMax", "type", "monotoneX", "fill", "var", "chart", "fillOpacity", "stroke", "stackId", "isAnimationActive", "false", "chartData", "systemStats", "Area", "name", "ZFS", "ARC", "order"], "doc_head": "\t\t\t\t\t\tdataKey={({ stats }) => (showMax ? stats?.mm : stats?.mu)}\n\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\tfill=\"var(--chart-2)\"\n\t\t\t\t\t\tfillOpacity={0.4}\n\t\t\t\t\t\tstroke=\"var(--chart-2)\"\n\t\t\t\t\t\tstackId=\"1\"\n\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{/* {chartData.systemStats.at(-1)?.stats.mz && ( */}\n\t\t\t\t\t<Area\n\t\t\t\t\t\tname=\"ZFS ARC\"\n\t\t\t\t\t\torder={2}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx", "rel_path": "src/site/src/components/charts/mem-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 82, "end_line": 93, "text": "\t\t\t\t\t\tdataKey={({ stats }) => (showMax ? null : stats?.mz)}\n\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\tfill=\"hsla(175 60% 45% / 0.8)\"\n\t\t\t\t\t\tfillOpacity={0.5}\n\t\t\t\t\t\tstroke=\"hsla(175 60% 45% / 0.8)\"\n\t\t\t\t\t\tstackId=\"1\"\n\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{/* )} */}\n\t\t\t\t\t<Area\n\t\t\t\t\t\tname={t`Cache / Buffers`}\n\t\t\t\t\t\torder={1}", "n_tokens": 115, "primary_symbol": "", "primary_kind": "", "primary_span": [82, 93], "def_symbols": [], "symbols": ["dataKey", "stats", "showMax", "null", "type", "monotoneX", "fill", "hsla", "fillOpacity", "stroke", "stackId", "isAnimationActive", "false", "Area", "name", "Cache", "Buffers", "order"], "doc_head": "\t\t\t\t\t\tdataKey={({ stats }) => (showMax ? null : stats?.mz)}\n\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\tfill=\"hsla(175 60% 45% / 0.8)\"\n\t\t\t\t\t\tfillOpacity={0.5}\n\t\t\t\t\t\tstroke=\"hsla(175 60% 45% / 0.8)\"\n\t\t\t\t\t\tstackId=\"1\"\n\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{/* )} */}\n\t\t\t\t\t<Area\n\t\t\t\t\t\tname={t`Cache / Buffers`}\n\t\t\t\t\t\torder={1}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/mem-chart.tsx", "rel_path": "src/site/src/components/charts/mem-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 94, "end_line": 108, "text": "\t\t\t\t\t\tdataKey={({ stats }) => (showMax ? null : stats?.mb)}\n\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\tfill=\"hsla(160 60% 45% / 0.5)\"\n\t\t\t\t\t\tfillOpacity={0.4}\n\t\t\t\t\t\tstroke=\"hsla(160 60% 45% / 0.5)\"\n\t\t\t\t\t\tstackId=\"1\"\n\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{/* <ChartLegend content={<ChartLegendContent />} /> */}\n\t\t\t\t</AreaChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})\n", "n_tokens": 122, "primary_symbol": "", "primary_kind": "", "primary_span": [94, 108], "def_symbols": [], "symbols": ["dataKey", "stats", "showMax", "null", "type", "monotoneX", "fill", "hsla", "fillOpacity", "stroke", "stackId", "isAnimationActive", "false", "ChartLegend", "content", "ChartLegendContent", "AreaChart", "ChartContainer", "div"], "doc_head": "\t\t\t\t\t\tdataKey={({ stats }) => (showMax ? null : stats?.mb)}\n\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\tfill=\"hsla(160 60% 45% / 0.5)\"\n\t\t\t\t\t\tfillOpacity={0.4}\n\t\t\t\t\t\tstroke=\"hsla(160 60% 45% / 0.5)\"\n\t\t\t\t\t\tstackId=\"1\"\n\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{/* <ChartLegend content={<ChartLegendContent />} /> */}\n\t\t\t\t</AreaChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx", "rel_path": "src/site/src/components/charts/gpu-power-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "import { CartesianGrid, Line, LineChart, YAxis } from \"recharts\"\n\nimport {\n\tChartContainer,\n\tChartLegend,\n\tChartLegendContent,\n\tChartTooltip,\n\tChartTooltipContent,\n\txAxis,\n} from \"@/components/ui/chart\"\nimport { cn, formatShortDate, toFixedFloat, decimalString, chartMargin } from \"@/lib/utils\"\nimport { ChartData } from \"@/types\"\nimport { memo, useMemo } from \"react\"\nimport { useYAxisWidth } from \"./hooks\"\n\nexport default memo(function GpuPowerChart({ chartData }: { chartData: ChartData }) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\n\tif (chartData.systemStats.length === 0) {\n\t\treturn null\n\t}\n", "n_tokens": 159, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 22], "def_symbols": [], "symbols": ["import", "CartesianGrid", "Line", "LineChart", "YAxis", "from", "recharts", "ChartContainer", "ChartLegend", "ChartLegendContent", "ChartTooltip", "ChartTooltipContent", "xAxis", "components", "chart", "formatShortDate", "toFixedFloat", "decimalString", "chartMargin", "lib", "utils", "ChartData", "types", "memo", "useMemo", "react", "useYAxisWidth", "hooks", "export", "default", "function", "GpuPowerChart", "chartData", "const", "yAxisWidth", "updateYAxisWidth", "systemStats", "length", "return", "null"], "doc_head": "import { CartesianGrid, Line, LineChart, YAxis } from \"recharts\"\nimport {\n\tChartContainer,\n\tChartLegend,\n\tChartLegendContent,\n\tChartTooltip,\n\tChartTooltipContent,\n\txAxis,\n} from \"@/components/ui/chart\"\nimport { cn, formatShortDate, toFixedFloat, decimalString, chartMargin } from \"@/lib/utils\"\nimport { ChartData } from \"@/types\"\nimport { memo, useMemo } from \"react\"\nimport { useYAxisWidth } from \"./hooks\"\nexport default memo(function GpuPowerChart({ chartData }: { chartData: ChartData }) {\n\tconst { yAxisWidth, updateYAxisWidth } = useYAxisWidth()\n\tif (chartData.systemStats.length === 0) {\n\t\treturn null\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx", "rel_path": "src/site/src/components/charts/gpu-power-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 23, "end_line": 41, "text": "\t/** Format temperature data for chart and assign colors */\n\tconst newChartData = useMemo(() => {\n\t\tconst newChartData = { data: [], colors: {} } as {\n\t\t\tdata: Record<string, number | string>[]\n\t\t\tcolors: Record<string, string>\n\t\t}\n\t\tconst powerSums = {} as Record<string, number>\n\t\tfor (let data of chartData.systemStats) {\n\t\t\tlet newData = { created: data.created } as Record<string, number | string>\n\n\t\t\tfor (let gpu of Object.values(data.stats?.g ?? {})) {\n\t\t\t\tif (gpu.p) {\n\t\t\t\t\tconst name = gpu.n\n\t\t\t\t\tnewData[name] = gpu.p\n\t\t\t\t\tpowerSums[name] = (powerSums[name] ?? 0) + newData[name]\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewChartData.data.push(newData)\n\t\t}", "n_tokens": 178, "primary_symbol": "", "primary_kind": "", "primary_span": [23, 41], "def_symbols": [], "symbols": ["Format", "temperature", "data", "for", "chart", "and", "assign", "colors", "const", "newChartData", "useMemo", "Record", "string", "number", "powerSums", "let", "chartData", "systemStats", "newData", "created", "gpu", "Object", "values", "stats", "name", "push"], "doc_head": "\t/** Format temperature data for chart and assign colors */\n\tconst newChartData = useMemo(() => {\n\t\tconst newChartData = { data: [], colors: {} } as {\n\t\t\tdata: Record<string, number | string>[]\n\t\t\tcolors: Record<string, string>\n\t\t}\n\t\tconst powerSums = {} as Record<string, number>\n\t\tfor (let data of chartData.systemStats) {\n\t\t\tlet newData = { created: data.created } as Record<string, number | string>\n\t\t\tfor (let gpu of Object.values(data.stats?.g ?? {})) {\n\t\t\t\tif (gpu.p) {\n\t\t\t\t\tconst name = gpu.n\n\t\t\t\t\tnewData[name] = gpu.p\n\t\t\t\t\tpowerSums[name] = (powerSums[name] ?? 0) + newData[name]\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewChartData.data.push(newData)\n\t\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx", "rel_path": "src/site/src/components/charts/gpu-power-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 42, "end_line": 42, "text": "\t\tconst keys = Object.keys(powerSums).sort((a, b) => powerSums[b] - powerSums[a])", "n_tokens": 28, "primary_symbol": "", "primary_kind": "", "primary_span": [42, 42], "def_symbols": [], "symbols": ["const", "keys", "Object", "powerSums", "sort"], "doc_head": "\t\tconst keys = Object.keys(powerSums).sort((a, b) => powerSums[b] - powerSums[a])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx", "rel_path": "src/site/src/components/charts/gpu-power-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 43, "end_line": 67, "text": "\t\tfor (let key of keys) {\n\t\t\tnewChartData.colors[key] = `hsl(${((keys.indexOf(key) * 360) / keys.length) % 360}, 60%, 55%)`\n\t\t}\n\t\treturn newChartData\n\t}, [chartData])\n\n\tconst colors = Object.keys(newChartData.colors)\n\n\t// console.log('rendered at', new Date())\n\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<LineChart accessibilityLayer data={newChartData.data} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\tdomain={[0, \"auto\"]}\n\t\t\t\t\t\twidth={yAxisWidth}", "n_tokens": 199, "primary_symbol": "", "primary_kind": "", "primary_span": [43, 67], "def_symbols": [], "symbols": ["for", "let", "key", "keys", "newChartData", "colors", "hsl", "indexOf", "length", "return", "chartData", "const", "Object", "console", "log", "rendered", "new", "Date", "div", "ChartContainer", "className", "full", "absolute", "aspect", "auto", "card", "opacity", "transition", "yAxisWidth", "LineChart", "accessibilityLayer", "data", "margin", "chartMargin", "CartesianGrid", "vertical", "false", "YAxis", "direction", "ltr", "orientation", "tracking", "tighter", "domain", "width"], "doc_head": "\t\tfor (let key of keys) {\n\t\t\tnewChartData.colors[key] = `hsl(${((keys.indexOf(key) * 360) / keys.length) % 360}, 60%, 55%)`\n\t\t}\n\t\treturn newChartData\n\t}, [chartData])\n\tconst colors = Object.keys(newChartData.colors)\n\t// console.log('rendered at', new Date())\n\treturn (\n\t\t<div>\n\t\t\t<ChartContainer\n\t\t\t\tclassName={cn(\"h-full w-full absolute aspect-auto bg-card opacity-0 transition-opacity\", {\n\t\t\t\t\t\"opacity-100\": yAxisWidth,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<LineChart accessibilityLayer data={newChartData.data} margin={chartMargin}>\n\t\t\t\t\t<CartesianGrid vertical={false} />\n\t\t\t\t\t<YAxis\n\t\t\t\t\t\tdirection=\"ltr\"\n\t\t\t\t\t\torientation={chartData.orientation}\n\t\t\t\t\t\tclassName=\"tracking-tighter\"\n\t\t\t\t\t\tdomain={[0, \"auto\"]}\n\t\t\t\t\t\twidth={yAxisWidth}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx", "rel_path": "src/site/src/components/charts/gpu-power-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 68, "end_line": 88, "text": "\t\t\t\t\t\ttickFormatter={(value) => {\n\t\t\t\t\t\t\tconst val = toFixedFloat(value, 2)\n\t\t\t\t\t\t\treturn updateYAxisWidth(val + \"W\")\n\t\t\t\t\t\t}}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\titemSorter={(a, b) => b.value - a.value}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}\n\t\t\t\t\t\t\t\tcontentFormatter={(item) => decimalString(item.value) + \"W\"}\n\t\t\t\t\t\t\t\t// indicator=\"line\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>", "n_tokens": 162, "primary_symbol": "", "primary_kind": "", "primary_span": [68, 88], "def_symbols": [], "symbols": ["tickFormatter", "value", "const", "val", "toFixedFloat", "return", "updateYAxisWidth", "tickLine", "false", "axisLine", "xAxis", "chartData", "ChartTooltip", "animationEasing", "ease", "out", "animationDuration", "ignore", "itemSorter", "content", "ChartTooltipContent", "labelFormatter", "data", "formatShortDate", "payload", "created", "contentFormatter", "item", "decimalString", "indicator", "line"], "doc_head": "\t\t\t\t\t\ttickFormatter={(value) => {\n\t\t\t\t\t\t\tconst val = toFixedFloat(value, 2)\n\t\t\t\t\t\t\treturn updateYAxisWidth(val + \"W\")\n\t\t\t\t\t\t}}\n\t\t\t\t\t\ttickLine={false}\n\t\t\t\t\t\taxisLine={false}\n\t\t\t\t\t/>\n\t\t\t\t\t{xAxis(chartData)}\n\t\t\t\t\t<ChartTooltip\n\t\t\t\t\t\tanimationEasing=\"ease-out\"\n\t\t\t\t\t\tanimationDuration={150}\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\titemSorter={(a, b) => b.value - a.value}\n\t\t\t\t\t\tcontent={\n\t\t\t\t\t\t\t<ChartTooltipContent\n\t\t\t\t\t\t\t\tlabelFormatter={(_, data) => formatShortDate(data[0].payload.created)}\n\t\t\t\t\t\t\t\tcontentFormatter={(item) => decimalString(item.value) + \"W\"}\n\t\t\t\t\t\t\t\t// indicator=\"line\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n\t\t\t\t\t/>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/gpu-power-chart.tsx", "rel_path": "src/site/src/components/charts/gpu-power-chart.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 89, "end_line": 107, "text": "\t\t\t\t\t{colors.map((key) => (\n\t\t\t\t\t\t<Line\n\t\t\t\t\t\t\tkey={key}\n\t\t\t\t\t\t\tdataKey={key}\n\t\t\t\t\t\t\tname={key}\n\t\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\t\tdot={false}\n\t\t\t\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t\t\t\tstroke={newChartData.colors[key]}\n\t\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t\t/>\n\t\t\t\t\t))}\n\t\t\t\t\t{colors.length > 1 && <ChartLegend content={<ChartLegendContent />} />}\n\t\t\t\t</LineChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})\n", "n_tokens": 115, "primary_symbol": "", "primary_kind": "", "primary_span": [89, 107], "def_symbols": [], "symbols": ["colors", "map", "key", "Line", "dataKey", "name", "type", "monotoneX", "dot", "false", "strokeWidth", "stroke", "newChartData", "isAnimationActive", "length", "ChartLegend", "content", "ChartLegendContent", "LineChart", "ChartContainer", "div"], "doc_head": "\t\t\t\t\t{colors.map((key) => (\n\t\t\t\t\t\t<Line\n\t\t\t\t\t\t\tkey={key}\n\t\t\t\t\t\t\tdataKey={key}\n\t\t\t\t\t\t\tname={key}\n\t\t\t\t\t\t\ttype=\"monotoneX\"\n\t\t\t\t\t\t\tdot={false}\n\t\t\t\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t\t\t\tstroke={newChartData.colors[key]}\n\t\t\t\t\t\t\tisAnimationActive={false}\n\t\t\t\t\t\t/>\n\t\t\t\t\t))}\n\t\t\t\t\t{colors.length > 1 && <ChartLegend content={<ChartLegendContent />} />}\n\t\t\t\t</LineChart>\n\t\t\t</ChartContainer>\n\t\t</div>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/chart-time-select.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/chart-time-select.tsx", "rel_path": "src/site/src/components/charts/chart-time-select.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 11, "text": "import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\"\nimport { $chartTime } from \"@/lib/stores\"\nimport { chartTimeData, cn } from \"@/lib/utils\"\nimport { ChartTimes } from \"@/types\"\nimport { useStore } from \"@nanostores/react\"\nimport { HistoryIcon } from \"lucide-react\"\n\nexport default function ChartTimeSelect({ className }: { className?: string }) {\n\tconst chartTime = useStore($chartTime)\n\n\treturn (", "n_tokens": 107, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 11], "def_symbols": [], "symbols": ["import", "Select", "SelectContent", "SelectItem", "SelectTrigger", "SelectValue", "from", "components", "select", "chartTime", "lib", "stores", "chartTimeData", "utils", "ChartTimes", "types", "useStore", "nanostores", "react", "HistoryIcon", "lucide", "export", "default", "function", "ChartTimeSelect", "className", "string", "const", "return"], "doc_head": "import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\"\nimport { $chartTime } from \"@/lib/stores\"\nimport { chartTimeData, cn } from \"@/lib/utils\"\nimport { ChartTimes } from \"@/types\"\nimport { useStore } from \"@nanostores/react\"\nimport { HistoryIcon } from \"lucide-react\"\nexport default function ChartTimeSelect({ className }: { className?: string }) {\n\tconst chartTime = useStore($chartTime)\n\treturn ("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/chart-time-select.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/chart-time-select.tsx", "rel_path": "src/site/src/components/charts/chart-time-select.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 12, "end_line": 27, "text": "\t\t<Select defaultValue=\"1h\" value={chartTime} onValueChange={(value: ChartTimes) => $chartTime.set(value)}>\n\t\t\t<SelectTrigger className={cn(className, \"relative ps-10 pe-5\")}>\n\t\t\t\t<HistoryIcon className=\"h-4 w-4 absolute start-4 top-1/2 -translate-y-1/2 opacity-85\" />\n\t\t\t\t<SelectValue />\n\t\t\t</SelectTrigger>\n\t\t\t<SelectContent>\n\t\t\t\t{Object.entries(chartTimeData).map(([value, { label }]) => (\n\t\t\t\t\t<SelectItem key={value} value={value}>\n\t\t\t\t\t\t{label()}\n\t\t\t\t\t</SelectItem>\n\t\t\t\t))}\n\t\t\t</SelectContent>\n\t\t</Select>\n\t)\n}\n", "n_tokens": 157, "primary_symbol": "", "primary_kind": "", "primary_span": [12, 27], "def_symbols": [], "symbols": ["Select", "defaultValue", "value", "chartTime", "onValueChange", "ChartTimes", "set", "SelectTrigger", "className", "relative", "HistoryIcon", "absolute", "start", "top", "translate", "opacity", "SelectValue", "SelectContent", "Object", "entries", "chartTimeData", "map", "label", "SelectItem", "key"], "doc_head": "\t\t<Select defaultValue=\"1h\" value={chartTime} onValueChange={(value: ChartTimes) => $chartTime.set(value)}>\n\t\t\t<SelectTrigger className={cn(className, \"relative ps-10 pe-5\")}>\n\t\t\t\t<HistoryIcon className=\"h-4 w-4 absolute start-4 top-1/2 -translate-y-1/2 opacity-85\" />\n\t\t\t\t<SelectValue />\n\t\t\t</SelectTrigger>\n\t\t\t<SelectContent>\n\t\t\t\t{Object.entries(chartTimeData).map(([value, { label }]) => (\n\t\t\t\t\t<SelectItem key={value} value={value}>\n\t\t\t\t\t\t{label()}\n\t\t\t\t\t</SelectItem>\n\t\t\t\t))}\n\t\t\t</SelectContent>\n\t\t</Select>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/hooks.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/hooks.ts", "rel_path": "src/site/src/components/charts/hooks.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 17, "text": "import { useMemo, useState } from \"react\"\nimport { ChartConfig } from \"@/components/ui/chart\"\nimport { ChartData } from \"@/types\"\n\n/** Chart configurations for CPU, memory, and network usage charts */\nexport interface ContainerChartConfigs {\n\tcpu: ChartConfig\n\tmemory: ChartConfig\n\tnetwork: ChartConfig\n}\n\n/**\n * Generates chart configurations for container metrics visualization\n * @param containerData - Array of container statistics data points\n * @returns Chart configurations for CPU, memory, and network metrics\n */\nexport function useContainerChartConfigs(containerData: ChartData[\"containerData\"]): ContainerChartConfigs {", "n_tokens": 125, "primary_symbol": "useContainerChartConfigs", "primary_kind": "function", "primary_span": [17, 17], "def_symbols": ["useContainerChartConfigs"], "symbols": ["useContainerChartConfigs", "import", "useMemo", "useState", "from", "react", "ChartConfig", "components", "chart", "ChartData", "types", "Chart", "configurations", "for", "CPU", "memory", "and", "network", "usage", "charts", "export", "interface", "ContainerChartConfigs", "cpu", "Generates", "container", "metrics", "visualization", "param", "containerData", "Array", "statistics", "data", "points", "returns", "function"], "doc_head": "import { useMemo, useState } from \"react\"\nimport { ChartConfig } from \"@/components/ui/chart\"\nimport { ChartData } from \"@/types\"\n/** Chart configurations for CPU, memory, and network usage charts */\nexport interface ContainerChartConfigs {\n\tcpu: ChartConfig\n\tmemory: ChartConfig\n\tnetwork: ChartConfig\n}\n/**\n * Generates chart configurations for container metrics visualization\n * @param containerData - Array of container statistics data points\n * @returns Chart configurations for CPU, memory, and network metrics\n */\nexport function useContainerChartConfigs(containerData: ChartData[\"containerData\"]): ContainerChartConfigs {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/hooks.ts#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/hooks.ts", "rel_path": "src/site/src/components/charts/hooks.ts", "ext": "ts", "language": "typescript", "chunk_number": 2, "start_line": 18, "end_line": 44, "text": "\treturn useMemo(() => {\n\t\tconst configs = {\n\t\t\tcpu: {} as ChartConfig,\n\t\t\tmemory: {} as ChartConfig,\n\t\t\tnetwork: {} as ChartConfig,\n\t\t}\n\n\t\t// Aggregate usage metrics for each container\n\t\tconst totalUsage = {\n\t\t\tcpu: new Map<string, number>(),\n\t\t\tmemory: new Map<string, number>(),\n\t\t\tnetwork: new Map<string, number>(),\n\t\t}\n\n\t\t// Process each data point to calculate totals\n\t\tfor (let i = 0; i < containerData.length; i++) {\n\t\t\tconst stats = containerData[i]\n\t\t\tconst containerNames = Object.keys(stats)\n\n\t\t\tfor (let j = 0; j < containerNames.length; j++) {\n\t\t\t\tconst containerName = containerNames[j]\n\t\t\t\t// Skip metadata field\n\t\t\t\tif (containerName === \"created\") {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst containerStats = stats[containerName]", "n_tokens": 193, "primary_symbol": "", "primary_kind": "", "primary_span": [18, 44], "def_symbols": [], "symbols": ["return", "useMemo", "const", "configs", "cpu", "ChartConfig", "memory", "network", "Aggregate", "usage", "metrics", "for", "each", "container", "totalUsage", "new", "Map", "string", "number", "Process", "data", "point", "calculate", "totals", "let", "containerData", "length", "stats", "containerNames", "Object", "keys", "containerName", "Skip", "metadata", "field", "created", "continue", "containerStats"], "doc_head": "\treturn useMemo(() => {\n\t\tconst configs = {\n\t\t\tcpu: {} as ChartConfig,\n\t\t\tmemory: {} as ChartConfig,\n\t\t\tnetwork: {} as ChartConfig,\n\t\t}\n\t\t// Aggregate usage metrics for each container\n\t\tconst totalUsage = {\n\t\t\tcpu: new Map<string, number>(),\n\t\t\tmemory: new Map<string, number>(),\n\t\t\tnetwork: new Map<string, number>(),\n\t\t}\n\t\t// Process each data point to calculate totals\n\t\tfor (let i = 0; i < containerData.length; i++) {\n\t\t\tconst stats = containerData[i]\n\t\t\tconst containerNames = Object.keys(stats)\n\t\t\tfor (let j = 0; j < containerNames.length; j++) {\n\t\t\t\tconst containerName = containerNames[j]\n\t\t\t\t// Skip metadata field\n\t\t\t\tif (containerName === \"created\") {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst containerStats = stats[containerName]"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/hooks.ts#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/hooks.ts", "rel_path": "src/site/src/components/charts/hooks.ts", "ext": "ts", "language": "typescript", "chunk_number": 3, "start_line": 45, "end_line": 61, "text": "\t\t\t\tif (!containerStats) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Accumulate metrics for CPU, memory, and network\n\t\t\t\tconst currentCpu = totalUsage.cpu.get(containerName) ?? 0\n\t\t\t\tconst currentMemory = totalUsage.memory.get(containerName) ?? 0\n\t\t\t\tconst currentNetwork = totalUsage.network.get(containerName) ?? 0\n\n\t\t\t\ttotalUsage.cpu.set(containerName, currentCpu + (containerStats.c ?? 0))\n\t\t\t\ttotalUsage.memory.set(containerName, currentMemory + (containerStats.m ?? 0))\n\t\t\t\ttotalUsage.network.set(containerName, currentNetwork + (containerStats.nr ?? 0) + (containerStats.ns ?? 0))\n\t\t\t}\n\t\t}\n\n\t\t// Generate chart configurations for each metric type\n\t\tObject.entries(totalUsage).forEach(([chartType, usageMap]) => {", "n_tokens": 176, "primary_symbol": "", "primary_kind": "", "primary_span": [45, 61], "def_symbols": [], "symbols": ["containerStats", "continue", "Accumulate", "metrics", "for", "CPU", "memory", "and", "network", "const", "currentCpu", "totalUsage", "cpu", "get", "containerName", "currentMemory", "currentNetwork", "set", "Generate", "chart", "configurations", "each", "metric", "type", "Object", "entries", "forEach", "chartType", "usageMap"], "doc_head": "\t\t\t\tif (!containerStats) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// Accumulate metrics for CPU, memory, and network\n\t\t\t\tconst currentCpu = totalUsage.cpu.get(containerName) ?? 0\n\t\t\t\tconst currentMemory = totalUsage.memory.get(containerName) ?? 0\n\t\t\t\tconst currentNetwork = totalUsage.network.get(containerName) ?? 0\n\t\t\t\ttotalUsage.cpu.set(containerName, currentCpu + (containerStats.c ?? 0))\n\t\t\t\ttotalUsage.memory.set(containerName, currentMemory + (containerStats.m ?? 0))\n\t\t\t\ttotalUsage.network.set(containerName, currentNetwork + (containerStats.nr ?? 0) + (containerStats.ns ?? 0))\n\t\t\t}\n\t\t}\n\t\t// Generate chart configurations for each metric type\n\t\tObject.entries(totalUsage).forEach(([chartType, usageMap]) => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/hooks.ts#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/hooks.ts", "rel_path": "src/site/src/components/charts/hooks.ts", "ext": "ts", "language": "typescript", "chunk_number": 4, "start_line": 62, "end_line": 82, "text": "\t\t\tconst sortedContainers = Array.from(usageMap.entries()).sort(([, a], [, b]) => b - a)\n\t\t\tconst chartConfig = {} as Record<string, { label: string; color: string }>\n\t\t\tconst count = sortedContainers.length\n\n\t\t\t// Generate colors for each container\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst [containerName] = sortedContainers[i]\n\t\t\t\tconst hue = ((i * 360) / count) % 360\n\t\t\t\tchartConfig[containerName] = {\n\t\t\t\t\tlabel: containerName,\n\t\t\t\t\tcolor: `hsl(${hue}, 60%, 55%)`,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconfigs[chartType as keyof typeof configs] = chartConfig\n\t\t})\n\n\t\treturn configs\n\t}, [containerData])\n}\n", "n_tokens": 172, "primary_symbol": "hue", "primary_kind": "function", "primary_span": [62, 82], "def_symbols": ["hue"], "symbols": ["hue", "const", "sortedContainers", "Array", "from", "usageMap", "entries", "sort", "chartConfig", "Record", "string", "label", "color", "count", "length", "Generate", "colors", "for", "each", "container", "let", "containerName", "hsl", "configs", "chartType", "keyof", "typeof", "return", "containerData"], "doc_head": "\t\t\tconst sortedContainers = Array.from(usageMap.entries()).sort(([, a], [, b]) => b - a)\n\t\t\tconst chartConfig = {} as Record<string, { label: string; color: string }>\n\t\t\tconst count = sortedContainers.length\n\t\t\t// Generate colors for each container\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst [containerName] = sortedContainers[i]\n\t\t\t\tconst hue = ((i * 360) / count) % 360\n\t\t\t\tchartConfig[containerName] = {\n\t\t\t\t\tlabel: containerName,\n\t\t\t\t\tcolor: `hsl(${hue}, 60%, 55%)`,\n\t\t\t\t}\n\t\t\t}\n\t\t\tconfigs[chartType as keyof typeof configs] = chartConfig\n\t\t})\n\t\treturn configs\n\t}, [containerData])\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/hooks.ts#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/charts/hooks.ts", "rel_path": "src/site/src/components/charts/hooks.ts", "ext": "ts", "language": "typescript", "chunk_number": 5, "start_line": 83, "end_line": 108, "text": "/** Sets the correct width of the y axis in recharts based on the longest label */\nexport function useYAxisWidth() {\n\tconst [yAxisWidth, setYAxisWidth] = useState(0)\n\tlet maxChars = 0\n\tlet timeout: ReturnType<typeof setTimeout>\n\tfunction updateYAxisWidth(str: string) {\n\t\tif (str.length > maxChars) {\n\t\t\tmaxChars = str.length\n\t\t\tconst div = document.createElement(\"div\")\n\t\t\tdiv.className = \"text-xs tabular-nums tracking-tighter table sr-only\"\n\t\t\tdiv.innerHTML = str\n\t\t\tclearTimeout(timeout)\n\t\t\ttimeout = setTimeout(() => {\n\t\t\t\tdocument.body.appendChild(div)\n\t\t\t\tconst width = div.offsetWidth + 24\n\t\t\t\tif (width > yAxisWidth) {\n\t\t\t\t\tsetYAxisWidth(div.offsetWidth + 24)\n\t\t\t\t}\n\t\t\t\tdocument.body.removeChild(div)\n\t\t\t})\n\t\t}\n\t\treturn str\n\t}\n\treturn { yAxisWidth, updateYAxisWidth }\n}\n", "n_tokens": 196, "primary_symbol": "useYAxisWidth", "primary_kind": "function", "primary_span": [84, 108], "def_symbols": ["useYAxisWidth", "updateYAxisWidth"], "symbols": ["useYAxisWidth", "updateYAxisWidth", "Sets", "the", "correct", "width", "axis", "recharts", "based", "longest", "label", "export", "function", "const", "yAxisWidth", "setYAxisWidth", "useState", "let", "maxChars", "timeout", "ReturnType", "typeof", "setTimeout", "str", "string", "length", "div", "document", "createElement", "className", "text", "tabular", "nums", "tracking", "tighter", "table", "only", "innerHTML", "clearTimeout", "body", "appendChild", "offsetWidth", "removeChild", "return"], "doc_head": "/** Sets the correct width of the y axis in recharts based on the longest label */\nexport function useYAxisWidth() {\n\tconst [yAxisWidth, setYAxisWidth] = useState(0)\n\tlet maxChars = 0\n\tlet timeout: ReturnType<typeof setTimeout>\n\tfunction updateYAxisWidth(str: string) {\n\t\tif (str.length > maxChars) {\n\t\t\tmaxChars = str.length\n\t\t\tconst div = document.createElement(\"div\")\n\t\t\tdiv.className = \"text-xs tabular-nums tracking-tighter table sr-only\"\n\t\t\tdiv.innerHTML = str\n\t\t\tclearTimeout(timeout)\n\t\t\ttimeout = setTimeout(() => {\n\t\t\t\tdocument.body.appendChild(div)\n\t\t\t\tconst width = div.offsetWidth + 24\n\t\t\t\tif (width > yAxisWidth) {\n\t\t\t\t\tsetYAxisWidth(div.offsetWidth + 24)\n\t\t\t\t}\n\t\t\t\tdocument.body.removeChild(div)\n\t\t\t})\n\t\t}\n\t\treturn str\n\t}\n\treturn { yAxisWidth, updateYAxisWidth }\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alert-button.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alert-button.tsx", "rel_path": "src/site/src/components/alerts/alert-button.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 20, "text": "import { t } from \"@lingui/core/macro\"\nimport { memo, useMemo, useState } from \"react\"\nimport { useStore } from \"@nanostores/react\"\nimport { $alerts } from \"@/lib/stores\"\nimport { BellIcon } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { SystemRecord } from \"@/types\"\nimport { AlertDialogContent } from \"./alerts-sheet\"\nimport { Sheet, SheetContent, SheetTrigger } from \"@/components/ui/sheet\"\n\nexport default memo(function AlertsButton({ system }: { system: SystemRecord }) {\n\tconst [opened, setOpened] = useState(false)\n\tconst alerts = useStore($alerts)\n\n\tconst hasSystemAlert = alerts[system.id]?.size > 0\n\treturn useMemo(\n\t\t() => (\n\t\t\t<Sheet>\n\t\t\t\t<SheetTrigger asChild>", "n_tokens": 185, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 20], "def_symbols": [], "symbols": ["import", "from", "lingui", "core", "macro", "memo", "useMemo", "useState", "react", "useStore", "nanostores", "alerts", "lib", "stores", "BellIcon", "lucide", "utils", "Button", "components", "button", "SystemRecord", "types", "AlertDialogContent", "sheet", "Sheet", "SheetContent", "SheetTrigger", "export", "default", "function", "AlertsButton", "system", "const", "opened", "setOpened", "false", "hasSystemAlert", "size", "return", "asChild"], "doc_head": "import { t } from \"@lingui/core/macro\"\nimport { memo, useMemo, useState } from \"react\"\nimport { useStore } from \"@nanostores/react\"\nimport { $alerts } from \"@/lib/stores\"\nimport { BellIcon } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { SystemRecord } from \"@/types\"\nimport { AlertDialogContent } from \"./alerts-sheet\"\nimport { Sheet, SheetContent, SheetTrigger } from \"@/components/ui/sheet\"\nexport default memo(function AlertsButton({ system }: { system: SystemRecord }) {\n\tconst [opened, setOpened] = useState(false)\n\tconst alerts = useStore($alerts)\n\tconst hasSystemAlert = alerts[system.id]?.size > 0\n\treturn useMemo(\n\t\t() => (\n\t\t\t<Sheet>\n\t\t\t\t<SheetTrigger asChild>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alert-button.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alert-button.tsx", "rel_path": "src/site/src/components/alerts/alert-button.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 21, "end_line": 37, "text": "\t\t\t\t\t<Button variant=\"ghost\" size=\"icon\" aria-label={t`Alerts`} data-nolink onClick={() => setOpened(true)}>\n\t\t\t\t\t\t<BellIcon\n\t\t\t\t\t\t\tclassName={cn(\"h-[1.2em] w-[1.2em] pointer-events-none\", {\n\t\t\t\t\t\t\t\t\"fill-primary\": hasSystemAlert,\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</Button>\n\t\t\t\t</SheetTrigger>\n\t\t\t\t<SheetContent className=\"max-h-full overflow-auto w-145 !max-w-full p-4 sm:p-6\">\n\t\t\t\t\t{opened && <AlertDialogContent system={system} />}\n\t\t\t\t</SheetContent>\n\t\t\t</Sheet>\n\t\t),\n\t\t[opened, hasSystemAlert]\n\t)\n})\n", "n_tokens": 153, "primary_symbol": "", "primary_kind": "", "primary_span": [21, 37], "def_symbols": [], "symbols": ["Button", "variant", "ghost", "size", "icon", "aria", "label", "Alerts", "data", "nolink", "onClick", "setOpened", "true", "BellIcon", "className", "pointer", "events", "none", "fill", "primary", "hasSystemAlert", "SheetTrigger", "SheetContent", "max", "full", "overflow", "auto", "opened", "AlertDialogContent", "system", "Sheet"], "doc_head": "\t\t\t\t\t<Button variant=\"ghost\" size=\"icon\" aria-label={t`Alerts`} data-nolink onClick={() => setOpened(true)}>\n\t\t\t\t\t\t<BellIcon\n\t\t\t\t\t\t\tclassName={cn(\"h-[1.2em] w-[1.2em] pointer-events-none\", {\n\t\t\t\t\t\t\t\t\"fill-primary\": hasSystemAlert,\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</Button>\n\t\t\t\t</SheetTrigger>\n\t\t\t\t<SheetContent className=\"max-h-full overflow-auto w-145 !max-w-full p-4 sm:p-6\">\n\t\t\t\t\t{opened && <AlertDialogContent system={system} />}\n\t\t\t\t</SheetContent>\n\t\t\t</Sheet>\n\t\t),\n\t\t[opened, hasSystemAlert]\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 14, "text": "import { t } from \"@lingui/core/macro\"\nimport { Trans, Plural } from \"@lingui/react/macro\"\nimport { $alerts, $systems } from \"@/lib/stores\"\nimport { cn, debounce } from \"@/lib/utils\"\nimport { alertInfo } from \"@/lib/alerts\"\nimport { Switch } from \"@/components/ui/switch\"\nimport { AlertInfo, AlertRecord, SystemRecord } from \"@/types\"\nimport { lazy, memo, Suspense, useMemo, useState } from \"react\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport { useStore } from \"@nanostores/react\"\nimport { getPagePath } from \"@nanostores/router\"\nimport { Checkbox } from \"@/components/ui/checkbox\"\nimport { DialogTitle, DialogDescription } from \"@/components/ui/dialog\"\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from \"@/components/ui/tabs\"", "n_tokens": 186, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 14], "def_symbols": [], "symbols": ["import", "from", "lingui", "core", "macro", "Trans", "Plural", "react", "alerts", "systems", "lib", "stores", "debounce", "utils", "alertInfo", "Switch", "components", "switch", "AlertInfo", "AlertRecord", "SystemRecord", "types", "lazy", "memo", "Suspense", "useMemo", "useState", "toast", "use", "useStore", "nanostores", "getPagePath", "router", "Checkbox", "checkbox", "DialogTitle", "DialogDescription", "dialog", "Tabs", "TabsList", "TabsTrigger", "TabsContent", "tabs"], "doc_head": "import { t } from \"@lingui/core/macro\"\nimport { Trans, Plural } from \"@lingui/react/macro\"\nimport { $alerts, $systems } from \"@/lib/stores\"\nimport { cn, debounce } from \"@/lib/utils\"\nimport { alertInfo } from \"@/lib/alerts\"\nimport { Switch } from \"@/components/ui/switch\"\nimport { AlertInfo, AlertRecord, SystemRecord } from \"@/types\"\nimport { lazy, memo, Suspense, useMemo, useState } from \"react\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport { useStore } from \"@nanostores/react\"\nimport { getPagePath } from \"@nanostores/router\"\nimport { Checkbox } from \"@/components/ui/checkbox\"\nimport { DialogTitle, DialogDescription } from \"@/components/ui/dialog\"\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from \"@/components/ui/tabs\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 15, "end_line": 39, "text": "import { ServerIcon, GlobeIcon } from \"lucide-react\"\nimport { $router, Link } from \"@/components/router\"\nimport { DialogHeader } from \"@/components/ui/dialog\"\nimport { pb } from \"@/lib/api\"\n\nconst Slider = lazy(() => import(\"@/components/ui/slider\"))\n\nconst endpoint = \"/api/beszel/user-alerts\"\n\nconst alertDebounce = 100\n\nconst alertKeys = Object.keys(alertInfo) as (keyof typeof alertInfo)[]\n\nconst failedUpdateToast = (error: unknown) => {\n\tconsole.error(error)\n\ttoast({\n\t\ttitle: t`Failed to update alert`,\n\t\tdescription: t`Please check logs for more details.`,\n\t\tvariant: \"destructive\",\n\t})\n}\n\n/** Create or update alerts for a given name and systems */\nconst upsertAlerts = debounce(\n\tasync ({ name, value, min, systems }: { name: string; value: number; min: number; systems: string[] }) => {", "n_tokens": 201, "primary_symbol": "failedUpdateToast", "primary_kind": "function", "primary_span": [15, 39], "def_symbols": ["failedUpdateToast"], "symbols": ["failedUpdateToast", "import", "ServerIcon", "GlobeIcon", "from", "lucide", "react", "router", "Link", "components", "DialogHeader", "dialog", "lib", "api", "const", "Slider", "lazy", "slider", "endpoint", "beszel", "user", "alerts", "alertDebounce", "alertKeys", "Object", "keys", "alertInfo", "keyof", "typeof", "error", "unknown", "console", "toast", "title", "Failed", "update", "alert", "description", "Please", "check", "logs", "for", "more", "details", "variant", "destructive", "Create", "given", "name", "and", "systems", "upsertAlerts", "debounce", "async", "value", "min", "string", "number"], "doc_head": "import { ServerIcon, GlobeIcon } from \"lucide-react\"\nimport { $router, Link } from \"@/components/router\"\nimport { DialogHeader } from \"@/components/ui/dialog\"\nimport { pb } from \"@/lib/api\"\nconst Slider = lazy(() => import(\"@/components/ui/slider\"))\nconst endpoint = \"/api/beszel/user-alerts\"\nconst alertDebounce = 100\nconst alertKeys = Object.keys(alertInfo) as (keyof typeof alertInfo)[]\nconst failedUpdateToast = (error: unknown) => {\n\tconsole.error(error)\n\ttoast({\n\t\ttitle: t`Failed to update alert`,\n\t\tdescription: t`Please check logs for more details.`,\n\t\tvariant: \"destructive\",\n\t})\n}\n/** Create or update alerts for a given name and systems */\nconst upsertAlerts = debounce(\n\tasync ({ name, value, min, systems }: { name: string; value: number; min: number; systems: string[] }) => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 40, "end_line": 64, "text": "\t\ttry {\n\t\t\tawait pb.send<{ success: boolean }>(endpoint, {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\t// overwrite is always true because we've done filtering client side\n\t\t\t\tbody: { name, value, min, systems, overwrite: true },\n\t\t\t})\n\t\t} catch (error) {\n\t\t\tfailedUpdateToast(error)\n\t\t}\n\t},\n\talertDebounce\n)\n\n/** Delete alerts for a given name and systems */\nconst deleteAlerts = debounce(async ({ name, systems }: { name: string; systems: string[] }) => {\n\ttry {\n\t\tawait pb.send<{ success: boolean }>(endpoint, {\n\t\t\tmethod: \"DELETE\",\n\t\t\tbody: { name, systems },\n\t\t})\n\t} catch (error) {\n\t\tfailedUpdateToast(error)\n\t}\n}, alertDebounce)\n", "n_tokens": 168, "primary_symbol": "", "primary_kind": "", "primary_span": [40, 64], "def_symbols": [], "symbols": ["try", "await", "send", "success", "boolean", "endpoint", "method", "POST", "overwrite", "always", "true", "because", "done", "filtering", "client", "side", "body", "name", "value", "min", "systems", "catch", "error", "failedUpdateToast", "alertDebounce", "Delete", "alerts", "for", "given", "and", "const", "deleteAlerts", "debounce", "async", "string", "DELETE"], "doc_head": "\t\ttry {\n\t\t\tawait pb.send<{ success: boolean }>(endpoint, {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\t// overwrite is always true because we've done filtering client side\n\t\t\t\tbody: { name, value, min, systems, overwrite: true },\n\t\t\t})\n\t\t} catch (error) {\n\t\t\tfailedUpdateToast(error)\n\t\t}\n\t},\n\talertDebounce\n)\n/** Delete alerts for a given name and systems */\nconst deleteAlerts = debounce(async ({ name, systems }: { name: string; systems: string[] }) => {\n\ttry {\n\t\tawait pb.send<{ success: boolean }>(endpoint, {\n\t\t\tmethod: \"DELETE\",\n\t\t\tbody: { name, systems },\n\t\t})\n\t} catch (error) {\n\t\tfailedUpdateToast(error)\n\t}\n}, alertDebounce)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 65, "end_line": 71, "text": "export const AlertDialogContent = memo(function AlertDialogContent({ system }: { system: SystemRecord }) {\n\tconst alerts = useStore($alerts)\n\tconst [overwriteExisting, setOverwriteExisting] = useState<boolean | \"indeterminate\">(false)\n\tconst [currentTab, setCurrentTab] = useState(\"system\")\n\n\tconst systemAlerts = alerts[system.id] ?? new Map()\n", "n_tokens": 74, "primary_symbol": "", "primary_kind": "", "primary_span": [65, 71], "def_symbols": [], "symbols": ["export", "const", "AlertDialogContent", "memo", "function", "system", "SystemRecord", "alerts", "useStore", "overwriteExisting", "setOverwriteExisting", "useState", "boolean", "indeterminate", "false", "currentTab", "setCurrentTab", "systemAlerts", "new", "Map"], "doc_head": "export const AlertDialogContent = memo(function AlertDialogContent({ system }: { system: SystemRecord }) {\n\tconst alerts = useStore($alerts)\n\tconst [overwriteExisting, setOverwriteExisting] = useState<boolean | \"indeterminate\">(false)\n\tconst [currentTab, setCurrentTab] = useState(\"system\")\n\tconst systemAlerts = alerts[system.id] ?? new Map()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 72, "end_line": 107, "text": "\t// We need to keep a copy of alerts when we switch to global tab. If we always compare to\n\t// current alerts, it will only be updated when first checked, then won't be updated because\n\t// after that it exists.\n\tconst alertsWhenGlobalSelected = useMemo(() => {\n\t\treturn currentTab === \"global\" ? structuredClone(alerts) : alerts\n\t}, [currentTab])\n\n\treturn (\n\t\t<>\n\t\t\t<DialogHeader>\n\t\t\t\t<DialogTitle className=\"text-xl\">\n\t\t\t\t\t<Trans>Alerts</Trans>\n\t\t\t\t</DialogTitle>\n\t\t\t\t<DialogDescription>\n\t\t\t\t\t<Trans>\n\t\t\t\t\t\tSee{\" \"}\n\t\t\t\t\t\t<Link href={getPagePath($router, \"settings\", { name: \"notifications\" })} className=\"link\">\n\t\t\t\t\t\t\tnotification settings\n\t\t\t\t\t\t</Link>{\" \"}\n\t\t\t\t\t\tto configure how you receive alerts.\n\t\t\t\t\t</Trans>\n\t\t\t\t</DialogDescription>\n\t\t\t</DialogHeader>\n\t\t\t<Tabs defaultValue=\"system\" onValueChange={setCurrentTab}>\n\t\t\t\t<TabsList className=\"mb-1 -mt-0.5\">\n\t\t\t\t\t<TabsTrigger value=\"system\">\n\t\t\t\t\t\t<ServerIcon className=\"me-2 h-3.5 w-3.5\" />\n\t\t\t\t\t\t<span className=\"truncate max-w-60\">{system.name}</span>\n\t\t\t\t\t</TabsTrigger>\n\t\t\t\t\t<TabsTrigger value=\"global\">\n\t\t\t\t\t\t<GlobeIcon className=\"me-1.5 h-3.5 w-3.5\" />\n\t\t\t\t\t\t<Trans>All Systems</Trans>\n\t\t\t\t\t</TabsTrigger>\n\t\t\t\t</TabsList>\n\t\t\t\t<TabsContent value=\"system\">\n\t\t\t\t\t<div className=\"grid gap-3\">", "n_tokens": 354, "primary_symbol": "", "primary_kind": "", "primary_span": [72, 107], "def_symbols": [], "symbols": ["need", "keep", "copy", "alerts", "when", "switch", "global", "tab", "always", "compare", "current", "will", "only", "updated", "first", "checked", "then", "won", "because", "after", "that", "exists", "const", "alertsWhenGlobalSelected", "useMemo", "return", "currentTab", "structuredClone", "DialogHeader", "DialogTitle", "className", "text", "Trans", "Alerts", "DialogDescription", "See", "Link", "href", "getPagePath", "router", "settings", "name", "notifications", "link", "notification", "configure", "how", "you", "receive", "Tabs", "defaultValue", "system", "onValueChange", "setCurrentTab", "TabsList", "TabsTrigger", "value", "ServerIcon", "span", "truncate", "max", "GlobeIcon", "All", "Systems", "TabsContent", "div", "grid", "gap"], "doc_head": "\t// We need to keep a copy of alerts when we switch to global tab. If we always compare to\n\t// current alerts, it will only be updated when first checked, then won't be updated because\n\t// after that it exists.\n\tconst alertsWhenGlobalSelected = useMemo(() => {\n\t\treturn currentTab === \"global\" ? structuredClone(alerts) : alerts\n\t}, [currentTab])\n\treturn (\n\t\t<>\n\t\t\t<DialogHeader>\n\t\t\t\t<DialogTitle className=\"text-xl\">\n\t\t\t\t\t<Trans>Alerts</Trans>\n\t\t\t\t</DialogTitle>\n\t\t\t\t<DialogDescription>\n\t\t\t\t\t<Trans>\n\t\t\t\t\t\tSee{\" \"}\n\t\t\t\t\t\t<Link href={getPagePath($router, \"settings\", { name: \"notifications\" })} className=\"link\">\n\t\t\t\t\t\t\tnotification settings\n\t\t\t\t\t\t</Link>{\" \"}\n\t\t\t\t\t\tto configure how you receive alerts.\n\t\t\t\t\t</Trans>\n\t\t\t\t</DialogDescription>\n\t\t\t</DialogHeader>\n\t\t\t<Tabs defaultValue=\"system\" onValueChange={setCurrentTab}>\n\t\t\t\t<TabsList className=\"mb-1 -mt-0.5\">\n\t\t\t\t\t<TabsTrigger value=\"system\">\n\t\t\t\t\t\t<ServerIcon className=\"me-2 h-3.5 w-3.5\" />\n\t\t\t\t\t\t<span className=\"truncate max-w-60\">{system.name}</span>\n\t\t\t\t\t</TabsTrigger>\n\t\t\t\t\t<TabsTrigger value=\"global\">\n\t\t\t\t\t\t<GlobeIcon className=\"me-1.5 h-3.5 w-3.5\" />\n\t\t\t\t\t\t<Trans>All Systems</Trans>\n\t\t\t\t\t</TabsTrigger>\n\t\t\t\t</TabsList>\n\t\t\t\t<TabsConten"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 108, "end_line": 132, "text": "\t\t\t\t\t\t{alertKeys.map((name) => (\n\t\t\t\t\t\t\t<AlertContent\n\t\t\t\t\t\t\t\tkey={name}\n\t\t\t\t\t\t\t\talertKey={name}\n\t\t\t\t\t\t\t\tdata={alertInfo[name as keyof typeof alertInfo]}\n\t\t\t\t\t\t\t\talert={systemAlerts.get(name)}\n\t\t\t\t\t\t\t\tsystem={system}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t</TabsContent>\n\t\t\t\t<TabsContent value=\"global\">\n\t\t\t\t\t<label\n\t\t\t\t\t\thtmlFor=\"ovw\"\n\t\t\t\t\t\tclassName=\"mb-3 flex gap-2 items-center justify-center cursor-pointer border rounded-sm py-3 px-4 border-destructive text-destructive font-semibold text-sm\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<Checkbox\n\t\t\t\t\t\t\tid=\"ovw\"\n\t\t\t\t\t\t\tclassName=\"text-destructive border-destructive data-[state=checked]:bg-destructive\"\n\t\t\t\t\t\t\tchecked={overwriteExisting}\n\t\t\t\t\t\t\tonCheckedChange={setOverwriteExisting}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<Trans>Overwrite existing alerts</Trans>\n\t\t\t\t\t</label>\n\t\t\t\t\t<div className=\"grid gap-3\">", "n_tokens": 207, "primary_symbol": "", "primary_kind": "", "primary_span": [108, 132], "def_symbols": [], "symbols": ["alertKeys", "map", "name", "AlertContent", "key", "alertKey", "data", "alertInfo", "keyof", "typeof", "alert", "systemAlerts", "get", "system", "div", "TabsContent", "value", "global", "label", "htmlFor", "ovw", "className", "flex", "gap", "items", "center", "justify", "cursor", "pointer", "border", "rounded", "destructive", "text", "font", "semibold", "Checkbox", "state", "checked", "overwriteExisting", "onCheckedChange", "setOverwriteExisting", "Trans", "Overwrite", "existing", "alerts", "grid"], "doc_head": "\t\t\t\t\t\t{alertKeys.map((name) => (\n\t\t\t\t\t\t\t<AlertContent\n\t\t\t\t\t\t\t\tkey={name}\n\t\t\t\t\t\t\t\talertKey={name}\n\t\t\t\t\t\t\t\tdata={alertInfo[name as keyof typeof alertInfo]}\n\t\t\t\t\t\t\t\talert={systemAlerts.get(name)}\n\t\t\t\t\t\t\t\tsystem={system}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t</TabsContent>\n\t\t\t\t<TabsContent value=\"global\">\n\t\t\t\t\t<label\n\t\t\t\t\t\thtmlFor=\"ovw\"\n\t\t\t\t\t\tclassName=\"mb-3 flex gap-2 items-center justify-center cursor-pointer border rounded-sm py-3 px-4 border-destructive text-destructive font-semibold text-sm\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<Checkbox\n\t\t\t\t\t\t\tid=\"ovw\"\n\t\t\t\t\t\t\tclassName=\"text-destructive border-destructive data-[state=checked]:bg-destructive\"\n\t\t\t\t\t\t\tchecked={overwriteExisting}\n\t\t\t\t\t\t\tonCheckedChange={setOverwriteExisting}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<Trans>Overwrite existing alerts</Trans>\n\t\t\t\t\t</label>\n\t\t\t\t\t<div className=\"grid gap-3\">"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 133, "end_line": 167, "text": "\t\t\t\t\t\t{alertKeys.map((name) => (\n\t\t\t\t\t\t\t<AlertContent\n\t\t\t\t\t\t\t\tkey={name}\n\t\t\t\t\t\t\t\talertKey={name}\n\t\t\t\t\t\t\t\tsystem={system}\n\t\t\t\t\t\t\t\talert={systemAlerts.get(name)}\n\t\t\t\t\t\t\t\tdata={alertInfo[name as keyof typeof alertInfo]}\n\t\t\t\t\t\t\t\tglobal={true}\n\t\t\t\t\t\t\t\toverwriteExisting={!!overwriteExisting}\n\t\t\t\t\t\t\t\tinitialAlertsState={alertsWhenGlobalSelected}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t</TabsContent>\n\t\t\t</Tabs>\n\t\t</>\n\t)\n})\n\nexport function AlertContent({\n\talertKey,\n\tdata: alertData,\n\tsystem,\n\talert,\n\tglobal = false,\n\toverwriteExisting = false,\n\tinitialAlertsState = {},\n}: {\n\talertKey: string\n\tdata: AlertInfo\n\tsystem: SystemRecord\n\talert?: AlertRecord\n\tglobal?: boolean\n\toverwriteExisting?: boolean\n\tinitialAlertsState?: Record<string, Map<string, AlertRecord>>", "n_tokens": 187, "primary_symbol": "AlertContent", "primary_kind": "function", "primary_span": [152, 167], "def_symbols": ["AlertContent"], "symbols": ["AlertContent", "alertKeys", "map", "name", "key", "alertKey", "system", "alert", "systemAlerts", "get", "data", "alertInfo", "keyof", "typeof", "global", "true", "overwriteExisting", "initialAlertsState", "alertsWhenGlobalSelected", "div", "TabsContent", "Tabs", "export", "function", "alertData", "false", "string", "AlertInfo", "SystemRecord", "AlertRecord", "boolean", "Record", "Map"], "doc_head": "\t\t\t\t\t\t{alertKeys.map((name) => (\n\t\t\t\t\t\t\t<AlertContent\n\t\t\t\t\t\t\t\tkey={name}\n\t\t\t\t\t\t\t\talertKey={name}\n\t\t\t\t\t\t\t\tsystem={system}\n\t\t\t\t\t\t\t\talert={systemAlerts.get(name)}\n\t\t\t\t\t\t\t\tdata={alertInfo[name as keyof typeof alertInfo]}\n\t\t\t\t\t\t\t\tglobal={true}\n\t\t\t\t\t\t\t\toverwriteExisting={!!overwriteExisting}\n\t\t\t\t\t\t\t\tinitialAlertsState={alertsWhenGlobalSelected}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t</TabsContent>\n\t\t\t</Tabs>\n\t\t</>\n\t)\n})\nexport function AlertContent({\n\talertKey,\n\tdata: alertData,\n\tsystem,\n\talert,\n\tglobal = false,\n\toverwriteExisting = false,\n\tinitialAlertsState = {},\n}: {\n\talertKey: string\n\tdata: AlertInfo\n\tsystem: SystemRecord\n\talert?: AlertRecord\n\tglobal?: boolean\n\toverwriteExisting?: boolean\n\tinitialAlertsState?: Record<string, Map<string, AlertRecord>>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 168, "end_line": 189, "text": "}) {\n\tconst { name } = alertData\n\n\tconst singleDescription = alertData.singleDesc?.()\n\n\tconst [checked, setChecked] = useState(global ? false : !!alert)\n\tconst [min, setMin] = useState(alert?.min || 10)\n\tconst [value, setValue] = useState(alert?.value || (singleDescription ? 0 : alertData.start ?? 80))\n\n\tconst Icon = alertData.icon\n\n\t/** Get system ids to update */\n\tfunction getSystemIds(): string[] {\n\t\t// if not global, update only the current system\n\t\tif (!global) {\n\t\t\treturn [system.id]\n\t\t}\n\t\t// if global, update all systems when overwriteExisting is true\n\t\t// update only systems without an existing alert when overwriteExisting is false\n\t\tconst allSystems = $systems.get()\n\t\tconst systemIds: string[] = []\n\t\tfor (const system of allSystems) {", "n_tokens": 188, "primary_symbol": "getSystemIds", "primary_kind": "function", "primary_span": [180, 189], "def_symbols": ["getSystemIds"], "symbols": ["getSystemIds", "const", "name", "alertData", "singleDescription", "singleDesc", "checked", "setChecked", "useState", "global", "false", "alert", "min", "setMin", "value", "setValue", "start", "Icon", "icon", "Get", "system", "ids", "update", "function", "string", "not", "only", "the", "current", "return", "all", "systems", "when", "overwriteExisting", "true", "without", "existing", "allSystems", "get", "systemIds", "for"], "doc_head": "}) {\n\tconst { name } = alertData\n\tconst singleDescription = alertData.singleDesc?.()\n\tconst [checked, setChecked] = useState(global ? false : !!alert)\n\tconst [min, setMin] = useState(alert?.min || 10)\n\tconst [value, setValue] = useState(alert?.value || (singleDescription ? 0 : alertData.start ?? 80))\n\tconst Icon = alertData.icon\n\t/** Get system ids to update */\n\tfunction getSystemIds(): string[] {\n\t\t// if not global, update only the current system\n\t\tif (!global) {\n\t\t\treturn [system.id]\n\t\t}\n\t\t// if global, update all systems when overwriteExisting is true\n\t\t// update only systems without an existing alert when overwriteExisting is false\n\t\tconst allSystems = $systems.get()\n\t\tconst systemIds: string[] = []\n\t\tfor (const system of allSystems) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 190, "end_line": 196, "text": "\t\t\tif (overwriteExisting || !initialAlertsState[system.id]?.has(alertKey)) {\n\t\t\t\tsystemIds.push(system.id)\n\t\t\t}\n\t\t}\n\t\treturn systemIds\n\t}\n", "n_tokens": 40, "primary_symbol": "", "primary_kind": "", "primary_span": [190, 196], "def_symbols": [], "symbols": ["overwriteExisting", "initialAlertsState", "system", "has", "alertKey", "systemIds", "push", "return"], "doc_head": "\t\t\tif (overwriteExisting || !initialAlertsState[system.id]?.has(alertKey)) {\n\t\t\t\tsystemIds.push(system.id)\n\t\t\t}\n\t\t}\n\t\treturn systemIds\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 197, "end_line": 224, "text": "\tfunction sendUpsert(min: number, value: number) {\n\t\tconst systems = getSystemIds()\n\t\tsystems.length &&\n\t\t\tupsertAlerts({\n\t\t\t\tname: alertKey,\n\t\t\t\tvalue,\n\t\t\t\tmin,\n\t\t\t\tsystems,\n\t\t\t})\n\t}\n\n\treturn (\n\t\t<div className=\"rounded-lg border border-muted-foreground/15 hover:border-muted-foreground/20 transition-colors duration-100 group\">\n\t\t\t<label\n\t\t\t\thtmlFor={`s${name}`}\n\t\t\t\tclassName={cn(\"flex flex-row items-center justify-between gap-4 cursor-pointer p-4\", {\n\t\t\t\t\t\"pb-0\": checked,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<div className=\"grid gap-1 select-none\">\n\t\t\t\t\t<p className=\"font-semibold flex gap-3 items-center\">\n\t\t\t\t\t\t<Icon className=\"h-4 w-4 opacity-85\" /> {alertData.name()}\n\t\t\t\t\t</p>\n\t\t\t\t\t{!checked && <span className=\"block text-sm text-muted-foreground\">{alertData.desc()}</span>}\n\t\t\t\t</div>\n\t\t\t\t<Switch\n\t\t\t\t\tid={`s${name}`}\n\t\t\t\t\tchecked={checked}", "n_tokens": 233, "primary_symbol": "sendUpsert", "primary_kind": "function", "primary_span": [197, 224], "def_symbols": ["sendUpsert"], "symbols": ["sendUpsert", "function", "min", "number", "value", "const", "systems", "getSystemIds", "length", "upsertAlerts", "name", "alertKey", "return", "div", "className", "rounded", "border", "muted", "foreground", "hover", "transition", "colors", "duration", "group", "label", "htmlFor", "flex", "row", "items", "center", "justify", "between", "gap", "cursor", "pointer", "checked", "grid", "select", "none", "font", "semibold", "Icon", "opacity", "alertData", "span", "block", "text", "desc", "Switch"], "doc_head": "\tfunction sendUpsert(min: number, value: number) {\n\t\tconst systems = getSystemIds()\n\t\tsystems.length &&\n\t\t\tupsertAlerts({\n\t\t\t\tname: alertKey,\n\t\t\t\tvalue,\n\t\t\t\tmin,\n\t\t\t\tsystems,\n\t\t\t})\n\t}\n\treturn (\n\t\t<div className=\"rounded-lg border border-muted-foreground/15 hover:border-muted-foreground/20 transition-colors duration-100 group\">\n\t\t\t<label\n\t\t\t\thtmlFor={`s${name}`}\n\t\t\t\tclassName={cn(\"flex flex-row items-center justify-between gap-4 cursor-pointer p-4\", {\n\t\t\t\t\t\"pb-0\": checked,\n\t\t\t\t})}\n\t\t\t>\n\t\t\t\t<div className=\"grid gap-1 select-none\">\n\t\t\t\t\t<p className=\"font-semibold flex gap-3 items-center\">\n\t\t\t\t\t\t<Icon className=\"h-4 w-4 opacity-85\" /> {alertData.name()}\n\t\t\t\t\t</p>\n\t\t\t\t\t{!checked && <span className=\"block text-sm text-muted-foreground\">{alertData.desc()}</span>}\n\t\t\t\t</div>\n\t\t\t\t<Switch\n\t\t\t\t\tid={`s${name}`}\n\t\t\t\t\tchecked={checked}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 11, "start_line": 225, "end_line": 234, "text": "\t\t\t\t\tonCheckedChange={(newChecked) => {\n\t\t\t\t\t\tsetChecked(newChecked)\n\t\t\t\t\t\tif (newChecked) {\n\t\t\t\t\t\t\t// if alert checked, create or update alert\n\t\t\t\t\t\t\tsendUpsert(min, value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// if unchecked, delete alert (unless global and overwriteExisting is false)\n\t\t\t\t\t\t\tdeleteAlerts({ name: alertKey, systems: getSystemIds() })\n\t\t\t\t\t\t\t// when force deleting all alerts of a type, also remove them from initialAlertsState\n\t\t\t\t\t\t\tif (overwriteExisting) {", "n_tokens": 110, "primary_symbol": "", "primary_kind": "", "primary_span": [225, 234], "def_symbols": [], "symbols": ["onCheckedChange", "newChecked", "setChecked", "alert", "checked", "create", "update", "sendUpsert", "min", "value", "else", "unchecked", "delete", "unless", "global", "and", "overwriteExisting", "false", "deleteAlerts", "name", "alertKey", "systems", "getSystemIds", "when", "force", "deleting", "all", "alerts", "type", "also", "remove", "them", "from", "initialAlertsState"], "doc_head": "\t\t\t\t\tonCheckedChange={(newChecked) => {\n\t\t\t\t\t\tsetChecked(newChecked)\n\t\t\t\t\t\tif (newChecked) {\n\t\t\t\t\t\t\t// if alert checked, create or update alert\n\t\t\t\t\t\t\tsendUpsert(min, value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// if unchecked, delete alert (unless global and overwriteExisting is false)\n\t\t\t\t\t\t\tdeleteAlerts({ name: alertKey, systems: getSystemIds() })\n\t\t\t\t\t\t\t// when force deleting all alerts of a type, also remove them from initialAlertsState\n\t\t\t\t\t\t\tif (overwriteExisting) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 12, "start_line": 235, "end_line": 260, "text": "\t\t\t\t\t\t\t\tfor (const curAlerts of Object.values(initialAlertsState)) {\n\t\t\t\t\t\t\t\t\tcurAlerts.delete(alertKey)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t/>\n\t\t\t</label>\n\t\t\t{checked && (\n\t\t\t\t<div className=\"grid sm:grid-cols-2 mt-1.5 gap-5 px-4 pb-5 tabular-nums text-muted-foreground\">\n\t\t\t\t\t<Suspense fallback={<div className=\"h-10\" />}>\n\t\t\t\t\t\t{!singleDescription && (\n\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<p id={`v${name}`} className=\"text-sm block h-8\">\n\t\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\t\tAverage exceeds{\" \"}\n\t\t\t\t\t\t\t\t\t\t<strong className=\"text-foreground\">\n\t\t\t\t\t\t\t\t\t\t\t{value}\n\t\t\t\t\t\t\t\t\t\t\t{alertData.unit}\n\t\t\t\t\t\t\t\t\t\t</strong>\n\t\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t<div className=\"flex gap-3\">\n\t\t\t\t\t\t\t\t\t<Slider\n\t\t\t\t\t\t\t\t\t\taria-labelledby={`v${name}`}\n\t\t\t\t\t\t\t\t\t\tdefaultValue={[value]}", "n_tokens": 208, "primary_symbol": "", "primary_kind": "", "primary_span": [235, 260], "def_symbols": [], "symbols": ["for", "const", "curAlerts", "Object", "values", "initialAlertsState", "delete", "alertKey", "label", "checked", "div", "className", "grid", "cols", "gap", "tabular", "nums", "text", "muted", "foreground", "Suspense", "fallback", "singleDescription", "name", "block", "Trans", "Average", "exceeds", "strong", "value", "alertData", "unit", "flex", "Slider", "aria", "labelledby", "defaultValue"], "doc_head": "\t\t\t\t\t\t\t\tfor (const curAlerts of Object.values(initialAlertsState)) {\n\t\t\t\t\t\t\t\t\tcurAlerts.delete(alertKey)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t/>\n\t\t\t</label>\n\t\t\t{checked && (\n\t\t\t\t<div className=\"grid sm:grid-cols-2 mt-1.5 gap-5 px-4 pb-5 tabular-nums text-muted-foreground\">\n\t\t\t\t\t<Suspense fallback={<div className=\"h-10\" />}>\n\t\t\t\t\t\t{!singleDescription && (\n\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<p id={`v${name}`} className=\"text-sm block h-8\">\n\t\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\t\tAverage exceeds{\" \"}\n\t\t\t\t\t\t\t\t\t\t<strong className=\"text-foreground\">\n\t\t\t\t\t\t\t\t\t\t\t{value}\n\t\t\t\t\t\t\t\t\t\t\t{alertData.unit}\n\t\t\t\t\t\t\t\t\t\t</strong>\n\t\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t<div className=\"flex gap-3\">\n\t\t\t\t\t\t\t\t\t<Slider\n\t\t\t\t\t\t\t\t\t\taria-labelledby={`v${name}`}\n\t\t\t\t\t\t\t\t\t\tdefaultValue={[value]}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 13, "start_line": 261, "end_line": 261, "text": "\t\t\t\t\t\t\t\t\t\tonValueCommit={(val) => sendUpsert(min, val[0])}", "n_tokens": 18, "primary_symbol": "", "primary_kind": "", "primary_span": [261, 261], "def_symbols": [], "symbols": ["onValueCommit", "val", "sendUpsert", "min"], "doc_head": "\t\t\t\t\t\t\t\t\t\tonValueCommit={(val) => sendUpsert(min, val[0])}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 14, "start_line": 262, "end_line": 286, "text": "\t\t\t\t\t\t\t\t\t\tonValueChange={(val) => setValue(val[0])}\n\t\t\t\t\t\t\t\t\t\tstep={alertData.step ?? 1}\n\t\t\t\t\t\t\t\t\t\tmin={alertData.min ?? 1}\n\t\t\t\t\t\t\t\t\t\tmax={alertData.max ?? 99}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t<div className={cn(singleDescription && \"col-span-full lowercase\")}>\n\t\t\t\t\t\t\t<p id={`t${name}`} className=\"text-sm block h-8 first-letter:uppercase\">\n\t\t\t\t\t\t\t\t{singleDescription && (\n\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t{singleDescription}\n\t\t\t\t\t\t\t\t\t\t{` `}\n\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\tFor <strong className=\"text-foreground\">{min}</strong>{\" \"}\n\t\t\t\t\t\t\t\t\t<Plural value={min} one=\"minute\" other=\"minutes\" />\n\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t<div className=\"flex gap-3\">\n\t\t\t\t\t\t\t\t<Slider\n\t\t\t\t\t\t\t\t\taria-labelledby={`v${name}`}\n\t\t\t\t\t\t\t\t\tdefaultValue={[min]}", "n_tokens": 205, "primary_symbol": "", "primary_kind": "", "primary_span": [262, 286], "def_symbols": [], "symbols": ["onValueChange", "val", "setValue", "step", "alertData", "min", "max", "div", "className", "singleDescription", "col", "span", "full", "lowercase", "name", "text", "block", "first", "letter", "uppercase", "Trans", "For", "strong", "foreground", "Plural", "value", "one", "minute", "other", "minutes", "flex", "gap", "Slider", "aria", "labelledby", "defaultValue"], "doc_head": "\t\t\t\t\t\t\t\t\t\tonValueChange={(val) => setValue(val[0])}\n\t\t\t\t\t\t\t\t\t\tstep={alertData.step ?? 1}\n\t\t\t\t\t\t\t\t\t\tmin={alertData.min ?? 1}\n\t\t\t\t\t\t\t\t\t\tmax={alertData.max ?? 99}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t<div className={cn(singleDescription && \"col-span-full lowercase\")}>\n\t\t\t\t\t\t\t<p id={`t${name}`} className=\"text-sm block h-8 first-letter:uppercase\">\n\t\t\t\t\t\t\t\t{singleDescription && (\n\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t{singleDescription}\n\t\t\t\t\t\t\t\t\t\t{` `}\n\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\tFor <strong className=\"text-foreground\">{min}</strong>{\" \"}\n\t\t\t\t\t\t\t\t\t<Plural value={min} one=\"minute\" other=\"minutes\" />\n\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t<div className=\"flex gap-3\">\n\t\t\t\t\t\t\t\t<Slider\n\t\t\t\t\t\t\t\t\taria-labelledby={`v${name}`}\n\t\t\t\t\t\t\t\t\tdefaultValue={[min]}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/alerts/alerts-sheet.tsx", "rel_path": "src/site/src/components/alerts/alerts-sheet.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 15, "start_line": 287, "end_line": 300, "text": "\t\t\t\t\t\t\t\t\tonValueCommit={(minVal) => sendUpsert(minVal[0], value)}\n\t\t\t\t\t\t\t\t\tonValueChange={(val) => setMin(val[0])}\n\t\t\t\t\t\t\t\t\tmin={1}\n\t\t\t\t\t\t\t\t\tmax={60}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</Suspense>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t)\n}\n", "n_tokens": 79, "primary_symbol": "", "primary_kind": "", "primary_span": [287, 300], "def_symbols": [], "symbols": ["onValueCommit", "minVal", "sendUpsert", "value", "onValueChange", "val", "setMin", "min", "max", "div", "Suspense"], "doc_head": "\t\t\t\t\t\t\t\t\tonValueCommit={(minVal) => sendUpsert(minVal[0], value)}\n\t\t\t\t\t\t\t\t\tonValueChange={(val) => setMin(val[0])}\n\t\t\t\t\t\t\t\t\tmin={1}\n\t\t\t\t\t\t\t\t\tmax={60}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</Suspense>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx", "rel_path": "src/site/src/components/routes/home.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 17, "text": "import { Suspense, memo, useEffect, useMemo } from \"react\"\nimport { Card, CardContent, CardHeader, CardTitle } from \"../ui/card\"\nimport { $alerts, $allSystemsById } from \"@/lib/stores\"\nimport { useStore } from \"@nanostores/react\"\nimport { GithubIcon } from \"lucide-react\"\nimport { Separator } from \"../ui/separator\"\nimport { AlertRecord } from \"@/types\"\nimport { Alert, AlertDescription, AlertTitle } from \"@/components/ui/alert\"\nimport { $router, Link } from \"../router\"\nimport { Plural, Trans, useLingui } from \"@lingui/react/macro\"\nimport { getPagePath } from \"@nanostores/router\"\nimport { alertInfo } from \"@/lib/alerts\"\nimport SystemsTable from \"@/components/systems-table/systems-table\"\n\nexport default memo(function () {\n\tconst { t } = useLingui()\n", "n_tokens": 191, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 17], "def_symbols": [], "symbols": ["import", "Suspense", "memo", "useEffect", "useMemo", "from", "react", "Card", "CardContent", "CardHeader", "CardTitle", "card", "alerts", "allSystemsById", "lib", "stores", "useStore", "nanostores", "GithubIcon", "lucide", "Separator", "separator", "AlertRecord", "types", "Alert", "AlertDescription", "AlertTitle", "components", "alert", "router", "Link", "Plural", "Trans", "useLingui", "lingui", "macro", "getPagePath", "alertInfo", "SystemsTable", "systems", "table", "export", "default", "function", "const"], "doc_head": "import { Suspense, memo, useEffect, useMemo } from \"react\"\nimport { Card, CardContent, CardHeader, CardTitle } from \"../ui/card\"\nimport { $alerts, $allSystemsById } from \"@/lib/stores\"\nimport { useStore } from \"@nanostores/react\"\nimport { GithubIcon } from \"lucide-react\"\nimport { Separator } from \"../ui/separator\"\nimport { AlertRecord } from \"@/types\"\nimport { Alert, AlertDescription, AlertTitle } from \"@/components/ui/alert\"\nimport { $router, Link } from \"../router\"\nimport { Plural, Trans, useLingui } from \"@lingui/react/macro\"\nimport { getPagePath } from \"@nanostores/router\"\nimport { alertInfo } from \"@/lib/alerts\"\nimport SystemsTable from \"@/components/systems-table/systems-table\"\nexport default memo(function () {\n\tconst { t } = useLingui()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx", "rel_path": "src/site/src/components/routes/home.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 18, "end_line": 22, "text": "\tuseEffect(() => {\n\t\tdocument.title = t`Dashboard` + \" / Beszel\"\n\t}, [t])\n\n\treturn useMemo(", "n_tokens": 27, "primary_symbol": "", "primary_kind": "", "primary_span": [18, 22], "def_symbols": [], "symbols": ["useEffect", "document", "title", "Dashboard", "Beszel", "return", "useMemo"], "doc_head": "\tuseEffect(() => {\n\t\tdocument.title = t`Dashboard` + \" / Beszel\"\n\t}, [t])\n\treturn useMemo("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx", "rel_path": "src/site/src/components/routes/home.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 23, "end_line": 52, "text": "\t\t() => (\n\t\t\t<>\n\t\t\t\t<ActiveAlerts />\n\t\t\t\t<Suspense>\n\t\t\t\t\t<SystemsTable />\n\t\t\t\t</Suspense>\n\n\t\t\t\t<div className=\"flex gap-1.5 justify-end items-center pe-3 sm:pe-6 mt-3.5 mb-4 text-xs opacity-80\">\n\t\t\t\t\t<a\n\t\t\t\t\t\thref=\"https://github.com/henrygd/beszel\"\n\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\tclassName=\"flex items-center gap-0.5 text-muted-foreground hover:text-foreground duration-75\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<GithubIcon className=\"h-3 w-3\" /> GitHub\n\t\t\t\t\t</a>\n\t\t\t\t\t<Separator orientation=\"vertical\" className=\"h-2.5 bg-muted-foreground opacity-70\" />\n\t\t\t\t\t<a\n\t\t\t\t\t\thref=\"https://github.com/henrygd/beszel/releases\"\n\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\tclassName=\"text-muted-foreground hover:text-foreground duration-75\"\n\t\t\t\t\t>\n\t\t\t\t\t\tBeszel {globalThis.BESZEL.HUB_VERSION}\n\t\t\t\t\t</a>\n\t\t\t\t</div>\n\t\t\t</>\n\t\t),\n\t\t[]\n\t)\n})\n", "n_tokens": 249, "primary_symbol": "", "primary_kind": "", "primary_span": [23, 52], "def_symbols": [], "symbols": ["ActiveAlerts", "Suspense", "SystemsTable", "div", "className", "flex", "gap", "justify", "end", "items", "center", "text", "opacity", "href", "https", "github", "com", "henrygd", "beszel", "target", "_blank", "muted", "foreground", "hover", "duration", "GithubIcon", "GitHub", "Separator", "orientation", "vertical", "releases", "Beszel", "globalThis", "BESZEL", "HUB_VERSION"], "doc_head": "\t\t() => (\n\t\t\t<>\n\t\t\t\t<ActiveAlerts />\n\t\t\t\t<Suspense>\n\t\t\t\t\t<SystemsTable />\n\t\t\t\t</Suspense>\n\t\t\t\t<div className=\"flex gap-1.5 justify-end items-center pe-3 sm:pe-6 mt-3.5 mb-4 text-xs opacity-80\">\n\t\t\t\t\t<a\n\t\t\t\t\t\thref=\"https://github.com/henrygd/beszel\"\n\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\tclassName=\"flex items-center gap-0.5 text-muted-foreground hover:text-foreground duration-75\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<GithubIcon className=\"h-3 w-3\" /> GitHub\n\t\t\t\t\t</a>\n\t\t\t\t\t<Separator orientation=\"vertical\" className=\"h-2.5 bg-muted-foreground opacity-70\" />\n\t\t\t\t\t<a\n\t\t\t\t\t\thref=\"https://github.com/henrygd/beszel/releases\"\n\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\tclassName=\"text-muted-foreground hover:text-foreground duration-75\"\n\t\t\t\t\t>\n\t\t\t\t\t\tBeszel {globalThis.BESZEL.HUB_VERSION}\n\t\t\t\t\t</a>\n\t\t\t\t</div>\n\t\t\t</>\n\t\t),\n\t\t[]\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx", "rel_path": "src/site/src/components/routes/home.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 53, "end_line": 74, "text": "const ActiveAlerts = () => {\n\tconst alerts = useStore($alerts)\n\tconst systems = useStore($allSystemsById)\n\n\tconst { activeAlerts, alertsKey } = useMemo(() => {\n\t\tconst activeAlerts: AlertRecord[] = []\n\t\t// key to prevent re-rendering if alerts change but active alerts didn't\n\t\tconst alertsKey: string[] = []\n\n\t\tfor (const systemId of Object.keys(alerts)) {\n\t\t\tfor (const alert of alerts[systemId].values()) {\n\t\t\t\tif (alert.triggered && alert.name in alertInfo) {\n\t\t\t\t\tactiveAlerts.push(alert)\n\t\t\t\t\talertsKey.push(`${alert.system}${alert.value}${alert.min}`)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { activeAlerts, alertsKey }\n\t}, [alerts])\n\n\treturn useMemo(() => {", "n_tokens": 170, "primary_symbol": "ActiveAlerts", "primary_kind": "function", "primary_span": [53, 74], "def_symbols": ["ActiveAlerts"], "symbols": ["ActiveAlerts", "const", "alerts", "useStore", "systems", "allSystemsById", "activeAlerts", "alertsKey", "useMemo", "AlertRecord", "key", "prevent", "rendering", "change", "but", "active", "didn", "string", "for", "systemId", "Object", "keys", "alert", "values", "triggered", "name", "alertInfo", "push", "system", "value", "min", "return"], "doc_head": "const ActiveAlerts = () => {\n\tconst alerts = useStore($alerts)\n\tconst systems = useStore($allSystemsById)\n\tconst { activeAlerts, alertsKey } = useMemo(() => {\n\t\tconst activeAlerts: AlertRecord[] = []\n\t\t// key to prevent re-rendering if alerts change but active alerts didn't\n\t\tconst alertsKey: string[] = []\n\t\tfor (const systemId of Object.keys(alerts)) {\n\t\t\tfor (const alert of alerts[systemId].values()) {\n\t\t\t\tif (alert.triggered && alert.name in alertInfo) {\n\t\t\t\t\tactiveAlerts.push(alert)\n\t\t\t\t\talertsKey.push(`${alert.system}${alert.value}${alert.min}`)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { activeAlerts, alertsKey }\n\t}, [alerts])\n\treturn useMemo(() => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx", "rel_path": "src/site/src/components/routes/home.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 75, "end_line": 89, "text": "\t\tif (activeAlerts.length === 0) {\n\t\t\treturn null\n\t\t}\n\t\treturn (\n\t\t\t<Card className=\"mb-4\">\n\t\t\t\t<CardHeader className=\"pb-4 px-2 sm:px-6 max-sm:pt-5 max-sm:pb-1\">\n\t\t\t\t\t<div className=\"px-2 sm:px-1\">\n\t\t\t\t\t\t<CardTitle>\n\t\t\t\t\t\t\t<Trans>Active Alerts</Trans>\n\t\t\t\t\t\t</CardTitle>\n\t\t\t\t\t</div>\n\t\t\t\t</CardHeader>\n\t\t\t\t<CardContent className=\"max-sm:p-2\">\n\t\t\t\t\t{activeAlerts.length > 0 && (\n\t\t\t\t\t\t<div className=\"grid sm:grid-cols-2 lg:grid-cols-3 2xl:grid-cols-4 gap-3\">", "n_tokens": 161, "primary_symbol": "", "primary_kind": "", "primary_span": [75, 89], "def_symbols": [], "symbols": ["activeAlerts", "length", "return", "null", "Card", "className", "CardHeader", "max", "div", "CardTitle", "Trans", "Active", "Alerts", "CardContent", "grid", "cols", "gap"], "doc_head": "\t\tif (activeAlerts.length === 0) {\n\t\t\treturn null\n\t\t}\n\t\treturn (\n\t\t\t<Card className=\"mb-4\">\n\t\t\t\t<CardHeader className=\"pb-4 px-2 sm:px-6 max-sm:pt-5 max-sm:pb-1\">\n\t\t\t\t\t<div className=\"px-2 sm:px-1\">\n\t\t\t\t\t\t<CardTitle>\n\t\t\t\t\t\t\t<Trans>Active Alerts</Trans>\n\t\t\t\t\t\t</CardTitle>\n\t\t\t\t\t</div>\n\t\t\t\t</CardHeader>\n\t\t\t\t<CardContent className=\"max-sm:p-2\">\n\t\t\t\t\t{activeAlerts.length > 0 && (\n\t\t\t\t\t\t<div className=\"grid sm:grid-cols-2 lg:grid-cols-3 2xl:grid-cols-4 gap-3\">"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/home.tsx", "rel_path": "src/site/src/components/routes/home.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 90, "end_line": 126, "text": "\t\t\t\t\t\t\t{activeAlerts.map((alert) => {\n\t\t\t\t\t\t\t\tconst info = alertInfo[alert.name as keyof typeof alertInfo]\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<Alert\n\t\t\t\t\t\t\t\t\t\tkey={alert.id}\n\t\t\t\t\t\t\t\t\t\tclassName=\"hover:-translate-y-px duration-200 bg-transparent border-foreground/10 hover:shadow-md shadow-black/5\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<info.icon className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t<AlertTitle>\n\t\t\t\t\t\t\t\t\t\t\t{systems[alert.system]?.name} {info.name().toLowerCase().replace(\"cpu\", \"CPU\")}\n\t\t\t\t\t\t\t\t\t\t</AlertTitle>\n\t\t\t\t\t\t\t\t\t\t<AlertDescription>\n\t\t\t\t\t\t\t\t\t\t\t{alert.name === \"Status\" ? (\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Connection is down</Trans>\n\t\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\t\t\t\t\tExceeds {alert.value}\n\t\t\t\t\t\t\t\t\t\t\t\t\t{info.unit} in last <Plural value={alert.min} one=\"# minute\" other=\"# minutes\" />\n\t\t\t\t\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</AlertDescription>\n\t\t\t\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\t\t\t\thref={getPagePath($router, \"system\", { name: systems[alert.system]?.name })}\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"absolute inset-0 w-full h-full\"\n\t\t\t\t\t\t\t\t\t\t\taria-label=\"View system\"\n\t\t\t\t\t\t\t\t\t\t></Link>\n\t\t\t\t\t\t\t\t\t</Alert>\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t</CardContent>\n\t\t\t</Card>\n\t\t)\n\t}, [alertsKey.join(\"\")])\n}\n", "n_tokens": 300, "primary_symbol": "", "primary_kind": "", "primary_span": [90, 126], "def_symbols": [], "symbols": ["activeAlerts", "map", "alert", "const", "info", "alertInfo", "name", "keyof", "typeof", "return", "Alert", "key", "className", "hover", "translate", "duration", "transparent", "border", "foreground", "shadow", "black", "icon", "AlertTitle", "systems", "system", "toLowerCase", "replace", "cpu", "CPU", "AlertDescription", "Status", "Trans", "Connection", "down", "Exceeds", "value", "unit", "last", "Plural", "min", "one", "minute", "other", "minutes", "Link", "href", "getPagePath", "router", "absolute", "inset", "full", "aria", "label", "View", "div", "CardContent", "Card", "alertsKey", "join"], "doc_head": "\t\t\t\t\t\t\t{activeAlerts.map((alert) => {\n\t\t\t\t\t\t\t\tconst info = alertInfo[alert.name as keyof typeof alertInfo]\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<Alert\n\t\t\t\t\t\t\t\t\t\tkey={alert.id}\n\t\t\t\t\t\t\t\t\t\tclassName=\"hover:-translate-y-px duration-200 bg-transparent border-foreground/10 hover:shadow-md shadow-black/5\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<info.icon className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t<AlertTitle>\n\t\t\t\t\t\t\t\t\t\t\t{systems[alert.system]?.name} {info.name().toLowerCase().replace(\"cpu\", \"CPU\")}\n\t\t\t\t\t\t\t\t\t\t</AlertTitle>\n\t\t\t\t\t\t\t\t\t\t<AlertDescription>\n\t\t\t\t\t\t\t\t\t\t\t{alert.name === \"Status\" ? (\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>Connection is down</Trans>\n\t\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\t\t\t\t\tExceeds {alert.value}\n\t\t\t\t\t\t\t\t\t\t\t\t\t{info.unit} in last <Plural value={alert.min} one=\"# minute\" other=\"# minutes\" />\n\t\t\t\t\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</AlertDescription>\n\t\t\t\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\t\t\t\thref={getPagePath($router, \"system\", { name: systems[alert.system]?.name })}\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"absolute inset-0 w-full h-full\"\n\t\t\t\t\t\t\t\t\t\t\taria-label=\"View system\"\n\t\t\t\t\t\t\t\t\t\t></Link>\n\t\t\t\t\t\t\t\t\t</Alert>\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t</CardContent>\n\t\t\t</Card>\n\t\t)\n\t}, [alertsKey.join(\"\")])\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 19, "text": "import { t } from \"@lingui/core/macro\"\nimport { Plural, Trans } from \"@lingui/react/macro\"\nimport {\n\t$systems,\n\t$chartTime,\n\t$containerFilter,\n\t$userSettings,\n\t$direction,\n\t$maxValues,\n\t$temperatureFilter,\n\t$allSystemsByName,\n} from \"@/lib/stores\"\nimport { ChartData, ChartTimes, ContainerStatsRecord, GPUData, SystemRecord, SystemStatsRecord } from \"@/types\"\nimport { useContainerChartConfigs } from \"@/components/charts/hooks\"\nimport { ChartType, Unit, Os, SystemStatus } from \"@/lib/enums\"\nimport React, { memo, useCallback, useEffect, useMemo, useRef, useState, type JSX } from \"react\"\nimport { Card, CardHeader, CardTitle, CardDescription } from \"../ui/card\"\nimport { useStore } from \"@nanostores/react\"\nimport Spinner from \"../spinner\"", "n_tokens": 190, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 19], "def_symbols": [], "symbols": ["import", "from", "lingui", "core", "macro", "Plural", "Trans", "react", "systems", "chartTime", "containerFilter", "userSettings", "direction", "maxValues", "temperatureFilter", "allSystemsByName", "lib", "stores", "ChartData", "ChartTimes", "ContainerStatsRecord", "GPUData", "SystemRecord", "SystemStatsRecord", "types", "useContainerChartConfigs", "components", "charts", "hooks", "ChartType", "Unit", "SystemStatus", "enums", "React", "memo", "useCallback", "useEffect", "useMemo", "useRef", "useState", "type", "JSX", "Card", "CardHeader", "CardTitle", "CardDescription", "card", "useStore", "nanostores", "Spinner", "spinner"], "doc_head": "import { t } from \"@lingui/core/macro\"\nimport { Plural, Trans } from \"@lingui/react/macro\"\nimport {\n\t$systems,\n\t$chartTime,\n\t$containerFilter,\n\t$userSettings,\n\t$direction,\n\t$maxValues,\n\t$temperatureFilter,\n\t$allSystemsByName,\n} from \"@/lib/stores\"\nimport { ChartData, ChartTimes, ContainerStatsRecord, GPUData, SystemRecord, SystemStatsRecord } from \"@/types\"\nimport { useContainerChartConfigs } from \"@/components/charts/hooks\"\nimport { ChartType, Unit, Os, SystemStatus } from \"@/lib/enums\"\nimport React, { memo, useCallback, useEffect, useMemo, useRef, useState, type JSX } from \"react\"\nimport { Card, CardHeader, CardTitle, CardDescription } from \"../ui/card\"\nimport { useStore } from \"@nanostores/react\"\nimport Spinner from \"../spinner\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 20, "end_line": 39, "text": "import { ClockArrowUp, CpuIcon, GlobeIcon, LayoutGridIcon, MonitorIcon, XIcon } from \"lucide-react\"\nimport ChartTimeSelect from \"../charts/chart-time-select\"\nimport {\n\tchartTimeData,\n\tcn,\n\tdecimalString,\n\tformatBytes,\n\tgetHostDisplayValue,\n\tlisten,\n\tparseSemVer,\n\ttoFixedFloat,\n\tuseBrowserStorage,\n} from \"@/lib/utils\"\nimport { getPbTimestamp, pb } from \"@/lib/api\"\nimport { Separator } from \"../ui/separator\"\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from \"../ui/tooltip\"\nimport { Button } from \"../ui/button\"\nimport { Input } from \"../ui/input\"\nimport { ChartAverage, ChartMax, Rows, TuxIcon, WindowsIcon, AppleIcon, FreeBsdIcon } from \"../ui/icons\"\nimport { useIntersectionObserver } from \"@/lib/use-intersection-observer\"", "n_tokens": 189, "primary_symbol": "", "primary_kind": "", "primary_span": [20, 39], "def_symbols": [], "symbols": ["import", "ClockArrowUp", "CpuIcon", "GlobeIcon", "LayoutGridIcon", "MonitorIcon", "XIcon", "from", "lucide", "react", "ChartTimeSelect", "charts", "chart", "time", "select", "chartTimeData", "decimalString", "formatBytes", "getHostDisplayValue", "listen", "parseSemVer", "toFixedFloat", "useBrowserStorage", "lib", "utils", "getPbTimestamp", "api", "Separator", "separator", "Tooltip", "TooltipContent", "TooltipProvider", "TooltipTrigger", "tooltip", "Button", "button", "Input", "input", "ChartAverage", "ChartMax", "Rows", "TuxIcon", "WindowsIcon", "AppleIcon", "FreeBsdIcon", "icons", "useIntersectionObserver", "use", "intersection", "observer"], "doc_head": "import { ClockArrowUp, CpuIcon, GlobeIcon, LayoutGridIcon, MonitorIcon, XIcon } from \"lucide-react\"\nimport ChartTimeSelect from \"../charts/chart-time-select\"\nimport {\n\tchartTimeData,\n\tcn,\n\tdecimalString,\n\tformatBytes,\n\tgetHostDisplayValue,\n\tlisten,\n\tparseSemVer,\n\ttoFixedFloat,\n\tuseBrowserStorage,\n} from \"@/lib/utils\"\nimport { getPbTimestamp, pb } from \"@/lib/api\"\nimport { Separator } from \"../ui/separator\"\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from \"../ui/tooltip\"\nimport { Button } from \"../ui/button\"\nimport { Input } from \"../ui/input\"\nimport { ChartAverage, ChartMax, Rows, TuxIcon, WindowsIcon, AppleIcon, FreeBsdIcon } from \"../ui/icons\"\nimport { useIntersectionObserver } from \"@/lib/use-intersection-observer\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 40, "end_line": 53, "text": "import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"../ui/select\"\nimport { timeTicks } from \"d3-time\"\nimport { useLingui } from \"@lingui/react/macro\"\nimport { $router, navigate } from \"../router\"\nimport { getPagePath } from \"@nanostores/router\"\nimport { batteryStateTranslations } from \"@/lib/i18n\"\nimport AreaChartDefault from \"@/components/charts/area-chart\"\nimport ContainerChart from \"@/components/charts/container-chart\"\nimport MemChart from \"@/components/charts/mem-chart\"\nimport DiskChart from \"@/components/charts/disk-chart\"\nimport SwapChart from \"@/components/charts/swap-chart\"\nimport TemperatureChart from \"@/components/charts/temperature-chart\"\nimport GpuPowerChart from \"@/components/charts/gpu-power-chart\"\nimport LoadAverageChart from \"@/components/charts/load-average-chart\"", "n_tokens": 183, "primary_symbol": "", "primary_kind": "", "primary_span": [40, 53], "def_symbols": [], "symbols": ["import", "Select", "SelectContent", "SelectItem", "SelectTrigger", "SelectValue", "from", "select", "timeTicks", "time", "useLingui", "lingui", "react", "macro", "router", "navigate", "getPagePath", "nanostores", "batteryStateTranslations", "lib", "i18n", "AreaChartDefault", "components", "charts", "area", "chart", "ContainerChart", "container", "MemChart", "mem", "DiskChart", "disk", "SwapChart", "swap", "TemperatureChart", "temperature", "GpuPowerChart", "gpu", "power", "LoadAverageChart", "load", "average"], "doc_head": "import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"../ui/select\"\nimport { timeTicks } from \"d3-time\"\nimport { useLingui } from \"@lingui/react/macro\"\nimport { $router, navigate } from \"../router\"\nimport { getPagePath } from \"@nanostores/router\"\nimport { batteryStateTranslations } from \"@/lib/i18n\"\nimport AreaChartDefault from \"@/components/charts/area-chart\"\nimport ContainerChart from \"@/components/charts/container-chart\"\nimport MemChart from \"@/components/charts/mem-chart\"\nimport DiskChart from \"@/components/charts/disk-chart\"\nimport SwapChart from \"@/components/charts/swap-chart\"\nimport TemperatureChart from \"@/components/charts/temperature-chart\"\nimport GpuPowerChart from \"@/components/charts/gpu-power-chart\"\nimport LoadAverageChart from \"@/components/charts/load-average-chart\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 54, "end_line": 77, "text": "import { subscribeKeys } from \"nanostores\"\n\nconst cache = new Map<string, any>()\n\n// create ticks and domain for charts\nfunction getTimeData(chartTime: ChartTimes, lastCreated: number) {\n\tconst cached = cache.get(\"td\")\n\tif (cached && cached.chartTime === chartTime) {\n\t\tif (!lastCreated || cached.time >= lastCreated) {\n\t\t\treturn cached.data\n\t\t}\n\t}\n\n\tconst now = new Date()\n\tconst startTime = chartTimeData[chartTime].getOffset(now)\n\tconst ticks = timeTicks(startTime, now, chartTimeData[chartTime].ticks ?? 12).map((date) => date.getTime())\n\tconst data = {\n\t\tticks,\n\t\tdomain: [chartTimeData[chartTime].getOffset(now).getTime(), now.getTime()],\n\t}\n\tcache.set(\"td\", { time: now.getTime(), data, chartTime })\n\treturn data\n}\n", "n_tokens": 186, "primary_symbol": "getTimeData", "primary_kind": "function", "primary_span": [59, 77], "def_symbols": ["getTimeData"], "symbols": ["getTimeData", "import", "subscribeKeys", "from", "nanostores", "const", "cache", "new", "Map", "string", "any", "create", "ticks", "and", "domain", "for", "charts", "function", "chartTime", "ChartTimes", "lastCreated", "number", "cached", "get", "time", "return", "data", "now", "Date", "startTime", "chartTimeData", "getOffset", "timeTicks", "map", "date", "getTime", "set"], "doc_head": "import { subscribeKeys } from \"nanostores\"\nconst cache = new Map<string, any>()\n// create ticks and domain for charts\nfunction getTimeData(chartTime: ChartTimes, lastCreated: number) {\n\tconst cached = cache.get(\"td\")\n\tif (cached && cached.chartTime === chartTime) {\n\t\tif (!lastCreated || cached.time >= lastCreated) {\n\t\t\treturn cached.data\n\t\t}\n\t}\n\tconst now = new Date()\n\tconst startTime = chartTimeData[chartTime].getOffset(now)\n\tconst ticks = timeTicks(startTime, now, chartTimeData[chartTime].ticks ?? 12).map((date) => date.getTime())\n\tconst data = {\n\t\tticks,\n\t\tdomain: [chartTimeData[chartTime].getOffset(now).getTime(), now.getTime()],\n\t}\n\tcache.set(\"td\", { time: now.getTime(), data, chartTime })\n\treturn data\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 78, "end_line": 102, "text": "// add empty values between records to make gaps if interval is too large\nfunction addEmptyValues<T extends SystemStatsRecord | ContainerStatsRecord>(\n\tprevRecords: T[],\n\tnewRecords: T[],\n\texpectedInterval: number\n) {\n\tconst modifiedRecords: T[] = []\n\tlet prevTime = (prevRecords.at(-1)?.created ?? 0) as number\n\tfor (let i = 0; i < newRecords.length; i++) {\n\t\tconst record = newRecords[i]\n\t\trecord.created = new Date(record.created).getTime()\n\t\tif (prevTime) {\n\t\t\tconst interval = record.created - prevTime\n\t\t\t// if interval is too large, add a null record\n\t\t\tif (interval > expectedInterval / 2 + expectedInterval) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tmodifiedRecords.push({ created: null, stats: null })\n\t\t\t}\n\t\t}\n\t\tprevTime = record.created\n\t\tmodifiedRecords.push(record)\n\t}\n\treturn modifiedRecords\n}\n", "n_tokens": 203, "primary_symbol": "", "primary_kind": "", "primary_span": [78, 102], "def_symbols": [], "symbols": ["add", "empty", "values", "between", "records", "make", "gaps", "interval", "too", "large", "function", "addEmptyValues", "extends", "SystemStatsRecord", "ContainerStatsRecord", "prevRecords", "newRecords", "expectedInterval", "number", "const", "modifiedRecords", "let", "prevTime", "created", "for", "length", "record", "new", "Date", "getTime", "null", "ignore", "push", "stats", "return"], "doc_head": "// add empty values between records to make gaps if interval is too large\nfunction addEmptyValues<T extends SystemStatsRecord | ContainerStatsRecord>(\n\tprevRecords: T[],\n\tnewRecords: T[],\n\texpectedInterval: number\n) {\n\tconst modifiedRecords: T[] = []\n\tlet prevTime = (prevRecords.at(-1)?.created ?? 0) as number\n\tfor (let i = 0; i < newRecords.length; i++) {\n\t\tconst record = newRecords[i]\n\t\trecord.created = new Date(record.created).getTime()\n\t\tif (prevTime) {\n\t\t\tconst interval = record.created - prevTime\n\t\t\t// if interval is too large, add a null record\n\t\t\tif (interval > expectedInterval / 2 + expectedInterval) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tmodifiedRecords.push({ created: null, stats: null })\n\t\t\t}\n\t\t}\n\t\tprevTime = record.created\n\t\tmodifiedRecords.push(record)\n\t}\n\treturn modifiedRecords\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 103, "end_line": 122, "text": "async function getStats<T>(collection: string, system: SystemRecord, chartTime: ChartTimes): Promise<T[]> {\n\tconst lastCached = cache.get(`${system.id}_${chartTime}_${collection}`)?.at(-1)?.created as number\n\treturn await pb.collection<T>(collection).getFullList({\n\t\tfilter: pb.filter(\"system={:id} && created > {:created} && type={:type}\", {\n\t\t\tid: system.id,\n\t\t\tcreated: getPbTimestamp(chartTime, lastCached ? new Date(lastCached + 1000) : undefined),\n\t\t\ttype: chartTimeData[chartTime].type,\n\t\t}),\n\t\tfields: \"created,stats\",\n\t\tsort: \"created\",\n\t})\n}\n\nfunction dockerOrPodman(str: string, system: SystemRecord) {\n\tif (system.info.p) {\n\t\tstr = str.replace(\"docker\", \"podman\").replace(\"Docker\", \"Podman\")\n\t}\n\treturn str\n}\n", "n_tokens": 197, "primary_symbol": "dockerOrPodman", "primary_kind": "function", "primary_span": [116, 122], "def_symbols": ["dockerOrPodman"], "symbols": ["dockerOrPodman", "async", "function", "getStats", "collection", "string", "system", "SystemRecord", "chartTime", "ChartTimes", "Promise", "const", "lastCached", "cache", "get", "created", "number", "return", "await", "getFullList", "filter", "type", "getPbTimestamp", "new", "Date", "undefined", "chartTimeData", "fields", "stats", "sort", "str", "info", "replace", "docker", "podman", "Docker", "Podman"], "doc_head": "async function getStats<T>(collection: string, system: SystemRecord, chartTime: ChartTimes): Promise<T[]> {\n\tconst lastCached = cache.get(`${system.id}_${chartTime}_${collection}`)?.at(-1)?.created as number\n\treturn await pb.collection<T>(collection).getFullList({\n\t\tfilter: pb.filter(\"system={:id} && created > {:created} && type={:type}\", {\n\t\t\tid: system.id,\n\t\t\tcreated: getPbTimestamp(chartTime, lastCached ? new Date(lastCached + 1000) : undefined),\n\t\t\ttype: chartTimeData[chartTime].type,\n\t\t}),\n\t\tfields: \"created,stats\",\n\t\tsort: \"created\",\n\t})\n}\nfunction dockerOrPodman(str: string, system: SystemRecord) {\n\tif (system.info.p) {\n\t\tstr = str.replace(\"docker\", \"podman\").replace(\"Docker\", \"Podman\")\n\t}\n\treturn str\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 123, "end_line": 140, "text": "export default memo(function SystemDetail({ name }: { name: string }) {\n\tconst direction = useStore($direction)\n\tconst { t } = useLingui()\n\tconst systems = useStore($systems)\n\tconst chartTime = useStore($chartTime)\n\tconst maxValues = useStore($maxValues)\n\tconst [grid, setGrid] = useBrowserStorage(\"grid\", true)\n\tconst [system, setSystem] = useState({} as SystemRecord)\n\tconst [systemStats, setSystemStats] = useState([] as SystemStatsRecord[])\n\tconst [containerData, setContainerData] = useState([] as ChartData[\"containerData\"])\n\tconst netCardRef = useRef<HTMLDivElement>(null)\n\tconst persistChartTime = useRef(false)\n\tconst [containerFilterBar, setContainerFilterBar] = useState(null as null | JSX.Element)\n\tconst [bottomSpacing, setBottomSpacing] = useState(0)\n\tconst [chartLoading, setChartLoading] = useState(true)\n\tconst isLongerChart = chartTime !== \"1h\"\n\tconst userSettings = $userSettings.get()\n", "n_tokens": 216, "primary_symbol": "", "primary_kind": "", "primary_span": [123, 140], "def_symbols": [], "symbols": ["export", "default", "memo", "function", "SystemDetail", "name", "string", "const", "direction", "useStore", "useLingui", "systems", "chartTime", "maxValues", "grid", "setGrid", "useBrowserStorage", "true", "system", "setSystem", "useState", "SystemRecord", "systemStats", "setSystemStats", "SystemStatsRecord", "containerData", "setContainerData", "ChartData", "netCardRef", "useRef", "HTMLDivElement", "null", "persistChartTime", "false", "containerFilterBar", "setContainerFilterBar", "JSX", "Element", "bottomSpacing", "setBottomSpacing", "chartLoading", "setChartLoading", "isLongerChart", "userSettings", "get"], "doc_head": "export default memo(function SystemDetail({ name }: { name: string }) {\n\tconst direction = useStore($direction)\n\tconst { t } = useLingui()\n\tconst systems = useStore($systems)\n\tconst chartTime = useStore($chartTime)\n\tconst maxValues = useStore($maxValues)\n\tconst [grid, setGrid] = useBrowserStorage(\"grid\", true)\n\tconst [system, setSystem] = useState({} as SystemRecord)\n\tconst [systemStats, setSystemStats] = useState([] as SystemStatsRecord[])\n\tconst [containerData, setContainerData] = useState([] as ChartData[\"containerData\"])\n\tconst netCardRef = useRef<HTMLDivElement>(null)\n\tconst persistChartTime = useRef(false)\n\tconst [containerFilterBar, setContainerFilterBar] = useState(null as null | JSX.Element)\n\tconst [bottomSpacing, setBottomSpacing] = useState(0)\n\tconst [chartLoading, setChartLoading] = useState(true)\n\tconst isLongerChart = chartTime !== \"1h\"\n\tconst userSettings = $userSettings.get()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 141, "end_line": 162, "text": "\tuseEffect(() => {\n\t\tdocument.title = `${name} / Beszel`\n\t\treturn () => {\n\t\t\tif (!persistChartTime.current) {\n\t\t\t\t$chartTime.set($userSettings.get().chartTime)\n\t\t\t}\n\t\t\tpersistChartTime.current = false\n\t\t\tsetSystemStats([])\n\t\t\tsetContainerData([])\n\t\t\tsetContainerFilterBar(null)\n\t\t\t$containerFilter.set(\"\")\n\t\t}\n\t}, [name])\n\n\t// find matching system and update when it changes\n\tuseEffect(() => {\n\t\treturn subscribeKeys($allSystemsByName, [name], (newSystems) => {\n\t\t\tconst sys = newSystems[name]\n\t\t\tsys?.id && setSystem(sys)\n\t\t})\n\t}, [name])\n", "n_tokens": 147, "primary_symbol": "", "primary_kind": "", "primary_span": [141, 162], "def_symbols": [], "symbols": ["useEffect", "document", "title", "name", "Beszel", "return", "persistChartTime", "current", "chartTime", "set", "userSettings", "get", "false", "setSystemStats", "setContainerData", "setContainerFilterBar", "null", "containerFilter", "find", "matching", "system", "and", "update", "when", "changes", "subscribeKeys", "allSystemsByName", "newSystems", "const", "sys", "setSystem"], "doc_head": "\tuseEffect(() => {\n\t\tdocument.title = `${name} / Beszel`\n\t\treturn () => {\n\t\t\tif (!persistChartTime.current) {\n\t\t\t\t$chartTime.set($userSettings.get().chartTime)\n\t\t\t}\n\t\t\tpersistChartTime.current = false\n\t\t\tsetSystemStats([])\n\t\t\tsetContainerData([])\n\t\t\tsetContainerFilterBar(null)\n\t\t\t$containerFilter.set(\"\")\n\t\t}\n\t}, [name])\n\t// find matching system and update when it changes\n\tuseEffect(() => {\n\t\treturn subscribeKeys($allSystemsByName, [name], (newSystems) => {\n\t\t\tconst sys = newSystems[name]\n\t\t\tsys?.id && setSystem(sys)\n\t\t})\n\t}, [name])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 163, "end_line": 182, "text": "\tconst chartData: ChartData = useMemo(() => {\n\t\tconst lastCreated = Math.max(\n\t\t\t(systemStats.at(-1)?.created as number) ?? 0,\n\t\t\t(containerData.at(-1)?.created as number) ?? 0\n\t\t)\n\t\treturn {\n\t\t\tsystemStats,\n\t\t\tcontainerData,\n\t\t\tchartTime,\n\t\t\torientation: direction === \"rtl\" ? \"right\" : \"left\",\n\t\t\t...getTimeData(chartTime, lastCreated),\n\t\t\tagentVersion: parseSemVer(system?.info?.v),\n\t\t}\n\t}, [systemStats, containerData, direction])\n\n\t// Share chart config computation for all container charts\n\tconst containerChartConfigs = useContainerChartConfigs(containerData)\n\n\t// get stats\n\tuseEffect(() => {", "n_tokens": 159, "primary_symbol": "", "primary_kind": "", "primary_span": [163, 182], "def_symbols": [], "symbols": ["const", "chartData", "ChartData", "useMemo", "lastCreated", "Math", "max", "systemStats", "created", "number", "containerData", "return", "chartTime", "orientation", "direction", "rtl", "right", "left", "getTimeData", "agentVersion", "parseSemVer", "system", "info", "Share", "chart", "config", "computation", "for", "all", "container", "charts", "containerChartConfigs", "useContainerChartConfigs", "get", "stats", "useEffect"], "doc_head": "\tconst chartData: ChartData = useMemo(() => {\n\t\tconst lastCreated = Math.max(\n\t\t\t(systemStats.at(-1)?.created as number) ?? 0,\n\t\t\t(containerData.at(-1)?.created as number) ?? 0\n\t\t)\n\t\treturn {\n\t\t\tsystemStats,\n\t\t\tcontainerData,\n\t\t\tchartTime,\n\t\t\torientation: direction === \"rtl\" ? \"right\" : \"left\",\n\t\t\t...getTimeData(chartTime, lastCreated),\n\t\t\tagentVersion: parseSemVer(system?.info?.v),\n\t\t}\n\t}, [systemStats, containerData, direction])\n\t// Share chart config computation for all container charts\n\tconst containerChartConfigs = useContainerChartConfigs(containerData)\n\t// get stats\n\tuseEffect(() => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 183, "end_line": 200, "text": "\t\tif (!system.id || !chartTime) {\n\t\t\treturn\n\t\t}\n\t\t// loading: true\n\t\tsetChartLoading(true)\n\t\tPromise.allSettled([\n\t\t\tgetStats<SystemStatsRecord>(\"system_stats\", system, chartTime),\n\t\t\tgetStats<ContainerStatsRecord>(\"container_stats\", system, chartTime),\n\t\t]).then(([systemStats, containerStats]) => {\n\t\t\t// loading: false\n\t\t\tsetChartLoading(false)\n\n\t\t\tconst { expectedInterval } = chartTimeData[chartTime]\n\t\t\t// make new system stats\n\t\t\tconst ss_cache_key = `${system.id}_${chartTime}_system_stats`\n\t\t\tlet systemData = (cache.get(ss_cache_key) || []) as SystemStatsRecord[]\n\t\t\tif (systemStats.status === \"fulfilled\" && systemStats.value.length) {\n\t\t\t\tsystemData = systemData.concat(addEmptyValues(systemData, systemStats.value, expectedInterval))", "n_tokens": 190, "primary_symbol": "", "primary_kind": "", "primary_span": [183, 200], "def_symbols": [], "symbols": ["system", "chartTime", "return", "loading", "true", "setChartLoading", "Promise", "allSettled", "getStats", "SystemStatsRecord", "system_stats", "ContainerStatsRecord", "container_stats", "then", "systemStats", "containerStats", "false", "const", "expectedInterval", "chartTimeData", "make", "new", "stats", "ss_cache_key", "_system_stats", "let", "systemData", "cache", "get", "status", "fulfilled", "value", "length", "concat", "addEmptyValues"], "doc_head": "\t\tif (!system.id || !chartTime) {\n\t\t\treturn\n\t\t}\n\t\t// loading: true\n\t\tsetChartLoading(true)\n\t\tPromise.allSettled([\n\t\t\tgetStats<SystemStatsRecord>(\"system_stats\", system, chartTime),\n\t\t\tgetStats<ContainerStatsRecord>(\"container_stats\", system, chartTime),\n\t\t]).then(([systemStats, containerStats]) => {\n\t\t\t// loading: false\n\t\t\tsetChartLoading(false)\n\t\t\tconst { expectedInterval } = chartTimeData[chartTime]\n\t\t\t// make new system stats\n\t\t\tconst ss_cache_key = `${system.id}_${chartTime}_system_stats`\n\t\t\tlet systemData = (cache.get(ss_cache_key) || []) as SystemStatsRecord[]\n\t\t\tif (systemStats.status === \"fulfilled\" && systemStats.value.length) {\n\t\t\t\tsystemData = systemData.concat(addEmptyValues(systemData, systemStats.value, expectedInterval))"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 11, "start_line": 201, "end_line": 218, "text": "\t\t\t\tif (systemData.length > 120) {\n\t\t\t\t\tsystemData = systemData.slice(-100)\n\t\t\t\t}\n\t\t\t\tcache.set(ss_cache_key, systemData)\n\t\t\t}\n\t\t\tsetSystemStats(systemData)\n\t\t\t// make new container stats\n\t\t\tconst cs_cache_key = `${system.id}_${chartTime}_container_stats`\n\t\t\tlet containerData = (cache.get(cs_cache_key) || []) as ContainerStatsRecord[]\n\t\t\tif (containerStats.status === \"fulfilled\" && containerStats.value.length) {\n\t\t\t\tcontainerData = containerData.concat(addEmptyValues(containerData, containerStats.value, expectedInterval))\n\t\t\t\tif (containerData.length > 120) {\n\t\t\t\t\tcontainerData = containerData.slice(-100)\n\t\t\t\t}\n\t\t\t\tcache.set(cs_cache_key, containerData)\n\t\t\t}\n\t\t\tif (containerData.length) {\n\t\t\t\t!containerFilterBar && setContainerFilterBar(<FilterBar />)", "n_tokens": 186, "primary_symbol": "", "primary_kind": "", "primary_span": [201, 218], "def_symbols": [], "symbols": ["systemData", "length", "slice", "cache", "set", "ss_cache_key", "setSystemStats", "make", "new", "container", "stats", "const", "cs_cache_key", "system", "chartTime", "_container_stats", "let", "containerData", "get", "ContainerStatsRecord", "containerStats", "status", "fulfilled", "value", "concat", "addEmptyValues", "expectedInterval", "containerFilterBar", "setContainerFilterBar", "FilterBar"], "doc_head": "\t\t\t\tif (systemData.length > 120) {\n\t\t\t\t\tsystemData = systemData.slice(-100)\n\t\t\t\t}\n\t\t\t\tcache.set(ss_cache_key, systemData)\n\t\t\t}\n\t\t\tsetSystemStats(systemData)\n\t\t\t// make new container stats\n\t\t\tconst cs_cache_key = `${system.id}_${chartTime}_container_stats`\n\t\t\tlet containerData = (cache.get(cs_cache_key) || []) as ContainerStatsRecord[]\n\t\t\tif (containerStats.status === \"fulfilled\" && containerStats.value.length) {\n\t\t\t\tcontainerData = containerData.concat(addEmptyValues(containerData, containerStats.value, expectedInterval))\n\t\t\t\tif (containerData.length > 120) {\n\t\t\t\t\tcontainerData = containerData.slice(-100)\n\t\t\t\t}\n\t\t\t\tcache.set(cs_cache_key, containerData)\n\t\t\t}\n\t\t\tif (containerData.length) {\n\t\t\t\t!containerFilterBar && setContainerFilterBar(<FilterBar />)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 12, "start_line": 219, "end_line": 245, "text": "\t\t\t} else if (containerFilterBar) {\n\t\t\t\tsetContainerFilterBar(null)\n\t\t\t}\n\t\t\tmakeContainerData(containerData)\n\t\t})\n\t}, [system, chartTime])\n\n\t// make container stats for charts\n\tconst makeContainerData = useCallback((containers: ContainerStatsRecord[]) => {\n\t\tconst containerData = [] as ChartData[\"containerData\"]\n\t\tfor (let { created, stats } of containers) {\n\t\t\tif (!created) {\n\t\t\t\t// @ts-ignore add null value for gaps\n\t\t\t\tcontainerData.push({ created: null })\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcreated = new Date(created).getTime()\n\t\t\t// @ts-ignore not dealing with this rn\n\t\t\tlet containerStats: ChartData[\"containerData\"][0] = { created }\n\t\t\tfor (let container of stats) {\n\t\t\t\tcontainerStats[container.n] = container\n\t\t\t}\n\t\t\tcontainerData.push(containerStats)\n\t\t}\n\t\tsetContainerData(containerData)\n\t}, [])\n", "n_tokens": 202, "primary_symbol": "", "primary_kind": "", "primary_span": [219, 245], "def_symbols": [], "symbols": ["else", "containerFilterBar", "setContainerFilterBar", "null", "makeContainerData", "containerData", "system", "chartTime", "make", "container", "stats", "for", "charts", "const", "useCallback", "containers", "ContainerStatsRecord", "ChartData", "let", "created", "ignore", "add", "value", "gaps", "push", "continue", "new", "Date", "getTime", "not", "dealing", "with", "this", "containerStats", "setContainerData"], "doc_head": "\t\t\t} else if (containerFilterBar) {\n\t\t\t\tsetContainerFilterBar(null)\n\t\t\t}\n\t\t\tmakeContainerData(containerData)\n\t\t})\n\t}, [system, chartTime])\n\t// make container stats for charts\n\tconst makeContainerData = useCallback((containers: ContainerStatsRecord[]) => {\n\t\tconst containerData = [] as ChartData[\"containerData\"]\n\t\tfor (let { created, stats } of containers) {\n\t\t\tif (!created) {\n\t\t\t\t// @ts-ignore add null value for gaps\n\t\t\t\tcontainerData.push({ created: null })\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcreated = new Date(created).getTime()\n\t\t\t// @ts-ignore not dealing with this rn\n\t\t\tlet containerStats: ChartData[\"containerData\"][0] = { created }\n\t\t\tfor (let container of stats) {\n\t\t\t\tcontainerStats[container.n] = container\n\t\t\t}\n\t\t\tcontainerData.push(containerStats)\n\t\t}\n\t\tsetContainerData(containerData)\n\t}, [])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 13, "start_line": 246, "end_line": 271, "text": "\t// values for system info bar\n\tconst systemInfo = useMemo(() => {\n\t\tif (!system.info) {\n\t\t\treturn []\n\t\t}\n\n\t\tconst osInfo = {\n\t\t\t[Os.Linux]: {\n\t\t\t\tIcon: TuxIcon,\n\t\t\t\tvalue: system.info.k,\n\t\t\t\tlabel: t({ comment: \"Linux kernel\", message: \"Kernel\" }),\n\t\t\t},\n\t\t\t[Os.Darwin]: {\n\t\t\t\tIcon: AppleIcon,\n\t\t\t\tvalue: `macOS ${system.info.k}`,\n\t\t\t},\n\t\t\t[Os.Windows]: {\n\t\t\t\tIcon: WindowsIcon,\n\t\t\t\tvalue: system.info.k,\n\t\t\t},\n\t\t\t[Os.FreeBSD]: {\n\t\t\t\tIcon: FreeBsdIcon,\n\t\t\t\tvalue: system.info.k,\n\t\t\t},\n\t\t}\n\t\tlet uptime: React.ReactNode", "n_tokens": 168, "primary_symbol": "", "primary_kind": "", "primary_span": [246, 271], "def_symbols": [], "symbols": ["values", "for", "system", "info", "bar", "const", "systemInfo", "useMemo", "return", "osInfo", "Linux", "Icon", "TuxIcon", "value", "label", "comment", "kernel", "message", "Kernel", "Darwin", "AppleIcon", "macOS", "Windows", "WindowsIcon", "FreeBSD", "FreeBsdIcon", "let", "uptime", "React", "ReactNode"], "doc_head": "\t// values for system info bar\n\tconst systemInfo = useMemo(() => {\n\t\tif (!system.info) {\n\t\t\treturn []\n\t\t}\n\t\tconst osInfo = {\n\t\t\t[Os.Linux]: {\n\t\t\t\tIcon: TuxIcon,\n\t\t\t\tvalue: system.info.k,\n\t\t\t\tlabel: t({ comment: \"Linux kernel\", message: \"Kernel\" }),\n\t\t\t},\n\t\t\t[Os.Darwin]: {\n\t\t\t\tIcon: AppleIcon,\n\t\t\t\tvalue: `macOS ${system.info.k}`,\n\t\t\t},\n\t\t\t[Os.Windows]: {\n\t\t\t\tIcon: WindowsIcon,\n\t\t\t\tvalue: system.info.k,\n\t\t\t},\n\t\t\t[Os.FreeBSD]: {\n\t\t\t\tIcon: FreeBsdIcon,\n\t\t\t\tvalue: system.info.k,\n\t\t\t},\n\t\t}\n\t\tlet uptime: React.ReactNode"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 14, "start_line": 272, "end_line": 283, "text": "\t\tif (system.info.u < 3600) {\n\t\t\tuptime = (\n\t\t\t\t<Plural\n\t\t\t\t\tvalue={Math.trunc(system.info.u / 60)}\n\t\t\t\t\tone=\"# minute\"\n\t\t\t\t\tfew=\"# minutes\"\n\t\t\t\t\tmany=\"# minutes\"\n\t\t\t\t\tother=\"# minutes\"\n\t\t\t\t/>\n\t\t\t)\n\t\t} else if (system.info.u < 172800) {\n\t\t\tuptime = <Plural value={Math.trunc(system.info.u / 3600)} one=\"# hour\" other=\"# hours\" />", "n_tokens": 110, "primary_symbol": "", "primary_kind": "", "primary_span": [272, 283], "def_symbols": [], "symbols": ["system", "info", "uptime", "Plural", "value", "Math", "trunc", "one", "minute", "few", "minutes", "many", "other", "else", "hour", "hours"], "doc_head": "\t\tif (system.info.u < 3600) {\n\t\t\tuptime = (\n\t\t\t\t<Plural\n\t\t\t\t\tvalue={Math.trunc(system.info.u / 60)}\n\t\t\t\t\tone=\"# minute\"\n\t\t\t\t\tfew=\"# minutes\"\n\t\t\t\t\tmany=\"# minutes\"\n\t\t\t\t\tother=\"# minutes\"\n\t\t\t\t/>\n\t\t\t)\n\t\t} else if (system.info.u < 172800) {\n\t\t\tuptime = <Plural value={Math.trunc(system.info.u / 3600)} one=\"# hour\" other=\"# hours\" />"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 15, "start_line": 284, "end_line": 310, "text": "\t\t} else {\n\t\t\tuptime = <Plural value={Math.trunc(system.info?.u / 86400)} one=\"# day\" other=\"# days\" />\n\t\t}\n\t\treturn [\n\t\t\t{ value: getHostDisplayValue(system), Icon: GlobeIcon },\n\t\t\t{\n\t\t\t\tvalue: system.info.h,\n\t\t\t\tIcon: MonitorIcon,\n\t\t\t\tlabel: \"Hostname\",\n\t\t\t\t// hide if hostname is same as host or name\n\t\t\t\thide: system.info.h === system.host || system.info.h === system.name,\n\t\t\t},\n\t\t\t{ value: uptime, Icon: ClockArrowUp, label: t`Uptime`, hide: !system.info.u },\n\t\t\tosInfo[system.info.os ?? Os.Linux],\n\t\t\t{\n\t\t\t\tvalue: `${system.info.m} (${system.info.c}c${system.info.t ? `/${system.info.t}t` : \"\"})`,\n\t\t\t\tIcon: CpuIcon,\n\t\t\t\thide: !system.info.m,\n\t\t\t},\n\t\t] as {\n\t\t\tvalue: string | number | undefined\n\t\t\tlabel?: string\n\t\t\tIcon: any\n\t\t\thide?: boolean\n\t\t}[]\n\t}, [system.info, t])\n", "n_tokens": 250, "primary_symbol": "", "primary_kind": "", "primary_span": [284, 310], "def_symbols": [], "symbols": ["else", "uptime", "Plural", "value", "Math", "trunc", "system", "info", "one", "day", "other", "days", "return", "getHostDisplayValue", "Icon", "GlobeIcon", "MonitorIcon", "label", "Hostname", "hide", "hostname", "same", "host", "name", "ClockArrowUp", "Uptime", "osInfo", "Linux", "CpuIcon", "string", "number", "undefined", "any", "boolean"], "doc_head": "\t\t} else {\n\t\t\tuptime = <Plural value={Math.trunc(system.info?.u / 86400)} one=\"# day\" other=\"# days\" />\n\t\t}\n\t\treturn [\n\t\t\t{ value: getHostDisplayValue(system), Icon: GlobeIcon },\n\t\t\t{\n\t\t\t\tvalue: system.info.h,\n\t\t\t\tIcon: MonitorIcon,\n\t\t\t\tlabel: \"Hostname\",\n\t\t\t\t// hide if hostname is same as host or name\n\t\t\t\thide: system.info.h === system.host || system.info.h === system.name,\n\t\t\t},\n\t\t\t{ value: uptime, Icon: ClockArrowUp, label: t`Uptime`, hide: !system.info.u },\n\t\t\tosInfo[system.info.os ?? Os.Linux],\n\t\t\t{\n\t\t\t\tvalue: `${system.info.m} (${system.info.c}c${system.info.t ? `/${system.info.t}t` : \"\"})`,\n\t\t\t\tIcon: CpuIcon,\n\t\t\t\thide: !system.info.m,\n\t\t\t},\n\t\t] as {\n\t\t\tvalue: string | number | undefined\n\t\t\tlabel?: string\n\t\t\tIcon: any\n\t\t\thide?: boolean\n\t\t}[]\n\t}, [system.info, t])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#16", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 16, "start_line": 311, "end_line": 329, "text": "\t/** Space for tooltip if more than 12 containers */\n\tuseEffect(() => {\n\t\tif (!netCardRef.current || !containerData.length) {\n\t\t\tsetBottomSpacing(0)\n\t\t\treturn\n\t\t}\n\t\tconst tooltipHeight = (Object.keys(containerData[0]).length - 11) * 17.8 - 40\n\t\tconst wrapperEl = document.getElementById(\"chartwrap\") as HTMLDivElement\n\t\tconst wrapperRect = wrapperEl.getBoundingClientRect()\n\t\tconst chartRect = netCardRef.current.getBoundingClientRect()\n\t\tconst distanceToBottom = wrapperRect.bottom - chartRect.bottom\n\t\tsetBottomSpacing(tooltipHeight - distanceToBottom)\n\t}, [netCardRef, containerData])\n\n\t// keyboard navigation between systems\n\tuseEffect(() => {\n\t\tif (!systems.length) {\n\t\t\treturn\n\t\t}", "n_tokens": 167, "primary_symbol": "tooltipHeight", "primary_kind": "function", "primary_span": [311, 329], "def_symbols": ["tooltipHeight"], "symbols": ["tooltipHeight", "Space", "for", "tooltip", "more", "than", "containers", "useEffect", "netCardRef", "current", "containerData", "length", "setBottomSpacing", "return", "const", "Object", "keys", "wrapperEl", "document", "getElementById", "chartwrap", "HTMLDivElement", "wrapperRect", "getBoundingClientRect", "chartRect", "distanceToBottom", "bottom", "keyboard", "navigation", "between", "systems"], "doc_head": "\t/** Space for tooltip if more than 12 containers */\n\tuseEffect(() => {\n\t\tif (!netCardRef.current || !containerData.length) {\n\t\t\tsetBottomSpacing(0)\n\t\t\treturn\n\t\t}\n\t\tconst tooltipHeight = (Object.keys(containerData[0]).length - 11) * 17.8 - 40\n\t\tconst wrapperEl = document.getElementById(\"chartwrap\") as HTMLDivElement\n\t\tconst wrapperRect = wrapperEl.getBoundingClientRect()\n\t\tconst chartRect = netCardRef.current.getBoundingClientRect()\n\t\tconst distanceToBottom = wrapperRect.bottom - chartRect.bottom\n\t\tsetBottomSpacing(tooltipHeight - distanceToBottom)\n\t}, [netCardRef, containerData])\n\t// keyboard navigation between systems\n\tuseEffect(() => {\n\t\tif (!systems.length) {\n\t\t\treturn\n\t\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#17", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 17, "start_line": 330, "end_line": 340, "text": "\t\tconst handleKeyUp = (e: KeyboardEvent) => {\n\t\t\tif (\n\t\t\t\te.target instanceof HTMLInputElement ||\n\t\t\t\te.target instanceof HTMLTextAreaElement ||\n\t\t\t\te.shiftKey ||\n\t\t\t\te.ctrlKey ||\n\t\t\t\te.metaKey\n\t\t\t) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst currentIndex = systems.findIndex((s) => s.name === name)", "n_tokens": 71, "primary_symbol": "handleKeyUp", "primary_kind": "function", "primary_span": [330, 340], "def_symbols": ["handleKeyUp"], "symbols": ["handleKeyUp", "const", "KeyboardEvent", "target", "instanceof", "HTMLInputElement", "HTMLTextAreaElement", "shiftKey", "ctrlKey", "metaKey", "return", "currentIndex", "systems", "findIndex", "name"], "doc_head": "\t\tconst handleKeyUp = (e: KeyboardEvent) => {\n\t\t\tif (\n\t\t\t\te.target instanceof HTMLInputElement ||\n\t\t\t\te.target instanceof HTMLTextAreaElement ||\n\t\t\t\te.shiftKey ||\n\t\t\t\te.ctrlKey ||\n\t\t\t\te.metaKey\n\t\t\t) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst currentIndex = systems.findIndex((s) => s.name === name)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#18", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 18, "start_line": 341, "end_line": 359, "text": "\t\t\tif (currentIndex === -1 || systems.length <= 1) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tswitch (e.key) {\n\t\t\t\tcase \"ArrowLeft\":\n\t\t\t\tcase \"h\":\n\t\t\t\t\tconst prevIndex = (currentIndex - 1 + systems.length) % systems.length\n\t\t\t\t\tpersistChartTime.current = true\n\t\t\t\t\treturn navigate(getPagePath($router, \"system\", { name: systems[prevIndex].name }))\n\t\t\t\tcase \"ArrowRight\":\n\t\t\t\tcase \"l\":\n\t\t\t\t\tconst nextIndex = (currentIndex + 1) % systems.length\n\t\t\t\t\tpersistChartTime.current = true\n\t\t\t\t\treturn navigate(getPagePath($router, \"system\", { name: systems[nextIndex].name }))\n\t\t\t}\n\t\t}\n\t\treturn listen(document, \"keyup\", handleKeyUp)\n\t}, [name, systems])\n", "n_tokens": 168, "primary_symbol": "prevIndex", "primary_kind": "function", "primary_span": [341, 359], "def_symbols": ["prevIndex", "nextIndex"], "symbols": ["prevIndex", "nextIndex", "currentIndex", "systems", "length", "return", "switch", "key", "case", "ArrowLeft", "const", "persistChartTime", "current", "true", "navigate", "getPagePath", "router", "system", "name", "ArrowRight", "listen", "document", "keyup", "handleKeyUp"], "doc_head": "\t\t\tif (currentIndex === -1 || systems.length <= 1) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tswitch (e.key) {\n\t\t\t\tcase \"ArrowLeft\":\n\t\t\t\tcase \"h\":\n\t\t\t\t\tconst prevIndex = (currentIndex - 1 + systems.length) % systems.length\n\t\t\t\t\tpersistChartTime.current = true\n\t\t\t\t\treturn navigate(getPagePath($router, \"system\", { name: systems[prevIndex].name }))\n\t\t\t\tcase \"ArrowRight\":\n\t\t\t\tcase \"l\":\n\t\t\t\t\tconst nextIndex = (currentIndex + 1) % systems.length\n\t\t\t\t\tpersistChartTime.current = true\n\t\t\t\t\treturn navigate(getPagePath($router, \"system\", { name: systems[nextIndex].name }))\n\t\t\t}\n\t\t}\n\t\treturn listen(document, \"keyup\", handleKeyUp)\n\t}, [name, systems])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#19", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 19, "start_line": 360, "end_line": 376, "text": "\tif (!system.id) {\n\t\treturn null\n\t}\n\n\t// select field for switching between avg and max values\n\tconst maxValSelect = isLongerChart ? <SelectAvgMax max={maxValues} /> : null\n\tconst showMax = chartTime !== \"1h\" && maxValues\n\n\t// if no data, show empty message\n\tconst dataEmpty = !chartLoading && chartData.systemStats.length === 0\n\tconst lastGpuVals = Object.values(systemStats.at(-1)?.stats.g ?? {})\n\tconst hasGpuData = lastGpuVals.length > 0\n\tconst hasGpuPowerData = lastGpuVals.some((gpu) => gpu.p !== undefined)\n\n\tlet translatedStatus: string = system.status\n\tif (system.status === SystemStatus.Up) {\n\t\ttranslatedStatus = t({ message: \"Up\", comment: \"Context: System is up\" })", "n_tokens": 184, "primary_symbol": "", "primary_kind": "", "primary_span": [360, 376], "def_symbols": [], "symbols": ["system", "return", "null", "select", "field", "for", "switching", "between", "avg", "and", "max", "values", "const", "maxValSelect", "isLongerChart", "SelectAvgMax", "maxValues", "showMax", "chartTime", "data", "show", "empty", "message", "dataEmpty", "chartLoading", "chartData", "systemStats", "length", "lastGpuVals", "Object", "stats", "hasGpuData", "hasGpuPowerData", "some", "gpu", "undefined", "let", "translatedStatus", "string", "status", "SystemStatus", "comment", "Context", "System"], "doc_head": "\tif (!system.id) {\n\t\treturn null\n\t}\n\t// select field for switching between avg and max values\n\tconst maxValSelect = isLongerChart ? <SelectAvgMax max={maxValues} /> : null\n\tconst showMax = chartTime !== \"1h\" && maxValues\n\t// if no data, show empty message\n\tconst dataEmpty = !chartLoading && chartData.systemStats.length === 0\n\tconst lastGpuVals = Object.values(systemStats.at(-1)?.stats.g ?? {})\n\tconst hasGpuData = lastGpuVals.length > 0\n\tconst hasGpuPowerData = lastGpuVals.some((gpu) => gpu.p !== undefined)\n\tlet translatedStatus: string = system.status\n\tif (system.status === SystemStatus.Up) {\n\t\ttranslatedStatus = t({ message: \"Up\", comment: \"Context: System is up\" })"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#20", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 20, "start_line": 377, "end_line": 408, "text": "\t} else if (system.status === SystemStatus.Down) {\n\t\ttranslatedStatus = t({ message: \"Down\", comment: \"Context: System is down\" })\n\t}\n\n\treturn (\n\t\t<>\n\t\t\t<div id=\"chartwrap\" className=\"grid gap-4 mb-14 overflow-x-clip\">\n\t\t\t\t{/* system info */}\n\t\t\t\t<Card>\n\t\t\t\t\t<div className=\"grid xl:flex gap-4 px-4 sm:px-6 pt-3 sm:pt-4 pb-5\">\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<h1 className=\"text-[1.6rem] font-semibold mb-1.5\">{system.name}</h1>\n\t\t\t\t\t\t\t<div className=\"flex flex-wrap items-center gap-3 gap-y-2 text-sm opacity-90\">\n\t\t\t\t\t\t\t\t<div className=\"capitalize flex gap-2 items-center\">\n\t\t\t\t\t\t\t\t\t<span className={cn(\"relative flex h-3 w-3\")}>\n\t\t\t\t\t\t\t\t\t\t{system.status === SystemStatus.Up && (\n\t\t\t\t\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75\"\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={{ animationDuration: \"1.5s\" }}\n\t\t\t\t\t\t\t\t\t\t\t></span>\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\t\t\t\tclassName={cn(\"relative inline-flex rounded-full h-3 w-3\", {\n\t\t\t\t\t\t\t\t\t\t\t\t\"bg-green-500\": system.status === SystemStatus.Up,\n\t\t\t\t\t\t\t\t\t\t\t\t\"bg-red-500\": system.status === SystemStatus.Down,\n\t\t\t\t\t\t\t\t\t\t\t\t\"bg-primary/40\": system.status === SystemStatus.Paused,\n\t\t\t\t\t\t\t\t\t\t\t\t\"bg-yellow-500\": system.status === SystemStatus.Pending,\n\t\t\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t\t\t></span>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t{translatedStatus}\n\t\t\t\t\t\t\t\t</div>", "n_tokens": 356, "primary_symbol": "", "primary_kind": "", "primary_span": [377, 408], "def_symbols": [], "symbols": ["else", "system", "status", "SystemStatus", "Down", "translatedStatus", "message", "comment", "Context", "System", "down", "return", "div", "chartwrap", "className", "grid", "gap", "overflow", "clip", "info", "Card", "flex", "text", "font", "semibold", "name", "wrap", "items", "center", "opacity", "capitalize", "span", "relative", "animate", "ping", "absolute", "inline", "full", "rounded", "green", "style", "animationDuration", "red", "primary", "Paused", "yellow", "Pending"], "doc_head": "\t} else if (system.status === SystemStatus.Down) {\n\t\ttranslatedStatus = t({ message: \"Down\", comment: \"Context: System is down\" })\n\t}\n\treturn (\n\t\t<>\n\t\t\t<div id=\"chartwrap\" className=\"grid gap-4 mb-14 overflow-x-clip\">\n\t\t\t\t{/* system info */}\n\t\t\t\t<Card>\n\t\t\t\t\t<div className=\"grid xl:flex gap-4 px-4 sm:px-6 pt-3 sm:pt-4 pb-5\">\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<h1 className=\"text-[1.6rem] font-semibold mb-1.5\">{system.name}</h1>\n\t\t\t\t\t\t\t<div className=\"flex flex-wrap items-center gap-3 gap-y-2 text-sm opacity-90\">\n\t\t\t\t\t\t\t\t<div className=\"capitalize flex gap-2 items-center\">\n\t\t\t\t\t\t\t\t\t<span className={cn(\"relative flex h-3 w-3\")}>\n\t\t\t\t\t\t\t\t\t\t{system.status === SystemStatus.Up && (\n\t\t\t\t\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75\"\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={{ animationDuration: \"1.5s\" }}\n\t\t\t\t\t\t\t\t\t\t\t></span>\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\t\t\t\tclassName={cn(\"relative inline-flex rounded-full h-3 w-3\", {\n\t\t\t\t\t\t\t\t\t\t\t\t\"bg-green-500\": system.status === SystemStatus.Up,\n\t\t\t\t\t\t\t\t\t\t\t\t\"bg-red-500\": system.status === SystemStatus.Down,\n\t\t\t\t\t\t\t\t\t\t\t\t\"bg-primary/40\": system.status === SystemStatus.Paused,\n\t\t\t\t\t\t\t\t\t\t\t\t\"bg-yellow-500\": system.statu"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#21", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 21, "start_line": 409, "end_line": 409, "text": "\t\t\t\t\t\t\t\t{systemInfo.map(({ value, label, Icon, hide }, i) => {", "n_tokens": 19, "primary_symbol": "", "primary_kind": "", "primary_span": [409, 409], "def_symbols": [], "symbols": ["systemInfo", "map", "value", "label", "Icon", "hide"], "doc_head": "\t\t\t\t\t\t\t\t{systemInfo.map(({ value, label, Icon, hide }, i) => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#22", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 22, "start_line": 410, "end_line": 445, "text": "\t\t\t\t\t\t\t\t\tif (hide || !value) {\n\t\t\t\t\t\t\t\t\t\treturn null\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst content = (\n\t\t\t\t\t\t\t\t\t\t<div className=\"flex gap-1.5 items-center\">\n\t\t\t\t\t\t\t\t\t\t\t<Icon className=\"h-4 w-4\" /> {value}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<div key={i} className=\"contents\">\n\t\t\t\t\t\t\t\t\t\t\t<Separator orientation=\"vertical\" className=\"h-4 bg-primary/30\" />\n\t\t\t\t\t\t\t\t\t\t\t{label ? (\n\t\t\t\t\t\t\t\t\t\t\t\t<TooltipProvider>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Tooltip delayDuration={150}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<TooltipTrigger asChild>{content}</TooltipTrigger>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<TooltipContent>{label}</TooltipContent>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t\t\t\t\t\t</TooltipProvider>\n\t\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t\tcontent\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"xl:ms-auto flex items-center gap-2 max-sm:-mb-1\">\n\t\t\t\t\t\t\t<ChartTimeSelect className=\"w-full xl:w-40\" />\n\t\t\t\t\t\t\t<TooltipProvider delayDuration={100}>\n\t\t\t\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t\taria-label={t`Toggle grid`}\n\t\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"hidden xl:flex p-0 text-primary\"", "n_tokens": 279, "primary_symbol": "content", "primary_kind": "function", "primary_span": [410, 445], "def_symbols": ["content"], "symbols": ["content", "hide", "value", "return", "null", "const", "div", "className", "flex", "gap", "items", "center", "Icon", "key", "contents", "Separator", "orientation", "vertical", "primary", "label", "TooltipProvider", "Tooltip", "delayDuration", "TooltipTrigger", "asChild", "TooltipContent", "auto", "max", "ChartTimeSelect", "full", "Button", "aria", "Toggle", "grid", "variant", "outline", "size", "icon", "hidden", "text"], "doc_head": "\t\t\t\t\t\t\t\t\tif (hide || !value) {\n\t\t\t\t\t\t\t\t\t\treturn null\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst content = (\n\t\t\t\t\t\t\t\t\t\t<div className=\"flex gap-1.5 items-center\">\n\t\t\t\t\t\t\t\t\t\t\t<Icon className=\"h-4 w-4\" /> {value}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<div key={i} className=\"contents\">\n\t\t\t\t\t\t\t\t\t\t\t<Separator orientation=\"vertical\" className=\"h-4 bg-primary/30\" />\n\t\t\t\t\t\t\t\t\t\t\t{label ? (\n\t\t\t\t\t\t\t\t\t\t\t\t<TooltipProvider>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Tooltip delayDuration={150}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<TooltipTrigger asChild>{content}</TooltipTrigger>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<TooltipContent>{label}</TooltipContent>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t\t\t\t\t\t</TooltipProvider>\n\t\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t\tcontent\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"xl:ms-auto flex items-center gap-2 max-sm:-mb-1\">\n\t\t\t\t\t\t\t<ChartTimeSelect className=\"w-full xl:w-40\" />\n\t\t\t\t\t\t\t<TooltipProvider delayDuration={100}>\n\t\t\t\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t\taria-label={t`Toggle grid`}\n\t\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"hidden xl:flex p-0 text-primary\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#23", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 23, "start_line": 446, "end_line": 476, "text": "\t\t\t\t\t\t\t\t\t\t\tonClick={() => setGrid(!grid)}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{grid ? (\n\t\t\t\t\t\t\t\t\t\t\t\t<LayoutGridIcon className=\"h-[1.2rem] w-[1.2rem] opacity-75\" />\n\t\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t\t<Rows className=\"h-[1.3rem] w-[1.3rem] opacity-75\" />\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t\t\t\t<TooltipContent>{t`Toggle grid`}</TooltipContent>\n\t\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t</TooltipProvider>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</Card>\n\n\t\t\t\t{/* main charts */}\n\t\t\t\t<div className=\"grid xl:grid-cols-2 gap-4\">\n\t\t\t\t\t<ChartCard\n\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\ttitle={t`CPU Usage`}\n\t\t\t\t\t\tdescription={t`Average system-wide CPU utilization`}\n\t\t\t\t\t\tcornerEl={maxValSelect}\n\t\t\t\t\t>\n\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\tmaxToggled={maxValues}\n\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlabel: t`CPU Usage`,", "n_tokens": 240, "primary_symbol": "", "primary_kind": "", "primary_span": [446, 476], "def_symbols": [], "symbols": ["onClick", "setGrid", "grid", "LayoutGridIcon", "className", "opacity", "Rows", "Button", "TooltipTrigger", "TooltipContent", "Toggle", "Tooltip", "TooltipProvider", "div", "Card", "main", "charts", "cols", "gap", "ChartCard", "empty", "dataEmpty", "title", "CPU", "Usage", "description", "Average", "system", "wide", "utilization", "cornerEl", "maxValSelect", "AreaChartDefault", "chartData", "maxToggled", "maxValues", "dataPoints", "label"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\tonClick={() => setGrid(!grid)}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{grid ? (\n\t\t\t\t\t\t\t\t\t\t\t\t<LayoutGridIcon className=\"h-[1.2rem] w-[1.2rem] opacity-75\" />\n\t\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t\t<Rows className=\"h-[1.3rem] w-[1.3rem] opacity-75\" />\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t\t\t\t<TooltipContent>{t`Toggle grid`}</TooltipContent>\n\t\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t</TooltipProvider>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</Card>\n\t\t\t\t{/* main charts */}\n\t\t\t\t<div className=\"grid xl:grid-cols-2 gap-4\">\n\t\t\t\t\t<ChartCard\n\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\ttitle={t`CPU Usage`}\n\t\t\t\t\t\tdescription={t`Average system-wide CPU utilization`}\n\t\t\t\t\t\tcornerEl={maxValSelect}\n\t\t\t\t\t>\n\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\tmaxToggled={maxValues}\n\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlabel: t`CPU Usage`,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#24", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 24, "start_line": 477, "end_line": 482, "text": "\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => (showMax ? stats?.cpum : stats?.cpu),\n\t\t\t\t\t\t\t\t\tcolor: 1,\n\t\t\t\t\t\t\t\t\topacity: 0.4,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\ttickFormatter={(val) => toFixedFloat(val, 2) + \"%\"}", "n_tokens": 61, "primary_symbol": "", "primary_kind": "", "primary_span": [477, 482], "def_symbols": [], "symbols": ["dataKey", "stats", "showMax", "cpum", "cpu", "color", "opacity", "tickFormatter", "val", "toFixedFloat"], "doc_head": "\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => (showMax ? stats?.cpum : stats?.cpu),\n\t\t\t\t\t\t\t\t\tcolor: 1,\n\t\t\t\t\t\t\t\t\topacity: 0.4,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\ttickFormatter={(val) => toFixedFloat(val, 2) + \"%\"}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#25", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 25, "start_line": 483, "end_line": 547, "text": "\t\t\t\t\t\t\tcontentFormatter={({ value }) => decimalString(value) + \"%\"}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</ChartCard>\n\n\t\t\t\t\t{containerFilterBar && (\n\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\ttitle={dockerOrPodman(t`Docker CPU Usage`, system)}\n\t\t\t\t\t\t\tdescription={t`Average CPU utilization of containers`}\n\t\t\t\t\t\t\tcornerEl={containerFilterBar}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<ContainerChart\n\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\tdataKey=\"c\"\n\t\t\t\t\t\t\t\tchartType={ChartType.CPU}\n\t\t\t\t\t\t\t\tchartConfig={containerChartConfigs.cpu}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t)}\n\n\t\t\t\t\t<ChartCard\n\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\ttitle={t`Memory Usage`}\n\t\t\t\t\t\tdescription={t`Precise utilization at the recorded time`}\n\t\t\t\t\t\tcornerEl={maxValSelect}\n\t\t\t\t\t>\n\t\t\t\t\t\t<MemChart chartData={chartData} showMax={showMax} />\n\t\t\t\t\t</ChartCard>\n\n\t\t\t\t\t{containerFilterBar && (\n\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\ttitle={dockerOrPodman(t`Docker Memory Usage`, system)}\n\t\t\t\t\t\t\tdescription={dockerOrPodman(t`Memory usage of docker containers`, system)}\n\t\t\t\t\t\t\tcornerEl={containerFilterBar}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<ContainerChart\n\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\tdataKey=\"m\"\n\t\t\t\t\t\t\t\tchartType={ChartType.Memory}\n\t\t\t\t\t\t\t\tchartConfig={containerChartConfigs.memory}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t)}\n\n\t\t\t\t\t<ChartCard empty={dataEmpty} grid={grid} title={t`Disk Usage`} description={t`Usage of root partition`}>\n\t\t\t\t\t\t<DiskChart chartData={chartData} dataKey=\"stats.du\" diskSize={systemStats.at(-1)?.stats.d ?? NaN} />\n\t\t\t\t\t</ChartCard>\n\n\t\t\t\t\t<ChartCard\n\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\ttitle={t`Disk I/O`}\n\t\t\t\t\t\tdescription={t`Throughput of root filesystem`}\n\t\t\t\t\t\tcornerEl={maxValSelect}\n\t\t\t\t\t>\n\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\tmaxToggled={maxValues}\n\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlabel: t({ message: \"Write\", comment: \"Disk write\" }),", "n_tokens": 508, "primary_symbol": "", "primary_kind": "", "primary_span": [483, 547], "def_symbols": [], "symbols": ["contentFormatter", "value", "decimalString", "ChartCard", "containerFilterBar", "empty", "dataEmpty", "grid", "title", "dockerOrPodman", "Docker", "CPU", "Usage", "system", "description", "Average", "utilization", "containers", "cornerEl", "ContainerChart", "chartData", "dataKey", "chartType", "ChartType", "chartConfig", "containerChartConfigs", "cpu", "Memory", "Precise", "the", "recorded", "time", "maxValSelect", "MemChart", "showMax", "usage", "docker", "memory", "Disk", "root", "partition", "DiskChart", "stats", "diskSize", "systemStats", "NaN", "Throughput", "filesystem", "AreaChartDefault", "maxToggled", "maxValues", "dataPoints", "label", "message", "Write", "comment", "write"], "doc_head": "\t\t\t\t\t\t\tcontentFormatter={({ value }) => decimalString(value) + \"%\"}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</ChartCard>\n\t\t\t\t\t{containerFilterBar && (\n\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\ttitle={dockerOrPodman(t`Docker CPU Usage`, system)}\n\t\t\t\t\t\t\tdescription={t`Average CPU utilization of containers`}\n\t\t\t\t\t\t\tcornerEl={containerFilterBar}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<ContainerChart\n\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\tdataKey=\"c\"\n\t\t\t\t\t\t\t\tchartType={ChartType.CPU}\n\t\t\t\t\t\t\t\tchartConfig={containerChartConfigs.cpu}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t)}\n\t\t\t\t\t<ChartCard\n\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\ttitle={t`Memory Usage`}\n\t\t\t\t\t\tdescription={t`Precise utilization at the recorded time`}\n\t\t\t\t\t\tcornerEl={maxValSelect}\n\t\t\t\t\t>\n\t\t\t\t\t\t<MemChart chartData={chartData} showMax={showMax} />\n\t\t\t\t\t</ChartCard>\n\t\t\t\t\t{containerFilterBar && (\n\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\ttitle={dockerOrPodman(t`Docker Memory Usage`, system)}\n\t\t\t\t\t\t\tdescription={dockerOrPodman(t`Memory usage of docker containers`, system)}\n\t\t\t\t\t\t\tcornerEl={containerFilterBar}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<ContainerChart\n\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\tdataKey=\"m\"\n\t\t\t\t\t\t\t\tchartType={ChartType.Memory}\n"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#26", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 26, "start_line": 548, "end_line": 562, "text": "\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => (showMax ? stats?.dwm : stats?.dw),\n\t\t\t\t\t\t\t\t\tcolor: 3,\n\t\t\t\t\t\t\t\t\topacity: 0.3,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlabel: t({ message: \"Read\", comment: \"Disk read\" }),\n\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => (showMax ? stats?.drm : stats?.dr),\n\t\t\t\t\t\t\t\t\tcolor: 1,\n\t\t\t\t\t\t\t\t\topacity: 0.3,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\t\tconst { value, unit } = formatBytes(val, true, userSettings.unitDisk, true)\n\t\t\t\t\t\t\t\treturn toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit\n\t\t\t\t\t\t\t}}", "n_tokens": 157, "primary_symbol": "", "primary_kind": "", "primary_span": [548, 562], "def_symbols": [], "symbols": ["dataKey", "stats", "showMax", "dwm", "color", "opacity", "label", "message", "Read", "comment", "Disk", "read", "drm", "tickFormatter", "val", "const", "value", "unit", "formatBytes", "true", "userSettings", "unitDisk", "return", "toFixedFloat"], "doc_head": "\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => (showMax ? stats?.dwm : stats?.dw),\n\t\t\t\t\t\t\t\t\tcolor: 3,\n\t\t\t\t\t\t\t\t\topacity: 0.3,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlabel: t({ message: \"Read\", comment: \"Disk read\" }),\n\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => (showMax ? stats?.drm : stats?.dr),\n\t\t\t\t\t\t\t\t\tcolor: 1,\n\t\t\t\t\t\t\t\t\topacity: 0.3,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\t\tconst { value, unit } = formatBytes(val, true, userSettings.unitDisk, true)\n\t\t\t\t\t\t\t\treturn toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit\n\t\t\t\t\t\t\t}}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#27", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 27, "start_line": 563, "end_line": 584, "text": "\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value, true, userSettings.unitDisk, true)\n\t\t\t\t\t\t\t\treturn decimalString(convertedValue, convertedValue >= 100 ? 1 : 2) + \" \" + unit\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</ChartCard>\n\n\t\t\t\t\t<ChartCard\n\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\ttitle={t`Bandwidth`}\n\t\t\t\t\t\tcornerEl={maxValSelect}\n\t\t\t\t\t\tdescription={t`Network traffic of public interfaces`}\n\t\t\t\t\t>\n\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\tmaxToggled={maxValues}\n\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlabel: t`Sent`,\n\t\t\t\t\t\t\t\t\t// use bytes if available, otherwise multiply old MB (can remove in future)\n\t\t\t\t\t\t\t\t\tdataKey(data) {", "n_tokens": 181, "primary_symbol": "", "primary_kind": "", "primary_span": [563, 584], "def_symbols": [], "symbols": ["contentFormatter", "value", "const", "convertedValue", "unit", "formatBytes", "true", "userSettings", "unitDisk", "return", "decimalString", "ChartCard", "empty", "dataEmpty", "grid", "title", "Bandwidth", "cornerEl", "maxValSelect", "description", "Network", "traffic", "public", "interfaces", "AreaChartDefault", "chartData", "maxToggled", "maxValues", "dataPoints", "label", "Sent", "use", "bytes", "available", "otherwise", "multiply", "old", "can", "remove", "future", "dataKey", "data"], "doc_head": "\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value, true, userSettings.unitDisk, true)\n\t\t\t\t\t\t\t\treturn decimalString(convertedValue, convertedValue >= 100 ? 1 : 2) + \" \" + unit\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</ChartCard>\n\t\t\t\t\t<ChartCard\n\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\ttitle={t`Bandwidth`}\n\t\t\t\t\t\tcornerEl={maxValSelect}\n\t\t\t\t\t\tdescription={t`Network traffic of public interfaces`}\n\t\t\t\t\t>\n\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\tmaxToggled={maxValues}\n\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlabel: t`Sent`,\n\t\t\t\t\t\t\t\t\t// use bytes if available, otherwise multiply old MB (can remove in future)\n\t\t\t\t\t\t\t\t\tdataKey(data) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#28", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 28, "start_line": 585, "end_line": 604, "text": "\t\t\t\t\t\t\t\t\t\tif (showMax) {\n\t\t\t\t\t\t\t\t\t\t\treturn data?.stats?.bm?.[0] ?? (data?.stats?.nsm ?? 0) * 1024 * 1024\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn data?.stats?.b?.[0] ?? data?.stats?.ns * 1024 * 1024\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcolor: 5,\n\t\t\t\t\t\t\t\t\topacity: 0.2,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlabel: t`Received`,\n\t\t\t\t\t\t\t\t\tdataKey(data) {\n\t\t\t\t\t\t\t\t\t\tif (showMax) {\n\t\t\t\t\t\t\t\t\t\t\treturn data?.stats?.bm?.[1] ?? (data?.stats?.nrm ?? 0) * 1024 * 1024\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn data?.stats?.b?.[1] ?? data?.stats?.nr * 1024 * 1024\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcolor: 2,\n\t\t\t\t\t\t\t\t\topacity: 0.2,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]}", "n_tokens": 197, "primary_symbol": "", "primary_kind": "", "primary_span": [585, 604], "def_symbols": [], "symbols": ["showMax", "return", "data", "stats", "nsm", "color", "opacity", "label", "Received", "dataKey", "nrm"], "doc_head": "\t\t\t\t\t\t\t\t\t\tif (showMax) {\n\t\t\t\t\t\t\t\t\t\t\treturn data?.stats?.bm?.[0] ?? (data?.stats?.nsm ?? 0) * 1024 * 1024\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn data?.stats?.b?.[0] ?? data?.stats?.ns * 1024 * 1024\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcolor: 5,\n\t\t\t\t\t\t\t\t\topacity: 0.2,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlabel: t`Received`,\n\t\t\t\t\t\t\t\t\tdataKey(data) {\n\t\t\t\t\t\t\t\t\t\tif (showMax) {\n\t\t\t\t\t\t\t\t\t\t\treturn data?.stats?.bm?.[1] ?? (data?.stats?.nrm ?? 0) * 1024 * 1024\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn data?.stats?.b?.[1] ?? data?.stats?.nr * 1024 * 1024\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcolor: 2,\n\t\t\t\t\t\t\t\t\topacity: 0.2,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#29", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 29, "start_line": 605, "end_line": 608, "text": "\t\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\t\tlet { value, unit } = formatBytes(val, true, userSettings.unitNet, false)\n\t\t\t\t\t\t\t\treturn toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit\n\t\t\t\t\t\t\t}}", "n_tokens": 57, "primary_symbol": "", "primary_kind": "", "primary_span": [605, 608], "def_symbols": [], "symbols": ["tickFormatter", "val", "let", "value", "unit", "formatBytes", "true", "userSettings", "unitNet", "false", "return", "toFixedFloat"], "doc_head": "\t\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\t\tlet { value, unit } = formatBytes(val, true, userSettings.unitNet, false)\n\t\t\t\t\t\t\t\treturn toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit\n\t\t\t\t\t\t\t}}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#30", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 30, "start_line": 609, "end_line": 692, "text": "\t\t\t\t\t\t\tcontentFormatter={(data) => {\n\t\t\t\t\t\t\t\tconst { value, unit } = formatBytes(data.value, true, userSettings.unitNet, false)\n\t\t\t\t\t\t\t\treturn decimalString(value, value >= 100 ? 1 : 2) + \" \" + unit\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</ChartCard>\n\n\t\t\t\t\t{containerFilterBar && containerData.length > 0 && (\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tref={netCardRef}\n\t\t\t\t\t\t\tclassName={cn({\n\t\t\t\t\t\t\t\t\"col-span-full\": !grid,\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\t\ttitle={dockerOrPodman(t`Docker Network I/O`, system)}\n\t\t\t\t\t\t\t\tdescription={dockerOrPodman(t`Network traffic of docker containers`, system)}\n\t\t\t\t\t\t\t\tcornerEl={containerFilterBar}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<ContainerChart\n\t\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\t\tchartType={ChartType.Network}\n\t\t\t\t\t\t\t\t\tdataKey=\"n\"\n\t\t\t\t\t\t\t\t\tchartConfig={containerChartConfigs.network}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* Swap chart */}\n\t\t\t\t\t{(systemStats.at(-1)?.stats.su ?? 0) > 0 && (\n\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\ttitle={t`Swap Usage`}\n\t\t\t\t\t\t\tdescription={t`Swap space used by the system`}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<SwapChart chartData={chartData} />\n\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* Load Average chart */}\n\t\t\t\t\t{chartData.agentVersion?.minor >= 12 && (\n\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\ttitle={t`Load Average`}\n\t\t\t\t\t\t\tdescription={t`System load averages over time`}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<LoadAverageChart chartData={chartData} />\n\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* Temperature chart */}\n\t\t\t\t\t{systemStats.at(-1)?.stats.t && (\n\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\ttitle={t`Temperature`}\n\t\t\t\t\t\t\tdescription={t`Temperatures of system sensors`}\n\t\t\t\t\t\t\tcornerEl={<FilterBar store={$temperatureFilter} />}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<TemperatureChart chartData={chartData} />\n\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* Battery chart */}\n\t\t\t\t\t{systemStats.at(-1)?.stats.bat && (\n\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\ttitle={t`Battery`}\n\t\t\t\t\t\t\tdescription={`${t({\n\t\t\t\t\t\t\t\tmessage: \"Current state\",\n\t\t\t\t\t\t\t\tcomment: \"Context: Battery state\",\n\t\t\t\t\t\t\t})}: ${batteryStateTranslations[systemStats.at(-1)?.stats.bat![1] ?? 0]()}`}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\tmaxToggled={maxValues}\n\t\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlabel: t`Charge`,", "n_tokens": 624, "primary_symbol": "", "primary_kind": "", "primary_span": [609, 692], "def_symbols": [], "symbols": ["contentFormatter", "data", "const", "value", "unit", "formatBytes", "true", "userSettings", "unitNet", "false", "return", "decimalString", "ChartCard", "containerFilterBar", "containerData", "length", "div", "ref", "netCardRef", "className", "col", "span", "full", "grid", "empty", "dataEmpty", "title", "dockerOrPodman", "Docker", "Network", "system", "description", "traffic", "docker", "containers", "cornerEl", "ContainerChart", "chartData", "chartType", "ChartType", "dataKey", "chartConfig", "containerChartConfigs", "network", "Swap", "chart", "systemStats", "stats", "Usage", "space", "used", "the", "SwapChart", "Load", "Average", "agentVersion", "minor", "System", "load", "averages", "over", "time", "LoadAverageChart", "Temperature", "Temperatures", "sensors", "FilterBar", "store", "temperatureFilter", "TemperatureChart", "Battery", "bat", "message", "Current", "state", "comment", "Context", "batteryStateTranslations", "AreaChartDefault", "maxToggled", "maxValues", "dataPoints", "label", "Charge"], "doc_head": "\t\t\t\t\t\t\tcontentFormatter={(data) => {\n\t\t\t\t\t\t\t\tconst { value, unit } = formatBytes(data.value, true, userSettings.unitNet, false)\n\t\t\t\t\t\t\t\treturn decimalString(value, value >= 100 ? 1 : 2) + \" \" + unit\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</ChartCard>\n\t\t\t\t\t{containerFilterBar && containerData.length > 0 && (\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tref={netCardRef}\n\t\t\t\t\t\t\tclassName={cn({\n\t\t\t\t\t\t\t\t\"col-span-full\": !grid,\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\t\ttitle={dockerOrPodman(t`Docker Network I/O`, system)}\n\t\t\t\t\t\t\t\tdescription={dockerOrPodman(t`Network traffic of docker containers`, system)}\n\t\t\t\t\t\t\t\tcornerEl={containerFilterBar}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<ContainerChart\n\t\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\t\tchartType={ChartType.Network}\n\t\t\t\t\t\t\t\t\tdataKey=\"n\"\n\t\t\t\t\t\t\t\t\tchartConfig={containerChartConfigs.network}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t\t{/* Swap chart */}\n\t\t\t\t\t{(systemStats.at(-1)?.stats.su ?? 0) > 0 && (\n\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\ttitle={t`Swap Usage`}\n\t\t\t\t\t\t\tdescription={t`Swap space used by the system`}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<SwapChart chartData={chartData} />\n\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t)}\n\t\t\t\t\t{/* Load Average chart */}\n\t\t\t\t\t{cha"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#31", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 31, "start_line": 693, "end_line": 720, "text": "\t\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => stats?.bat?.[0],\n\t\t\t\t\t\t\t\t\t\tcolor: 1,\n\t\t\t\t\t\t\t\t\t\topacity: 0.35,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t\tdomain={[0, 100]}\n\t\t\t\t\t\t\t\ttickFormatter={(val) => `${val}%`}\n\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => `${value}%`}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* GPU power draw chart */}\n\t\t\t\t\t{hasGpuPowerData && (\n\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\ttitle={t`GPU Power Draw`}\n\t\t\t\t\t\t\tdescription={t`Average power consumption of GPUs`}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<GpuPowerChart chartData={chartData} />\n\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\n\t\t\t\t{/* GPU charts */}\n\t\t\t\t{hasGpuData && (\n\t\t\t\t\t<div className=\"grid xl:grid-cols-2 gap-4\">", "n_tokens": 197, "primary_symbol": "", "primary_kind": "", "primary_span": [693, 720], "def_symbols": [], "symbols": ["dataKey", "stats", "bat", "color", "opacity", "domain", "tickFormatter", "val", "contentFormatter", "value", "ChartCard", "GPU", "power", "draw", "chart", "hasGpuPowerData", "empty", "dataEmpty", "grid", "title", "Power", "Draw", "description", "Average", "consumption", "GPUs", "GpuPowerChart", "chartData", "div", "charts", "hasGpuData", "className", "cols", "gap"], "doc_head": "\t\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => stats?.bat?.[0],\n\t\t\t\t\t\t\t\t\t\tcolor: 1,\n\t\t\t\t\t\t\t\t\t\topacity: 0.35,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t\tdomain={[0, 100]}\n\t\t\t\t\t\t\t\ttickFormatter={(val) => `${val}%`}\n\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => `${value}%`}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t)}\n\t\t\t\t\t{/* GPU power draw chart */}\n\t\t\t\t\t{hasGpuPowerData && (\n\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\ttitle={t`GPU Power Draw`}\n\t\t\t\t\t\t\tdescription={t`Average power consumption of GPUs`}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<GpuPowerChart chartData={chartData} />\n\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t\t{/* GPU charts */}\n\t\t\t\t{hasGpuData && (\n\t\t\t\t\t<div className=\"grid xl:grid-cols-2 gap-4\">"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#32", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 32, "start_line": 721, "end_line": 741, "text": "\t\t\t\t\t\t{Object.keys(systemStats.at(-1)?.stats.g ?? {}).map((id) => {\n\t\t\t\t\t\t\tconst gpu = systemStats.at(-1)?.stats.g?.[id] as GPUData\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<div key={id} className=\"contents\">\n\t\t\t\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\t\t\t\ttitle={`${gpu.n} ${t`Usage`}`}\n\t\t\t\t\t\t\t\t\t\tdescription={t`Average utilization of ${gpu.n}`}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: t`Usage`,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => stats?.g?.[id]?.u ?? 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\topacity: 0.35,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t\t\t\t\ttickFormatter={(val) => toFixedFloat(val, 2) + \"%\"}", "n_tokens": 189, "primary_symbol": "", "primary_kind": "", "primary_span": [721, 741], "def_symbols": [], "symbols": ["Object", "keys", "systemStats", "stats", "map", "const", "gpu", "GPUData", "return", "div", "key", "className", "contents", "ChartCard", "empty", "dataEmpty", "grid", "title", "Usage", "description", "Average", "utilization", "AreaChartDefault", "chartData", "dataPoints", "label", "dataKey", "color", "opacity", "tickFormatter", "val", "toFixedFloat"], "doc_head": "\t\t\t\t\t\t{Object.keys(systemStats.at(-1)?.stats.g ?? {}).map((id) => {\n\t\t\t\t\t\t\tconst gpu = systemStats.at(-1)?.stats.g?.[id] as GPUData\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<div key={id} className=\"contents\">\n\t\t\t\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\t\t\t\ttitle={`${gpu.n} ${t`Usage`}`}\n\t\t\t\t\t\t\t\t\t\tdescription={t`Average utilization of ${gpu.n}`}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: t`Usage`,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => stats?.g?.[id]?.u ?? 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\topacity: 0.35,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t\t\t\t\ttickFormatter={(val) => toFixedFloat(val, 2) + \"%\"}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#33", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 33, "start_line": 742, "end_line": 765, "text": "\t\t\t\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => decimalString(value) + \"%\"}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\t\t\t\ttitle={`${gpu.n} VRAM`}\n\t\t\t\t\t\t\t\t\t\tdescription={t`Precise utilization at the recorded time`}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: t`Usage`,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => stats?.g?.[id]?.mu ?? 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\topacity: 0.25,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t\t\t\t\tmax={gpu.mt}\n\t\t\t\t\t\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\t\t\t\t\t\tconst { value, unit } = formatBytes(val, false, Unit.Bytes, true)\n\t\t\t\t\t\t\t\t\t\t\t\treturn toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit\n\t\t\t\t\t\t\t\t\t\t\t}}", "n_tokens": 198, "primary_symbol": "", "primary_kind": "", "primary_span": [742, 765], "def_symbols": [], "symbols": ["contentFormatter", "value", "decimalString", "ChartCard", "empty", "dataEmpty", "grid", "title", "gpu", "VRAM", "description", "Precise", "utilization", "the", "recorded", "time", "AreaChartDefault", "chartData", "dataPoints", "label", "Usage", "dataKey", "stats", "color", "opacity", "max", "tickFormatter", "val", "const", "unit", "formatBytes", "false", "Unit", "Bytes", "true", "return", "toFixedFloat"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => decimalString(value) + \"%\"}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\t\t\t\ttitle={`${gpu.n} VRAM`}\n\t\t\t\t\t\t\t\t\t\tdescription={t`Precise utilization at the recorded time`}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: t`Usage`,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => stats?.g?.[id]?.mu ?? 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\topacity: 0.25,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t\t\t\t\tmax={gpu.mt}\n\t\t\t\t\t\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\t\t\t\t\t\tconst { value, unit } = formatBytes(val, false, Unit.Bytes, true)\n\t\t\t\t\t\t\t\t\t\t\t\treturn toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit\n\t\t\t\t\t\t\t\t\t\t\t}}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#34", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 34, "start_line": 766, "end_line": 780, "text": "\t\t\t\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value, false, Unit.Bytes, true)\n\t\t\t\t\t\t\t\t\t\t\t\treturn decimalString(convertedValue) + \" \" + unit\n\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\n\t\t\t\t{/* extra filesystem charts */}\n\t\t\t\t{Object.keys(systemStats.at(-1)?.stats.efs ?? {}).length > 0 && (\n\t\t\t\t\t<div className=\"grid xl:grid-cols-2 gap-4\">", "n_tokens": 120, "primary_symbol": "", "primary_kind": "", "primary_span": [766, 780], "def_symbols": [], "symbols": ["contentFormatter", "value", "const", "convertedValue", "unit", "formatBytes", "false", "Unit", "Bytes", "true", "return", "decimalString", "ChartCard", "div", "extra", "filesystem", "charts", "Object", "keys", "systemStats", "stats", "efs", "length", "className", "grid", "cols", "gap"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value, false, Unit.Bytes, true)\n\t\t\t\t\t\t\t\t\t\t\t\treturn decimalString(convertedValue) + \" \" + unit\n\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t\t{/* extra filesystem charts */}\n\t\t\t\t{Object.keys(systemStats.at(-1)?.stats.efs ?? {}).length > 0 && (\n\t\t\t\t\t<div className=\"grid xl:grid-cols-2 gap-4\">"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#35", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 35, "start_line": 781, "end_line": 807, "text": "\t\t\t\t\t\t{Object.keys(systemStats.at(-1)?.stats.efs ?? {}).map((extraFsName) => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<div key={extraFsName} className=\"contents\">\n\t\t\t\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\t\t\t\ttitle={`${extraFsName} ${t`Usage`}`}\n\t\t\t\t\t\t\t\t\t\tdescription={t`Disk usage of ${extraFsName}`}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<DiskChart\n\t\t\t\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\t\t\t\tdataKey={`stats.efs.${extraFsName}.du`}\n\t\t\t\t\t\t\t\t\t\t\tdiskSize={systemStats.at(-1)?.stats.efs?.[extraFsName].d ?? NaN}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\t\t\t\ttitle={`${extraFsName} I/O`}\n\t\t\t\t\t\t\t\t\t\tdescription={t`Throughput of ${extraFsName}`}\n\t\t\t\t\t\t\t\t\t\tcornerEl={maxValSelect}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: t`Write`,", "n_tokens": 231, "primary_symbol": "", "primary_kind": "", "primary_span": [781, 807], "def_symbols": [], "symbols": ["Object", "keys", "systemStats", "stats", "efs", "map", "extraFsName", "return", "div", "key", "className", "contents", "ChartCard", "empty", "dataEmpty", "grid", "title", "Usage", "description", "Disk", "usage", "DiskChart", "chartData", "dataKey", "diskSize", "NaN", "Throughput", "cornerEl", "maxValSelect", "AreaChartDefault", "dataPoints", "label", "Write"], "doc_head": "\t\t\t\t\t\t{Object.keys(systemStats.at(-1)?.stats.efs ?? {}).map((extraFsName) => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<div key={extraFsName} className=\"contents\">\n\t\t\t\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\t\t\t\ttitle={`${extraFsName} ${t`Usage`}`}\n\t\t\t\t\t\t\t\t\t\tdescription={t`Disk usage of ${extraFsName}`}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<DiskChart\n\t\t\t\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\t\t\t\tdataKey={`stats.efs.${extraFsName}.du`}\n\t\t\t\t\t\t\t\t\t\t\tdiskSize={systemStats.at(-1)?.stats.efs?.[extraFsName].d ?? NaN}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t\t\t\t\t<ChartCard\n\t\t\t\t\t\t\t\t\t\tempty={dataEmpty}\n\t\t\t\t\t\t\t\t\t\tgrid={grid}\n\t\t\t\t\t\t\t\t\t\ttitle={`${extraFsName} I/O`}\n\t\t\t\t\t\t\t\t\t\tdescription={t`Throughput of ${extraFsName}`}\n\t\t\t\t\t\t\t\t\t\tcornerEl={maxValSelect}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<AreaChartDefault\n\t\t\t\t\t\t\t\t\t\t\tchartData={chartData}\n\t\t\t\t\t\t\t\t\t\t\tdataPoints={[\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: t`Write`,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#36", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 36, "start_line": 808, "end_line": 823, "text": "\t\t\t\t\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => stats?.efs?.[extraFsName]?.[showMax ? \"wm\" : \"w\"] ?? 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\topacity: 0.3,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: t`Read`,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => stats?.efs?.[extraFsName]?.[showMax ? \"rm\" : \"r\"] ?? 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\topacity: 0.3,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t\t\t\t\tmaxToggled={maxValues}\n\t\t\t\t\t\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\t\t\t\t\t\tconst { value, unit } = formatBytes(val, true, userSettings.unitDisk, true)\n\t\t\t\t\t\t\t\t\t\t\t\treturn toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit\n\t\t\t\t\t\t\t\t\t\t\t}}", "n_tokens": 178, "primary_symbol": "", "primary_kind": "", "primary_span": [808, 823], "def_symbols": [], "symbols": ["dataKey", "stats", "efs", "extraFsName", "showMax", "color", "opacity", "label", "Read", "maxToggled", "maxValues", "tickFormatter", "val", "const", "value", "unit", "formatBytes", "true", "userSettings", "unitDisk", "return", "toFixedFloat"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => stats?.efs?.[extraFsName]?.[showMax ? \"wm\" : \"w\"] ?? 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\topacity: 0.3,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tlabel: t`Read`,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdataKey: ({ stats }) => stats?.efs?.[extraFsName]?.[showMax ? \"rm\" : \"r\"] ?? 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\topacity: 0.3,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t\t\t\t\tmaxToggled={maxValues}\n\t\t\t\t\t\t\t\t\t\t\ttickFormatter={(val) => {\n\t\t\t\t\t\t\t\t\t\t\t\tconst { value, unit } = formatBytes(val, true, userSettings.unitDisk, true)\n\t\t\t\t\t\t\t\t\t\t\t\treturn toFixedFloat(value, value >= 10 ? 0 : 1) + \" \" + unit\n\t\t\t\t\t\t\t\t\t\t\t}}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#37", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 37, "start_line": 824, "end_line": 846, "text": "\t\t\t\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value, true, userSettings.unitDisk, true)\n\t\t\t\t\t\t\t\t\t\t\t\treturn decimalString(convertedValue, convertedValue >= 100 ? 1 : 2) + \" \" + unit\n\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</div>\n\n\t\t\t{/* add space for tooltip if more than 12 containers */}\n\t\t\t{bottomSpacing > 0 && <span className=\"block\" style={{ height: bottomSpacing }} />}\n\t\t</>\n\t)\n})\n\nfunction FilterBar({ store = $containerFilter }: { store?: typeof $containerFilter }) {\n\tconst containerFilter = useStore(store)\n\tconst { t } = useLingui()\n", "n_tokens": 175, "primary_symbol": "FilterBar", "primary_kind": "function", "primary_span": [843, 846], "def_symbols": ["FilterBar"], "symbols": ["FilterBar", "contentFormatter", "value", "const", "convertedValue", "unit", "formatBytes", "true", "userSettings", "unitDisk", "return", "decimalString", "ChartCard", "div", "add", "space", "for", "tooltip", "more", "than", "containers", "bottomSpacing", "span", "className", "block", "style", "height", "function", "store", "containerFilter", "typeof", "useStore", "useLingui"], "doc_head": "\t\t\t\t\t\t\t\t\t\t\tcontentFormatter={({ value }) => {\n\t\t\t\t\t\t\t\t\t\t\t\tconst { value: convertedValue, unit } = formatBytes(value, true, userSettings.unitDisk, true)\n\t\t\t\t\t\t\t\t\t\t\t\treturn decimalString(convertedValue, convertedValue >= 100 ? 1 : 2) + \" \" + unit\n\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t</ChartCard>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t\t{/* add space for tooltip if more than 12 containers */}\n\t\t\t{bottomSpacing > 0 && <span className=\"block\" style={{ height: bottomSpacing }} />}\n\t\t</>\n\t)\n})\nfunction FilterBar({ store = $containerFilter }: { store?: typeof $containerFilter }) {\n\tconst containerFilter = useStore(store)\n\tconst { t } = useLingui()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#38", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 38, "start_line": 847, "end_line": 869, "text": "\tconst handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n\t\tstore.set(e.target.value)\n\t}, [])\n\n\treturn (\n\t\t<>\n\t\t\t<Input placeholder={t`Filter...`} className=\"ps-4 pe-8\" value={containerFilter} onChange={handleChange} />\n\t\t\t{containerFilter && (\n\t\t\t\t<Button\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\taria-label=\"Clear\"\n\t\t\t\t\tclassName=\"absolute right-1 top-1/2 -translate-y-1/2 h-7 w-7 text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-100\"\n\t\t\t\t\tonClick={() => store.set(\"\")}\n\t\t\t\t>\n\t\t\t\t\t<XIcon className=\"h-4 w-4\" />\n\t\t\t\t</Button>\n\t\t\t)}\n\t\t</>\n\t)\n}\n", "n_tokens": 178, "primary_symbol": "", "primary_kind": "", "primary_span": [847, 869], "def_symbols": [], "symbols": ["const", "handleChange", "useCallback", "React", "ChangeEvent", "HTMLInputElement", "store", "set", "target", "value", "return", "Input", "placeholder", "Filter", "className", "containerFilter", "onChange", "Button", "type", "button", "variant", "ghost", "size", "icon", "aria", "label", "Clear", "absolute", "right", "top", "translate", "text", "gray", "hover", "dark", "onClick", "XIcon"], "doc_head": "\tconst handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n\t\tstore.set(e.target.value)\n\t}, [])\n\treturn (\n\t\t<>\n\t\t\t<Input placeholder={t`Filter...`} className=\"ps-4 pe-8\" value={containerFilter} onChange={handleChange} />\n\t\t\t{containerFilter && (\n\t\t\t\t<Button\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\taria-label=\"Clear\"\n\t\t\t\t\tclassName=\"absolute right-1 top-1/2 -translate-y-1/2 h-7 w-7 text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-100\"\n\t\t\t\t\tonClick={() => store.set(\"\")}\n\t\t\t\t>\n\t\t\t\t\t<XIcon className=\"h-4 w-4\" />\n\t\t\t\t</Button>\n\t\t\t)}\n\t\t</>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#39", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 39, "start_line": 870, "end_line": 872, "text": "const SelectAvgMax = memo(({ max }: { max: boolean }) => {\n\tconst Icon = max ? ChartMax : ChartAverage\n\treturn (", "n_tokens": 29, "primary_symbol": "", "primary_kind": "", "primary_span": [870, 872], "def_symbols": [], "symbols": ["const", "SelectAvgMax", "memo", "max", "boolean", "Icon", "ChartMax", "ChartAverage", "return"], "doc_head": "const SelectAvgMax = memo(({ max }: { max: boolean }) => {\n\tconst Icon = max ? ChartMax : ChartAverage\n\treturn ("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#40", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 40, "start_line": 873, "end_line": 889, "text": "\t\t<Select value={max ? \"max\" : \"avg\"} onValueChange={(e) => $maxValues.set(e === \"max\")}>\n\t\t\t<SelectTrigger className=\"relative ps-10 pe-5\">\n\t\t\t\t<Icon className=\"h-4 w-4 absolute start-4 top-1/2 -translate-y-1/2 opacity-85\" />\n\t\t\t\t<SelectValue />\n\t\t\t</SelectTrigger>\n\t\t\t<SelectContent>\n\t\t\t\t<SelectItem key=\"avg\" value=\"avg\">\n\t\t\t\t\t<Trans>Average</Trans>\n\t\t\t\t</SelectItem>\n\t\t\t\t<SelectItem key=\"max\" value=\"max\">\n\t\t\t\t\t<Trans comment=\"Chart select field. Please try to keep this short.\">Max 1 min</Trans>\n\t\t\t\t</SelectItem>\n\t\t\t</SelectContent>\n\t\t</Select>\n\t)\n})\n", "n_tokens": 178, "primary_symbol": "", "primary_kind": "", "primary_span": [873, 889], "def_symbols": [], "symbols": ["Select", "value", "max", "avg", "onValueChange", "maxValues", "set", "SelectTrigger", "className", "relative", "Icon", "absolute", "start", "top", "translate", "opacity", "SelectValue", "SelectContent", "SelectItem", "key", "Trans", "Average", "comment", "Chart", "select", "field", "Please", "try", "keep", "this", "short", "Max", "min"], "doc_head": "\t\t<Select value={max ? \"max\" : \"avg\"} onValueChange={(e) => $maxValues.set(e === \"max\")}>\n\t\t\t<SelectTrigger className=\"relative ps-10 pe-5\">\n\t\t\t\t<Icon className=\"h-4 w-4 absolute start-4 top-1/2 -translate-y-1/2 opacity-85\" />\n\t\t\t\t<SelectValue />\n\t\t\t</SelectTrigger>\n\t\t\t<SelectContent>\n\t\t\t\t<SelectItem key=\"avg\" value=\"avg\">\n\t\t\t\t\t<Trans>Average</Trans>\n\t\t\t\t</SelectItem>\n\t\t\t\t<SelectItem key=\"max\" value=\"max\">\n\t\t\t\t\t<Trans comment=\"Chart select field. Please try to keep this short.\">Max 1 min</Trans>\n\t\t\t\t</SelectItem>\n\t\t\t</SelectContent>\n\t\t</Select>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#41", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 41, "start_line": 890, "end_line": 903, "text": "function ChartCard({\n\ttitle,\n\tdescription,\n\tchildren,\n\tgrid,\n\tempty,\n\tcornerEl,\n}: {\n\ttitle: string\n\tdescription: string\n\tchildren: React.ReactNode\n\tgrid?: boolean\n\tempty?: boolean\n\tcornerEl?: JSX.Element | null", "n_tokens": 53, "primary_symbol": "ChartCard", "primary_kind": "function", "primary_span": [890, 903], "def_symbols": ["ChartCard"], "symbols": ["ChartCard", "function", "title", "description", "children", "grid", "empty", "cornerEl", "string", "React", "ReactNode", "boolean", "JSX", "Element", "null"], "doc_head": "function ChartCard({\n\ttitle,\n\tdescription,\n\tchildren,\n\tgrid,\n\tempty,\n\tcornerEl,\n}: {\n\ttitle: string\n\tdescription: string\n\tchildren: React.ReactNode\n\tgrid?: boolean\n\tempty?: boolean\n\tcornerEl?: JSX.Element | null"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx#42", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/system.tsx", "rel_path": "src/site/src/components/routes/system.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 42, "start_line": 904, "end_line": 927, "text": "}) {\n\tconst { isIntersecting, ref } = useIntersectionObserver()\n\n\treturn (\n\t\t<Card className={cn(\"pb-2 sm:pb-4 odd:last-of-type:col-span-full\", { \"col-span-full\": !grid })} ref={ref}>\n\t\t\t<CardHeader className=\"pb-5 pt-4 gap-1 relative max-sm:py-3 max-sm:px-4\">\n\t\t\t\t<CardTitle className=\"text-xl sm:text-2xl\">{title}</CardTitle>\n\t\t\t\t<CardDescription>{description}</CardDescription>\n\t\t\t\t{cornerEl && <div className=\"relative py-1 block sm:w-44 sm:absolute sm:top-3.5 sm:end-3.5\">{cornerEl}</div>}\n\t\t\t</CardHeader>\n\t\t\t<div className=\"ps-0 w-[calc(100%-1.5em)] h-48 md:h-52 relative group\">\n\t\t\t\t{\n\t\t\t\t\t<Spinner\n\t\t\t\t\t\tmsg={empty ? t`Waiting for enough records to display` : undefined}\n\t\t\t\t\t\t// className=\"group-has-[.opacity-100]:opacity-0 transition-opacity\"\n\t\t\t\t\t\tclassName=\"group-has-[.opacity-100]:invisible duration-100\"\n\t\t\t\t\t/>\n\t\t\t\t}\n\t\t\t\t{isIntersecting && children}\n\t\t\t</div>\n\t\t</Card>\n\t)\n}\n", "n_tokens": 278, "primary_symbol": "", "primary_kind": "", "primary_span": [904, 927], "def_symbols": [], "symbols": ["const", "isIntersecting", "ref", "useIntersectionObserver", "return", "Card", "className", "odd", "last", "type", "col", "span", "full", "grid", "CardHeader", "gap", "relative", "max", "CardTitle", "text", "title", "CardDescription", "description", "cornerEl", "div", "block", "absolute", "top", "end", "calc", "group", "Spinner", "msg", "empty", "Waiting", "for", "enough", "records", "display", "undefined", "has", "opacity", "transition", "invisible", "duration", "children"], "doc_head": "}) {\n\tconst { isIntersecting, ref } = useIntersectionObserver()\n\treturn (\n\t\t<Card className={cn(\"pb-2 sm:pb-4 odd:last-of-type:col-span-full\", { \"col-span-full\": !grid })} ref={ref}>\n\t\t\t<CardHeader className=\"pb-5 pt-4 gap-1 relative max-sm:py-3 max-sm:px-4\">\n\t\t\t\t<CardTitle className=\"text-xl sm:text-2xl\">{title}</CardTitle>\n\t\t\t\t<CardDescription>{description}</CardDescription>\n\t\t\t\t{cornerEl && <div className=\"relative py-1 block sm:w-44 sm:absolute sm:top-3.5 sm:end-3.5\">{cornerEl}</div>}\n\t\t\t</CardHeader>\n\t\t\t<div className=\"ps-0 w-[calc(100%-1.5em)] h-48 md:h-52 relative group\">\n\t\t\t\t{\n\t\t\t\t\t<Spinner\n\t\t\t\t\t\tmsg={empty ? t`Waiting for enough records to display` : undefined}\n\t\t\t\t\t\t// className=\"group-has-[.opacity-100]:opacity-0 transition-opacity\"\n\t\t\t\t\t\tclassName=\"group-has-[.opacity-100]:invisible duration-100\"\n\t\t\t\t\t/>\n\t\t\t\t}\n\t\t\t\t{isIntersecting && children}\n\t\t\t</div>\n\t\t</Card>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 18, "text": "import { Trans, useLingui } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\nimport { $publicKey } from \"@/lib/stores\"\nimport { memo, useEffect, useMemo, useState } from \"react\"\nimport { Table, TableCell, TableHead, TableBody, TableRow, TableHeader } from \"@/components/ui/table\"\nimport { FingerprintRecord } from \"@/types\"\nimport {\n\tCopyIcon,\n\tFingerprintIcon,\n\tKeyIcon,\n\tMoreHorizontalIcon,\n\tRotateCwIcon,\n\tServerIcon,\n\tTrash2Icon,\n} from \"lucide-react\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport { cn, copyToClipboard, generateToken, getHubURL, tokenMap } from \"@/lib/utils\"\nimport { isReadOnlyUser, pb } from \"@/lib/api\"", "n_tokens": 175, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 18], "def_symbols": [], "symbols": ["import", "Trans", "useLingui", "from", "lingui", "react", "macro", "core", "publicKey", "lib", "stores", "memo", "useEffect", "useMemo", "useState", "Table", "TableCell", "TableHead", "TableBody", "TableRow", "TableHeader", "components", "table", "FingerprintRecord", "types", "CopyIcon", "FingerprintIcon", "KeyIcon", "MoreHorizontalIcon", "RotateCwIcon", "ServerIcon", "Trash2Icon", "lucide", "toast", "use", "copyToClipboard", "generateToken", "getHubURL", "tokenMap", "utils", "isReadOnlyUser", "api"], "doc_head": "import { Trans, useLingui } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\nimport { $publicKey } from \"@/lib/stores\"\nimport { memo, useEffect, useMemo, useState } from \"react\"\nimport { Table, TableCell, TableHead, TableBody, TableRow, TableHeader } from \"@/components/ui/table\"\nimport { FingerprintRecord } from \"@/types\"\nimport {\n\tCopyIcon,\n\tFingerprintIcon,\n\tKeyIcon,\n\tMoreHorizontalIcon,\n\tRotateCwIcon,\n\tServerIcon,\n\tTrash2Icon,\n} from \"lucide-react\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport { cn, copyToClipboard, generateToken, getHubURL, tokenMap } from \"@/lib/utils\"\nimport { isReadOnlyUser, pb } from \"@/lib/api\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 19, "end_line": 46, "text": "import {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuItem,\n\tDropdownMenuSeparator,\n\tDropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\nimport { Button } from \"@/components/ui/button\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { Switch } from \"@/components/ui/switch\"\nimport {\n\tcopyDockerCompose,\n\tcopyDockerRun,\n\tcopyLinuxCommand,\n\tcopyWindowsCommand,\n\tDropdownItem,\n\tInstallDropdown,\n} from \"@/components/install-dropdowns\"\nimport { AppleIcon, DockerIcon, TuxIcon, WindowsIcon } from \"@/components/ui/icons\"\nimport { redirectPage } from \"@nanostores/router\"\nimport { $router } from \"@/components/router\"\n\nconst pbFingerprintOptions = {\n\texpand: \"system\",\n\tfields: \"id,fingerprint,token,system,expand.system.name\",\n}\n\nfunction sortFingerprints(fingerprints: FingerprintRecord[]) {", "n_tokens": 188, "primary_symbol": "sortFingerprints", "primary_kind": "function", "primary_span": [46, 46], "def_symbols": ["sortFingerprints"], "symbols": ["sortFingerprints", "import", "DropdownMenu", "DropdownMenuContent", "DropdownMenuItem", "DropdownMenuSeparator", "DropdownMenuTrigger", "from", "components", "dropdown", "menu", "Button", "button", "Separator", "separator", "Switch", "switch", "copyDockerCompose", "copyDockerRun", "copyLinuxCommand", "copyWindowsCommand", "DropdownItem", "InstallDropdown", "install", "dropdowns", "AppleIcon", "DockerIcon", "TuxIcon", "WindowsIcon", "icons", "redirectPage", "nanostores", "router", "const", "pbFingerprintOptions", "expand", "system", "fields", "fingerprint", "token", "name", "function", "fingerprints", "FingerprintRecord"], "doc_head": "import {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuItem,\n\tDropdownMenuSeparator,\n\tDropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\nimport { Button } from \"@/components/ui/button\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { Switch } from \"@/components/ui/switch\"\nimport {\n\tcopyDockerCompose,\n\tcopyDockerRun,\n\tcopyLinuxCommand,\n\tcopyWindowsCommand,\n\tDropdownItem,\n\tInstallDropdown,\n} from \"@/components/install-dropdowns\"\nimport { AppleIcon, DockerIcon, TuxIcon, WindowsIcon } from \"@/components/ui/icons\"\nimport { redirectPage } from \"@nanostores/router\"\nimport { $router } from \"@/components/router\"\nconst pbFingerprintOptions = {\n\texpand: \"system\",\n\tfields: \"id,fingerprint,token,system,expand.system.name\",\n}\nfunction sortFingerprints(fingerprints: FingerprintRecord[]) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 47, "end_line": 72, "text": "\treturn fingerprints.sort((a, b) => a.expand.system.name.localeCompare(b.expand.system.name))\n}\n\nconst SettingsFingerprintsPage = memo(() => {\n\tif (isReadOnlyUser()) {\n\t\tredirectPage($router, \"settings\", { name: \"general\" })\n\t}\n\tconst [fingerprints, setFingerprints] = useState<FingerprintRecord[]>([])\n\n\t// Get fingerprint records on mount\n\tuseEffect(() => {\n\t\tpb.collection(\"fingerprints\")\n\t\t\t.getFullList<FingerprintRecord>(pbFingerprintOptions)\n\t\t\t.then((prints) => {\n\t\t\t\tsetFingerprints(sortFingerprints(prints))\n\t\t\t})\n\t}, [])\n\n\t// Subscribe to fingerprint updates\n\tuseEffect(() => {\n\t\tlet unsubscribe: (() => void) | undefined\n\t\t;(async () => {\n\t\t\t// subscribe to fingerprint updates\n\t\t\tunsubscribe = await pb.collection(\"fingerprints\").subscribe(\n\t\t\t\t\"*\",\n\t\t\t\t(res) => {", "n_tokens": 197, "primary_symbol": "", "primary_kind": "", "primary_span": [47, 72], "def_symbols": [], "symbols": ["return", "fingerprints", "sort", "expand", "system", "name", "localeCompare", "const", "SettingsFingerprintsPage", "memo", "isReadOnlyUser", "redirectPage", "router", "settings", "general", "setFingerprints", "useState", "FingerprintRecord", "Get", "fingerprint", "records", "mount", "useEffect", "collection", "getFullList", "pbFingerprintOptions", "then", "prints", "sortFingerprints", "Subscribe", "updates", "let", "unsubscribe", "void", "undefined", "async", "subscribe", "await", "res"], "doc_head": "\treturn fingerprints.sort((a, b) => a.expand.system.name.localeCompare(b.expand.system.name))\n}\nconst SettingsFingerprintsPage = memo(() => {\n\tif (isReadOnlyUser()) {\n\t\tredirectPage($router, \"settings\", { name: \"general\" })\n\t}\n\tconst [fingerprints, setFingerprints] = useState<FingerprintRecord[]>([])\n\t// Get fingerprint records on mount\n\tuseEffect(() => {\n\t\tpb.collection(\"fingerprints\")\n\t\t\t.getFullList<FingerprintRecord>(pbFingerprintOptions)\n\t\t\t.then((prints) => {\n\t\t\t\tsetFingerprints(sortFingerprints(prints))\n\t\t\t})\n\t}, [])\n\t// Subscribe to fingerprint updates\n\tuseEffect(() => {\n\t\tlet unsubscribe: (() => void) | undefined\n\t\t;(async () => {\n\t\t\t// subscribe to fingerprint updates\n\t\t\tunsubscribe = await pb.collection(\"fingerprints\").subscribe(\n\t\t\t\t\"*\",\n\t\t\t\t(res) => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 73, "end_line": 99, "text": "\t\t\t\t\tsetFingerprints((currentFingerprints) => {\n\t\t\t\t\t\tif (res.action === \"create\") {\n\t\t\t\t\t\t\treturn sortFingerprints([...currentFingerprints, res.record as FingerprintRecord])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (res.action === \"update\") {\n\t\t\t\t\t\t\treturn currentFingerprints.map((fingerprint) => {\n\t\t\t\t\t\t\t\tif (fingerprint.id === res.record.id) {\n\t\t\t\t\t\t\t\t\treturn { ...fingerprint, ...res.record } as FingerprintRecord\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn fingerprint\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (res.action === \"delete\") {\n\t\t\t\t\t\t\treturn currentFingerprints.filter((fingerprint) => fingerprint.id !== res.record.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn currentFingerprints\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tpbFingerprintOptions\n\t\t\t)\n\t\t})()\n\t\t// unsubscribe on unmount\n\t\treturn () => unsubscribe?.()\n\t}, [])\n\n\t// Update token map whenever fingerprints change\n\tuseEffect(() => {", "n_tokens": 200, "primary_symbol": "", "primary_kind": "", "primary_span": [73, 99], "def_symbols": [], "symbols": ["setFingerprints", "currentFingerprints", "res", "action", "create", "return", "sortFingerprints", "record", "FingerprintRecord", "update", "map", "fingerprint", "delete", "filter", "pbFingerprintOptions", "unsubscribe", "unmount", "Update", "token", "whenever", "fingerprints", "change", "useEffect"], "doc_head": "\t\t\t\t\tsetFingerprints((currentFingerprints) => {\n\t\t\t\t\t\tif (res.action === \"create\") {\n\t\t\t\t\t\t\treturn sortFingerprints([...currentFingerprints, res.record as FingerprintRecord])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (res.action === \"update\") {\n\t\t\t\t\t\t\treturn currentFingerprints.map((fingerprint) => {\n\t\t\t\t\t\t\t\tif (fingerprint.id === res.record.id) {\n\t\t\t\t\t\t\t\t\treturn { ...fingerprint, ...res.record } as FingerprintRecord\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn fingerprint\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (res.action === \"delete\") {\n\t\t\t\t\t\t\treturn currentFingerprints.filter((fingerprint) => fingerprint.id !== res.record.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn currentFingerprints\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tpbFingerprintOptions\n\t\t\t)\n\t\t})()\n\t\t// unsubscribe on unmount\n\t\treturn () => unsubscribe?.()\n\t}, [])\n\t// Update token map whenever fingerprints change\n\tuseEffect(() => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 100, "end_line": 115, "text": "\t\tfor (const fingerprint of fingerprints) {\n\t\t\ttokenMap.set(fingerprint.system, fingerprint.token)\n\t\t}\n\t}, [fingerprints])\n\n\treturn (\n\t\t<>\n\t\t\t<SectionIntro />\n\t\t\t<Separator className=\"my-4\" />\n\t\t\t<SectionUniversalToken />\n\t\t\t<Separator className=\"my-4\" />\n\t\t\t<SectionTable fingerprints={fingerprints} />\n\t\t</>\n\t)\n})\n", "n_tokens": 87, "primary_symbol": "", "primary_kind": "", "primary_span": [100, 115], "def_symbols": [], "symbols": ["for", "const", "fingerprint", "fingerprints", "tokenMap", "set", "system", "token", "return", "SectionIntro", "Separator", "className", "SectionUniversalToken", "SectionTable"], "doc_head": "\t\tfor (const fingerprint of fingerprints) {\n\t\t\ttokenMap.set(fingerprint.system, fingerprint.token)\n\t\t}\n\t}, [fingerprints])\n\treturn (\n\t\t<>\n\t\t\t<SectionIntro />\n\t\t\t<Separator className=\"my-4\" />\n\t\t\t<SectionUniversalToken />\n\t\t\t<Separator className=\"my-4\" />\n\t\t\t<SectionTable fingerprints={fingerprints} />\n\t\t</>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 116, "end_line": 139, "text": "const SectionIntro = memo(() => {\n\treturn (\n\t\t<div>\n\t\t\t<h3 className=\"text-xl font-medium mb-2\">\n\t\t\t\t<Trans>Tokens & Fingerprints</Trans>\n\t\t\t</h3>\n\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t<Trans>Tokens and fingerprints are used to authenticate WebSocket connections to the hub.</Trans>\n\t\t\t</p>\n\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed mt-1.5\">\n\t\t\t\t<Trans>\n\t\t\t\t\tTokens allow agents to connect and register. Fingerprints are stable identifiers unique to each system, set on\n\t\t\t\t\tfirst connection.\n\t\t\t\t</Trans>\n\t\t\t</p>\n\t\t</div>\n\t)\n})\n\nconst SectionUniversalToken = memo(() => {\n\tconst [token, setToken] = useState(\"\")\n\tconst [isLoading, setIsLoading] = useState(true)\n\tconst [checked, setChecked] = useState(false)\n", "n_tokens": 197, "primary_symbol": "", "primary_kind": "", "primary_span": [116, 139], "def_symbols": [], "symbols": ["const", "SectionIntro", "memo", "return", "div", "className", "text", "font", "medium", "Trans", "Tokens", "Fingerprints", "muted", "foreground", "leading", "relaxed", "and", "fingerprints", "are", "used", "authenticate", "WebSocket", "connections", "the", "hub", "allow", "agents", "connect", "register", "stable", "identifiers", "unique", "each", "system", "set", "first", "connection", "SectionUniversalToken", "token", "setToken", "useState", "isLoading", "setIsLoading", "true", "checked", "setChecked", "false"], "doc_head": "const SectionIntro = memo(() => {\n\treturn (\n\t\t<div>\n\t\t\t<h3 className=\"text-xl font-medium mb-2\">\n\t\t\t\t<Trans>Tokens & Fingerprints</Trans>\n\t\t\t</h3>\n\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t<Trans>Tokens and fingerprints are used to authenticate WebSocket connections to the hub.</Trans>\n\t\t\t</p>\n\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed mt-1.5\">\n\t\t\t\t<Trans>\n\t\t\t\t\tTokens allow agents to connect and register. Fingerprints are stable identifiers unique to each system, set on\n\t\t\t\t\tfirst connection.\n\t\t\t\t</Trans>\n\t\t\t</p>\n\t\t</div>\n\t)\n})\nconst SectionUniversalToken = memo(() => {\n\tconst [token, setToken] = useState(\"\")\n\tconst [isLoading, setIsLoading] = useState(true)\n\tconst [checked, setChecked] = useState(false)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 140, "end_line": 152, "text": "\tasync function updateToken(enable: number = -1) {\n\t\t// enable: 0 for disable, 1 for enable, -1 (unset) for get current state\n\t\tconst data = await pb.send(`/api/beszel/universal-token`, {\n\t\t\tquery: {\n\t\t\t\ttoken,\n\t\t\t\tenable,\n\t\t\t},\n\t\t})\n\t\tsetToken(data.token)\n\t\tsetChecked(data.active)\n\t\tsetIsLoading(false)\n\t}\n", "n_tokens": 91, "primary_symbol": "updateToken", "primary_kind": "function", "primary_span": [140, 152], "def_symbols": ["updateToken"], "symbols": ["updateToken", "async", "function", "enable", "number", "for", "disable", "unset", "get", "current", "state", "const", "data", "await", "send", "api", "beszel", "universal", "token", "query", "setToken", "setChecked", "active", "setIsLoading", "false"], "doc_head": "\tasync function updateToken(enable: number = -1) {\n\t\t// enable: 0 for disable, 1 for enable, -1 (unset) for get current state\n\t\tconst data = await pb.send(`/api/beszel/universal-token`, {\n\t\t\tquery: {\n\t\t\t\ttoken,\n\t\t\t\tenable,\n\t\t\t},\n\t\t})\n\t\tsetToken(data.token)\n\t\tsetChecked(data.active)\n\t\tsetIsLoading(false)\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 153, "end_line": 172, "text": "\tuseEffect(() => {\n\t\tupdateToken()\n\t}, [])\n\n\treturn (\n\t\t<div>\n\t\t\t<h3 className=\"text-lg font-medium mb-2\">\n\t\t\t\t<Trans>Universal token</Trans>\n\t\t\t</h3>\n\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t<Trans>\n\t\t\t\t\tWhen enabled, this token allows agents to self-register without prior system creation. Expires after one hour\n\t\t\t\t\tor on hub restart.\n\t\t\t\t</Trans>\n\t\t\t</p>\n\t\t\t<div className=\"min-h-16 overflow-auto max-w-full inline-flex items-center gap-5 mt-3 border py-2 ps-5 pe-4 rounded-md\">\n\t\t\t\t{!isLoading && (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<Switch\n\t\t\t\t\t\t\tdefaultChecked={checked}", "n_tokens": 164, "primary_symbol": "", "primary_kind": "", "primary_span": [153, 172], "def_symbols": [], "symbols": ["useEffect", "updateToken", "return", "div", "className", "text", "font", "medium", "Trans", "Universal", "token", "muted", "foreground", "leading", "relaxed", "When", "enabled", "this", "allows", "agents", "self", "register", "without", "prior", "system", "creation", "Expires", "after", "one", "hour", "hub", "restart", "min", "overflow", "auto", "max", "full", "inline", "flex", "items", "center", "gap", "border", "rounded", "isLoading", "Switch", "defaultChecked", "checked"], "doc_head": "\tuseEffect(() => {\n\t\tupdateToken()\n\t}, [])\n\treturn (\n\t\t<div>\n\t\t\t<h3 className=\"text-lg font-medium mb-2\">\n\t\t\t\t<Trans>Universal token</Trans>\n\t\t\t</h3>\n\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t<Trans>\n\t\t\t\t\tWhen enabled, this token allows agents to self-register without prior system creation. Expires after one hour\n\t\t\t\t\tor on hub restart.\n\t\t\t\t</Trans>\n\t\t\t</p>\n\t\t\t<div className=\"min-h-16 overflow-auto max-w-full inline-flex items-center gap-5 mt-3 border py-2 ps-5 pe-4 rounded-md\">\n\t\t\t\t{!isLoading && (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<Switch\n\t\t\t\t\t\t\tdefaultChecked={checked}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 173, "end_line": 200, "text": "\t\t\t\t\t\t\tonCheckedChange={(checked) => {\n\t\t\t\t\t\t\t\tupdateToken(checked ? 1 : 0)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<span\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\"text-sm text-primary opacity-60 transition-opacity\",\n\t\t\t\t\t\t\t\tchecked ? \"opacity-100\" : \"select-none\"\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{token}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<ActionsButtonUniversalToken token={token} checked={checked} />\n\t\t\t\t\t</>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t)\n})\n\nconst ActionsButtonUniversalToken = memo(({ token, checked }: { token: string; checked: boolean }) => {\n\tconst { t } = useLingui()\n\tconst publicKey = $publicKey.get()\n\tconst port = \"45876\"\n\n\tconst dropdownItems: DropdownItem[] = [\n\t\t{\n\t\t\ttext: t({ message: \"Copy docker compose\", context: \"Button to copy docker compose file content\" }),", "n_tokens": 198, "primary_symbol": "", "primary_kind": "", "primary_span": [173, 200], "def_symbols": [], "symbols": ["onCheckedChange", "checked", "updateToken", "span", "className", "text", "primary", "opacity", "transition", "select", "none", "token", "ActionsButtonUniversalToken", "div", "const", "memo", "string", "boolean", "useLingui", "publicKey", "get", "port", "dropdownItems", "DropdownItem", "message", "Copy", "docker", "compose", "context", "Button", "copy", "file", "content"], "doc_head": "\t\t\t\t\t\t\tonCheckedChange={(checked) => {\n\t\t\t\t\t\t\t\tupdateToken(checked ? 1 : 0)\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<span\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\"text-sm text-primary opacity-60 transition-opacity\",\n\t\t\t\t\t\t\t\tchecked ? \"opacity-100\" : \"select-none\"\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{token}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<ActionsButtonUniversalToken token={token} checked={checked} />\n\t\t\t\t\t</>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t)\n})\nconst ActionsButtonUniversalToken = memo(({ token, checked }: { token: string; checked: boolean }) => {\n\tconst { t } = useLingui()\n\tconst publicKey = $publicKey.get()\n\tconst port = \"45876\"\n\tconst dropdownItems: DropdownItem[] = [\n\t\t{\n\t\t\ttext: t({ message: \"Copy docker compose\", context: \"Button to copy docker compose file content\" }),"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 201, "end_line": 220, "text": "\t\t\tonClick: () => copyDockerCompose(port, publicKey, token),\n\t\t\ticons: [DockerIcon],\n\t\t},\n\t\t{\n\t\t\ttext: t({ message: \"Copy docker run\", context: \"Button to copy docker run command\" }),\n\t\t\tonClick: () => copyDockerRun(port, publicKey, token),\n\t\t\ticons: [DockerIcon],\n\t\t},\n\t\t{\n\t\t\ttext: t`Copy Linux command`,\n\t\t\tonClick: () => copyLinuxCommand(port, publicKey, token),\n\t\t\ticons: [TuxIcon],\n\t\t},\n\t\t{\n\t\t\ttext: t({ message: \"Homebrew command\", context: \"Button to copy install command\" }),\n\t\t\tonClick: () => copyLinuxCommand(port, publicKey, token, true),\n\t\t\ticons: [TuxIcon, AppleIcon],\n\t\t},\n\t\t{\n\t\t\ttext: t({ message: \"Windows command\", context: \"Button to copy install command\" }),", "n_tokens": 198, "primary_symbol": "", "primary_kind": "", "primary_span": [201, 220], "def_symbols": [], "symbols": ["onClick", "copyDockerCompose", "port", "publicKey", "token", "icons", "DockerIcon", "text", "message", "Copy", "docker", "run", "context", "Button", "copy", "command", "copyDockerRun", "Linux", "copyLinuxCommand", "TuxIcon", "Homebrew", "install", "true", "AppleIcon", "Windows"], "doc_head": "\t\t\tonClick: () => copyDockerCompose(port, publicKey, token),\n\t\t\ticons: [DockerIcon],\n\t\t},\n\t\t{\n\t\t\ttext: t({ message: \"Copy docker run\", context: \"Button to copy docker run command\" }),\n\t\t\tonClick: () => copyDockerRun(port, publicKey, token),\n\t\t\ticons: [DockerIcon],\n\t\t},\n\t\t{\n\t\t\ttext: t`Copy Linux command`,\n\t\t\tonClick: () => copyLinuxCommand(port, publicKey, token),\n\t\t\ticons: [TuxIcon],\n\t\t},\n\t\t{\n\t\t\ttext: t({ message: \"Homebrew command\", context: \"Button to copy install command\" }),\n\t\t\tonClick: () => copyLinuxCommand(port, publicKey, token, true),\n\t\t\ticons: [TuxIcon, AppleIcon],\n\t\t},\n\t\t{\n\t\t\ttext: t({ message: \"Windows command\", context: \"Button to copy install command\" }),"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 11, "start_line": 221, "end_line": 246, "text": "\t\t\tonClick: () => copyWindowsCommand(port, publicKey, token),\n\t\t\ticons: [WindowsIcon],\n\t\t},\n\t]\n\treturn (\n\t\t<div className=\"flex items-center gap-2\">\n\t\t\t<DropdownMenu>\n\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t<Button\n\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\tdisabled={!checked}\n\t\t\t\t\t\tclassName={cn(\"transition-opacity\", !checked && \"opacity-50\")}\n\t\t\t\t\t>\n\t\t\t\t\t\t<span className=\"sr-only\">\n\t\t\t\t\t\t\t<Trans>Open menu</Trans>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<MoreHorizontalIcon className=\"w-5\" />\n\t\t\t\t\t</Button>\n\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t<InstallDropdown items={dropdownItems} />\n\t\t\t</DropdownMenu>\n\t\t</div>\n\t)\n})\n", "n_tokens": 169, "primary_symbol": "", "primary_kind": "", "primary_span": [221, 246], "def_symbols": [], "symbols": ["onClick", "copyWindowsCommand", "port", "publicKey", "token", "icons", "WindowsIcon", "return", "div", "className", "flex", "items", "center", "gap", "DropdownMenu", "DropdownMenuTrigger", "asChild", "Button", "variant", "ghost", "size", "icon", "disabled", "checked", "transition", "opacity", "span", "only", "Trans", "Open", "menu", "MoreHorizontalIcon", "InstallDropdown", "dropdownItems"], "doc_head": "\t\t\tonClick: () => copyWindowsCommand(port, publicKey, token),\n\t\t\ticons: [WindowsIcon],\n\t\t},\n\t]\n\treturn (\n\t\t<div className=\"flex items-center gap-2\">\n\t\t\t<DropdownMenu>\n\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t<Button\n\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\tdisabled={!checked}\n\t\t\t\t\t\tclassName={cn(\"transition-opacity\", !checked && \"opacity-50\")}\n\t\t\t\t\t>\n\t\t\t\t\t\t<span className=\"sr-only\">\n\t\t\t\t\t\t\t<Trans>Open menu</Trans>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<MoreHorizontalIcon className=\"w-5\" />\n\t\t\t\t\t</Button>\n\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t<InstallDropdown items={dropdownItems} />\n\t\t\t</DropdownMenu>\n\t\t</div>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 12, "start_line": 247, "end_line": 275, "text": "const SectionTable = memo(({ fingerprints = [] }: { fingerprints: FingerprintRecord[] }) => {\n\tconst { t } = useLingui()\n\tconst isReadOnly = isReadOnlyUser()\n\n\tconst headerCols = useMemo(\n\t\t() => [\n\t\t\t{\n\t\t\t\tlabel: t`System`,\n\t\t\t\tIcon: ServerIcon,\n\t\t\t\tw: \"11em\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: t`Token`,\n\t\t\t\tIcon: KeyIcon,\n\t\t\t\tw: \"20em\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: t`Fingerprint`,\n\t\t\t\tIcon: FingerprintIcon,\n\t\t\t\tw: \"20em\",\n\t\t\t},\n\t\t],\n\t\t[t]\n\t)\n\treturn (\n\t\t<div className=\"rounded-md border overflow-hidden w-full mt-4\">\n\t\t\t<Table>\n\t\t\t\t<TableHeader>\n\t\t\t\t\t<tr className=\"border-border/50\">", "n_tokens": 180, "primary_symbol": "", "primary_kind": "", "primary_span": [247, 275], "def_symbols": [], "symbols": ["const", "SectionTable", "memo", "fingerprints", "FingerprintRecord", "useLingui", "isReadOnly", "isReadOnlyUser", "headerCols", "useMemo", "label", "System", "Icon", "ServerIcon", "Token", "KeyIcon", "Fingerprint", "FingerprintIcon", "return", "div", "className", "rounded", "border", "overflow", "hidden", "full", "Table", "TableHeader"], "doc_head": "const SectionTable = memo(({ fingerprints = [] }: { fingerprints: FingerprintRecord[] }) => {\n\tconst { t } = useLingui()\n\tconst isReadOnly = isReadOnlyUser()\n\tconst headerCols = useMemo(\n\t\t() => [\n\t\t\t{\n\t\t\t\tlabel: t`System`,\n\t\t\t\tIcon: ServerIcon,\n\t\t\t\tw: \"11em\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: t`Token`,\n\t\t\t\tIcon: KeyIcon,\n\t\t\t\tw: \"20em\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: t`Fingerprint`,\n\t\t\t\tIcon: FingerprintIcon,\n\t\t\t\tw: \"20em\",\n\t\t\t},\n\t\t],\n\t\t[t]\n\t)\n\treturn (\n\t\t<div className=\"rounded-md border overflow-hidden w-full mt-4\">\n\t\t\t<Table>\n\t\t\t\t<TableHeader>\n\t\t\t\t\t<tr className=\"border-border/50\">"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 13, "start_line": 276, "end_line": 293, "text": "\t\t\t\t\t\t{headerCols.map((col) => (\n\t\t\t\t\t\t\t<TableHead key={col.label} style={{ minWidth: col.w }}>\n\t\t\t\t\t\t\t\t<span className=\"flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t<col.Icon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t{col.label}\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</TableHead>\n\t\t\t\t\t\t))}\n\t\t\t\t\t\t{!isReadOnly && (\n\t\t\t\t\t\t\t<TableHead className=\"w-0\">\n\t\t\t\t\t\t\t\t<span className=\"sr-only\">\n\t\t\t\t\t\t\t\t\t<Trans>Actions</Trans>\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</TableHead>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</tr>\n\t\t\t\t</TableHeader>\n\t\t\t\t<TableBody className=\"whitespace-pre\">", "n_tokens": 144, "primary_symbol": "", "primary_kind": "", "primary_span": [276, 293], "def_symbols": [], "symbols": ["headerCols", "map", "col", "TableHead", "key", "label", "style", "minWidth", "span", "className", "flex", "items", "center", "gap", "Icon", "size", "isReadOnly", "only", "Trans", "Actions", "TableHeader", "TableBody", "whitespace", "pre"], "doc_head": "\t\t\t\t\t\t{headerCols.map((col) => (\n\t\t\t\t\t\t\t<TableHead key={col.label} style={{ minWidth: col.w }}>\n\t\t\t\t\t\t\t\t<span className=\"flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t<col.Icon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t{col.label}\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</TableHead>\n\t\t\t\t\t\t))}\n\t\t\t\t\t\t{!isReadOnly && (\n\t\t\t\t\t\t\t<TableHead className=\"w-0\">\n\t\t\t\t\t\t\t\t<span className=\"sr-only\">\n\t\t\t\t\t\t\t\t\t<Trans>Actions</Trans>\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</TableHead>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</tr>\n\t\t\t\t</TableHeader>\n\t\t\t\t<TableBody className=\"whitespace-pre\">"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 14, "start_line": 294, "end_line": 313, "text": "\t\t\t\t\t{fingerprints.map((fingerprint, i) => (\n\t\t\t\t\t\t<TableRow key={i}>\n\t\t\t\t\t\t\t<TableCell className=\"font-medium ps-5 py-2 max-w-60 truncate\">\n\t\t\t\t\t\t\t\t{fingerprint.expand.system.name}\n\t\t\t\t\t\t\t</TableCell>\n\t\t\t\t\t\t\t<TableCell className=\"font-mono text-[0.95em] py-2\">{fingerprint.token}</TableCell>\n\t\t\t\t\t\t\t<TableCell className=\"font-mono text-[0.95em] py-2\">{fingerprint.fingerprint}</TableCell>\n\t\t\t\t\t\t\t{!isReadOnly && (\n\t\t\t\t\t\t\t\t<TableCell className=\"py-2 px-4 xl:px-2\">\n\t\t\t\t\t\t\t\t\t<ActionsButtonTable fingerprint={fingerprint} />\n\t\t\t\t\t\t\t\t</TableCell>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</TableRow>\n\t\t\t\t\t))}\n\t\t\t\t</TableBody>\n\t\t\t</Table>\n\t\t</div>\n\t)\n})\n", "n_tokens": 182, "primary_symbol": "", "primary_kind": "", "primary_span": [294, 313], "def_symbols": [], "symbols": ["fingerprints", "map", "fingerprint", "TableRow", "key", "TableCell", "className", "font", "medium", "max", "truncate", "expand", "system", "name", "mono", "text", "token", "isReadOnly", "ActionsButtonTable", "TableBody", "Table", "div"], "doc_head": "\t\t\t\t\t{fingerprints.map((fingerprint, i) => (\n\t\t\t\t\t\t<TableRow key={i}>\n\t\t\t\t\t\t\t<TableCell className=\"font-medium ps-5 py-2 max-w-60 truncate\">\n\t\t\t\t\t\t\t\t{fingerprint.expand.system.name}\n\t\t\t\t\t\t\t</TableCell>\n\t\t\t\t\t\t\t<TableCell className=\"font-mono text-[0.95em] py-2\">{fingerprint.token}</TableCell>\n\t\t\t\t\t\t\t<TableCell className=\"font-mono text-[0.95em] py-2\">{fingerprint.fingerprint}</TableCell>\n\t\t\t\t\t\t\t{!isReadOnly && (\n\t\t\t\t\t\t\t\t<TableCell className=\"py-2 px-4 xl:px-2\">\n\t\t\t\t\t\t\t\t\t<ActionsButtonTable fingerprint={fingerprint} />\n\t\t\t\t\t\t\t\t</TableCell>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</TableRow>\n\t\t\t\t\t))}\n\t\t\t\t</TableBody>\n\t\t\t</Table>\n\t\t</div>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 15, "start_line": 314, "end_line": 330, "text": "async function updateFingerprint(fingerprint: FingerprintRecord, rotateToken = false) {\n\ttry {\n\t\tawait pb.collection(\"fingerprints\").update(fingerprint.id, {\n\t\t\tfingerprint: \"\",\n\t\t\ttoken: rotateToken ? generateToken() : fingerprint.token,\n\t\t})\n\t} catch (error: any) {\n\t\ttoast({\n\t\t\ttitle: t`Error`,\n\t\t\tdescription: error.message,\n\t\t})\n\t}\n}\n\nconst ActionsButtonTable = memo(({ fingerprint }: { fingerprint: FingerprintRecord }) => {\n\tconst envVar = `HUB_URL=${getHubURL()}\\nTOKEN=${fingerprint.token}`\n\tconst copyEnv = () => copyToClipboard(envVar)", "n_tokens": 138, "primary_symbol": "updateFingerprint", "primary_kind": "function", "primary_span": [314, 330], "def_symbols": ["updateFingerprint", "copyEnv"], "symbols": ["updateFingerprint", "copyEnv", "async", "function", "fingerprint", "FingerprintRecord", "rotateToken", "false", "try", "await", "collection", "fingerprints", "update", "token", "generateToken", "catch", "error", "any", "toast", "title", "Error", "description", "message", "const", "ActionsButtonTable", "memo", "envVar", "HUB_URL", "getHubURL", "nTOKEN", "copyToClipboard"], "doc_head": "async function updateFingerprint(fingerprint: FingerprintRecord, rotateToken = false) {\n\ttry {\n\t\tawait pb.collection(\"fingerprints\").update(fingerprint.id, {\n\t\t\tfingerprint: \"\",\n\t\t\ttoken: rotateToken ? generateToken() : fingerprint.token,\n\t\t})\n\t} catch (error: any) {\n\t\ttoast({\n\t\t\ttitle: t`Error`,\n\t\t\tdescription: error.message,\n\t\t})\n\t}\n}\nconst ActionsButtonTable = memo(({ fingerprint }: { fingerprint: FingerprintRecord }) => {\n\tconst envVar = `HUB_URL=${getHubURL()}\\nTOKEN=${fingerprint.token}`\n\tconst copyEnv = () => copyToClipboard(envVar)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#16", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 16, "start_line": 331, "end_line": 352, "text": "\tconst copyYaml = () => copyToClipboard(envVar.replaceAll(\"=\", \": \"))\n\n\treturn (\n\t\t<DropdownMenu>\n\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t<Button variant=\"ghost\" size={\"icon\"} data-nolink>\n\t\t\t\t\t<span className=\"sr-only\">\n\t\t\t\t\t\t<Trans>Open menu</Trans>\n\t\t\t\t\t</span>\n\t\t\t\t\t<MoreHorizontalIcon className=\"w-5\" />\n\t\t\t\t</Button>\n\t\t\t</DropdownMenuTrigger>\n\t\t\t<DropdownMenuContent align=\"end\">\n\t\t\t\t<DropdownMenuItem onClick={copyYaml}>\n\t\t\t\t\t<CopyIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t<Trans>Copy YAML</Trans>\n\t\t\t\t</DropdownMenuItem>\n\t\t\t\t<DropdownMenuItem onClick={copyEnv}>\n\t\t\t\t\t<CopyIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t<Trans context=\"Environment variables\">Copy env</Trans>\n\t\t\t\t</DropdownMenuItem>\n\t\t\t\t<DropdownMenuSeparator />", "n_tokens": 207, "primary_symbol": "copyYaml", "primary_kind": "function", "primary_span": [331, 352], "def_symbols": ["copyYaml"], "symbols": ["copyYaml", "const", "copyToClipboard", "envVar", "replaceAll", "return", "DropdownMenu", "DropdownMenuTrigger", "asChild", "Button", "variant", "ghost", "size", "icon", "data", "nolink", "span", "className", "only", "Trans", "Open", "menu", "MoreHorizontalIcon", "DropdownMenuContent", "align", "end", "DropdownMenuItem", "onClick", "CopyIcon", "Copy", "YAML", "copyEnv", "context", "Environment", "variables", "env", "DropdownMenuSeparator"], "doc_head": "\tconst copyYaml = () => copyToClipboard(envVar.replaceAll(\"=\", \": \"))\n\treturn (\n\t\t<DropdownMenu>\n\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t<Button variant=\"ghost\" size={\"icon\"} data-nolink>\n\t\t\t\t\t<span className=\"sr-only\">\n\t\t\t\t\t\t<Trans>Open menu</Trans>\n\t\t\t\t\t</span>\n\t\t\t\t\t<MoreHorizontalIcon className=\"w-5\" />\n\t\t\t\t</Button>\n\t\t\t</DropdownMenuTrigger>\n\t\t\t<DropdownMenuContent align=\"end\">\n\t\t\t\t<DropdownMenuItem onClick={copyYaml}>\n\t\t\t\t\t<CopyIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t<Trans>Copy YAML</Trans>\n\t\t\t\t</DropdownMenuItem>\n\t\t\t\t<DropdownMenuItem onClick={copyEnv}>\n\t\t\t\t\t<CopyIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t<Trans context=\"Environment variables\">Copy env</Trans>\n\t\t\t\t</DropdownMenuItem>\n\t\t\t\t<DropdownMenuSeparator />"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx#17", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/tokens-fingerprints.tsx", "rel_path": "src/site/src/components/routes/settings/tokens-fingerprints.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 17, "start_line": 353, "end_line": 369, "text": "\t\t\t\t<DropdownMenuItem onSelect={() => updateFingerprint(fingerprint, true)}>\n\t\t\t\t\t<RotateCwIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t<Trans>Rotate token</Trans>\n\t\t\t\t</DropdownMenuItem>\n\t\t\t\t{fingerprint.fingerprint && (\n\t\t\t\t\t<DropdownMenuItem onSelect={() => updateFingerprint(fingerprint)}>\n\t\t\t\t\t\t<Trash2Icon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t<Trans>Delete fingerprint</Trans>\n\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t)}\n\t\t\t</DropdownMenuContent>\n\t\t</DropdownMenu>\n\t)\n})\n\nexport default SettingsFingerprintsPage\n", "n_tokens": 134, "primary_symbol": "", "primary_kind": "", "primary_span": [353, 369], "def_symbols": [], "symbols": ["DropdownMenuItem", "onSelect", "updateFingerprint", "fingerprint", "true", "RotateCwIcon", "className", "size", "Trans", "Rotate", "token", "Trash2Icon", "Delete", "DropdownMenuContent", "DropdownMenu", "export", "default", "SettingsFingerprintsPage"], "doc_head": "\t\t\t\t<DropdownMenuItem onSelect={() => updateFingerprint(fingerprint, true)}>\n\t\t\t\t\t<RotateCwIcon className=\"me-2.5 size-4\" />\n\t\t\t\t\t<Trans>Rotate token</Trans>\n\t\t\t\t</DropdownMenuItem>\n\t\t\t\t{fingerprint.fingerprint && (\n\t\t\t\t\t<DropdownMenuItem onSelect={() => updateFingerprint(fingerprint)}>\n\t\t\t\t\t\t<Trash2Icon className=\"me-2.5 size-4\" />\n\t\t\t\t\t\t<Trans>Delete fingerprint</Trans>\n\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t)}\n\t\t\t</DropdownMenuContent>\n\t\t</DropdownMenu>\n\t)\n})\nexport default SettingsFingerprintsPage"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/config-yaml.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/config-yaml.tsx", "rel_path": "src/site/src/components/routes/settings/config-yaml.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 14, "text": "import { t } from \"@lingui/core/macro\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { Button } from \"@/components/ui/button\"\nimport { redirectPage } from \"@nanostores/router\"\nimport { $router } from \"@/components/router\"\nimport { AlertCircleIcon, FileSlidersIcon, LoaderCircleIcon } from \"lucide-react\"\nimport { Alert, AlertDescription, AlertTitle } from \"@/components/ui/alert\"\nimport { useState } from \"react\"\nimport { Textarea } from \"@/components/ui/textarea\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport clsx from \"clsx\"\nimport { isAdmin, pb } from \"@/lib/api\"\n", "n_tokens": 155, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 14], "def_symbols": [], "symbols": ["import", "from", "lingui", "core", "macro", "Trans", "react", "Separator", "components", "separator", "Button", "button", "redirectPage", "nanostores", "router", "AlertCircleIcon", "FileSlidersIcon", "LoaderCircleIcon", "lucide", "Alert", "AlertDescription", "AlertTitle", "alert", "useState", "Textarea", "textarea", "toast", "use", "clsx", "isAdmin", "lib", "api"], "doc_head": "import { t } from \"@lingui/core/macro\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { Button } from \"@/components/ui/button\"\nimport { redirectPage } from \"@nanostores/router\"\nimport { $router } from \"@/components/router\"\nimport { AlertCircleIcon, FileSlidersIcon, LoaderCircleIcon } from \"lucide-react\"\nimport { Alert, AlertDescription, AlertTitle } from \"@/components/ui/alert\"\nimport { useState } from \"react\"\nimport { Textarea } from \"@/components/ui/textarea\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport clsx from \"clsx\"\nimport { isAdmin, pb } from \"@/lib/api\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/config-yaml.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/config-yaml.tsx", "rel_path": "src/site/src/components/routes/settings/config-yaml.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 15, "end_line": 36, "text": "export default function ConfigYaml() {\n\tconst [configContent, setConfigContent] = useState<string>(\"\")\n\tconst [isLoading, setIsLoading] = useState(false)\n\n\tconst ButtonIcon = isLoading ? LoaderCircleIcon : FileSlidersIcon\n\n\tasync function fetchConfig() {\n\t\ttry {\n\t\t\tsetIsLoading(true)\n\t\t\tconst { config } = await pb.send<{ config: string }>(\"/api/beszel/config-yaml\", {})\n\t\t\tsetConfigContent(config)\n\t\t} catch (error: any) {\n\t\t\ttoast({\n\t\t\t\ttitle: t`Error`,\n\t\t\t\tdescription: error.message,\n\t\t\t\tvariant: \"destructive\",\n\t\t\t})\n\t\t} finally {\n\t\t\tsetIsLoading(false)\n\t\t}\n\t}\n", "n_tokens": 147, "primary_symbol": "fetchConfig", "primary_kind": "function", "primary_span": [21, 36], "def_symbols": ["fetchConfig"], "symbols": ["fetchConfig", "export", "default", "function", "ConfigYaml", "const", "configContent", "setConfigContent", "useState", "string", "isLoading", "setIsLoading", "false", "ButtonIcon", "LoaderCircleIcon", "FileSlidersIcon", "async", "try", "true", "config", "await", "send", "api", "beszel", "yaml", "catch", "error", "any", "toast", "title", "Error", "description", "message", "variant", "destructive", "finally"], "doc_head": "export default function ConfigYaml() {\n\tconst [configContent, setConfigContent] = useState<string>(\"\")\n\tconst [isLoading, setIsLoading] = useState(false)\n\tconst ButtonIcon = isLoading ? LoaderCircleIcon : FileSlidersIcon\n\tasync function fetchConfig() {\n\t\ttry {\n\t\t\tsetIsLoading(true)\n\t\t\tconst { config } = await pb.send<{ config: string }>(\"/api/beszel/config-yaml\", {})\n\t\t\tsetConfigContent(config)\n\t\t} catch (error: any) {\n\t\t\ttoast({\n\t\t\t\ttitle: t`Error`,\n\t\t\t\tdescription: error.message,\n\t\t\t\tvariant: \"destructive\",\n\t\t\t})\n\t\t} finally {\n\t\t\tsetIsLoading(false)\n\t\t}\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/config-yaml.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/config-yaml.tsx", "rel_path": "src/site/src/components/routes/settings/config-yaml.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 37, "end_line": 98, "text": "\tif (!isAdmin()) {\n\t\tredirectPage($router, \"settings\", { name: \"general\" })\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<div>\n\t\t\t\t<h3 className=\"text-xl font-medium mb-2\">\n\t\t\t\t\t<Trans>YAML Configuration</Trans>\n\t\t\t\t</h3>\n\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t<Trans>Export your current systems configuration.</Trans>\n\t\t\t\t</p>\n\t\t\t</div>\n\t\t\t<Separator className=\"my-4\" />\n\t\t\t<div className=\"space-y-2\">\n\t\t\t\t<div className=\"mb-4\">\n\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed my-1\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tSystems may be managed in a <code className=\"bg-muted rounded-sm px-1 text-primary\">config.yml</code> file\n\t\t\t\t\t\t\tinside your data directory.\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</p>\n\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tOn each restart, systems in the database will be updated to match the systems defined in the file.\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</p>\n\t\t\t\t\t<Alert className=\"my-4 border-destructive text-destructive w-auto table md:pe-6\">\n\t\t\t\t\t\t<AlertCircleIcon className=\"h-4 w-4 stroke-destructive\" />\n\t\t\t\t\t\t<AlertTitle>\n\t\t\t\t\t\t\t<Trans>Caution - potential data loss</Trans>\n\t\t\t\t\t\t</AlertTitle>\n\t\t\t\t\t\t<AlertDescription>\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\tExisting systems not defined in <code>config.yml</code> will be deleted. Please make regular backups.\n\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t</AlertDescription>\n\t\t\t\t\t</Alert>\n\t\t\t\t</div>\n\t\t\t\t{configContent && (\n\t\t\t\t\t<Textarea\n\t\t\t\t\t\tdir=\"ltr\"\n\t\t\t\t\t\tautoFocus\n\t\t\t\t\t\tdefaultValue={configContent}\n\t\t\t\t\t\tspellCheck=\"false\"\n\t\t\t\t\t\trows={Math.min(25, configContent.split(\"\\n\").length)}\n\t\t\t\t\t\tclassName=\"font-mono whitespace-pre\"\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t\t<Separator className=\"my-5\" />\n\t\t\t<Button type=\"button\" className=\"mt-2 flex items-center gap-1\" onClick={fetchConfig} disabled={isLoading}>\n\t\t\t\t<ButtonIcon className={clsx(\"h-4 w-4 me-0.5\", isLoading && \"animate-spin\")} />\n\t\t\t\t<Trans>Export configuration</Trans>\n\t\t\t</Button>\n\t\t</div>\n\t)\n}\n", "n_tokens": 547, "primary_symbol": "", "primary_kind": "", "primary_span": [37, 98], "def_symbols": [], "symbols": ["isAdmin", "redirectPage", "router", "settings", "name", "general", "return", "div", "className", "text", "font", "medium", "Trans", "YAML", "Configuration", "muted", "foreground", "leading", "relaxed", "Export", "your", "current", "systems", "configuration", "Separator", "space", "Systems", "may", "managed", "code", "rounded", "primary", "config", "yml", "file", "inside", "data", "directory", "each", "restart", "the", "database", "will", "updated", "match", "defined", "Alert", "border", "destructive", "auto", "table", "AlertCircleIcon", "stroke", "AlertTitle", "Caution", "potential", "loss", "AlertDescription", "Existing", "not", "deleted", "Please", "make", "regular", "backups", "configContent", "Textarea", "dir", "ltr", "autoFocus", "defaultValue", "spellCheck", "false", "rows", "Math", "min", "split", "length", "mono", "whitespace", "pre", "Button", "type", "button", "flex", "items", "center", "gap", "onClick", "fetchConfig", "disabled", "isLoading", "ButtonIcon", "clsx", "animate", "spin"], "doc_head": "\tif (!isAdmin()) {\n\t\tredirectPage($router, \"settings\", { name: \"general\" })\n\t}\n\treturn (\n\t\t<div>\n\t\t\t<div>\n\t\t\t\t<h3 className=\"text-xl font-medium mb-2\">\n\t\t\t\t\t<Trans>YAML Configuration</Trans>\n\t\t\t\t</h3>\n\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t<Trans>Export your current systems configuration.</Trans>\n\t\t\t\t</p>\n\t\t\t</div>\n\t\t\t<Separator className=\"my-4\" />\n\t\t\t<div className=\"space-y-2\">\n\t\t\t\t<div className=\"mb-4\">\n\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed my-1\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tSystems may be managed in a <code className=\"bg-muted rounded-sm px-1 text-primary\">config.yml</code> file\n\t\t\t\t\t\t\tinside your data directory.\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</p>\n\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tOn each restart, systems in the database will be updated to match the systems defined in the file.\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</p>\n\t\t\t\t\t<Alert className=\"my-4 border-destructive text-destructive w-auto table md:pe-6\">\n\t\t\t\t\t\t<AlertCircleIcon className=\"h-4 w-4 stroke-destructive\" />\n\t\t\t\t\t\t<AlertTitle>\n\t\t\t\t\t\t\t<Trans>Caution - potential data loss</Trans>\n\t\t\t\t\t\t</AlertTitle>\n\t\t\t\t\t\t<AlertDescription>\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx", "rel_path": "src/site/src/components/routes/settings/notifications.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 17, "text": "import { t } from \"@lingui/core/macro\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { Card } from \"@/components/ui/card\"\nimport { BellIcon, LoaderCircleIcon, PlusIcon, SaveIcon, Trash2Icon } from \"lucide-react\"\nimport { ChangeEventHandler, useEffect, useState } from \"react\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport { InputTags } from \"@/components/ui/input-tags\"\nimport { UserSettings } from \"@/types\"\nimport { saveSettings } from \"./layout\"\nimport * as v from \"valibot\"\nimport { prependBasePath } from \"@/components/router\"\nimport { isAdmin, pb } from \"@/lib/api\"\n", "n_tokens": 188, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 17], "def_symbols": [], "symbols": ["import", "from", "lingui", "core", "macro", "Trans", "react", "Button", "components", "button", "Input", "input", "Label", "label", "Separator", "separator", "Card", "card", "BellIcon", "LoaderCircleIcon", "PlusIcon", "SaveIcon", "Trash2Icon", "lucide", "ChangeEventHandler", "useEffect", "useState", "toast", "use", "InputTags", "tags", "UserSettings", "types", "saveSettings", "layout", "valibot", "prependBasePath", "router", "isAdmin", "lib", "api"], "doc_head": "import { t } from \"@lingui/core/macro\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { Card } from \"@/components/ui/card\"\nimport { BellIcon, LoaderCircleIcon, PlusIcon, SaveIcon, Trash2Icon } from \"lucide-react\"\nimport { ChangeEventHandler, useEffect, useState } from \"react\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport { InputTags } from \"@/components/ui/input-tags\"\nimport { UserSettings } from \"@/types\"\nimport { saveSettings } from \"./layout\"\nimport * as v from \"valibot\"\nimport { prependBasePath } from \"@/components/router\"\nimport { isAdmin, pb } from \"@/lib/api\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx", "rel_path": "src/site/src/components/routes/settings/notifications.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 18, "end_line": 41, "text": "interface ShoutrrrUrlCardProps {\n\turl: string\n\tonUrlChange: ChangeEventHandler<HTMLInputElement>\n\tonRemove: () => void\n}\n\nconst NotificationSchema = v.object({\n\temails: v.array(v.pipe(v.string(), v.email())),\n\twebhooks: v.array(v.pipe(v.string(), v.url())),\n})\n\nconst SettingsNotificationsPage = ({ userSettings }: { userSettings: UserSettings }) => {\n\tconst [webhooks, setWebhooks] = useState(userSettings.webhooks ?? [])\n\tconst [emails, setEmails] = useState<string[]>(userSettings.emails ?? [])\n\tconst [isLoading, setIsLoading] = useState(false)\n\n\t// update values when userSettings changes\n\tuseEffect(() => {\n\t\tsetWebhooks(userSettings.webhooks ?? [])\n\t\tsetEmails(userSettings.emails ?? [])\n\t}, [userSettings])\n\n\tfunction addWebhook() {\n\t\tsetWebhooks([...webhooks, \"\"])", "n_tokens": 182, "primary_symbol": "addWebhook", "primary_kind": "function", "primary_span": [40, 41], "def_symbols": ["addWebhook", "SettingsNotificationsPage"], "symbols": ["addWebhook", "SettingsNotificationsPage", "interface", "ShoutrrrUrlCardProps", "url", "string", "onUrlChange", "ChangeEventHandler", "HTMLInputElement", "onRemove", "void", "const", "NotificationSchema", "object", "emails", "array", "pipe", "email", "webhooks", "userSettings", "UserSettings", "setWebhooks", "useState", "setEmails", "isLoading", "setIsLoading", "false", "update", "values", "when", "changes", "useEffect", "function"], "doc_head": "interface ShoutrrrUrlCardProps {\n\turl: string\n\tonUrlChange: ChangeEventHandler<HTMLInputElement>\n\tonRemove: () => void\n}\nconst NotificationSchema = v.object({\n\temails: v.array(v.pipe(v.string(), v.email())),\n\twebhooks: v.array(v.pipe(v.string(), v.url())),\n})\nconst SettingsNotificationsPage = ({ userSettings }: { userSettings: UserSettings }) => {\n\tconst [webhooks, setWebhooks] = useState(userSettings.webhooks ?? [])\n\tconst [emails, setEmails] = useState<string[]>(userSettings.emails ?? [])\n\tconst [isLoading, setIsLoading] = useState(false)\n\t// update values when userSettings changes\n\tuseEffect(() => {\n\t\tsetWebhooks(userSettings.webhooks ?? [])\n\t\tsetEmails(userSettings.emails ?? [])\n\t}, [userSettings])\n\tfunction addWebhook() {\n\t\tsetWebhooks([...webhooks, \"\"])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx", "rel_path": "src/site/src/components/routes/settings/notifications.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 42, "end_line": 60, "text": "\t\t// focus on the new input\n\t\tqueueMicrotask(() => {\n\t\t\tconst inputs = document.querySelectorAll(\"#webhooks input\") as NodeListOf<HTMLInputElement>\n\t\t\tinputs[inputs.length - 1]?.focus()\n\t\t})\n\t}\n\tconst removeWebhook = (index: number) => setWebhooks(webhooks.filter((_, i) => i !== index))\n\n\tfunction updateWebhook(index: number, value: string) {\n\t\tconst newWebhooks = [...webhooks]\n\t\tnewWebhooks[index] = value\n\t\tsetWebhooks(newWebhooks)\n\t}\n\n\tasync function updateSettings() {\n\t\tsetIsLoading(true)\n\t\ttry {\n\t\t\tconst parsedData = v.parse(NotificationSchema, { emails, webhooks })\n\t\t\tawait saveSettings(parsedData)", "n_tokens": 155, "primary_symbol": "updateWebhook", "primary_kind": "function", "primary_span": [50, 60], "def_symbols": ["updateWebhook", "updateSettings", "removeWebhook"], "symbols": ["updateWebhook", "updateSettings", "removeWebhook", "focus", "the", "new", "input", "queueMicrotask", "const", "inputs", "document", "querySelectorAll", "webhooks", "NodeListOf", "HTMLInputElement", "length", "index", "number", "setWebhooks", "filter", "function", "value", "string", "newWebhooks", "async", "setIsLoading", "true", "try", "parsedData", "parse", "NotificationSchema", "emails", "await", "saveSettings"], "doc_head": "\t\t// focus on the new input\n\t\tqueueMicrotask(() => {\n\t\t\tconst inputs = document.querySelectorAll(\"#webhooks input\") as NodeListOf<HTMLInputElement>\n\t\t\tinputs[inputs.length - 1]?.focus()\n\t\t})\n\t}\n\tconst removeWebhook = (index: number) => setWebhooks(webhooks.filter((_, i) => i !== index))\n\tfunction updateWebhook(index: number, value: string) {\n\t\tconst newWebhooks = [...webhooks]\n\t\tnewWebhooks[index] = value\n\t\tsetWebhooks(newWebhooks)\n\t}\n\tasync function updateSettings() {\n\t\tsetIsLoading(true)\n\t\ttry {\n\t\t\tconst parsedData = v.parse(NotificationSchema, { emails, webhooks })\n\t\t\tawait saveSettings(parsedData)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx", "rel_path": "src/site/src/components/routes/settings/notifications.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 61, "end_line": 138, "text": "\t\t} catch (e: any) {\n\t\t\ttoast({\n\t\t\t\ttitle: t`Failed to save settings`,\n\t\t\t\tdescription: e.message,\n\t\t\t\tvariant: \"destructive\",\n\t\t\t})\n\t\t}\n\t\tsetIsLoading(false)\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<div>\n\t\t\t\t<h3 className=\"text-xl font-medium mb-2\">\n\t\t\t\t\t<Trans>Notifications</Trans>\n\t\t\t\t</h3>\n\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t<Trans>Configure how you receive alert notifications.</Trans>\n\t\t\t\t</p>\n\t\t\t\t<p className=\"text-sm text-muted-foreground mt-1.5 leading-relaxed\">\n\t\t\t\t\t<Trans>\n\t\t\t\t\t\tLooking instead for where to create alerts? Click the bell <BellIcon className=\"inline h-4 w-4\" /> icons in\n\t\t\t\t\t\tthe systems table.\n\t\t\t\t\t</Trans>\n\t\t\t\t</p>\n\t\t\t</div>\n\t\t\t<Separator className=\"my-4\" />\n\t\t\t<div className=\"space-y-5\">\n\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t<div className=\"mb-2\">\n\t\t\t\t\t\t<h3 className=\"mb-1 text-lg font-medium\">\n\t\t\t\t\t\t\t<Trans>Email notifications</Trans>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t{isAdmin() && (\n\t\t\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\tPlease{\" \"}\n\t\t\t\t\t\t\t\t\t<a href={prependBasePath(\"/_/#/settings/mail\")} className=\"link\" target=\"_blank\">\n\t\t\t\t\t\t\t\t\t\tconfigure an SMTP server\n\t\t\t\t\t\t\t\t\t</a>{\" \"}\n\t\t\t\t\t\t\t\t\tto ensure alerts are delivered.\n\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t\t<Label className=\"block\" htmlFor=\"email\">\n\t\t\t\t\t\t<Trans>To email(s)</Trans>\n\t\t\t\t\t</Label>\n\t\t\t\t\t<InputTags\n\t\t\t\t\t\tvalue={emails}\n\t\t\t\t\t\tonChange={setEmails}\n\t\t\t\t\t\tplaceholder={t`Enter email address...`}\n\t\t\t\t\t\tclassName=\"w-full\"\n\t\t\t\t\t\ttype=\"email\"\n\t\t\t\t\t\tid=\"email\"\n\t\t\t\t\t/>\n\t\t\t\t\t<p className=\"text-[0.8rem] text-muted-foreground\">\n\t\t\t\t\t\t<Trans>Save address using enter key or comma. Leave blank to disable email notifications.</Trans>\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t\t<Separator />\n\t\t\t\t<div className=\"space-y-3\">\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h3 className=\"mb-1 text-lg font-medium\">\n\t\t\t\t\t\t\t<Trans>Webhook / Push notifications</Trans>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\tBeszel uses{\" \"}\n\t\t\t\t\t\t\t\t<a href=\"https://beszel.dev/guide/notifications\" target=\"_blank\" className=\"link\">\n\t\t\t\t\t\t\t\t\tShoutrrr\n\t\t\t\t\t\t\t\t</a>{\" \"}\n\t\t\t\t\t\t\t\tto integrate with popular notification services.\n\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t{webhooks.length > 0 && (\n\t\t\t\t\t\t<div className=\"grid gap-2.5\" id=\"webhooks\">", "n_tokens": 650, "primary_symbol": "", "primary_kind": "", "primary_span": [61, 138], "def_symbols": [], "symbols": ["catch", "any", "toast", "title", "Failed", "save", "settings", "description", "message", "variant", "destructive", "setIsLoading", "false", "return", "div", "className", "text", "font", "medium", "Trans", "Notifications", "muted", "foreground", "leading", "relaxed", "Configure", "how", "you", "receive", "alert", "notifications", "Looking", "instead", "for", "where", "create", "alerts", "Click", "the", "bell", "BellIcon", "inline", "icons", "systems", "table", "Separator", "space", "grid", "gap", "Email", "isAdmin", "Please", "href", "prependBasePath", "mail", "link", "target", "_blank", "configure", "SMTP", "server", "ensure", "are", "delivered", "Label", "block", "htmlFor", "email", "InputTags", "value", "emails", "onChange", "setEmails", "placeholder", "Enter", "address", "full", "type", "Save", "using", "enter", "key", "comma", "Leave", "blank", "disable", "Webhook", "Push", "Beszel", "uses", "https", "beszel", "dev", "guide", "Shoutrrr", "integrate", "with", "popular", "notification", "services", "webhooks", "length"], "doc_head": "\t\t} catch (e: any) {\n\t\t\ttoast({\n\t\t\t\ttitle: t`Failed to save settings`,\n\t\t\t\tdescription: e.message,\n\t\t\t\tvariant: \"destructive\",\n\t\t\t})\n\t\t}\n\t\tsetIsLoading(false)\n\t}\n\treturn (\n\t\t<div>\n\t\t\t<div>\n\t\t\t\t<h3 className=\"text-xl font-medium mb-2\">\n\t\t\t\t\t<Trans>Notifications</Trans>\n\t\t\t\t</h3>\n\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t<Trans>Configure how you receive alert notifications.</Trans>\n\t\t\t\t</p>\n\t\t\t\t<p className=\"text-sm text-muted-foreground mt-1.5 leading-relaxed\">\n\t\t\t\t\t<Trans>\n\t\t\t\t\t\tLooking instead for where to create alerts? Click the bell <BellIcon className=\"inline h-4 w-4\" /> icons in\n\t\t\t\t\t\tthe systems table.\n\t\t\t\t\t</Trans>\n\t\t\t\t</p>\n\t\t\t</div>\n\t\t\t<Separator className=\"my-4\" />\n\t\t\t<div className=\"space-y-5\">\n\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t<div className=\"mb-2\">\n\t\t\t\t\t\t<h3 className=\"mb-1 text-lg font-medium\">\n\t\t\t\t\t\t\t<Trans>Email notifications</Trans>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t{isAdmin() && (\n\t\t\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\tPlease{\" \"}\n\t\t\t\t\t\t\t\t\t<a href={prependBasePath(\"/_/#/settings/mail\")} className=\"link\" target=\"_blank\">\n\t\t\t\t\t\t\t\t\t\tconfigure an SMTP server\n\t\t\t\t\t\t\t\t\t</a>{\" \"}\n\t\t\t\t\t\t\t\t\tto ensure a"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx", "rel_path": "src/site/src/components/routes/settings/notifications.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 139, "end_line": 143, "text": "\t\t\t\t\t\t\t{webhooks.map((webhook, index) => (\n\t\t\t\t\t\t\t\t<ShoutrrrUrlCard\n\t\t\t\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\t\t\t\turl={webhook}\n\t\t\t\t\t\t\t\t\tonUrlChange={(e: React.ChangeEvent<HTMLInputElement>) => updateWebhook(index, e.target.value)}", "n_tokens": 57, "primary_symbol": "", "primary_kind": "", "primary_span": [139, 143], "def_symbols": [], "symbols": ["webhooks", "map", "webhook", "index", "ShoutrrrUrlCard", "key", "url", "onUrlChange", "React", "ChangeEvent", "HTMLInputElement", "updateWebhook", "target", "value"], "doc_head": "\t\t\t\t\t\t\t{webhooks.map((webhook, index) => (\n\t\t\t\t\t\t\t\t<ShoutrrrUrlCard\n\t\t\t\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\t\t\t\turl={webhook}\n\t\t\t\t\t\t\t\t\tonUrlChange={(e: React.ChangeEvent<HTMLInputElement>) => updateWebhook(index, e.target.value)}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx", "rel_path": "src/site/src/components/routes/settings/notifications.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 144, "end_line": 174, "text": "\t\t\t\t\t\t\t\t\tonRemove={() => removeWebhook(index)}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t\t<Button\n\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\tclassName=\"mt-2 flex items-center gap-1\"\n\t\t\t\t\t\tonClick={addWebhook}\n\t\t\t\t\t>\n\t\t\t\t\t\t<PlusIcon className=\"h-4 w-4 -ms-0.5\" />\n\t\t\t\t\t\t<Trans>Add URL</Trans>\n\t\t\t\t\t</Button>\n\t\t\t\t</div>\n\t\t\t\t<Separator />\n\t\t\t\t<Button\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t\tclassName=\"flex items-center gap-1.5 disabled:opacity-100\"\n\t\t\t\t\tonClick={updateSettings}\n\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t>\n\t\t\t\t\t{isLoading ? <LoaderCircleIcon className=\"h-4 w-4 animate-spin\" /> : <SaveIcon className=\"h-4 w-4\" />}\n\t\t\t\t\t<Trans>Save Settings</Trans>\n\t\t\t\t</Button>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n", "n_tokens": 216, "primary_symbol": "", "primary_kind": "", "primary_span": [144, 174], "def_symbols": [], "symbols": ["onRemove", "removeWebhook", "index", "div", "Button", "type", "button", "variant", "outline", "size", "className", "flex", "items", "center", "gap", "onClick", "addWebhook", "PlusIcon", "Trans", "Add", "URL", "Separator", "disabled", "opacity", "updateSettings", "isLoading", "LoaderCircleIcon", "animate", "spin", "SaveIcon", "Save", "Settings"], "doc_head": "\t\t\t\t\t\t\t\t\tonRemove={() => removeWebhook(index)}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t\t<Button\n\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\tclassName=\"mt-2 flex items-center gap-1\"\n\t\t\t\t\t\tonClick={addWebhook}\n\t\t\t\t\t>\n\t\t\t\t\t\t<PlusIcon className=\"h-4 w-4 -ms-0.5\" />\n\t\t\t\t\t\t<Trans>Add URL</Trans>\n\t\t\t\t\t</Button>\n\t\t\t\t</div>\n\t\t\t\t<Separator />\n\t\t\t\t<Button\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t\tclassName=\"flex items-center gap-1.5 disabled:opacity-100\"\n\t\t\t\t\tonClick={updateSettings}\n\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t>\n\t\t\t\t\t{isLoading ? <LoaderCircleIcon className=\"h-4 w-4 animate-spin\" /> : <SaveIcon className=\"h-4 w-4\" />}\n\t\t\t\t\t<Trans>Save Settings</Trans>\n\t\t\t\t</Button>\n\t\t\t</div>\n\t\t</div>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx", "rel_path": "src/site/src/components/routes/settings/notifications.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 175, "end_line": 185, "text": "const ShoutrrrUrlCard = ({ url, onUrlChange, onRemove }: ShoutrrrUrlCardProps) => {\n\tconst [isLoading, setIsLoading] = useState(false)\n\n\tconst sendTestNotification = async () => {\n\t\tsetIsLoading(true)\n\t\tconst res = await pb.send(\"/api/beszel/test-notification\", { method: \"POST\", body: { url } })\n\t\tif (\"err\" in res && !res.err) {\n\t\t\ttoast({\n\t\t\t\ttitle: t`Test notification sent`,\n\t\t\t\tdescription: t`Check your notification service`,\n\t\t\t})", "n_tokens": 120, "primary_symbol": "ShoutrrrUrlCard", "primary_kind": "function", "primary_span": [175, 185], "def_symbols": ["ShoutrrrUrlCard", "sendTestNotification"], "symbols": ["ShoutrrrUrlCard", "sendTestNotification", "const", "url", "onUrlChange", "onRemove", "ShoutrrrUrlCardProps", "isLoading", "setIsLoading", "useState", "false", "async", "true", "res", "await", "send", "api", "beszel", "test", "notification", "method", "POST", "body", "err", "toast", "title", "Test", "sent", "description", "Check", "your", "service"], "doc_head": "const ShoutrrrUrlCard = ({ url, onUrlChange, onRemove }: ShoutrrrUrlCardProps) => {\n\tconst [isLoading, setIsLoading] = useState(false)\n\tconst sendTestNotification = async () => {\n\t\tsetIsLoading(true)\n\t\tconst res = await pb.send(\"/api/beszel/test-notification\", { method: \"POST\", body: { url } })\n\t\tif (\"err\" in res && !res.err) {\n\t\t\ttoast({\n\t\t\t\ttitle: t`Test notification sent`,\n\t\t\t\tdescription: t`Check your notification service`,\n\t\t\t})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx", "rel_path": "src/site/src/components/routes/settings/notifications.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 186, "end_line": 225, "text": "\t\t} else {\n\t\t\ttoast({\n\t\t\t\ttitle: t`Error`,\n\t\t\t\tdescription: res.err ?? t`Failed to send test notification`,\n\t\t\t\tvariant: \"destructive\",\n\t\t\t})\n\t\t}\n\t\tsetIsLoading(false)\n\t}\n\n\treturn (\n\t\t<Card className=\"bg-muted/40 p-2 md:p-3\">\n\t\t\t<div className=\"flex items-center gap-1\">\n\t\t\t\t<Input\n\t\t\t\t\ttype=\"url\"\n\t\t\t\t\tclassName=\"light:bg-card\"\n\t\t\t\t\trequired\n\t\t\t\t\tplaceholder=\"generic://webhook.site/xxxxxx\"\n\t\t\t\t\tvalue={url}\n\t\t\t\t\tonChange={onUrlChange}\n\t\t\t\t/>\n\t\t\t\t<Button type=\"button\" variant=\"outline\" disabled={isLoading || url === \"\"} onClick={sendTestNotification}>\n\t\t\t\t\t{isLoading ? (\n\t\t\t\t\t\t<LoaderCircleIcon className=\"h-4 w-4 animate-spin\" />\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\tTest <span className=\"hidden sm:inline\">URL</span>\n\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t)}\n\t\t\t\t</Button>\n\t\t\t\t<Button type=\"button\" variant=\"outline\" size=\"icon\" className=\"shrink-0\" aria-label=\"Delete\" onClick={onRemove}>\n\t\t\t\t\t<Trash2Icon className=\"h-4 w-4\" />\n\t\t\t\t</Button>\n\t\t\t</div>\n\t\t</Card>\n\t)\n}\n", "n_tokens": 290, "primary_symbol": "", "primary_kind": "", "primary_span": [186, 225], "def_symbols": [], "symbols": ["else", "toast", "title", "Error", "description", "res", "err", "Failed", "send", "test", "notification", "variant", "destructive", "setIsLoading", "false", "return", "Card", "className", "muted", "div", "flex", "items", "center", "gap", "Input", "type", "url", "light", "card", "required", "placeholder", "generic", "webhook", "site", "xxxxxx", "value", "onChange", "onUrlChange", "Button", "button", "outline", "disabled", "isLoading", "onClick", "sendTestNotification", "LoaderCircleIcon", "animate", "spin", "span", "Trans", "Test", "hidden", "inline", "URL", "size", "icon", "shrink", "aria", "label", "Delete", "onRemove", "Trash2Icon"], "doc_head": "\t\t} else {\n\t\t\ttoast({\n\t\t\t\ttitle: t`Error`,\n\t\t\t\tdescription: res.err ?? t`Failed to send test notification`,\n\t\t\t\tvariant: \"destructive\",\n\t\t\t})\n\t\t}\n\t\tsetIsLoading(false)\n\t}\n\treturn (\n\t\t<Card className=\"bg-muted/40 p-2 md:p-3\">\n\t\t\t<div className=\"flex items-center gap-1\">\n\t\t\t\t<Input\n\t\t\t\t\ttype=\"url\"\n\t\t\t\t\tclassName=\"light:bg-card\"\n\t\t\t\t\trequired\n\t\t\t\t\tplaceholder=\"generic://webhook.site/xxxxxx\"\n\t\t\t\t\tvalue={url}\n\t\t\t\t\tonChange={onUrlChange}\n\t\t\t\t/>\n\t\t\t\t<Button type=\"button\" variant=\"outline\" disabled={isLoading || url === \"\"} onClick={sendTestNotification}>\n\t\t\t\t\t{isLoading ? (\n\t\t\t\t\t\t<LoaderCircleIcon className=\"h-4 w-4 animate-spin\" />\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\tTest <span className=\"hidden sm:inline\">URL</span>\n\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t)}\n\t\t\t\t</Button>\n\t\t\t\t<Button type=\"button\" variant=\"outline\" size=\"icon\" className=\"shrink-0\" aria-label=\"Delete\" onClick={onRemove}>\n\t\t\t\t\t<Trash2Icon className=\"h-4 w-4\" />\n\t\t\t\t</Button>\n\t\t\t</div>\n\t\t</Card>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/notifications.tsx", "rel_path": "src/site/src/components/routes/settings/notifications.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 226, "end_line": 227, "text": "export default SettingsNotificationsPage\n", "n_tokens": 6, "primary_symbol": "", "primary_kind": "", "primary_span": [226, 227], "def_symbols": [], "symbols": ["export", "default", "SettingsNotificationsPage"], "doc_head": "export default SettingsNotificationsPage"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx", "rel_path": "src/site/src/components/routes/settings/layout.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 14, "text": "import { t } from \"@lingui/core/macro\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { lazy, useEffect } from \"react\"\nimport { Separator } from \"../../ui/separator\"\nimport { SidebarNav } from \"./sidebar-nav.tsx\"\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card.tsx\"\nimport { useStore } from \"@nanostores/react\"\nimport { $router } from \"@/components/router.tsx\"\nimport { getPagePath, redirectPage } from \"@nanostores/router\"\nimport { BellIcon, FileSlidersIcon, FingerprintIcon, SettingsIcon, AlertOctagonIcon } from \"lucide-react\"\nimport { $userSettings } from \"@/lib/stores.ts\"\nimport { toast } from \"@/components/ui/use-toast.ts\"\nimport { UserSettings } from \"@/types\"\nimport { useLingui } from \"@lingui/react/macro\"", "n_tokens": 197, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 14], "def_symbols": [], "symbols": ["import", "from", "lingui", "core", "macro", "Trans", "react", "lazy", "useEffect", "Separator", "separator", "SidebarNav", "sidebar", "nav", "tsx", "Card", "CardContent", "CardDescription", "CardHeader", "CardTitle", "components", "card", "useStore", "nanostores", "router", "getPagePath", "redirectPage", "BellIcon", "FileSlidersIcon", "FingerprintIcon", "SettingsIcon", "AlertOctagonIcon", "lucide", "userSettings", "lib", "stores", "toast", "use", "UserSettings", "types", "useLingui"], "doc_head": "import { t } from \"@lingui/core/macro\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { lazy, useEffect } from \"react\"\nimport { Separator } from \"../../ui/separator\"\nimport { SidebarNav } from \"./sidebar-nav.tsx\"\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card.tsx\"\nimport { useStore } from \"@nanostores/react\"\nimport { $router } from \"@/components/router.tsx\"\nimport { getPagePath, redirectPage } from \"@nanostores/router\"\nimport { BellIcon, FileSlidersIcon, FingerprintIcon, SettingsIcon, AlertOctagonIcon } from \"lucide-react\"\nimport { $userSettings } from \"@/lib/stores.ts\"\nimport { toast } from \"@/components/ui/use-toast.ts\"\nimport { UserSettings } from \"@/types\"\nimport { useLingui } from \"@lingui/react/macro\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx", "rel_path": "src/site/src/components/routes/settings/layout.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 15, "end_line": 29, "text": "import { pb } from \"@/lib/api\"\n\nconst generalSettingsImport = () => import(\"./general.tsx\")\nconst notificationsSettingsImport = () => import(\"./notifications.tsx\")\nconst configYamlSettingsImport = () => import(\"./config-yaml.tsx\")\nconst fingerprintsSettingsImport = () => import(\"./tokens-fingerprints.tsx\")\nconst alertsHistoryDataTableSettingsImport = () => import(\"./alerts-history-data-table.tsx\")\n\nconst GeneralSettings = lazy(generalSettingsImport)\nconst NotificationsSettings = lazy(notificationsSettingsImport)\nconst ConfigYamlSettings = lazy(configYamlSettingsImport)\nconst FingerprintsSettings = lazy(fingerprintsSettingsImport)\nconst AlertsHistoryDataTableSettings = lazy(alertsHistoryDataTableSettingsImport)\n\nexport async function saveSettings(newSettings: Partial<UserSettings>) {", "n_tokens": 158, "primary_symbol": "saveSettings", "primary_kind": "function", "primary_span": [29, 29], "def_symbols": ["saveSettings", "generalSettingsImport", "notificationsSettingsImport", "configYamlSettingsImport", "fingerprintsSettingsImport", "alertsHistoryDataTableSettingsImport"], "symbols": ["saveSettings", "generalSettingsImport", "notificationsSettingsImport", "configYamlSettingsImport", "fingerprintsSettingsImport", "alertsHistoryDataTableSettingsImport", "import", "from", "lib", "api", "const", "general", "tsx", "notifications", "config", "yaml", "tokens", "fingerprints", "alerts", "history", "data", "table", "GeneralSettings", "lazy", "NotificationsSettings", "ConfigYamlSettings", "FingerprintsSettings", "AlertsHistoryDataTableSettings", "export", "async", "function", "newSettings", "Partial", "UserSettings"], "doc_head": "import { pb } from \"@/lib/api\"\nconst generalSettingsImport = () => import(\"./general.tsx\")\nconst notificationsSettingsImport = () => import(\"./notifications.tsx\")\nconst configYamlSettingsImport = () => import(\"./config-yaml.tsx\")\nconst fingerprintsSettingsImport = () => import(\"./tokens-fingerprints.tsx\")\nconst alertsHistoryDataTableSettingsImport = () => import(\"./alerts-history-data-table.tsx\")\nconst GeneralSettings = lazy(generalSettingsImport)\nconst NotificationsSettings = lazy(notificationsSettingsImport)\nconst ConfigYamlSettings = lazy(configYamlSettingsImport)\nconst FingerprintsSettings = lazy(fingerprintsSettingsImport)\nconst AlertsHistoryDataTableSettings = lazy(alertsHistoryDataTableSettingsImport)\nexport async function saveSettings(newSettings: Partial<UserSettings>) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx", "rel_path": "src/site/src/components/routes/settings/layout.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 30, "end_line": 56, "text": "\ttry {\n\t\t// get fresh copy of settings\n\t\tconst req = await pb.collection(\"user_settings\").getFirstListItem(\"\", {\n\t\t\tfields: \"id,settings\",\n\t\t})\n\t\t// update user settings\n\t\tconst updatedSettings = await pb.collection(\"user_settings\").update(req.id, {\n\t\t\tsettings: {\n\t\t\t\t...req.settings,\n\t\t\t\t...newSettings,\n\t\t\t},\n\t\t})\n\t\t$userSettings.set(updatedSettings.settings)\n\t\ttoast({\n\t\t\ttitle: t`Settings saved`,\n\t\t\tdescription: t`Your user settings have been updated.`,\n\t\t})\n\t} catch (e) {\n\t\t// console.error('update settings', e)\n\t\ttoast({\n\t\t\ttitle: t`Failed to save settings`,\n\t\t\tdescription: t`Check logs for more details.`,\n\t\t\tvariant: \"destructive\",\n\t\t})\n\t}\n}\n", "n_tokens": 177, "primary_symbol": "", "primary_kind": "", "primary_span": [30, 56], "def_symbols": [], "symbols": ["try", "get", "fresh", "copy", "settings", "const", "req", "await", "collection", "user_settings", "getFirstListItem", "fields", "update", "user", "updatedSettings", "newSettings", "userSettings", "set", "toast", "title", "Settings", "saved", "description", "Your", "have", "been", "updated", "catch", "console", "error", "Failed", "save", "Check", "logs", "for", "more", "details", "variant", "destructive"], "doc_head": "\ttry {\n\t\t// get fresh copy of settings\n\t\tconst req = await pb.collection(\"user_settings\").getFirstListItem(\"\", {\n\t\t\tfields: \"id,settings\",\n\t\t})\n\t\t// update user settings\n\t\tconst updatedSettings = await pb.collection(\"user_settings\").update(req.id, {\n\t\t\tsettings: {\n\t\t\t\t...req.settings,\n\t\t\t\t...newSettings,\n\t\t\t},\n\t\t})\n\t\t$userSettings.set(updatedSettings.settings)\n\t\ttoast({\n\t\t\ttitle: t`Settings saved`,\n\t\t\tdescription: t`Your user settings have been updated.`,\n\t\t})\n\t} catch (e) {\n\t\t// console.error('update settings', e)\n\t\ttoast({\n\t\t\ttitle: t`Failed to save settings`,\n\t\t\tdescription: t`Check logs for more details.`,\n\t\t\tvariant: \"destructive\",\n\t\t})\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx", "rel_path": "src/site/src/components/routes/settings/layout.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 57, "end_line": 95, "text": "export default function SettingsLayout() {\n\tconst { t } = useLingui()\n\n\tconst sidebarNavItems = [\n\t\t{\n\t\t\ttitle: t({ message: `General`, comment: \"Context: General settings\" }),\n\t\t\thref: getPagePath($router, \"settings\", { name: \"general\" }),\n\t\t\ticon: SettingsIcon,\n\t\t},\n\t\t{\n\t\t\ttitle: t`Notifications`,\n\t\t\thref: getPagePath($router, \"settings\", { name: \"notifications\" }),\n\t\t\ticon: BellIcon,\n\t\t\tpreload: notificationsSettingsImport,\n\t\t},\n\t\t{\n\t\t\ttitle: t`Tokens & Fingerprints`,\n\t\t\thref: getPagePath($router, \"settings\", { name: \"tokens\" }),\n\t\t\ticon: FingerprintIcon,\n\t\t\tnoReadOnly: true,\n\t\t\tpreload: fingerprintsSettingsImport,\n\t\t},\n\t\t{\n\t\t\ttitle: t`Alert History`,\n\t\t\thref: getPagePath($router, \"settings\", { name: \"alert-history\" }),\n\t\t\ticon: AlertOctagonIcon,\n\t\t\tpreload: alertsHistoryDataTableSettingsImport,\n\t\t},\n\t\t{\n\t\t\ttitle: t`YAML Config`,\n\t\t\thref: getPagePath($router, \"settings\", { name: \"config\" }),\n\t\t\ticon: FileSlidersIcon,\n\t\t\tadmin: true,\n\t\t\tpreload: configYamlSettingsImport,\n\t\t},\n\t]\n\n\tconst page = useStore($router)\n", "n_tokens": 294, "primary_symbol": "", "primary_kind": "", "primary_span": [57, 95], "def_symbols": [], "symbols": ["export", "default", "function", "SettingsLayout", "const", "useLingui", "sidebarNavItems", "title", "message", "General", "comment", "Context", "settings", "href", "getPagePath", "router", "name", "general", "icon", "SettingsIcon", "Notifications", "notifications", "BellIcon", "preload", "notificationsSettingsImport", "Tokens", "Fingerprints", "tokens", "FingerprintIcon", "noReadOnly", "true", "fingerprintsSettingsImport", "Alert", "History", "alert", "history", "AlertOctagonIcon", "alertsHistoryDataTableSettingsImport", "YAML", "Config", "config", "FileSlidersIcon", "admin", "configYamlSettingsImport", "page", "useStore"], "doc_head": "export default function SettingsLayout() {\n\tconst { t } = useLingui()\n\tconst sidebarNavItems = [\n\t\t{\n\t\t\ttitle: t({ message: `General`, comment: \"Context: General settings\" }),\n\t\t\thref: getPagePath($router, \"settings\", { name: \"general\" }),\n\t\t\ticon: SettingsIcon,\n\t\t},\n\t\t{\n\t\t\ttitle: t`Notifications`,\n\t\t\thref: getPagePath($router, \"settings\", { name: \"notifications\" }),\n\t\t\ticon: BellIcon,\n\t\t\tpreload: notificationsSettingsImport,\n\t\t},\n\t\t{\n\t\t\ttitle: t`Tokens & Fingerprints`,\n\t\t\thref: getPagePath($router, \"settings\", { name: \"tokens\" }),\n\t\t\ticon: FingerprintIcon,\n\t\t\tnoReadOnly: true,\n\t\t\tpreload: fingerprintsSettingsImport,\n\t\t},\n\t\t{\n\t\t\ttitle: t`Alert History`,\n\t\t\thref: getPagePath($router, \"settings\", { name: \"alert-history\" }),\n\t\t\ticon: AlertOctagonIcon,\n\t\t\tpreload: alertsHistoryDataTableSettingsImport,\n\t\t},\n\t\t{\n\t\t\ttitle: t`YAML Config`,\n\t\t\thref: getPagePath($router, \"settings\", { name: \"config\" }),\n\t\t\ticon: FileSlidersIcon,\n\t\t\tadmin: true,\n\t\t\tpreload: configYamlSettingsImport,\n\t\t},\n\t]\n\tconst page = useStore($router)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx", "rel_path": "src/site/src/components/routes/settings/layout.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 96, "end_line": 97, "text": "\tuseEffect(() => {\n\t\tdocument.title = t`Settings` + \" / Beszel\"", "n_tokens": 19, "primary_symbol": "", "primary_kind": "", "primary_span": [96, 97], "def_symbols": [], "symbols": ["useEffect", "document", "title", "Settings", "Beszel"], "doc_head": "\tuseEffect(() => {\n\t\tdocument.title = t`Settings` + \" / Beszel\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx", "rel_path": "src/site/src/components/routes/settings/layout.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 98, "end_line": 129, "text": "\t\t// @ts-ignore redirect to account page if no page is specified\n\t\tif (!page?.params?.name) {\n\t\t\tredirectPage($router, \"settings\", { name: \"general\" })\n\t\t}\n\t}, [])\n\n\treturn (\n\t\t<Card className=\"pt-5 px-4 pb-8 min-h-96 mb-14 sm:pt-6 sm:px-7\">\n\t\t\t<CardHeader className=\"p-0\">\n\t\t\t\t<CardTitle className=\"mb-1\">\n\t\t\t\t\t<Trans>Settings</Trans>\n\t\t\t\t</CardTitle>\n\t\t\t\t<CardDescription>\n\t\t\t\t\t<Trans>Manage display and notification preferences.</Trans>\n\t\t\t\t</CardDescription>\n\t\t\t</CardHeader>\n\t\t\t<CardContent className=\"p-0\">\n\t\t\t\t<Separator className=\"hidden md:block my-5\" />\n\t\t\t\t<div className=\"flex flex-col gap-3.5 md:flex-row md:gap-5 lg:gap-12\">\n\t\t\t\t\t<aside className=\"md:max-w-52 min-w-40\">\n\t\t\t\t\t\t<SidebarNav items={sidebarNavItems} />\n\t\t\t\t\t</aside>\n\t\t\t\t\t<div className=\"flex-1 min-w-0\">\n\t\t\t\t\t\t{/* @ts-ignore */}\n\t\t\t\t\t\t<SettingsContent name={page?.params?.name ?? \"general\"} />\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</CardContent>\n\t\t</Card>\n\t)\n}\n", "n_tokens": 291, "primary_symbol": "", "primary_kind": "", "primary_span": [98, 129], "def_symbols": [], "symbols": ["ignore", "redirect", "account", "page", "specified", "params", "name", "redirectPage", "router", "settings", "general", "return", "Card", "className", "min", "CardHeader", "CardTitle", "Trans", "Settings", "CardDescription", "Manage", "display", "and", "notification", "preferences", "CardContent", "Separator", "hidden", "block", "div", "flex", "col", "gap", "row", "aside", "max", "SidebarNav", "items", "sidebarNavItems", "SettingsContent"], "doc_head": "\t\t// @ts-ignore redirect to account page if no page is specified\n\t\tif (!page?.params?.name) {\n\t\t\tredirectPage($router, \"settings\", { name: \"general\" })\n\t\t}\n\t}, [])\n\treturn (\n\t\t<Card className=\"pt-5 px-4 pb-8 min-h-96 mb-14 sm:pt-6 sm:px-7\">\n\t\t\t<CardHeader className=\"p-0\">\n\t\t\t\t<CardTitle className=\"mb-1\">\n\t\t\t\t\t<Trans>Settings</Trans>\n\t\t\t\t</CardTitle>\n\t\t\t\t<CardDescription>\n\t\t\t\t\t<Trans>Manage display and notification preferences.</Trans>\n\t\t\t\t</CardDescription>\n\t\t\t</CardHeader>\n\t\t\t<CardContent className=\"p-0\">\n\t\t\t\t<Separator className=\"hidden md:block my-5\" />\n\t\t\t\t<div className=\"flex flex-col gap-3.5 md:flex-row md:gap-5 lg:gap-12\">\n\t\t\t\t\t<aside className=\"md:max-w-52 min-w-40\">\n\t\t\t\t\t\t<SidebarNav items={sidebarNavItems} />\n\t\t\t\t\t</aside>\n\t\t\t\t\t<div className=\"flex-1 min-w-0\">\n\t\t\t\t\t\t{/* @ts-ignore */}\n\t\t\t\t\t\t<SettingsContent name={page?.params?.name ?? \"general\"} />\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</CardContent>\n\t\t</Card>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/layout.tsx", "rel_path": "src/site/src/components/routes/settings/layout.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 130, "end_line": 146, "text": "function SettingsContent({ name }: { name: string }) {\n\tconst userSettings = useStore($userSettings)\n\n\tswitch (name) {\n\t\tcase \"general\":\n\t\t\treturn <GeneralSettings userSettings={userSettings} />\n\t\tcase \"notifications\":\n\t\t\treturn <NotificationsSettings userSettings={userSettings} />\n\t\tcase \"config\":\n\t\t\treturn <ConfigYamlSettings />\n\t\tcase \"tokens\":\n\t\t\treturn <FingerprintsSettings />\n\t\tcase \"alert-history\":\n\t\t\treturn <AlertsHistoryDataTableSettings />\n\t}\n}\n", "n_tokens": 105, "primary_symbol": "SettingsContent", "primary_kind": "function", "primary_span": [130, 146], "def_symbols": ["SettingsContent"], "symbols": ["SettingsContent", "function", "name", "string", "const", "userSettings", "useStore", "switch", "case", "general", "return", "GeneralSettings", "notifications", "NotificationsSettings", "config", "ConfigYamlSettings", "tokens", "FingerprintsSettings", "alert", "history", "AlertsHistoryDataTableSettings"], "doc_head": "function SettingsContent({ name }: { name: string }) {\n\tconst userSettings = useStore($userSettings)\n\tswitch (name) {\n\t\tcase \"general\":\n\t\t\treturn <GeneralSettings userSettings={userSettings} />\n\t\tcase \"notifications\":\n\t\t\treturn <NotificationsSettings userSettings={userSettings} />\n\t\tcase \"config\":\n\t\t\treturn <ConfigYamlSettings />\n\t\tcase \"tokens\":\n\t\t\treturn <FingerprintsSettings />\n\t\tcase \"alert-history\":\n\t\t\treturn <AlertsHistoryDataTableSettings />\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/sidebar-nav.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/sidebar-nav.tsx", "rel_path": "src/site/src/components/routes/settings/sidebar-nav.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 20, "text": "import React from \"react\"\nimport { cn } from \"@/lib/utils\"\nimport { isAdmin, isReadOnlyUser } from \"@/lib/api\"\nimport { buttonVariants } from \"../../ui/button\"\nimport { $router, Link, navigate } from \"../../router\"\nimport { useStore } from \"@nanostores/react\"\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\"\nimport { Separator } from \"@/components/ui/separator\"\n\ninterface SidebarNavProps extends React.HTMLAttributes<HTMLElement> {\n\titems: {\n\t\thref: string\n\t\ttitle: string\n\t\ticon?: React.FC<React.SVGProps<SVGSVGElement>>\n\t\tadmin?: boolean\n\t\tnoReadOnly?: boolean\n\t\tpreload?: () => Promise<{ default: React.ComponentType<any> }>\n\t}[]\n}\n", "n_tokens": 170, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 20], "def_symbols": [], "symbols": ["import", "React", "from", "react", "lib", "utils", "isAdmin", "isReadOnlyUser", "api", "buttonVariants", "button", "router", "Link", "navigate", "useStore", "nanostores", "Select", "SelectContent", "SelectItem", "SelectTrigger", "SelectValue", "components", "select", "Separator", "separator", "interface", "SidebarNavProps", "extends", "HTMLAttributes", "HTMLElement", "items", "href", "string", "title", "icon", "SVGProps", "SVGSVGElement", "admin", "boolean", "noReadOnly", "preload", "Promise", "default", "ComponentType", "any"], "doc_head": "import React from \"react\"\nimport { cn } from \"@/lib/utils\"\nimport { isAdmin, isReadOnlyUser } from \"@/lib/api\"\nimport { buttonVariants } from \"../../ui/button\"\nimport { $router, Link, navigate } from \"../../router\"\nimport { useStore } from \"@nanostores/react\"\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\"\nimport { Separator } from \"@/components/ui/separator\"\ninterface SidebarNavProps extends React.HTMLAttributes<HTMLElement> {\n\titems: {\n\t\thref: string\n\t\ttitle: string\n\t\ticon?: React.FC<React.SVGProps<SVGSVGElement>>\n\t\tadmin?: boolean\n\t\tnoReadOnly?: boolean\n\t\tpreload?: () => Promise<{ default: React.ComponentType<any> }>\n\t}[]\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/sidebar-nav.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/sidebar-nav.tsx", "rel_path": "src/site/src/components/routes/settings/sidebar-nav.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 21, "end_line": 32, "text": "export function SidebarNav({ className, items, ...props }: SidebarNavProps) {\n\tconst page = useStore($router)\n\n\treturn (\n\t\t<>\n\t\t\t{/* Mobile View */}\n\t\t\t<div className=\"md:hidden\">\n\t\t\t\t<Select onValueChange={navigate} value={page?.path}>\n\t\t\t\t\t<SelectTrigger className=\"w-full my-3.5\">\n\t\t\t\t\t\t<SelectValue placeholder=\"Select page\" />\n\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t<SelectContent>", "n_tokens": 94, "primary_symbol": "SidebarNav", "primary_kind": "function", "primary_span": [21, 32], "def_symbols": ["SidebarNav"], "symbols": ["SidebarNav", "export", "function", "className", "items", "props", "SidebarNavProps", "const", "page", "useStore", "router", "return", "Mobile", "View", "div", "hidden", "Select", "onValueChange", "navigate", "value", "path", "SelectTrigger", "full", "SelectValue", "placeholder", "SelectContent"], "doc_head": "export function SidebarNav({ className, items, ...props }: SidebarNavProps) {\n\tconst page = useStore($router)\n\treturn (\n\t\t<>\n\t\t\t{/* Mobile View */}\n\t\t\t<div className=\"md:hidden\">\n\t\t\t\t<Select onValueChange={navigate} value={page?.path}>\n\t\t\t\t\t<SelectTrigger className=\"w-full my-3.5\">\n\t\t\t\t\t\t<SelectValue placeholder=\"Select page\" />\n\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t<SelectContent>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/sidebar-nav.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/sidebar-nav.tsx", "rel_path": "src/site/src/components/routes/settings/sidebar-nav.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 33, "end_line": 56, "text": "\t\t\t\t\t\t{items.map((item) => {\n\t\t\t\t\t\t\tif (item.admin && !isAdmin()) return null\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<SelectItem key={item.href} value={item.href}>\n\t\t\t\t\t\t\t\t\t<span className=\"flex items-center gap-2 truncate\">\n\t\t\t\t\t\t\t\t\t\t{item.icon && <item.icon className=\"size-4\" />}\n\t\t\t\t\t\t\t\t\t\t<span className=\"truncate\">{item.title}</span>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t</SelectContent>\n\t\t\t\t</Select>\n\t\t\t\t<Separator />\n\t\t\t</div>\n\n\t\t\t{/* Desktop View */}\n\t\t\t<nav className={cn(\"hidden md:grid gap-1 sticky top-6\", className)} {...props}>\n\t\t\t\t{items.map((item) => {\n\t\t\t\t\tif ((item.admin && !isAdmin()) || (item.noReadOnly && isReadOnlyUser())) {\n\t\t\t\t\t\treturn null\n\t\t\t\t\t}\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<Link", "n_tokens": 191, "primary_symbol": "", "primary_kind": "", "primary_span": [33, 56], "def_symbols": [], "symbols": ["items", "map", "item", "admin", "isAdmin", "return", "null", "SelectItem", "key", "href", "value", "span", "className", "flex", "center", "gap", "truncate", "icon", "size", "title", "SelectContent", "Select", "Separator", "div", "Desktop", "View", "nav", "hidden", "grid", "sticky", "top", "props", "noReadOnly", "isReadOnlyUser", "Link"], "doc_head": "\t\t\t\t\t\t{items.map((item) => {\n\t\t\t\t\t\t\tif (item.admin && !isAdmin()) return null\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<SelectItem key={item.href} value={item.href}>\n\t\t\t\t\t\t\t\t\t<span className=\"flex items-center gap-2 truncate\">\n\t\t\t\t\t\t\t\t\t\t{item.icon && <item.icon className=\"size-4\" />}\n\t\t\t\t\t\t\t\t\t\t<span className=\"truncate\">{item.title}</span>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t</SelectContent>\n\t\t\t\t</Select>\n\t\t\t\t<Separator />\n\t\t\t</div>\n\t\t\t{/* Desktop View */}\n\t\t\t<nav className={cn(\"hidden md:grid gap-1 sticky top-6\", className)} {...props}>\n\t\t\t\t{items.map((item) => {\n\t\t\t\t\tif ((item.admin && !isAdmin()) || (item.noReadOnly && isReadOnlyUser())) {\n\t\t\t\t\t\treturn null\n\t\t\t\t\t}\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<Link"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/sidebar-nav.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/sidebar-nav.tsx", "rel_path": "src/site/src/components/routes/settings/sidebar-nav.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 57, "end_line": 75, "text": "\t\t\t\t\t\t\tonMouseEnter={() => item.preload?.()}\n\t\t\t\t\t\t\tkey={item.href}\n\t\t\t\t\t\t\thref={item.href}\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\tbuttonVariants({ variant: \"ghost\" }),\n\t\t\t\t\t\t\t\t\"flex items-center gap-3 justify-start truncate duration-50\",\n\t\t\t\t\t\t\t\tpage?.path === item.href ? \"bg-muted hover:bg-accent/70\" : \"hover:bg-accent/50\"\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{item.icon && <item.icon className=\"size-4 shrink-0\" />}\n\t\t\t\t\t\t\t<span className=\"truncate\">{item.title}</span>\n\t\t\t\t\t\t</Link>\n\t\t\t\t\t)\n\t\t\t\t})}\n\t\t\t</nav>\n\t\t</>\n\t)\n}\n", "n_tokens": 143, "primary_symbol": "", "primary_kind": "", "primary_span": [57, 75], "def_symbols": [], "symbols": ["onMouseEnter", "item", "preload", "key", "href", "className", "buttonVariants", "variant", "ghost", "flex", "items", "center", "gap", "justify", "start", "truncate", "duration", "page", "path", "muted", "hover", "accent", "icon", "size", "shrink", "span", "title", "Link", "nav"], "doc_head": "\t\t\t\t\t\t\tonMouseEnter={() => item.preload?.()}\n\t\t\t\t\t\t\tkey={item.href}\n\t\t\t\t\t\t\thref={item.href}\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\tbuttonVariants({ variant: \"ghost\" }),\n\t\t\t\t\t\t\t\t\"flex items-center gap-3 justify-start truncate duration-50\",\n\t\t\t\t\t\t\t\tpage?.path === item.href ? \"bg-muted hover:bg-accent/70\" : \"hover:bg-accent/50\"\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{item.icon && <item.icon className=\"size-4 shrink-0\" />}\n\t\t\t\t\t\t\t<span className=\"truncate\">{item.title}</span>\n\t\t\t\t\t\t</Link>\n\t\t\t\t\t)\n\t\t\t\t})}\n\t\t\t</nav>\n\t\t</>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "import { pb } from \"@/lib/api\"\nimport { cn, formatDuration, formatShortDate } from \"@/lib/utils\"\nimport { alertInfo } from \"@/lib/alerts\"\nimport { AlertsHistoryRecord } from \"@/types\"\nimport {\n\tgetCoreRowModel,\n\tgetPaginationRowModel,\n\tgetSortedRowModel,\n\tgetFilteredRowModel,\n\tuseReactTable,\n\tflexRender,\n\tColumnFiltersState,\n\tSortingState,\n\tVisibilityState,\n} from \"@tanstack/react-table\"\nimport { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from \"@/components/ui/table\"\nimport { Button, buttonVariants } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { alertsHistoryColumns } from \"../../alerts-history-columns\"\nimport { Checkbox } from \"@/components/ui/checkbox\"\nimport { memo, useEffect, useState } from \"react\"\nimport { Label } from \"@/components/ui/label\"", "n_tokens": 189, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 22], "def_symbols": [], "symbols": ["import", "from", "lib", "api", "formatDuration", "formatShortDate", "utils", "alertInfo", "alerts", "AlertsHistoryRecord", "types", "getCoreRowModel", "getPaginationRowModel", "getSortedRowModel", "getFilteredRowModel", "useReactTable", "flexRender", "ColumnFiltersState", "SortingState", "VisibilityState", "tanstack", "react", "table", "Table", "TableBody", "TableCell", "TableHead", "TableHeader", "TableRow", "components", "Button", "buttonVariants", "button", "Input", "input", "alertsHistoryColumns", "history", "columns", "Checkbox", "checkbox", "memo", "useEffect", "useState", "Label", "label"], "doc_head": "import { pb } from \"@/lib/api\"\nimport { cn, formatDuration, formatShortDate } from \"@/lib/utils\"\nimport { alertInfo } from \"@/lib/alerts\"\nimport { AlertsHistoryRecord } from \"@/types\"\nimport {\n\tgetCoreRowModel,\n\tgetPaginationRowModel,\n\tgetSortedRowModel,\n\tgetFilteredRowModel,\n\tuseReactTable,\n\tflexRender,\n\tColumnFiltersState,\n\tSortingState,\n\tVisibilityState,\n} from \"@tanstack/react-table\"\nimport { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from \"@/components/ui/table\"\nimport { Button, buttonVariants } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { alertsHistoryColumns } from \"../../alerts-history-columns\"\nimport { Checkbox } from \"@/components/ui/checkbox\"\nimport { memo, useEffect, useState } from \"react\"\nimport { Label } from \"@/components/ui/label\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 23, "end_line": 46, "text": "import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from \"@/components/ui/select\"\nimport {\n\tChevronLeftIcon,\n\tChevronRightIcon,\n\tChevronsLeftIcon,\n\tChevronsRightIcon,\n\tDownloadIcon,\n\tTrash2Icon,\n} from \"lucide-react\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\nimport { useToast } from \"@/components/ui/use-toast\"\nimport {\n\tAlertDialog,\n\tAlertDialogAction,\n\tAlertDialogCancel,\n\tAlertDialogContent,\n\tAlertDialogDescription,\n\tAlertDialogFooter,\n\tAlertDialogHeader,\n\tAlertDialogTitle,\n\tAlertDialogTrigger,\n} from \"@/components/ui/alert-dialog\"\n", "n_tokens": 146, "primary_symbol": "", "primary_kind": "", "primary_span": [23, 46], "def_symbols": [], "symbols": ["import", "Select", "SelectTrigger", "SelectValue", "SelectContent", "SelectItem", "from", "components", "select", "ChevronLeftIcon", "ChevronRightIcon", "ChevronsLeftIcon", "ChevronsRightIcon", "DownloadIcon", "Trash2Icon", "lucide", "react", "Trans", "lingui", "macro", "core", "useToast", "use", "toast", "AlertDialog", "AlertDialogAction", "AlertDialogCancel", "AlertDialogContent", "AlertDialogDescription", "AlertDialogFooter", "AlertDialogHeader", "AlertDialogTitle", "AlertDialogTrigger", "alert", "dialog"], "doc_head": "import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from \"@/components/ui/select\"\nimport {\n\tChevronLeftIcon,\n\tChevronRightIcon,\n\tChevronsLeftIcon,\n\tChevronsRightIcon,\n\tDownloadIcon,\n\tTrash2Icon,\n} from \"lucide-react\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\nimport { useToast } from \"@/components/ui/use-toast\"\nimport {\n\tAlertDialog,\n\tAlertDialogAction,\n\tAlertDialogCancel,\n\tAlertDialogContent,\n\tAlertDialogDescription,\n\tAlertDialogFooter,\n\tAlertDialogHeader,\n\tAlertDialogTitle,\n\tAlertDialogTrigger,\n} from \"@/components/ui/alert-dialog\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 47, "end_line": 59, "text": "const SectionIntro = memo(() => {\n\treturn (\n\t\t<div>\n\t\t\t<h3 className=\"text-xl font-medium mb-2\">\n\t\t\t\t<Trans>Alert History</Trans>\n\t\t\t</h3>\n\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t<Trans>View your 200 most recent alerts.</Trans>\n\t\t\t</p>\n\t\t</div>\n\t)\n})\n", "n_tokens": 87, "primary_symbol": "", "primary_kind": "", "primary_span": [47, 59], "def_symbols": [], "symbols": ["const", "SectionIntro", "memo", "return", "div", "className", "text", "font", "medium", "Trans", "Alert", "History", "muted", "foreground", "leading", "relaxed", "View", "your", "most", "recent", "alerts"], "doc_head": "const SectionIntro = memo(() => {\n\treturn (\n\t\t<div>\n\t\t\t<h3 className=\"text-xl font-medium mb-2\">\n\t\t\t\t<Trans>Alert History</Trans>\n\t\t\t</h3>\n\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t<Trans>View your 200 most recent alerts.</Trans>\n\t\t\t</p>\n\t\t</div>\n\t)\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 60, "end_line": 69, "text": "export default function AlertsHistoryDataTable() {\n\tconst [data, setData] = useState<AlertsHistoryRecord[]>([])\n\tconst [sorting, setSorting] = useState<SortingState>([])\n\tconst [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([])\n\tconst [columnVisibility, setColumnVisibility] = useState<VisibilityState>({})\n\tconst [rowSelection, setRowSelection] = useState({})\n\tconst [globalFilter, setGlobalFilter] = useState(\"\")\n\tconst { toast } = useToast()\n\tconst [deleteOpen, setDeleteDialogOpen] = useState(false)\n", "n_tokens": 116, "primary_symbol": "", "primary_kind": "", "primary_span": [60, 69], "def_symbols": [], "symbols": ["export", "default", "function", "AlertsHistoryDataTable", "const", "data", "setData", "useState", "AlertsHistoryRecord", "sorting", "setSorting", "SortingState", "columnFilters", "setColumnFilters", "ColumnFiltersState", "columnVisibility", "setColumnVisibility", "VisibilityState", "rowSelection", "setRowSelection", "globalFilter", "setGlobalFilter", "toast", "useToast", "deleteOpen", "setDeleteDialogOpen", "false"], "doc_head": "export default function AlertsHistoryDataTable() {\n\tconst [data, setData] = useState<AlertsHistoryRecord[]>([])\n\tconst [sorting, setSorting] = useState<SortingState>([])\n\tconst [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([])\n\tconst [columnVisibility, setColumnVisibility] = useState<VisibilityState>({})\n\tconst [rowSelection, setRowSelection] = useState({})\n\tconst [globalFilter, setGlobalFilter] = useState(\"\")\n\tconst { toast } = useToast()\n\tconst [deleteOpen, setDeleteDialogOpen] = useState(false)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 70, "end_line": 92, "text": "\tuseEffect(() => {\n\t\tlet unsubscribe: (() => void) | undefined\n\t\tconst pbOptions = {\n\t\t\texpand: \"system\",\n\t\t\tfields: \"id,name,value,state,created,resolved,expand.system.name\",\n\t\t}\n\t\t// Initial load\n\t\tpb.collection<AlertsHistoryRecord>(\"alerts_history\")\n\t\t\t.getList(0, 200, {\n\t\t\t\t...pbOptions,\n\t\t\t\tsort: \"-created\",\n\t\t\t})\n\t\t\t.then(({ items }) => setData(items))\n\n\t\t// Subscribe to changes\n\t\t;(async () => {\n\t\t\tunsubscribe = await pb.collection(\"alerts_history\").subscribe(\n\t\t\t\t\"*\",\n\t\t\t\t(e) => {\n\t\t\t\t\tif (e.action === \"create\") {\n\t\t\t\t\t\tsetData((current) => [e.record as AlertsHistoryRecord, ...current])\n\t\t\t\t\t}\n\t\t\t\t\tif (e.action === \"update\") {", "n_tokens": 181, "primary_symbol": "", "primary_kind": "", "primary_span": [70, 92], "def_symbols": [], "symbols": ["useEffect", "let", "unsubscribe", "void", "undefined", "const", "pbOptions", "expand", "system", "fields", "name", "value", "state", "created", "resolved", "Initial", "load", "collection", "AlertsHistoryRecord", "alerts_history", "getList", "sort", "then", "items", "setData", "Subscribe", "changes", "async", "await", "subscribe", "action", "create", "current", "record", "update"], "doc_head": "\tuseEffect(() => {\n\t\tlet unsubscribe: (() => void) | undefined\n\t\tconst pbOptions = {\n\t\t\texpand: \"system\",\n\t\t\tfields: \"id,name,value,state,created,resolved,expand.system.name\",\n\t\t}\n\t\t// Initial load\n\t\tpb.collection<AlertsHistoryRecord>(\"alerts_history\")\n\t\t\t.getList(0, 200, {\n\t\t\t\t...pbOptions,\n\t\t\t\tsort: \"-created\",\n\t\t\t})\n\t\t\t.then(({ items }) => setData(items))\n\t\t// Subscribe to changes\n\t\t;(async () => {\n\t\t\tunsubscribe = await pb.collection(\"alerts_history\").subscribe(\n\t\t\t\t\"*\",\n\t\t\t\t(e) => {\n\t\t\t\t\tif (e.action === \"create\") {\n\t\t\t\t\t\tsetData((current) => [e.record as AlertsHistoryRecord, ...current])\n\t\t\t\t\t}\n\t\t\t\t\tif (e.action === \"update\") {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 93, "end_line": 114, "text": "\t\t\t\t\t\tsetData((current) => current.map((r) => (r.id === e.record.id ? (e.record as AlertsHistoryRecord) : r)))\n\t\t\t\t\t}\n\t\t\t\t\tif (e.action === \"delete\") {\n\t\t\t\t\t\tsetData((current) => current.filter((r) => r.id !== e.record.id))\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tpbOptions\n\t\t\t)\n\t\t})()\n\t\t// Unsubscribe on unmount\n\t\treturn () => unsubscribe?.()\n\t}, [])\n\n\tconst table = useReactTable({\n\t\tdata,\n\t\tcolumns: [\n\t\t\t{\n\t\t\t\tid: \"select\",\n\t\t\t\theader: ({ table }) => (\n\t\t\t\t\t<Checkbox\n\t\t\t\t\t\tclassName=\"ms-2\"\n\t\t\t\t\t\tchecked={table.getIsAllPageRowsSelected() || (table.getIsSomePageRowsSelected() && \"indeterminate\")}", "n_tokens": 173, "primary_symbol": "", "primary_kind": "", "primary_span": [93, 114], "def_symbols": [], "symbols": ["setData", "current", "map", "record", "AlertsHistoryRecord", "action", "delete", "filter", "pbOptions", "Unsubscribe", "unmount", "return", "unsubscribe", "const", "table", "useReactTable", "data", "columns", "select", "header", "Checkbox", "className", "checked", "getIsAllPageRowsSelected", "getIsSomePageRowsSelected", "indeterminate"], "doc_head": "\t\t\t\t\t\tsetData((current) => current.map((r) => (r.id === e.record.id ? (e.record as AlertsHistoryRecord) : r)))\n\t\t\t\t\t}\n\t\t\t\t\tif (e.action === \"delete\") {\n\t\t\t\t\t\tsetData((current) => current.filter((r) => r.id !== e.record.id))\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tpbOptions\n\t\t\t)\n\t\t})()\n\t\t// Unsubscribe on unmount\n\t\treturn () => unsubscribe?.()\n\t}, [])\n\tconst table = useReactTable({\n\t\tdata,\n\t\tcolumns: [\n\t\t\t{\n\t\t\t\tid: \"select\",\n\t\t\t\theader: ({ table }) => (\n\t\t\t\t\t<Checkbox\n\t\t\t\t\t\tclassName=\"ms-2\"\n\t\t\t\t\t\tchecked={table.getIsAllPageRowsSelected() || (table.getIsSomePageRowsSelected() && \"indeterminate\")}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 115, "end_line": 121, "text": "\t\t\t\t\t\tonCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}\n\t\t\t\t\t\taria-label=\"Select all\"\n\t\t\t\t\t/>\n\t\t\t\t),\n\t\t\t\tcell: ({ row }) => (\n\t\t\t\t\t<Checkbox\n\t\t\t\t\t\tchecked={row.getIsSelected()}", "n_tokens": 54, "primary_symbol": "", "primary_kind": "", "primary_span": [115, 121], "def_symbols": [], "symbols": ["onCheckedChange", "value", "table", "toggleAllPageRowsSelected", "aria", "label", "Select", "all", "cell", "row", "Checkbox", "checked", "getIsSelected"], "doc_head": "\t\t\t\t\t\tonCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}\n\t\t\t\t\t\taria-label=\"Select all\"\n\t\t\t\t\t/>\n\t\t\t\t),\n\t\t\t\tcell: ({ row }) => (\n\t\t\t\t\t<Checkbox\n\t\t\t\t\t\tchecked={row.getIsSelected()}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 122, "end_line": 146, "text": "\t\t\t\t\t\tonCheckedChange={(value) => row.toggleSelected(!!value)}\n\t\t\t\t\t\taria-label=\"Select row\"\n\t\t\t\t\t/>\n\t\t\t\t),\n\t\t\t\tenableSorting: false,\n\t\t\t\tenableHiding: false,\n\t\t\t},\n\t\t\t...alertsHistoryColumns,\n\t\t],\n\t\tgetCoreRowModel: getCoreRowModel(),\n\t\tgetPaginationRowModel: getPaginationRowModel(),\n\t\tgetSortedRowModel: getSortedRowModel(),\n\t\tgetFilteredRowModel: getFilteredRowModel(),\n\t\tonSortingChange: setSorting,\n\t\tonColumnFiltersChange: setColumnFilters,\n\t\tonColumnVisibilityChange: setColumnVisibility,\n\t\tonRowSelectionChange: setRowSelection,\n\t\tstate: {\n\t\t\tsorting,\n\t\t\tcolumnFilters,\n\t\t\tcolumnVisibility,\n\t\t\trowSelection,\n\t\t\tglobalFilter,\n\t\t},\n\t\tonGlobalFilterChange: setGlobalFilter,", "n_tokens": 176, "primary_symbol": "", "primary_kind": "", "primary_span": [122, 146], "def_symbols": [], "symbols": ["onCheckedChange", "value", "row", "toggleSelected", "aria", "label", "Select", "enableSorting", "false", "enableHiding", "alertsHistoryColumns", "getCoreRowModel", "getPaginationRowModel", "getSortedRowModel", "getFilteredRowModel", "onSortingChange", "setSorting", "onColumnFiltersChange", "setColumnFilters", "onColumnVisibilityChange", "setColumnVisibility", "onRowSelectionChange", "setRowSelection", "state", "sorting", "columnFilters", "columnVisibility", "rowSelection", "globalFilter", "onGlobalFilterChange", "setGlobalFilter"], "doc_head": "\t\t\t\t\t\tonCheckedChange={(value) => row.toggleSelected(!!value)}\n\t\t\t\t\t\taria-label=\"Select row\"\n\t\t\t\t\t/>\n\t\t\t\t),\n\t\t\t\tenableSorting: false,\n\t\t\t\tenableHiding: false,\n\t\t\t},\n\t\t\t...alertsHistoryColumns,\n\t\t],\n\t\tgetCoreRowModel: getCoreRowModel(),\n\t\tgetPaginationRowModel: getPaginationRowModel(),\n\t\tgetSortedRowModel: getSortedRowModel(),\n\t\tgetFilteredRowModel: getFilteredRowModel(),\n\t\tonSortingChange: setSorting,\n\t\tonColumnFiltersChange: setColumnFilters,\n\t\tonColumnVisibilityChange: setColumnVisibility,\n\t\tonRowSelectionChange: setRowSelection,\n\t\tstate: {\n\t\t\tsorting,\n\t\t\tcolumnFilters,\n\t\t\tcolumnVisibility,\n\t\t\trowSelection,\n\t\t\tglobalFilter,\n\t\t},\n\t\tonGlobalFilterChange: setGlobalFilter,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 147, "end_line": 169, "text": "\t\tglobalFilterFn: (row, _columnId, filterValue) => {\n\t\t\tconst system = row.original.expand?.system?.name ?? \"\"\n\t\t\tconst name = row.getValue(\"name\") ?? \"\"\n\t\t\tconst created = row.getValue(\"created\") ?? \"\"\n\t\t\tconst search = String(filterValue).toLowerCase()\n\t\t\treturn (\n\t\t\t\tsystem.toLowerCase().includes(search) ||\n\t\t\t\t(name as string).toLowerCase().includes(search) ||\n\t\t\t\t(created as string).toLowerCase().includes(search)\n\t\t\t)\n\t\t},\n\t})\n\n\t// Bulk delete handler\n\tconst handleBulkDelete = async () => {\n\t\tsetDeleteDialogOpen(false)\n\t\tconst selectedIds = table.getSelectedRowModel().rows.map((row) => row.original.id)\n\t\ttry {\n\t\t\tlet batch = pb.createBatch()\n\t\t\tlet inBatch = 0\n\t\t\tfor (const id of selectedIds) {\n\t\t\t\tbatch.collection(\"alerts_history\").delete(id)\n\t\t\t\tinBatch++", "n_tokens": 190, "primary_symbol": "handleBulkDelete", "primary_kind": "function", "primary_span": [147, 169], "def_symbols": ["handleBulkDelete"], "symbols": ["handleBulkDelete", "globalFilterFn", "row", "_columnId", "filterValue", "const", "system", "original", "expand", "name", "getValue", "created", "search", "String", "toLowerCase", "return", "includes", "string", "Bulk", "delete", "handler", "async", "setDeleteDialogOpen", "false", "selectedIds", "table", "getSelectedRowModel", "rows", "map", "try", "let", "batch", "createBatch", "inBatch", "for", "collection", "alerts_history"], "doc_head": "\t\tglobalFilterFn: (row, _columnId, filterValue) => {\n\t\t\tconst system = row.original.expand?.system?.name ?? \"\"\n\t\t\tconst name = row.getValue(\"name\") ?? \"\"\n\t\t\tconst created = row.getValue(\"created\") ?? \"\"\n\t\t\tconst search = String(filterValue).toLowerCase()\n\t\t\treturn (\n\t\t\t\tsystem.toLowerCase().includes(search) ||\n\t\t\t\t(name as string).toLowerCase().includes(search) ||\n\t\t\t\t(created as string).toLowerCase().includes(search)\n\t\t\t)\n\t\t},\n\t})\n\t// Bulk delete handler\n\tconst handleBulkDelete = async () => {\n\t\tsetDeleteDialogOpen(false)\n\t\tconst selectedIds = table.getSelectedRowModel().rows.map((row) => row.original.id)\n\t\ttry {\n\t\t\tlet batch = pb.createBatch()\n\t\t\tlet inBatch = 0\n\t\t\tfor (const id of selectedIds) {\n\t\t\t\tbatch.collection(\"alerts_history\").delete(id)\n\t\t\t\tinBatch++"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 170, "end_line": 193, "text": "\t\t\t\tif (inBatch > 20) {\n\t\t\t\t\tawait batch.send()\n\t\t\t\t\tbatch = pb.createBatch()\n\t\t\t\t\tinBatch = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tinBatch && (await batch.send())\n\t\t\ttable.resetRowSelection()\n\t\t} catch (e) {\n\t\t\ttoast({\n\t\t\t\tvariant: \"destructive\",\n\t\t\t\ttitle: t`Error`,\n\t\t\t\tdescription: `Failed to delete records.`,\n\t\t\t})\n\t\t}\n\t}\n\n\t// Export to CSV handler\n\tconst handleExportCSV = () => {\n\t\tconst selectedRows = table.getSelectedRowModel().rows\n\t\tif (!selectedRows.length) return\n\t\tconst cells: Record<string, (record: AlertsHistoryRecord) => string> = {\n\t\t\tsystem: (record) => record.expand?.system?.name || record.system,\n\t\t\tname: (record) => alertInfo[record.name]?.name() || record.name,", "n_tokens": 186, "primary_symbol": "handleExportCSV", "primary_kind": "function", "primary_span": [170, 193], "def_symbols": ["handleExportCSV"], "symbols": ["handleExportCSV", "inBatch", "await", "batch", "send", "createBatch", "table", "resetRowSelection", "catch", "toast", "variant", "destructive", "title", "Error", "description", "Failed", "delete", "records", "Export", "CSV", "handler", "const", "selectedRows", "getSelectedRowModel", "rows", "length", "return", "cells", "Record", "string", "record", "AlertsHistoryRecord", "system", "expand", "name", "alertInfo"], "doc_head": "\t\t\t\tif (inBatch > 20) {\n\t\t\t\t\tawait batch.send()\n\t\t\t\t\tbatch = pb.createBatch()\n\t\t\t\t\tinBatch = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tinBatch && (await batch.send())\n\t\t\ttable.resetRowSelection()\n\t\t} catch (e) {\n\t\t\ttoast({\n\t\t\t\tvariant: \"destructive\",\n\t\t\t\ttitle: t`Error`,\n\t\t\t\tdescription: `Failed to delete records.`,\n\t\t\t})\n\t\t}\n\t}\n\t// Export to CSV handler\n\tconst handleExportCSV = () => {\n\t\tconst selectedRows = table.getSelectedRowModel().rows\n\t\tif (!selectedRows.length) return\n\t\tconst cells: Record<string, (record: AlertsHistoryRecord) => string> = {\n\t\t\tsystem: (record) => record.expand?.system?.name || record.system,\n\t\t\tname: (record) => alertInfo[record.name]?.name() || record.name,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 11, "start_line": 194, "end_line": 204, "text": "\t\t\tvalue: (record) => record.value + (alertInfo[record.name]?.unit ?? \"\"),\n\t\t\tstate: (record) => (record.resolved ? t`Resolved` : t`Active`),\n\t\t\tcreated: (record) => formatShortDate(record.created),\n\t\t\tresolved: (record) => (record.resolved ? formatShortDate(record.resolved) : \"\"),\n\t\t\tduration: (record) => (record.resolved ? formatDuration(record.created, record.resolved) : \"\"),\n\t\t}\n\t\tconst csvRows = [Object.keys(cells).join(\",\")]\n\t\tfor (const row of selectedRows) {\n\t\t\tconst r = row.original\n\t\t\tcsvRows.push(\n\t\t\t\tObject.values(cells)", "n_tokens": 144, "primary_symbol": "", "primary_kind": "", "primary_span": [194, 204], "def_symbols": [], "symbols": ["value", "record", "alertInfo", "name", "unit", "state", "resolved", "Resolved", "Active", "created", "formatShortDate", "duration", "formatDuration", "const", "csvRows", "Object", "keys", "cells", "join", "for", "row", "selectedRows", "original", "push", "values"], "doc_head": "\t\t\tvalue: (record) => record.value + (alertInfo[record.name]?.unit ?? \"\"),\n\t\t\tstate: (record) => (record.resolved ? t`Resolved` : t`Active`),\n\t\t\tcreated: (record) => formatShortDate(record.created),\n\t\t\tresolved: (record) => (record.resolved ? formatShortDate(record.resolved) : \"\"),\n\t\t\tduration: (record) => (record.resolved ? formatDuration(record.created, record.resolved) : \"\"),\n\t\t}\n\t\tconst csvRows = [Object.keys(cells).join(\",\")]\n\t\tfor (const row of selectedRows) {\n\t\t\tconst r = row.original\n\t\t\tcsvRows.push(\n\t\t\t\tObject.values(cells)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 12, "start_line": 205, "end_line": 224, "text": "\t\t\t\t\t.map((val) => val(r))\n\t\t\t\t\t.join(\",\")\n\t\t\t)\n\t\t}\n\t\tconst blob = new Blob([csvRows.join(\"\\n\")], { type: \"text/csv\" })\n\t\tconst url = URL.createObjectURL(blob)\n\t\tconst a = document.createElement(\"a\")\n\t\ta.href = url\n\t\ta.download = \"alerts_history.csv\"\n\t\ta.click()\n\t\tURL.revokeObjectURL(url)\n\t}\n\n\treturn (\n\t\t<div className=\"@container w-full\">\n\t\t\t<div className=\"@3xl:flex items-end mb-4 gap-4\">\n\t\t\t\t<SectionIntro />\n\t\t\t\t<div className=\"flex items-center gap-2 ms-auto mt-3 @3xl:mt-0\">\n\t\t\t\t\t{table.getFilteredSelectedRowModel().rows.length > 0 && (\n\t\t\t\t\t\t<div className=\"fixed bottom-0 left-0 w-full p-4 grid grid-cols-2 items-center gap-4 z-50 backdrop-blur-md shrink-0 @lg:static @lg:p-0 @lg:w-auto @lg:gap-3\">", "n_tokens": 221, "primary_symbol": "", "primary_kind": "", "primary_span": [205, 224], "def_symbols": [], "symbols": ["map", "val", "join", "const", "blob", "new", "Blob", "csvRows", "type", "text", "csv", "url", "URL", "createObjectURL", "document", "createElement", "href", "download", "alerts_history", "click", "revokeObjectURL", "return", "div", "className", "container", "full", "flex", "items", "end", "gap", "SectionIntro", "center", "auto", "table", "getFilteredSelectedRowModel", "rows", "length", "fixed", "bottom", "left", "grid", "cols", "backdrop", "blur", "shrink", "static"], "doc_head": "\t\t\t\t\t.map((val) => val(r))\n\t\t\t\t\t.join(\",\")\n\t\t\t)\n\t\t}\n\t\tconst blob = new Blob([csvRows.join(\"\\n\")], { type: \"text/csv\" })\n\t\tconst url = URL.createObjectURL(blob)\n\t\tconst a = document.createElement(\"a\")\n\t\ta.href = url\n\t\ta.download = \"alerts_history.csv\"\n\t\ta.click()\n\t\tURL.revokeObjectURL(url)\n\t}\n\treturn (\n\t\t<div className=\"@container w-full\">\n\t\t\t<div className=\"@3xl:flex items-end mb-4 gap-4\">\n\t\t\t\t<SectionIntro />\n\t\t\t\t<div className=\"flex items-center gap-2 ms-auto mt-3 @3xl:mt-0\">\n\t\t\t\t\t{table.getFilteredSelectedRowModel().rows.length > 0 && (\n\t\t\t\t\t\t<div className=\"fixed bottom-0 left-0 w-full p-4 grid grid-cols-2 items-center gap-4 z-50 backdrop-blur-md shrink-0 @lg:static @lg:p-0 @lg:w-auto @lg:gap-3\">"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 13, "start_line": 225, "end_line": 266, "text": "\t\t\t\t\t\t\t<AlertDialog open={deleteOpen} onOpenChange={(open) => setDeleteDialogOpen(open)}>\n\t\t\t\t\t\t\t\t<AlertDialogTrigger asChild>\n\t\t\t\t\t\t\t\t\t<Button variant=\"destructive\" className=\"h-9 shrink-0\">\n\t\t\t\t\t\t\t\t\t\t<Trash2Icon className=\"size-4 shrink-0\" />\n\t\t\t\t\t\t\t\t\t\t<span className=\"ms-1\">\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Delete</Trans>\n\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t</AlertDialogTrigger>\n\t\t\t\t\t\t\t\t<AlertDialogContent>\n\t\t\t\t\t\t\t\t\t<AlertDialogHeader>\n\t\t\t\t\t\t\t\t\t\t<AlertDialogTitle>\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Are you sure?</Trans>\n\t\t\t\t\t\t\t\t\t\t</AlertDialogTitle>\n\t\t\t\t\t\t\t\t\t\t<AlertDialogDescription>\n\t\t\t\t\t\t\t\t\t\t\t<Trans>This will permanently delete all selected records from the database.</Trans>\n\t\t\t\t\t\t\t\t\t\t</AlertDialogDescription>\n\t\t\t\t\t\t\t\t\t</AlertDialogHeader>\n\t\t\t\t\t\t\t\t\t<AlertDialogFooter>\n\t\t\t\t\t\t\t\t\t\t<AlertDialogCancel>\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Cancel</Trans>\n\t\t\t\t\t\t\t\t\t\t</AlertDialogCancel>\n\t\t\t\t\t\t\t\t\t\t<AlertDialogAction\n\t\t\t\t\t\t\t\t\t\t\tclassName={cn(buttonVariants({ variant: \"destructive\" }))}\n\t\t\t\t\t\t\t\t\t\t\tonClick={handleBulkDelete}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Continue</Trans>\n\t\t\t\t\t\t\t\t\t\t</AlertDialogAction>\n\t\t\t\t\t\t\t\t\t</AlertDialogFooter>\n\t\t\t\t\t\t\t\t</AlertDialogContent>\n\t\t\t\t\t\t\t</AlertDialog>\n\t\t\t\t\t\t\t<Button variant=\"outline\" className=\"h-10\" onClick={handleExportCSV}>\n\t\t\t\t\t\t\t\t<DownloadIcon className=\"size-4\" />\n\t\t\t\t\t\t\t\t<span className=\"ms-1\">\n\t\t\t\t\t\t\t\t\t<Trans>Export</Trans>\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t\t<Input\n\t\t\t\t\t\tplaceholder={t`Filter...`}\n\t\t\t\t\t\tvalue={globalFilter}", "n_tokens": 342, "primary_symbol": "", "primary_kind": "", "primary_span": [225, 266], "def_symbols": [], "symbols": ["AlertDialog", "open", "deleteOpen", "onOpenChange", "setDeleteDialogOpen", "AlertDialogTrigger", "asChild", "Button", "variant", "destructive", "className", "shrink", "Trash2Icon", "size", "span", "Trans", "Delete", "AlertDialogContent", "AlertDialogHeader", "AlertDialogTitle", "Are", "you", "sure", "AlertDialogDescription", "This", "will", "permanently", "delete", "all", "selected", "records", "from", "the", "database", "AlertDialogFooter", "AlertDialogCancel", "Cancel", "AlertDialogAction", "buttonVariants", "onClick", "handleBulkDelete", "Continue", "outline", "handleExportCSV", "DownloadIcon", "Export", "div", "Input", "placeholder", "Filter", "value", "globalFilter"], "doc_head": "\t\t\t\t\t\t\t<AlertDialog open={deleteOpen} onOpenChange={(open) => setDeleteDialogOpen(open)}>\n\t\t\t\t\t\t\t\t<AlertDialogTrigger asChild>\n\t\t\t\t\t\t\t\t\t<Button variant=\"destructive\" className=\"h-9 shrink-0\">\n\t\t\t\t\t\t\t\t\t\t<Trash2Icon className=\"size-4 shrink-0\" />\n\t\t\t\t\t\t\t\t\t\t<span className=\"ms-1\">\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Delete</Trans>\n\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t</AlertDialogTrigger>\n\t\t\t\t\t\t\t\t<AlertDialogContent>\n\t\t\t\t\t\t\t\t\t<AlertDialogHeader>\n\t\t\t\t\t\t\t\t\t\t<AlertDialogTitle>\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Are you sure?</Trans>\n\t\t\t\t\t\t\t\t\t\t</AlertDialogTitle>\n\t\t\t\t\t\t\t\t\t\t<AlertDialogDescription>\n\t\t\t\t\t\t\t\t\t\t\t<Trans>This will permanently delete all selected records from the database.</Trans>\n\t\t\t\t\t\t\t\t\t\t</AlertDialogDescription>\n\t\t\t\t\t\t\t\t\t</AlertDialogHeader>\n\t\t\t\t\t\t\t\t\t<AlertDialogFooter>\n\t\t\t\t\t\t\t\t\t\t<AlertDialogCancel>\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Cancel</Trans>\n\t\t\t\t\t\t\t\t\t\t</AlertDialogCancel>\n\t\t\t\t\t\t\t\t\t\t<AlertDialogAction\n\t\t\t\t\t\t\t\t\t\t\tclassName={cn(buttonVariants({ variant: \"destructive\" }))}\n\t\t\t\t\t\t\t\t\t\t\tonClick={handleBulkDelete}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<Trans>Continue</Trans>\n\t\t\t\t\t\t\t\t\t\t</AlertDialogAction>\n\t\t\t\t\t\t\t\t\t</AlertDialogFooter>\n\t\t\t\t\t\t\t\t</AlertDialogContent>\n\t\t\t\t\t\t\t</AlertDialog>\n\t\t\t\t\t\t\t<Button variant=\"outline\" className=\"h-10"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 14, "start_line": 267, "end_line": 286, "text": "\t\t\t\t\t\tonChange={(e) => setGlobalFilter(e.target.value)}\n\t\t\t\t\t\tclassName=\"px-4 w-full max-w-full @3xl:w-64\"\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div className=\"rounded-md border overflow-x-auto whitespace-nowrap\">\n\t\t\t\t<Table>\n\t\t\t\t\t<TableHeader>\n\t\t\t\t\t\t{table.getHeaderGroups().map((headerGroup) => (\n\t\t\t\t\t\t\t<tr key={headerGroup.id} className=\"border-border/50\">\n\t\t\t\t\t\t\t\t{headerGroup.headers.map((header) => (\n\t\t\t\t\t\t\t\t\t<TableHead className=\"px-2\" key={header.id}>\n\t\t\t\t\t\t\t\t\t\t{header.isPlaceholder ? null : flexRender(header.column.columnDef.header, header.getContext())}\n\t\t\t\t\t\t\t\t\t</TableHead>\n\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</TableHeader>\n\t\t\t\t\t<TableBody>\n\t\t\t\t\t\t{table.getRowModel().rows.length ? (", "n_tokens": 189, "primary_symbol": "", "primary_kind": "", "primary_span": [267, 286], "def_symbols": [], "symbols": ["onChange", "setGlobalFilter", "target", "value", "className", "full", "max", "div", "rounded", "border", "overflow", "auto", "whitespace", "nowrap", "Table", "TableHeader", "table", "getHeaderGroups", "map", "headerGroup", "key", "headers", "header", "TableHead", "isPlaceholder", "null", "flexRender", "column", "columnDef", "getContext", "TableBody", "getRowModel", "rows", "length"], "doc_head": "\t\t\t\t\t\tonChange={(e) => setGlobalFilter(e.target.value)}\n\t\t\t\t\t\tclassName=\"px-4 w-full max-w-full @3xl:w-64\"\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div className=\"rounded-md border overflow-x-auto whitespace-nowrap\">\n\t\t\t\t<Table>\n\t\t\t\t\t<TableHeader>\n\t\t\t\t\t\t{table.getHeaderGroups().map((headerGroup) => (\n\t\t\t\t\t\t\t<tr key={headerGroup.id} className=\"border-border/50\">\n\t\t\t\t\t\t\t\t{headerGroup.headers.map((header) => (\n\t\t\t\t\t\t\t\t\t<TableHead className=\"px-2\" key={header.id}>\n\t\t\t\t\t\t\t\t\t\t{header.isPlaceholder ? null : flexRender(header.column.columnDef.header, header.getContext())}\n\t\t\t\t\t\t\t\t\t</TableHead>\n\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</TableHeader>\n\t\t\t\t\t<TableBody>\n\t\t\t\t\t\t{table.getRowModel().rows.length ? ("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 15, "start_line": 287, "end_line": 288, "text": "\t\t\t\t\t\t\ttable.getRowModel().rows.map((row) => (\n\t\t\t\t\t\t\t\t<TableRow key={row.id} data-state={row.getIsSelected() && \"selected\"}>", "n_tokens": 34, "primary_symbol": "", "primary_kind": "", "primary_span": [287, 288], "def_symbols": [], "symbols": ["table", "getRowModel", "rows", "map", "row", "TableRow", "key", "data", "state", "getIsSelected", "selected"], "doc_head": "\t\t\t\t\t\t\ttable.getRowModel().rows.map((row) => (\n\t\t\t\t\t\t\t\t<TableRow key={row.id} data-state={row.getIsSelected() && \"selected\"}>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#16", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 16, "start_line": 289, "end_line": 319, "text": "\t\t\t\t\t\t\t\t\t{row.getVisibleCells().map((cell) => (\n\t\t\t\t\t\t\t\t\t\t<TableCell key={cell.id} className=\"py-3\">\n\t\t\t\t\t\t\t\t\t\t\t{flexRender(cell.column.columnDef.cell, cell.getContext())}\n\t\t\t\t\t\t\t\t\t\t</TableCell>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</TableRow>\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<TableRow>\n\t\t\t\t\t\t\t\t<TableCell colSpan={table.getAllColumns().length} className=\"h-24 text-center\">\n\t\t\t\t\t\t\t\t\t<Trans>No results.</Trans>\n\t\t\t\t\t\t\t\t</TableCell>\n\t\t\t\t\t\t\t</TableRow>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</TableBody>\n\t\t\t\t</Table>\n\t\t\t</div>\n\t\t\t<div className=\"flex items-center justify-between ps-1 tabular-nums\">\n\t\t\t\t<div className=\"text-muted-foreground hidden flex-1 text-sm lg:flex\">\n\t\t\t\t\t<Trans>\n\t\t\t\t\t\t{table.getFilteredSelectedRowModel().rows.length} of {table.getFilteredRowModel().rows.length} row(s)\n\t\t\t\t\t\tselected.\n\t\t\t\t\t</Trans>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"flex w-full items-center gap-8 lg:w-fit my-3\">\n\t\t\t\t\t<div className=\"hidden items-center gap-2 lg:flex\">\n\t\t\t\t\t\t<Label htmlFor=\"rows-per-page\" className=\"text-sm font-medium\">\n\t\t\t\t\t\t\t<Trans>Rows per page</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<Select\n\t\t\t\t\t\t\tvalue={`${table.getState().pagination.pageSize}`}", "n_tokens": 290, "primary_symbol": "", "primary_kind": "", "primary_span": [289, 319], "def_symbols": [], "symbols": ["row", "getVisibleCells", "map", "cell", "TableCell", "key", "className", "flexRender", "column", "columnDef", "getContext", "TableRow", "colSpan", "table", "getAllColumns", "length", "text", "center", "Trans", "results", "TableBody", "Table", "div", "flex", "items", "justify", "between", "tabular", "nums", "muted", "foreground", "hidden", "getFilteredSelectedRowModel", "rows", "getFilteredRowModel", "selected", "full", "gap", "fit", "Label", "htmlFor", "per", "page", "font", "medium", "Rows", "Select", "value", "getState", "pagination", "pageSize"], "doc_head": "\t\t\t\t\t\t\t\t\t{row.getVisibleCells().map((cell) => (\n\t\t\t\t\t\t\t\t\t\t<TableCell key={cell.id} className=\"py-3\">\n\t\t\t\t\t\t\t\t\t\t\t{flexRender(cell.column.columnDef.cell, cell.getContext())}\n\t\t\t\t\t\t\t\t\t\t</TableCell>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</TableRow>\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<TableRow>\n\t\t\t\t\t\t\t\t<TableCell colSpan={table.getAllColumns().length} className=\"h-24 text-center\">\n\t\t\t\t\t\t\t\t\t<Trans>No results.</Trans>\n\t\t\t\t\t\t\t\t</TableCell>\n\t\t\t\t\t\t\t</TableRow>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</TableBody>\n\t\t\t\t</Table>\n\t\t\t</div>\n\t\t\t<div className=\"flex items-center justify-between ps-1 tabular-nums\">\n\t\t\t\t<div className=\"text-muted-foreground hidden flex-1 text-sm lg:flex\">\n\t\t\t\t\t<Trans>\n\t\t\t\t\t\t{table.getFilteredSelectedRowModel().rows.length} of {table.getFilteredRowModel().rows.length} row(s)\n\t\t\t\t\t\tselected.\n\t\t\t\t\t</Trans>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"flex w-full items-center gap-8 lg:w-fit my-3\">\n\t\t\t\t\t<div className=\"hidden items-center gap-2 lg:flex\">\n\t\t\t\t\t\t<Label htmlFor=\"rows-per-page\" className=\"text-sm font-medium\">\n\t\t\t\t\t\t\t<Trans>Rows per page</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<Select\n\t\t\t\t\t\t\tvalue={`${table.getState().pagination.pageSize}`}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#17", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 17, "start_line": 320, "end_line": 327, "text": "\t\t\t\t\t\t\tonValueChange={(value) => {\n\t\t\t\t\t\t\t\ttable.setPageSize(Number(value))\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<SelectTrigger className=\"w-[4.8em]\" id=\"rows-per-page\">\n\t\t\t\t\t\t\t\t<SelectValue placeholder={table.getState().pagination.pageSize} />\n\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t<SelectContent side=\"top\">", "n_tokens": 68, "primary_symbol": "", "primary_kind": "", "primary_span": [320, 327], "def_symbols": [], "symbols": ["onValueChange", "value", "table", "setPageSize", "Number", "SelectTrigger", "className", "rows", "per", "page", "SelectValue", "placeholder", "getState", "pagination", "pageSize", "SelectContent", "side", "top"], "doc_head": "\t\t\t\t\t\t\tonValueChange={(value) => {\n\t\t\t\t\t\t\t\ttable.setPageSize(Number(value))\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<SelectTrigger className=\"w-[4.8em]\" id=\"rows-per-page\">\n\t\t\t\t\t\t\t\t<SelectValue placeholder={table.getState().pagination.pageSize} />\n\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t<SelectContent side=\"top\">"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#18", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 18, "start_line": 328, "end_line": 344, "text": "\t\t\t\t\t\t\t\t{[10, 20, 50, 100, 200].map((pageSize) => (\n\t\t\t\t\t\t\t\t\t<SelectItem key={pageSize} value={`${pageSize}`}>\n\t\t\t\t\t\t\t\t\t\t{pageSize}\n\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t</Select>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"flex w-fit items-center justify-center text-sm font-medium\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tPage {table.getState().pagination.pageIndex + 1} of {table.getPageCount()}\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"ms-auto flex items-center gap-2 lg:ms-0\">\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tclassName=\"hidden size-9 p-0 lg:flex\"", "n_tokens": 159, "primary_symbol": "", "primary_kind": "", "primary_span": [328, 344], "def_symbols": [], "symbols": ["map", "pageSize", "SelectItem", "key", "value", "SelectContent", "Select", "div", "className", "flex", "fit", "items", "center", "justify", "text", "font", "medium", "Trans", "Page", "table", "getState", "pagination", "pageIndex", "getPageCount", "auto", "gap", "Button", "variant", "outline", "hidden", "size"], "doc_head": "\t\t\t\t\t\t\t\t{[10, 20, 50, 100, 200].map((pageSize) => (\n\t\t\t\t\t\t\t\t\t<SelectItem key={pageSize} value={`${pageSize}`}>\n\t\t\t\t\t\t\t\t\t\t{pageSize}\n\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t</Select>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"flex w-fit items-center justify-center text-sm font-medium\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tPage {table.getState().pagination.pageIndex + 1} of {table.getPageCount()}\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"ms-auto flex items-center gap-2 lg:ms-0\">\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tclassName=\"hidden size-9 p-0 lg:flex\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#19", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 19, "start_line": 345, "end_line": 364, "text": "\t\t\t\t\t\t\tonClick={() => table.setPageIndex(0)}\n\t\t\t\t\t\t\tdisabled={!table.getCanPreviousPage()}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"sr-only\">Go to first page</span>\n\t\t\t\t\t\t\t<ChevronsLeftIcon className=\"size-5\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tclassName=\"size-9\"\n\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\tonClick={() => table.previousPage()}\n\t\t\t\t\t\t\tdisabled={!table.getCanPreviousPage()}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"sr-only\">Go to previous page</span>\n\t\t\t\t\t\t\t<ChevronLeftIcon className=\"size-5\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tclassName=\"size-9\"\n\t\t\t\t\t\t\tsize=\"icon\"", "n_tokens": 156, "primary_symbol": "", "primary_kind": "", "primary_span": [345, 364], "def_symbols": [], "symbols": ["onClick", "table", "setPageIndex", "disabled", "getCanPreviousPage", "span", "className", "only", "first", "page", "ChevronsLeftIcon", "size", "Button", "variant", "outline", "icon", "previousPage", "previous", "ChevronLeftIcon"], "doc_head": "\t\t\t\t\t\t\tonClick={() => table.setPageIndex(0)}\n\t\t\t\t\t\t\tdisabled={!table.getCanPreviousPage()}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"sr-only\">Go to first page</span>\n\t\t\t\t\t\t\t<ChevronsLeftIcon className=\"size-5\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tclassName=\"size-9\"\n\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\tonClick={() => table.previousPage()}\n\t\t\t\t\t\t\tdisabled={!table.getCanPreviousPage()}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"sr-only\">Go to previous page</span>\n\t\t\t\t\t\t\t<ChevronLeftIcon className=\"size-5\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tclassName=\"size-9\"\n\t\t\t\t\t\t\tsize=\"icon\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx#20", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/alerts-history-data-table.tsx", "rel_path": "src/site/src/components/routes/settings/alerts-history-data-table.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 20, "start_line": 365, "end_line": 387, "text": "\t\t\t\t\t\t\tonClick={() => table.nextPage()}\n\t\t\t\t\t\t\tdisabled={!table.getCanNextPage()}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"sr-only\">Go to next page</span>\n\t\t\t\t\t\t\t<ChevronRightIcon className=\"size-5\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tclassName=\"hidden size-9 lg:flex\"\n\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\tonClick={() => table.setPageIndex(table.getPageCount() - 1)}\n\t\t\t\t\t\t\tdisabled={!table.getCanNextPage()}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"sr-only\">Go to last page</span>\n\t\t\t\t\t\t\t<ChevronsRightIcon className=\"size-5\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n", "n_tokens": 165, "primary_symbol": "", "primary_kind": "", "primary_span": [365, 387], "def_symbols": [], "symbols": ["onClick", "table", "nextPage", "disabled", "getCanNextPage", "span", "className", "only", "next", "page", "ChevronRightIcon", "size", "Button", "variant", "outline", "hidden", "flex", "icon", "setPageIndex", "getPageCount", "last", "ChevronsRightIcon", "div"], "doc_head": "\t\t\t\t\t\t\tonClick={() => table.nextPage()}\n\t\t\t\t\t\t\tdisabled={!table.getCanNextPage()}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"sr-only\">Go to next page</span>\n\t\t\t\t\t\t\t<ChevronRightIcon className=\"size-5\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tclassName=\"hidden size-9 lg:flex\"\n\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\tonClick={() => table.setPageIndex(table.getPageCount() - 1)}\n\t\t\t\t\t\t\tdisabled={!table.getCanNextPage()}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"sr-only\">Go to last page</span>\n\t\t\t\t\t\t\t<ChevronsRightIcon className=\"size-5\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx", "rel_path": "src/site/src/components/routes/settings/general.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 16, "text": "import { Trans } from \"@lingui/react/macro\"\nimport { Button } from \"@/components/ui/button\"\nimport { Label } from \"@/components/ui/label\"\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\"\nimport { chartTimeData } from \"@/lib/utils\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { LanguagesIcon, LoaderCircleIcon, SaveIcon } from \"lucide-react\"\nimport { UserSettings } from \"@/types\"\nimport { saveSettings } from \"./layout\"\nimport { useState } from \"react\"\nimport languages from \"@/lib/languages\"\nimport { dynamicActivate } from \"@/lib/i18n\"\nimport { useLingui } from \"@lingui/react/macro\"\nimport { Input } from \"@/components/ui/input\"\nimport { Unit } from \"@/lib/enums\"\n", "n_tokens": 177, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 16], "def_symbols": [], "symbols": ["import", "Trans", "from", "lingui", "react", "macro", "Button", "components", "button", "Label", "label", "Select", "SelectContent", "SelectItem", "SelectTrigger", "SelectValue", "select", "chartTimeData", "lib", "utils", "Separator", "separator", "LanguagesIcon", "LoaderCircleIcon", "SaveIcon", "lucide", "UserSettings", "types", "saveSettings", "layout", "useState", "languages", "dynamicActivate", "i18n", "useLingui", "Input", "input", "Unit", "enums"], "doc_head": "import { Trans } from \"@lingui/react/macro\"\nimport { Button } from \"@/components/ui/button\"\nimport { Label } from \"@/components/ui/label\"\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\"\nimport { chartTimeData } from \"@/lib/utils\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { LanguagesIcon, LoaderCircleIcon, SaveIcon } from \"lucide-react\"\nimport { UserSettings } from \"@/types\"\nimport { saveSettings } from \"./layout\"\nimport { useState } from \"react\"\nimport languages from \"@/lib/languages\"\nimport { dynamicActivate } from \"@/lib/i18n\"\nimport { useLingui } from \"@lingui/react/macro\"\nimport { Input } from \"@/components/ui/input\"\nimport { Unit } from \"@/lib/enums\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx", "rel_path": "src/site/src/components/routes/settings/general.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 17, "end_line": 20, "text": "export default function SettingsProfilePage({ userSettings }: { userSettings: UserSettings }) {\n\tconst [isLoading, setIsLoading] = useState(false)\n\tconst { i18n } = useLingui()\n", "n_tokens": 41, "primary_symbol": "", "primary_kind": "", "primary_span": [17, 20], "def_symbols": [], "symbols": ["export", "default", "function", "SettingsProfilePage", "userSettings", "UserSettings", "const", "isLoading", "setIsLoading", "useState", "false", "i18n", "useLingui"], "doc_head": "export default function SettingsProfilePage({ userSettings }: { userSettings: UserSettings }) {\n\tconst [isLoading, setIsLoading] = useState(false)\n\tconst { i18n } = useLingui()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx", "rel_path": "src/site/src/components/routes/settings/general.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 21, "end_line": 60, "text": "\tasync function handleSubmit(e: React.FormEvent<HTMLFormElement>) {\n\t\te.preventDefault()\n\t\tsetIsLoading(true)\n\t\tconst formData = new FormData(e.target as HTMLFormElement)\n\t\tconst data = Object.fromEntries(formData) as Partial<UserSettings>\n\t\tawait saveSettings(data)\n\t\tsetIsLoading(false)\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<div>\n\t\t\t\t<h3 className=\"text-xl font-medium mb-2\">\n\t\t\t\t\t<Trans>General</Trans>\n\t\t\t\t</h3>\n\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t<Trans>Change general application options.</Trans>\n\t\t\t\t</p>\n\t\t\t</div>\n\t\t\t<Separator className=\"my-4\" />\n\t\t\t<form onSubmit={handleSubmit} className=\"space-y-5\">\n\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t<div className=\"mb-2\">\n\t\t\t\t\t\t<h3 className=\"mb-1 text-lg font-medium flex items-center gap-2\">\n\t\t\t\t\t\t\t<LanguagesIcon className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t<Trans>Language</Trans>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\tWant to help improve our translations? Check{\" \"}\n\t\t\t\t\t\t\t\t<a href=\"https://crowdin.com/project/beszel\" className=\"link\" target=\"_blank\" rel=\"noopener noreferrer\">\n\t\t\t\t\t\t\t\t\tCrowdin\n\t\t\t\t\t\t\t\t</a>{\" \"}\n\t\t\t\t\t\t\t\tfor details.\n\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<Label className=\"block\" htmlFor=\"lang\">\n\t\t\t\t\t\t<Trans>Preferred Language</Trans>\n\t\t\t\t\t</Label>", "n_tokens": 351, "primary_symbol": "handleSubmit", "primary_kind": "function", "primary_span": [21, 60], "def_symbols": ["handleSubmit"], "symbols": ["handleSubmit", "async", "function", "React", "FormEvent", "HTMLFormElement", "preventDefault", "setIsLoading", "true", "const", "formData", "new", "FormData", "target", "data", "Object", "fromEntries", "Partial", "UserSettings", "await", "saveSettings", "false", "return", "div", "className", "text", "font", "medium", "Trans", "General", "muted", "foreground", "leading", "relaxed", "Change", "general", "application", "options", "Separator", "form", "onSubmit", "space", "grid", "gap", "flex", "items", "center", "LanguagesIcon", "Language", "Want", "help", "improve", "our", "translations", "Check", "href", "https", "crowdin", "com", "project", "beszel", "link", "_blank", "rel", "noopener", "noreferrer", "Crowdin", "for", "details", "Label", "block", "htmlFor", "lang", "Preferred"], "doc_head": "\tasync function handleSubmit(e: React.FormEvent<HTMLFormElement>) {\n\t\te.preventDefault()\n\t\tsetIsLoading(true)\n\t\tconst formData = new FormData(e.target as HTMLFormElement)\n\t\tconst data = Object.fromEntries(formData) as Partial<UserSettings>\n\t\tawait saveSettings(data)\n\t\tsetIsLoading(false)\n\t}\n\treturn (\n\t\t<div>\n\t\t\t<div>\n\t\t\t\t<h3 className=\"text-xl font-medium mb-2\">\n\t\t\t\t\t<Trans>General</Trans>\n\t\t\t\t</h3>\n\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t<Trans>Change general application options.</Trans>\n\t\t\t\t</p>\n\t\t\t</div>\n\t\t\t<Separator className=\"my-4\" />\n\t\t\t<form onSubmit={handleSubmit} className=\"space-y-5\">\n\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t<div className=\"mb-2\">\n\t\t\t\t\t\t<h3 className=\"mb-1 text-lg font-medium flex items-center gap-2\">\n\t\t\t\t\t\t\t<LanguagesIcon className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t<Trans>Language</Trans>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\tWant to help improve our translations? Check{\" \"}\n\t\t\t\t\t\t\t\t<a href=\"https://crowdin.com/project/beszel\" className=\"link\" target=\"_blank\" rel=\"noopener noreferrer\">\n\t\t\t\t\t\t\t\t\tCrowdin\n\t\t\t\t\t\t\t\t</a>{\" \"}\n\t\t\t\t\t\t\t\tfor details.\n\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</d"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx", "rel_path": "src/site/src/components/routes/settings/general.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 61, "end_line": 65, "text": "\t\t\t\t\t<Select value={i18n.locale} onValueChange={(lang: string) => dynamicActivate(lang)}>\n\t\t\t\t\t\t<SelectTrigger id=\"lang\">\n\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t<SelectContent>", "n_tokens": 47, "primary_symbol": "", "primary_kind": "", "primary_span": [61, 65], "def_symbols": [], "symbols": ["Select", "value", "i18n", "locale", "onValueChange", "lang", "string", "dynamicActivate", "SelectTrigger", "SelectValue", "SelectContent"], "doc_head": "\t\t\t\t\t<Select value={i18n.locale} onValueChange={(lang: string) => dynamicActivate(lang)}>\n\t\t\t\t\t\t<SelectTrigger id=\"lang\">\n\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t<SelectContent>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx", "rel_path": "src/site/src/components/routes/settings/general.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 66, "end_line": 92, "text": "\t\t\t\t\t\t\t{languages.map((lang) => (\n\t\t\t\t\t\t\t\t<SelectItem key={lang.lang} value={lang.lang}>\n\t\t\t\t\t\t\t\t\t<span className=\"me-2.5\">{lang.e}</span>\n\t\t\t\t\t\t\t\t\t{lang.label}\n\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t</Select>\n\t\t\t\t</div>\n\t\t\t\t<Separator />\n\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t<div className=\"mb-2\">\n\t\t\t\t\t\t<h3 className=\"mb-1 text-lg font-medium\">\n\t\t\t\t\t\t\t<Trans>Chart options</Trans>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t\t<Trans>Adjust display options for charts.</Trans>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<Label className=\"block\" htmlFor=\"chartTime\">\n\t\t\t\t\t\t<Trans>Default time period</Trans>\n\t\t\t\t\t</Label>\n\t\t\t\t\t<Select name=\"chartTime\" key={userSettings.chartTime} defaultValue={userSettings.chartTime}>\n\t\t\t\t\t\t<SelectTrigger id=\"chartTime\">\n\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t<SelectContent>", "n_tokens": 239, "primary_symbol": "", "primary_kind": "", "primary_span": [66, 92], "def_symbols": [], "symbols": ["languages", "map", "lang", "SelectItem", "key", "value", "span", "className", "label", "SelectContent", "Select", "div", "Separator", "grid", "gap", "text", "font", "medium", "Trans", "Chart", "options", "muted", "foreground", "leading", "relaxed", "Adjust", "display", "for", "charts", "Label", "block", "htmlFor", "chartTime", "Default", "time", "period", "name", "userSettings", "defaultValue", "SelectTrigger", "SelectValue"], "doc_head": "\t\t\t\t\t\t\t{languages.map((lang) => (\n\t\t\t\t\t\t\t\t<SelectItem key={lang.lang} value={lang.lang}>\n\t\t\t\t\t\t\t\t\t<span className=\"me-2.5\">{lang.e}</span>\n\t\t\t\t\t\t\t\t\t{lang.label}\n\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t</Select>\n\t\t\t\t</div>\n\t\t\t\t<Separator />\n\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t<div className=\"mb-2\">\n\t\t\t\t\t\t<h3 className=\"mb-1 text-lg font-medium\">\n\t\t\t\t\t\t\t<Trans>Chart options</Trans>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t\t<Trans>Adjust display options for charts.</Trans>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<Label className=\"block\" htmlFor=\"chartTime\">\n\t\t\t\t\t\t<Trans>Default time period</Trans>\n\t\t\t\t\t</Label>\n\t\t\t\t\t<Select name=\"chartTime\" key={userSettings.chartTime} defaultValue={userSettings.chartTime}>\n\t\t\t\t\t\t<SelectTrigger id=\"chartTime\">\n\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t<SelectContent>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/routes/settings/general.tsx", "rel_path": "src/site/src/components/routes/settings/general.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 93, "end_line": 233, "text": "\t\t\t\t\t\t\t{Object.entries(chartTimeData).map(([value, { label }]) => (\n\t\t\t\t\t\t\t\t<SelectItem key={value} value={value}>\n\t\t\t\t\t\t\t\t\t{label()}\n\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t</Select>\n\t\t\t\t\t<p className=\"text-[0.8rem] text-muted-foreground\">\n\t\t\t\t\t\t<Trans>Sets the default time range for charts when a system is viewed.</Trans>\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t\t<Separator />\n\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t<div className=\"mb-2\">\n\t\t\t\t\t\t<h3 className=\"mb-1 text-lg font-medium\">\n\t\t\t\t\t\t\t<Trans comment=\"Temperature / network units\">Unit preferences</Trans>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t\t<Trans>Change display units for metrics.</Trans>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"grid sm:grid-cols-3 gap-4\">\n\t\t\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t\t\t<Label className=\"block\" htmlFor=\"unitTemp\">\n\t\t\t\t\t\t\t\t<Trans>Temperature unit</Trans>\n\t\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t\t<Select\n\t\t\t\t\t\t\t\tname=\"unitTemp\"\n\t\t\t\t\t\t\t\tkey={userSettings.unitTemp}\n\t\t\t\t\t\t\t\tdefaultValue={userSettings.unitTemp?.toString() || String(Unit.Celsius)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"unitTemp\">\n\t\t\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t<SelectItem value={String(Unit.Celsius)}>\n\t\t\t\t\t\t\t\t\t\t<Trans>Celsius (C)</Trans>\n\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t<SelectItem value={String(Unit.Fahrenheit)}>\n\t\t\t\t\t\t\t\t\t\t<Trans>Fahrenheit (F)</Trans>\n\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t\t\t<Label className=\"block\" htmlFor=\"unitNet\">\n\t\t\t\t\t\t\t\t<Trans comment=\"Context: Bytes or bits\">Network unit</Trans>\n\t\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t\t<Select\n\t\t\t\t\t\t\t\tname=\"unitNet\"\n\t\t\t\t\t\t\t\tkey={userSettings.unitNet}\n\t\t\t\t\t\t\t\tdefaultValue={userSettings.unitNet?.toString() ?? String(Unit.Bytes)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"unitNet\">\n\t\t\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t<SelectItem value={String(Unit.Bytes)}>\n\t\t\t\t\t\t\t\t\t\t<Trans>Bytes (KB/s, MB/s, GB/s)</Trans>\n\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t<SelectItem value={String(Unit.Bits)}>\n\t\t\t\t\t\t\t\t\t\t<Trans>Bits (Kbps, Mbps, Gbps)</Trans>\n\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t\t\t<Label className=\"block\" htmlFor=\"unitDisk\">\n\t\t\t\t\t\t\t\t<Trans>Disk unit</Trans>\n\t\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t\t<Select\n\t\t\t\t\t\t\t\tname=\"unitDisk\"\n\t\t\t\t\t\t\t\tkey={userSettings.unitDisk}\n\t\t\t\t\t\t\t\tdefaultValue={userSettings.unitDisk?.toString() ?? String(Unit.Bytes)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"unitDisk\">\n\t\t\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t<SelectItem value={String(Unit.Bytes)}>\n\t\t\t\t\t\t\t\t\t\t<Trans>Bytes (KB/s, MB/s, GB/s)</Trans>\n\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t<SelectItem value={String(Unit.Bits)}>\n\t\t\t\t\t\t\t\t\t\t<Trans>Bits (Kbps, Mbps, Gbps)</Trans>\n\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<Separator />\n\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t<div className=\"mb-2\">\n\t\t\t\t\t\t<h3 className=\"mb-1 text-lg font-medium\">\n\t\t\t\t\t\t\t<Trans>Warning thresholds</Trans>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t\t<Trans>Set percentage thresholds for meter colors.</Trans>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"grid grid-cols-2 lg:grid-cols-3 gap-4 items-end\">\n\t\t\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t\t\t<Label htmlFor=\"colorWarn\">\n\t\t\t\t\t\t\t\t<Trans>Warning (%)</Trans>\n\t\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\tid=\"colorWarn\"\n\t\t\t\t\t\t\t\tname=\"colorWarn\"\n\t\t\t\t\t\t\t\ttype=\"number\"\n\t\t\t\t\t\t\t\tmin={1}\n\t\t\t\t\t\t\t\tmax={100}\n\t\t\t\t\t\t\t\tclassName=\"min-w-24\"\n\t\t\t\t\t\t\t\tdefaultValue={userSettings.colorWarn ?? 65}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"grid gap-1\">\n\t\t\t\t\t\t\t<Label htmlFor=\"colorCrit\">\n\t\t\t\t\t\t\t\t<Trans>Critical (%)</Trans>\n\t\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\tid=\"colorCrit\"\n\t\t\t\t\t\t\t\tname=\"colorCrit\"\n\t\t\t\t\t\t\t\ttype=\"number\"\n\t\t\t\t\t\t\t\tmin={1}\n\t\t\t\t\t\t\t\tmax={100}\n\t\t\t\t\t\t\t\tclassName=\"min-w-24\"\n\t\t\t\t\t\t\t\tdefaultValue={userSettings.colorCrit ?? 90}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<Separator />\n\t\t\t\t<Button type=\"submit\" className=\"flex items-center gap-1.5 disabled:opacity-100\" disabled={isLoading}>\n\t\t\t\t\t{isLoading ? <LoaderCircleIcon className=\"h-4 w-4 animate-spin\" /> : <SaveIcon className=\"h-4 w-4\" />}\n\t\t\t\t\t<Trans>Save Settings</Trans>\n\t\t\t\t</Button>\n\t\t\t</form>\n\t\t</div>\n\t)\n}\n", "n_tokens": 1183, "primary_symbol": "", "primary_kind": "", "primary_span": [93, 233], "def_symbols": [], "symbols": ["Object", "entries", "chartTimeData", "map", "value", "label", "SelectItem", "key", "SelectContent", "Select", "className", "text", "muted", "foreground", "Trans", "Sets", "the", "default", "time", "range", "for", "charts", "when", "system", "viewed", "div", "Separator", "grid", "gap", "font", "medium", "comment", "Temperature", "network", "units", "Unit", "preferences", "leading", "relaxed", "Change", "display", "metrics", "cols", "Label", "block", "htmlFor", "unitTemp", "unit", "name", "userSettings", "defaultValue", "toString", "String", "Celsius", "SelectTrigger", "SelectValue", "Fahrenheit", "unitNet", "Context", "Bytes", "bits", "Network", "Bits", "Kbps", "Mbps", "Gbps", "unitDisk", "Disk", "Warning", "thresholds", "Set", "percentage", "meter", "colors", "items", "end", "colorWarn", "Input", "type", "number", "min", "max", "colorCrit", "Critical", "Button", "submit", "flex", "center", "disabled", "opacity", "isLoading", "LoaderCircleIcon", "animate", "spin", "SaveIcon", "Save", "Settings", "form"], "doc_head": "\t\t\t\t\t\t\t{Object.entries(chartTimeData).map(([value, { label }]) => (\n\t\t\t\t\t\t\t\t<SelectItem key={value} value={value}>\n\t\t\t\t\t\t\t\t\t{label()}\n\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t</Select>\n\t\t\t\t\t<p className=\"text-[0.8rem] text-muted-foreground\">\n\t\t\t\t\t\t<Trans>Sets the default time range for charts when a system is viewed.</Trans>\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t\t<Separator />\n\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t<div className=\"mb-2\">\n\t\t\t\t\t\t<h3 className=\"mb-1 text-lg font-medium\">\n\t\t\t\t\t\t\t<Trans comment=\"Temperature / network units\">Unit preferences</Trans>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<p className=\"text-sm text-muted-foreground leading-relaxed\">\n\t\t\t\t\t\t\t<Trans>Change display units for metrics.</Trans>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"grid sm:grid-cols-3 gap-4\">\n\t\t\t\t\t\t<div className=\"grid gap-2\">\n\t\t\t\t\t\t\t<Label className=\"block\" htmlFor=\"unitTemp\">\n\t\t\t\t\t\t\t\t<Trans>Temperature unit</Trans>\n\t\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t\t<Select\n\t\t\t\t\t\t\t\tname=\"unitTemp\"\n\t\t\t\t\t\t\t\tkey={userSettings.unitTemp}\n\t\t\t\t\t\t\t\tdefaultValue={userSettings.unitTemp?.toString() || String(Unit.Celsius)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"unitTemp\">\n\t\t\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/login.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/login.tsx", "rel_path": "src/site/src/components/login/login.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "import { t } from \"@lingui/core/macro\"\nimport { UserAuthForm } from \"@/components/login/auth-form\"\nimport { Logo } from \"../logo\"\nimport { useEffect, useMemo, useState } from \"react\"\nimport { useStore } from \"@nanostores/react\"\nimport ForgotPassword from \"./forgot-pass-form\"\nimport { $router } from \"../router\"\nimport { AuthMethodsList } from \"pocketbase\"\nimport { useTheme } from \"../theme-provider\"\nimport { pb } from \"@/lib/api\"\nimport { ModeToggle } from \"../mode-toggle\"\nimport { OtpRequestForm } from \"./otp-forms\"\n\nexport default function () {\n\tconst page = useStore($router)\n\tconst [isFirstRun, setFirstRun] = useState(false)\n\tconst [authMethods, setAuthMethods] = useState<AuthMethodsList>()\n\tconst { theme } = useTheme()\n\n\tuseEffect(() => {\n\t\tdocument.title = t`Login` + \" / Beszel\"\n", "n_tokens": 199, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 22], "def_symbols": [], "symbols": ["import", "from", "lingui", "core", "macro", "UserAuthForm", "components", "login", "auth", "form", "Logo", "logo", "useEffect", "useMemo", "useState", "react", "useStore", "nanostores", "ForgotPassword", "forgot", "pass", "router", "AuthMethodsList", "pocketbase", "useTheme", "theme", "provider", "lib", "api", "ModeToggle", "mode", "toggle", "OtpRequestForm", "otp", "forms", "export", "default", "function", "const", "page", "isFirstRun", "setFirstRun", "false", "authMethods", "setAuthMethods", "document", "title", "Login", "Beszel"], "doc_head": "import { t } from \"@lingui/core/macro\"\nimport { UserAuthForm } from \"@/components/login/auth-form\"\nimport { Logo } from \"../logo\"\nimport { useEffect, useMemo, useState } from \"react\"\nimport { useStore } from \"@nanostores/react\"\nimport ForgotPassword from \"./forgot-pass-form\"\nimport { $router } from \"../router\"\nimport { AuthMethodsList } from \"pocketbase\"\nimport { useTheme } from \"../theme-provider\"\nimport { pb } from \"@/lib/api\"\nimport { ModeToggle } from \"../mode-toggle\"\nimport { OtpRequestForm } from \"./otp-forms\"\nexport default function () {\n\tconst page = useStore($router)\n\tconst [isFirstRun, setFirstRun] = useState(false)\n\tconst [authMethods, setAuthMethods] = useState<AuthMethodsList>()\n\tconst { theme } = useTheme()\n\tuseEffect(() => {\n\t\tdocument.title = t`Login` + \" / Beszel\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/login.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/login.tsx", "rel_path": "src/site/src/components/login/login.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 23, "end_line": 47, "text": "\t\tpb.send(\"/api/beszel/first-run\", {}).then(({ firstRun }) => {\n\t\t\tsetFirstRun(firstRun)\n\t\t})\n\t}, [])\n\n\tuseEffect(() => {\n\t\tpb.collection(\"users\")\n\t\t\t.listAuthMethods()\n\t\t\t.then((methods) => {\n\t\t\t\tsetAuthMethods(methods)\n\t\t\t})\n\t}, [])\n\n\tconst subtitle = useMemo(() => {\n\t\tif (isFirstRun) {\n\t\t\treturn t`Please create an admin account`\n\t\t} else if (page?.route === \"forgot_password\") {\n\t\t\treturn t`Enter email address to reset password`\n\t\t} else if (page?.route === \"request_otp\") {\n\t\t\treturn t`Request a one-time password`\n\t\t} else {\n\t\t\treturn t`Please sign in to your account`\n\t\t}\n\t}, [isFirstRun, page])\n", "n_tokens": 178, "primary_symbol": "", "primary_kind": "", "primary_span": [23, 47], "def_symbols": [], "symbols": ["send", "api", "beszel", "first", "run", "then", "firstRun", "setFirstRun", "useEffect", "collection", "users", "listAuthMethods", "methods", "setAuthMethods", "const", "subtitle", "useMemo", "isFirstRun", "return", "Please", "create", "admin", "account", "else", "page", "route", "forgot_password", "Enter", "email", "address", "reset", "password", "request_otp", "Request", "one", "time", "sign", "your"], "doc_head": "\t\tpb.send(\"/api/beszel/first-run\", {}).then(({ firstRun }) => {\n\t\t\tsetFirstRun(firstRun)\n\t\t})\n\t}, [])\n\tuseEffect(() => {\n\t\tpb.collection(\"users\")\n\t\t\t.listAuthMethods()\n\t\t\t.then((methods) => {\n\t\t\t\tsetAuthMethods(methods)\n\t\t\t})\n\t}, [])\n\tconst subtitle = useMemo(() => {\n\t\tif (isFirstRun) {\n\t\t\treturn t`Please create an admin account`\n\t\t} else if (page?.route === \"forgot_password\") {\n\t\t\treturn t`Enter email address to reset password`\n\t\t} else if (page?.route === \"request_otp\") {\n\t\t\treturn t`Request a one-time password`\n\t\t} else {\n\t\t\treturn t`Please sign in to your account`\n\t\t}\n\t}, [isFirstRun, page])"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/login.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/login.tsx", "rel_path": "src/site/src/components/login/login.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 48, "end_line": 80, "text": "\tif (!authMethods) {\n\t\treturn null\n\t}\n\n\treturn (\n\t\t<div className=\"min-h-svh grid items-center py-12\">\n\t\t\t<div\n\t\t\t\tclassName=\"grid gap-5 w-full px-4 mx-auto\"\n\t\t\t\t// @ts-ignore\n\t\t\t\tstyle={{ maxWidth: \"21.5em\", \"--border\": theme == \"light\" ? \"hsl(30, 8%, 70%)\" : \"hsl(220, 3%, 25%)\" }}\n\t\t\t>\n\t\t\t\t<div className=\"absolute top-3 right-3\">\n\t\t\t\t\t<ModeToggle />\n\t\t\t\t</div>\n\t\t\t\t<div className=\"text-center\">\n\t\t\t\t\t<h1 className=\"mb-3\">\n\t\t\t\t\t\t<Logo className=\"h-7 fill-foreground mx-auto\" />\n\t\t\t\t\t\t<span className=\"sr-only\">Beszel</span>\n\t\t\t\t\t</h1>\n\t\t\t\t\t<p className=\"text-sm text-muted-foreground\">{subtitle}</p>\n\t\t\t\t</div>\n\t\t\t\t{page?.route === \"forgot_password\" ? (\n\t\t\t\t\t<ForgotPassword />\n\t\t\t\t) : page?.route === \"request_otp\" ? (\n\t\t\t\t\t<OtpRequestForm />\n\t\t\t\t) : (\n\t\t\t\t\t<UserAuthForm isFirstRun={isFirstRun} authMethods={authMethods} />\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n", "n_tokens": 286, "primary_symbol": "", "primary_kind": "", "primary_span": [48, 80], "def_symbols": [], "symbols": ["authMethods", "return", "null", "div", "className", "min", "svh", "grid", "items", "center", "gap", "full", "auto", "ignore", "style", "maxWidth", "border", "theme", "light", "hsl", "absolute", "top", "right", "ModeToggle", "text", "Logo", "fill", "foreground", "span", "only", "Beszel", "muted", "subtitle", "page", "route", "forgot_password", "ForgotPassword", "request_otp", "OtpRequestForm", "UserAuthForm", "isFirstRun"], "doc_head": "\tif (!authMethods) {\n\t\treturn null\n\t}\n\treturn (\n\t\t<div className=\"min-h-svh grid items-center py-12\">\n\t\t\t<div\n\t\t\t\tclassName=\"grid gap-5 w-full px-4 mx-auto\"\n\t\t\t\t// @ts-ignore\n\t\t\t\tstyle={{ maxWidth: \"21.5em\", \"--border\": theme == \"light\" ? \"hsl(30, 8%, 70%)\" : \"hsl(220, 3%, 25%)\" }}\n\t\t\t>\n\t\t\t\t<div className=\"absolute top-3 right-3\">\n\t\t\t\t\t<ModeToggle />\n\t\t\t\t</div>\n\t\t\t\t<div className=\"text-center\">\n\t\t\t\t\t<h1 className=\"mb-3\">\n\t\t\t\t\t\t<Logo className=\"h-7 fill-foreground mx-auto\" />\n\t\t\t\t\t\t<span className=\"sr-only\">Beszel</span>\n\t\t\t\t\t</h1>\n\t\t\t\t\t<p className=\"text-sm text-muted-foreground\">{subtitle}</p>\n\t\t\t\t</div>\n\t\t\t\t{page?.route === \"forgot_password\" ? (\n\t\t\t\t\t<ForgotPassword />\n\t\t\t\t) : page?.route === \"request_otp\" ? (\n\t\t\t\t\t<OtpRequestForm />\n\t\t\t\t) : (\n\t\t\t\t\t<UserAuthForm isFirstRun={isFirstRun} authMethods={authMethods} />\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/forgot-pass-form.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/forgot-pass-form.tsx", "rel_path": "src/site/src/components/login/forgot-pass-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 21, "text": "import { Trans } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\nimport { LoaderCircle, MailIcon, SendHorizonalIcon } from \"lucide-react\"\nimport { Input } from \"../ui/input\"\nimport { Label } from \"../ui/label\"\nimport { useCallback, useState } from \"react\"\nimport { toast } from \"../ui/use-toast\"\nimport { buttonVariants } from \"../ui/button\"\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogHeader } from \"../ui/dialog\"\nimport { DialogContent, DialogTrigger, DialogTitle } from \"../ui/dialog\"\nimport { pb } from \"@/lib/api\"\n\nconst showLoginFaliedToast = () => {\n\ttoast({\n\t\ttitle: t`Login attempt failed`,\n\t\tdescription: t`Please check your credentials and try again`,\n\t\tvariant: \"destructive\",\n\t})\n}\n", "n_tokens": 187, "primary_symbol": "showLoginFaliedToast", "primary_kind": "function", "primary_span": [1, 21], "def_symbols": ["showLoginFaliedToast"], "symbols": ["showLoginFaliedToast", "import", "Trans", "from", "lingui", "react", "macro", "core", "LoaderCircle", "MailIcon", "SendHorizonalIcon", "lucide", "Input", "input", "Label", "label", "useCallback", "useState", "toast", "use", "buttonVariants", "button", "lib", "utils", "Dialog", "DialogHeader", "dialog", "DialogContent", "DialogTrigger", "DialogTitle", "api", "const", "title", "Login", "attempt", "failed", "description", "Please", "check", "your", "credentials", "and", "try", "again", "variant", "destructive"], "doc_head": "import { Trans } from \"@lingui/react/macro\"\nimport { t } from \"@lingui/core/macro\"\nimport { LoaderCircle, MailIcon, SendHorizonalIcon } from \"lucide-react\"\nimport { Input } from \"../ui/input\"\nimport { Label } from \"../ui/label\"\nimport { useCallback, useState } from \"react\"\nimport { toast } from \"../ui/use-toast\"\nimport { buttonVariants } from \"../ui/button\"\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogHeader } from \"../ui/dialog\"\nimport { DialogContent, DialogTrigger, DialogTitle } from \"../ui/dialog\"\nimport { pb } from \"@/lib/api\"\nconst showLoginFaliedToast = () => {\n\ttoast({\n\t\ttitle: t`Login attempt failed`,\n\t\tdescription: t`Please check your credentials and try again`,\n\t\tvariant: \"destructive\",\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/forgot-pass-form.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/forgot-pass-form.tsx", "rel_path": "src/site/src/components/login/forgot-pass-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 22, "end_line": 38, "text": "export default function ForgotPassword() {\n\tconst [isLoading, setIsLoading] = useState<boolean>(false)\n\tconst [email, setEmail] = useState(\"\")\n\n\tconst handleSubmit = useCallback(\n\t\tasync (e: React.FormEvent<HTMLFormElement>) => {\n\t\t\te.preventDefault()\n\t\t\tsetIsLoading(true)\n\t\t\ttry {\n\t\t\t\t// console.log(email)\n\t\t\t\tawait pb.collection(\"users\").requestPasswordReset(email)\n\t\t\t\ttoast({\n\t\t\t\t\ttitle: t`Password reset request received`,\n\t\t\t\t\tdescription: t`Check ${email} for a reset link.`,\n\t\t\t\t})\n\t\t\t} catch (e) {\n\t\t\t\tshowLoginFaliedToast()", "n_tokens": 127, "primary_symbol": "", "primary_kind": "", "primary_span": [22, 38], "def_symbols": [], "symbols": ["export", "default", "function", "ForgotPassword", "const", "isLoading", "setIsLoading", "useState", "boolean", "false", "email", "setEmail", "handleSubmit", "useCallback", "async", "React", "FormEvent", "HTMLFormElement", "preventDefault", "true", "try", "console", "log", "await", "collection", "users", "requestPasswordReset", "toast", "title", "Password", "reset", "request", "received", "description", "Check", "for", "link", "catch", "showLoginFaliedToast"], "doc_head": "export default function ForgotPassword() {\n\tconst [isLoading, setIsLoading] = useState<boolean>(false)\n\tconst [email, setEmail] = useState(\"\")\n\tconst handleSubmit = useCallback(\n\t\tasync (e: React.FormEvent<HTMLFormElement>) => {\n\t\t\te.preventDefault()\n\t\t\tsetIsLoading(true)\n\t\t\ttry {\n\t\t\t\t// console.log(email)\n\t\t\t\tawait pb.collection(\"users\").requestPasswordReset(email)\n\t\t\t\ttoast({\n\t\t\t\t\ttitle: t`Password reset request received`,\n\t\t\t\t\tdescription: t`Check ${email} for a reset link.`,\n\t\t\t\t})\n\t\t\t} catch (e) {\n\t\t\t\tshowLoginFaliedToast()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/forgot-pass-form.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/forgot-pass-form.tsx", "rel_path": "src/site/src/components/login/forgot-pass-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 39, "end_line": 57, "text": "\t\t\t} finally {\n\t\t\t\tsetIsLoading(false)\n\t\t\t\tsetEmail(\"\")\n\t\t\t}\n\t\t},\n\t\t[email]\n\t)\n\n\treturn (\n\t\t<>\n\t\t\t<form onSubmit={handleSubmit}>\n\t\t\t\t<div className=\"grid gap-3\">\n\t\t\t\t\t<div className=\"grid gap-1 relative\">\n\t\t\t\t\t\t<MailIcon className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n\t\t\t\t\t\t<Label className=\"sr-only\" htmlFor=\"email\">\n\t\t\t\t\t\t\t<Trans>Email</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\tvalue={email}", "n_tokens": 121, "primary_symbol": "", "primary_kind": "", "primary_span": [39, 57], "def_symbols": [], "symbols": ["finally", "setIsLoading", "false", "setEmail", "email", "return", "form", "onSubmit", "handleSubmit", "div", "className", "grid", "gap", "relative", "MailIcon", "absolute", "left", "top", "text", "muted", "foreground", "Label", "only", "htmlFor", "Trans", "Email", "Input", "value"], "doc_head": "\t\t\t} finally {\n\t\t\t\tsetIsLoading(false)\n\t\t\t\tsetEmail(\"\")\n\t\t\t}\n\t\t},\n\t\t[email]\n\t)\n\treturn (\n\t\t<>\n\t\t\t<form onSubmit={handleSubmit}>\n\t\t\t\t<div className=\"grid gap-3\">\n\t\t\t\t\t<div className=\"grid gap-1 relative\">\n\t\t\t\t\t\t<MailIcon className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n\t\t\t\t\t\t<Label className=\"sr-only\" htmlFor=\"email\">\n\t\t\t\t\t\t\t<Trans>Email</Trans>\n\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\tvalue={email}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/forgot-pass-form.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/forgot-pass-form.tsx", "rel_path": "src/site/src/components/login/forgot-pass-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 58, "end_line": 112, "text": "\t\t\t\t\t\t\tonChange={(e) => setEmail(e.target.value)}\n\t\t\t\t\t\t\tid=\"email\"\n\t\t\t\t\t\t\tname=\"email\"\n\t\t\t\t\t\t\trequired\n\t\t\t\t\t\t\tplaceholder=\"name@example.com\"\n\t\t\t\t\t\t\ttype=\"email\"\n\t\t\t\t\t\t\tautoCapitalize=\"none\"\n\t\t\t\t\t\t\tautoComplete=\"email\"\n\t\t\t\t\t\t\tautoCorrect=\"off\"\n\t\t\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t\t\t\tclassName=\"ps-9\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t\t<button className={cn(buttonVariants())} disabled={isLoading}>\n\t\t\t\t\t\t{isLoading ? (\n\t\t\t\t\t\t\t<LoaderCircle className=\"me-2 h-4 w-4 animate-spin\" />\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<SendHorizonalIcon className=\"me-2 h-4 w-4\" />\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t<Trans>Reset Password</Trans>\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</form>\n\t\t\t<Dialog>\n\t\t\t\t<DialogTrigger asChild>\n\t\t\t\t\t<button className=\"text-sm mx-auto hover:text-brand underline underline-offset-4 opacity-70 hover:opacity-100 transition-opacity\">\n\t\t\t\t\t\t<Trans>Command line instructions</Trans>\n\t\t\t\t\t</button>\n\t\t\t\t</DialogTrigger>\n\t\t\t\t<DialogContent className=\"max-w-[41em]\">\n\t\t\t\t\t<DialogHeader>\n\t\t\t\t\t\t<DialogTitle>\n\t\t\t\t\t\t\t<Trans>Command line instructions</Trans>\n\t\t\t\t\t\t</DialogTitle>\n\t\t\t\t\t</DialogHeader>\n\t\t\t\t\t<p className=\"text-primary/70 text-[0.95em] leading-relaxed\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tIf you've lost the password to your admin account, you may reset it using the following command.\n\t\t\t\t\t\t</Trans>\n\t\t\t\t\t</p>\n\t\t\t\t\t<p className=\"text-primary/70 text-[0.95em] leading-relaxed\">\n\t\t\t\t\t\t<Trans>Then log into the backend and reset your user account password in the users table.</Trans>\n\t\t\t\t\t</p>\n\t\t\t\t\t<code className=\"bg-muted rounded-sm py-0.5 px-2.5 me-auto text-sm\">\n\t\t\t\t\t\t./beszel superuser upsert user@example.com password\n\t\t\t\t\t</code>\n\t\t\t\t\t<code className=\"bg-muted rounded-sm py-0.5 px-2.5 me-auto text-sm\">\n\t\t\t\t\t\tdocker exec beszel /beszel superuser upsert name@example.com password\n\t\t\t\t\t</code>\n\t\t\t\t</DialogContent>\n\t\t\t</Dialog>\n\t\t</>\n\t)\n}\n", "n_tokens": 493, "primary_symbol": "", "primary_kind": "", "primary_span": [58, 112], "def_symbols": [], "symbols": ["onChange", "setEmail", "target", "value", "email", "name", "required", "placeholder", "example", "com", "type", "autoCapitalize", "none", "autoComplete", "autoCorrect", "off", "disabled", "isLoading", "className", "div", "button", "buttonVariants", "LoaderCircle", "animate", "spin", "SendHorizonalIcon", "Trans", "Reset", "Password", "form", "Dialog", "DialogTrigger", "asChild", "text", "auto", "hover", "brand", "underline", "offset", "opacity", "transition", "Command", "line", "instructions", "DialogContent", "max", "DialogHeader", "DialogTitle", "primary", "leading", "relaxed", "you", "lost", "the", "password", "your", "admin", "account", "may", "reset", "using", "following", "command", "Then", "log", "into", "backend", "and", "user", "users", "table", "code", "muted", "rounded", "beszel", "superuser", "upsert", "docker", "exec"], "doc_head": "\t\t\t\t\t\t\tonChange={(e) => setEmail(e.target.value)}\n\t\t\t\t\t\t\tid=\"email\"\n\t\t\t\t\t\t\tname=\"email\"\n\t\t\t\t\t\t\trequired\n\t\t\t\t\t\t\tplaceholder=\"name@example.com\"\n\t\t\t\t\t\t\ttype=\"email\"\n\t\t\t\t\t\t\tautoCapitalize=\"none\"\n\t\t\t\t\t\t\tautoComplete=\"email\"\n\t\t\t\t\t\t\tautoCorrect=\"off\"\n\t\t\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t\t\t\tclassName=\"ps-9\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t\t<button className={cn(buttonVariants())} disabled={isLoading}>\n\t\t\t\t\t\t{isLoading ? (\n\t\t\t\t\t\t\t<LoaderCircle className=\"me-2 h-4 w-4 animate-spin\" />\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<SendHorizonalIcon className=\"me-2 h-4 w-4\" />\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t<Trans>Reset Password</Trans>\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</form>\n\t\t\t<Dialog>\n\t\t\t\t<DialogTrigger asChild>\n\t\t\t\t\t<button className=\"text-sm mx-auto hover:text-brand underline underline-offset-4 opacity-70 hover:opacity-100 transition-opacity\">\n\t\t\t\t\t\t<Trans>Command line instructions</Trans>\n\t\t\t\t\t</button>\n\t\t\t\t</DialogTrigger>\n\t\t\t\t<DialogContent className=\"max-w-[41em]\">\n\t\t\t\t\t<DialogHeader>\n\t\t\t\t\t\t<DialogTitle>\n\t\t\t\t\t\t\t<Trans>Command line instructions</Trans>\n\t\t\t\t\t\t</DialogTitle>\n\t\t\t\t\t</DialogHeader>\n\t\t\t\t\t<p className=\"text-primary/70 text-[0.95em] leading-relaxed\">\n\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\tIf you've lost the password to your admin account, you may res"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx", "rel_path": "src/site/src/components/login/otp-forms.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 16, "text": "import { useCallback, useState } from \"react\"\nimport { pb } from \"@/lib/api\"\nimport { $authenticated } from \"@/lib/stores\"\nimport { InputOTP, InputOTPGroup, InputOTPSlot } from \"@/components/ui/otp\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { showLoginFaliedToast } from \"./auth-form\"\nimport { cn } from \"@/lib/utils\"\nimport { MailIcon, LoaderCircle, SendHorizonalIcon } from \"lucide-react\"\nimport { Label } from \"../ui/label\"\nimport { buttonVariants } from \"../ui/button\"\nimport { Input } from \"../ui/input\"\nimport { $router } from \"../router\"\n\nexport function OtpInputForm({ otpId, mfaId }: { otpId: string; mfaId: string }) {\n\tconst [value, setValue] = useState(\"\")\n", "n_tokens": 181, "primary_symbol": "OtpInputForm", "primary_kind": "function", "primary_span": [14, 16], "def_symbols": ["OtpInputForm"], "symbols": ["OtpInputForm", "import", "useCallback", "useState", "from", "react", "lib", "api", "authenticated", "stores", "InputOTP", "InputOTPGroup", "InputOTPSlot", "components", "otp", "Trans", "lingui", "macro", "showLoginFaliedToast", "auth", "form", "utils", "MailIcon", "LoaderCircle", "SendHorizonalIcon", "lucide", "Label", "label", "buttonVariants", "button", "Input", "input", "router", "export", "function", "otpId", "mfaId", "string", "const", "value", "setValue"], "doc_head": "import { useCallback, useState } from \"react\"\nimport { pb } from \"@/lib/api\"\nimport { $authenticated } from \"@/lib/stores\"\nimport { InputOTP, InputOTPGroup, InputOTPSlot } from \"@/components/ui/otp\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { showLoginFaliedToast } from \"./auth-form\"\nimport { cn } from \"@/lib/utils\"\nimport { MailIcon, LoaderCircle, SendHorizonalIcon } from \"lucide-react\"\nimport { Label } from \"../ui/label\"\nimport { buttonVariants } from \"../ui/button\"\nimport { Input } from \"../ui/input\"\nimport { $router } from \"../router\"\nexport function OtpInputForm({ otpId, mfaId }: { otpId: string; mfaId: string }) {\n\tconst [value, setValue] = useState(\"\")"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx", "rel_path": "src/site/src/components/login/otp-forms.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 17, "end_line": 32, "text": "\tif (value.length === 6) {\n\t\tpb.collection(\"users\")\n\t\t\t.authWithOTP(otpId, value, { mfaId })\n\t\t\t.then(() => {\n\t\t\t\t$router.open(\"/\")\n\t\t\t\t$authenticated.set(true)\n\t\t\t})\n\t\t\t.catch((err) => {\n\t\t\t\tshowLoginFaliedToast(err.message)\n\t\t\t})\n\t}\n\n\treturn (\n\t\t<div className=\"grid gap-3 items-center justify-center\">\n\t\t\t<InputOTP maxLength={6} value={value} onChange={setValue} autoFocus>\n\t\t\t\t<InputOTPGroup>", "n_tokens": 116, "primary_symbol": "", "primary_kind": "", "primary_span": [17, 32], "def_symbols": [], "symbols": ["value", "length", "collection", "users", "authWithOTP", "otpId", "mfaId", "then", "router", "open", "authenticated", "set", "true", "catch", "err", "showLoginFaliedToast", "message", "return", "div", "className", "grid", "gap", "items", "center", "justify", "InputOTP", "maxLength", "onChange", "setValue", "autoFocus", "InputOTPGroup"], "doc_head": "\tif (value.length === 6) {\n\t\tpb.collection(\"users\")\n\t\t\t.authWithOTP(otpId, value, { mfaId })\n\t\t\t.then(() => {\n\t\t\t\t$router.open(\"/\")\n\t\t\t\t$authenticated.set(true)\n\t\t\t})\n\t\t\t.catch((err) => {\n\t\t\t\tshowLoginFaliedToast(err.message)\n\t\t\t})\n\t}\n\treturn (\n\t\t<div className=\"grid gap-3 items-center justify-center\">\n\t\t\t<InputOTP maxLength={6} value={value} onChange={setValue} autoFocus>\n\t\t\t\t<InputOTPGroup>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx", "rel_path": "src/site/src/components/login/otp-forms.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 33, "end_line": 53, "text": "\t\t\t\t\t{Array.from({ length: 6 }).map((_, i) => (\n\t\t\t\t\t\t<InputOTPSlot key={i} index={i} />\n\t\t\t\t\t))}\n\t\t\t\t</InputOTPGroup>\n\t\t\t</InputOTP>\n\t\t\t<div className=\"text-center text-sm text-muted-foreground\">\n\t\t\t\t<Trans>Enter your one-time password.</Trans>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n\nexport function OtpRequestForm() {\n\tconst [isLoading, setIsLoading] = useState<boolean>(false)\n\tconst [email, setEmail] = useState(\"\")\n\tconst [otpId, setOtpId] = useState<string | undefined>()\n\n\tconst handleSubmit = useCallback(\n\t\tasync (e: React.FormEvent<HTMLFormElement>) => {\n\t\t\te.preventDefault()\n\t\t\tsetIsLoading(true)", "n_tokens": 164, "primary_symbol": "OtpRequestForm", "primary_kind": "function", "primary_span": [45, 53], "def_symbols": ["OtpRequestForm"], "symbols": ["OtpRequestForm", "Array", "from", "length", "map", "InputOTPSlot", "key", "index", "InputOTPGroup", "InputOTP", "div", "className", "text", "center", "muted", "foreground", "Trans", "Enter", "your", "one", "time", "password", "export", "function", "const", "isLoading", "setIsLoading", "useState", "boolean", "false", "email", "setEmail", "otpId", "setOtpId", "string", "undefined", "handleSubmit", "useCallback", "async", "React", "FormEvent", "HTMLFormElement", "preventDefault", "true"], "doc_head": "\t\t\t\t\t{Array.from({ length: 6 }).map((_, i) => (\n\t\t\t\t\t\t<InputOTPSlot key={i} index={i} />\n\t\t\t\t\t))}\n\t\t\t\t</InputOTPGroup>\n\t\t\t</InputOTP>\n\t\t\t<div className=\"text-center text-sm text-muted-foreground\">\n\t\t\t\t<Trans>Enter your one-time password.</Trans>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\nexport function OtpRequestForm() {\n\tconst [isLoading, setIsLoading] = useState<boolean>(false)\n\tconst [email, setEmail] = useState(\"\")\n\tconst [otpId, setOtpId] = useState<string | undefined>()\n\tconst handleSubmit = useCallback(\n\t\tasync (e: React.FormEvent<HTMLFormElement>) => {\n\t\t\te.preventDefault()\n\t\t\tsetIsLoading(true)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx", "rel_path": "src/site/src/components/login/otp-forms.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 54, "end_line": 67, "text": "\t\t\ttry {\n\t\t\t\t// console.log(email)\n\t\t\t\tconst { otpId } = await pb.collection(\"users\").requestOTP(email)\n\t\t\t\tsetOtpId(otpId)\n\t\t\t} catch (e: any) {\n\t\t\t\tshowLoginFaliedToast(e?.message)\n\t\t\t} finally {\n\t\t\t\tsetIsLoading(false)\n\t\t\t\tsetEmail(\"\")\n\t\t\t}\n\t\t},\n\t\t[email]\n\t)\n", "n_tokens": 83, "primary_symbol": "", "primary_kind": "", "primary_span": [54, 67], "def_symbols": [], "symbols": ["try", "console", "log", "email", "const", "otpId", "await", "collection", "users", "requestOTP", "setOtpId", "catch", "any", "showLoginFaliedToast", "message", "finally", "setIsLoading", "false", "setEmail"], "doc_head": "\t\t\ttry {\n\t\t\t\t// console.log(email)\n\t\t\t\tconst { otpId } = await pb.collection(\"users\").requestOTP(email)\n\t\t\t\tsetOtpId(otpId)\n\t\t\t} catch (e: any) {\n\t\t\t\tshowLoginFaliedToast(e?.message)\n\t\t\t} finally {\n\t\t\t\tsetIsLoading(false)\n\t\t\t\tsetEmail(\"\")\n\t\t\t}\n\t\t},\n\t\t[email]\n\t)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx", "rel_path": "src/site/src/components/login/otp-forms.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 68, "end_line": 81, "text": "\tif (otpId) {\n\t\treturn <OtpInputForm otpId={otpId} mfaId={\"\"} />\n\t}\n\n\treturn (\n\t\t<form onSubmit={handleSubmit}>\n\t\t\t<div className=\"grid gap-3\">\n\t\t\t\t<div className=\"grid gap-1 relative\">\n\t\t\t\t\t<MailIcon className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n\t\t\t\t\t<Label className=\"sr-only\" htmlFor=\"email\">\n\t\t\t\t\t\t<Trans>Email</Trans>\n\t\t\t\t\t</Label>\n\t\t\t\t\t<Input\n\t\t\t\t\t\tvalue={email}", "n_tokens": 119, "primary_symbol": "", "primary_kind": "", "primary_span": [68, 81], "def_symbols": [], "symbols": ["otpId", "return", "OtpInputForm", "mfaId", "form", "onSubmit", "handleSubmit", "div", "className", "grid", "gap", "relative", "MailIcon", "absolute", "left", "top", "text", "muted", "foreground", "Label", "only", "htmlFor", "email", "Trans", "Email", "Input", "value"], "doc_head": "\tif (otpId) {\n\t\treturn <OtpInputForm otpId={otpId} mfaId={\"\"} />\n\t}\n\treturn (\n\t\t<form onSubmit={handleSubmit}>\n\t\t\t<div className=\"grid gap-3\">\n\t\t\t\t<div className=\"grid gap-1 relative\">\n\t\t\t\t\t<MailIcon className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n\t\t\t\t\t<Label className=\"sr-only\" htmlFor=\"email\">\n\t\t\t\t\t\t<Trans>Email</Trans>\n\t\t\t\t\t</Label>\n\t\t\t\t\t<Input\n\t\t\t\t\t\tvalue={email}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/otp-forms.tsx", "rel_path": "src/site/src/components/login/otp-forms.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 82, "end_line": 107, "text": "\t\t\t\t\t\tonChange={(e) => setEmail(e.target.value)}\n\t\t\t\t\t\tid=\"email\"\n\t\t\t\t\t\tname=\"email\"\n\t\t\t\t\t\trequired\n\t\t\t\t\t\tplaceholder=\"name@example.com\"\n\t\t\t\t\t\ttype=\"email\"\n\t\t\t\t\t\tautoCapitalize=\"none\"\n\t\t\t\t\t\tautoComplete=\"email\"\n\t\t\t\t\t\tautoCorrect=\"off\"\n\t\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t\t\tclassName=\"ps-9\"\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t\t<button className={cn(buttonVariants())} disabled={isLoading}>\n\t\t\t\t\t{isLoading ? (\n\t\t\t\t\t\t<LoaderCircle className=\"me-2 h-4 w-4 animate-spin\" />\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<SendHorizonalIcon className=\"me-2 h-4 w-4\" />\n\t\t\t\t\t)}\n\t\t\t\t\t<Trans>Request OTP</Trans>\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t</form>\n\t)\n}\n", "n_tokens": 174, "primary_symbol": "", "primary_kind": "", "primary_span": [82, 107], "def_symbols": [], "symbols": ["onChange", "setEmail", "target", "value", "email", "name", "required", "placeholder", "example", "com", "type", "autoCapitalize", "none", "autoComplete", "autoCorrect", "off", "disabled", "isLoading", "className", "div", "button", "buttonVariants", "LoaderCircle", "animate", "spin", "SendHorizonalIcon", "Trans", "Request", "OTP", "form"], "doc_head": "\t\t\t\t\t\tonChange={(e) => setEmail(e.target.value)}\n\t\t\t\t\t\tid=\"email\"\n\t\t\t\t\t\tname=\"email\"\n\t\t\t\t\t\trequired\n\t\t\t\t\t\tplaceholder=\"name@example.com\"\n\t\t\t\t\t\ttype=\"email\"\n\t\t\t\t\t\tautoCapitalize=\"none\"\n\t\t\t\t\t\tautoComplete=\"email\"\n\t\t\t\t\t\tautoCorrect=\"off\"\n\t\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t\t\tclassName=\"ps-9\"\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t\t<button className={cn(buttonVariants())} disabled={isLoading}>\n\t\t\t\t\t{isLoading ? (\n\t\t\t\t\t\t<LoaderCircle className=\"me-2 h-4 w-4 animate-spin\" />\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<SendHorizonalIcon className=\"me-2 h-4 w-4\" />\n\t\t\t\t\t)}\n\t\t\t\t\t<Trans>Request OTP</Trans>\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t</form>\n\t)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx", "rel_path": "src/site/src/components/login/auth-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 14, "text": "import { t } from \"@lingui/core/macro\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport { KeyIcon, LoaderCircle, LockIcon, LogInIcon, MailIcon } from \"lucide-react\"\nimport { $authenticated } from \"@/lib/stores\"\nimport * as v from \"valibot\"\nimport { toast } from \"../ui/use-toast\"\nimport { Dialog, DialogContent, DialogTrigger, DialogHeader, DialogTitle } from \"@/components/ui/dialog\"\nimport { useCallback, useEffect, useState } from \"react\"\nimport { AuthMethodsList, AuthProviderInfo, OAuth2AuthConfig } from \"pocketbase\"\nimport { $router, Link, prependBasePath } from \"../router\"", "n_tokens": 192, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 14], "def_symbols": [], "symbols": ["import", "from", "lingui", "core", "macro", "Trans", "react", "lib", "utils", "buttonVariants", "components", "button", "Input", "input", "Label", "label", "KeyIcon", "LoaderCircle", "LockIcon", "LogInIcon", "MailIcon", "lucide", "authenticated", "stores", "valibot", "toast", "use", "Dialog", "DialogContent", "DialogTrigger", "DialogHeader", "DialogTitle", "dialog", "useCallback", "useEffect", "useState", "AuthMethodsList", "AuthProviderInfo", "OAuth2AuthConfig", "pocketbase", "router", "Link", "prependBasePath"], "doc_head": "import { t } from \"@lingui/core/macro\"\nimport { Trans } from \"@lingui/react/macro\"\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport { KeyIcon, LoaderCircle, LockIcon, LogInIcon, MailIcon } from \"lucide-react\"\nimport { $authenticated } from \"@/lib/stores\"\nimport * as v from \"valibot\"\nimport { toast } from \"../ui/use-toast\"\nimport { Dialog, DialogContent, DialogTrigger, DialogHeader, DialogTitle } from \"@/components/ui/dialog\"\nimport { useCallback, useEffect, useState } from \"react\"\nimport { AuthMethodsList, AuthProviderInfo, OAuth2AuthConfig } from \"pocketbase\"\nimport { $router, Link, prependBasePath } from \"../router\""}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx", "rel_path": "src/site/src/components/login/auth-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 2, "start_line": 15, "end_line": 39, "text": "import { getPagePath } from \"@nanostores/router\"\nimport { pb } from \"@/lib/api\"\nimport { OtpInputForm } from \"./otp-forms\"\n\nconst honeypot = v.literal(\"\")\nconst emailSchema = v.pipe(v.string(), v.email(t`Invalid email address.`))\nconst passwordSchema = v.pipe(\n\tv.string(),\n\tv.minLength(8, t`Password must be at least 8 characters.`),\n\tv.maxBytes(72, t`Password must be less than 72 bytes.`)\n)\n\nconst LoginSchema = v.looseObject({\n\tname: honeypot,\n\temail: emailSchema,\n\tpassword: passwordSchema,\n})\n\nconst RegisterSchema = v.looseObject({\n\tname: honeypot,\n\temail: emailSchema,\n\tpassword: passwordSchema,\n\tpasswordConfirm: passwordSchema,\n})\n", "n_tokens": 164, "primary_symbol": "", "primary_kind": "", "primary_span": [15, 39], "def_symbols": [], "symbols": ["import", "getPagePath", "from", "nanostores", "router", "lib", "api", "OtpInputForm", "otp", "forms", "const", "honeypot", "literal", "emailSchema", "pipe", "string", "email", "Invalid", "address", "passwordSchema", "minLength", "Password", "must", "least", "characters", "maxBytes", "less", "than", "bytes", "LoginSchema", "looseObject", "name", "password", "RegisterSchema", "passwordConfirm"], "doc_head": "import { getPagePath } from \"@nanostores/router\"\nimport { pb } from \"@/lib/api\"\nimport { OtpInputForm } from \"./otp-forms\"\nconst honeypot = v.literal(\"\")\nconst emailSchema = v.pipe(v.string(), v.email(t`Invalid email address.`))\nconst passwordSchema = v.pipe(\n\tv.string(),\n\tv.minLength(8, t`Password must be at least 8 characters.`),\n\tv.maxBytes(72, t`Password must be less than 72 bytes.`)\n)\nconst LoginSchema = v.looseObject({\n\tname: honeypot,\n\temail: emailSchema,\n\tpassword: passwordSchema,\n})\nconst RegisterSchema = v.looseObject({\n\tname: honeypot,\n\temail: emailSchema,\n\tpassword: passwordSchema,\n\tpasswordConfirm: passwordSchema,\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx", "rel_path": "src/site/src/components/login/auth-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 3, "start_line": 40, "end_line": 65, "text": "export const showLoginFaliedToast = (description?: string) => {\n\tdescription ||= t`Please check your credentials and try again`\n\ttoast({\n\t\ttitle: t`Login attempt failed`,\n\t\tdescription,\n\t\tvariant: \"destructive\",\n\t})\n}\n\nconst getAuthProviderIcon = (provider: AuthProviderInfo) => {\n\tlet { name } = provider\n\tif (name.startsWith(\"oidc\")) {\n\t\tname = \"oidc\"\n\t}\n\treturn prependBasePath(`/_/images/oauth2/${name}.svg`)\n}\n\nexport function UserAuthForm({\n\tclassName,\n\tisFirstRun,\n\tauthMethods,\n\t...props\n}: {\n\tclassName?: string\n\tisFirstRun: boolean\n\tauthMethods: AuthMethodsList", "n_tokens": 145, "primary_symbol": "UserAuthForm", "primary_kind": "function", "primary_span": [57, 65], "def_symbols": ["UserAuthForm", "getAuthProviderIcon"], "symbols": ["UserAuthForm", "getAuthProviderIcon", "export", "const", "showLoginFaliedToast", "description", "string", "Please", "check", "your", "credentials", "and", "try", "again", "toast", "title", "Login", "attempt", "failed", "variant", "destructive", "provider", "AuthProviderInfo", "let", "name", "startsWith", "oidc", "return", "prependBasePath", "images", "oauth2", "svg", "function", "className", "isFirstRun", "authMethods", "props", "boolean", "AuthMethodsList"], "doc_head": "export const showLoginFaliedToast = (description?: string) => {\n\tdescription ||= t`Please check your credentials and try again`\n\ttoast({\n\t\ttitle: t`Login attempt failed`,\n\t\tdescription,\n\t\tvariant: \"destructive\",\n\t})\n}\nconst getAuthProviderIcon = (provider: AuthProviderInfo) => {\n\tlet { name } = provider\n\tif (name.startsWith(\"oidc\")) {\n\t\tname = \"oidc\"\n\t}\n\treturn prependBasePath(`/_/images/oauth2/${name}.svg`)\n}\nexport function UserAuthForm({\n\tclassName,\n\tisFirstRun,\n\tauthMethods,\n\t...props\n}: {\n\tclassName?: string\n\tisFirstRun: boolean\n\tauthMethods: AuthMethodsList"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx", "rel_path": "src/site/src/components/login/auth-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 4, "start_line": 66, "end_line": 83, "text": "}) {\n\tconst [isLoading, setIsLoading] = useState<boolean>(false)\n\tconst [isOauthLoading, setIsOauthLoading] = useState<boolean>(false)\n\tconst [errors, setErrors] = useState<Record<string, string | undefined>>({})\n\tconst [mfaId, setMfaId] = useState<string | undefined>()\n\tconst [otpId, setOtpId] = useState<string | undefined>()\n\n\tconst handleSubmit = useCallback(\n\t\tasync (e: React.FormEvent<HTMLFormElement>) => {\n\t\t\te.preventDefault()\n\t\t\tsetIsLoading(true)\n\t\t\t// store email for later use if mfa is enabled\n\t\t\tlet email = \"\"\n\t\t\ttry {\n\t\t\t\tconst formData = new FormData(e.target as HTMLFormElement)\n\t\t\t\tconst data = Object.fromEntries(formData) as Record<string, any>\n\t\t\t\tconst Schema = isFirstRun ? RegisterSchema : LoginSchema\n\t\t\t\tconst result = v.safeParse(Schema, data)", "n_tokens": 188, "primary_symbol": "", "primary_kind": "", "primary_span": [66, 83], "def_symbols": [], "symbols": ["const", "isLoading", "setIsLoading", "useState", "boolean", "false", "isOauthLoading", "setIsOauthLoading", "errors", "setErrors", "Record", "string", "undefined", "mfaId", "setMfaId", "otpId", "setOtpId", "handleSubmit", "useCallback", "async", "React", "FormEvent", "HTMLFormElement", "preventDefault", "true", "store", "email", "for", "later", "use", "mfa", "enabled", "let", "try", "formData", "new", "FormData", "target", "data", "Object", "fromEntries", "any", "Schema", "isFirstRun", "RegisterSchema", "LoginSchema", "result", "safeParse"], "doc_head": "}) {\n\tconst [isLoading, setIsLoading] = useState<boolean>(false)\n\tconst [isOauthLoading, setIsOauthLoading] = useState<boolean>(false)\n\tconst [errors, setErrors] = useState<Record<string, string | undefined>>({})\n\tconst [mfaId, setMfaId] = useState<string | undefined>()\n\tconst [otpId, setOtpId] = useState<string | undefined>()\n\tconst handleSubmit = useCallback(\n\t\tasync (e: React.FormEvent<HTMLFormElement>) => {\n\t\t\te.preventDefault()\n\t\t\tsetIsLoading(true)\n\t\t\t// store email for later use if mfa is enabled\n\t\t\tlet email = \"\"\n\t\t\ttry {\n\t\t\t\tconst formData = new FormData(e.target as HTMLFormElement)\n\t\t\t\tconst data = Object.fromEntries(formData) as Record<string, any>\n\t\t\t\tconst Schema = isFirstRun ? RegisterSchema : LoginSchema\n\t\t\t\tconst result = v.safeParse(Schema, data)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx", "rel_path": "src/site/src/components/login/auth-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 5, "start_line": 84, "end_line": 111, "text": "\t\t\t\tif (!result.success) {\n\t\t\t\t\tconsole.log(result)\n\t\t\t\t\tlet errors = {}\n\t\t\t\t\tfor (const issue of result.issues) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\terrors[issue.path[0].key] = issue.message\n\t\t\t\t\t}\n\t\t\t\t\tsetErrors(errors)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconst { password, passwordConfirm } = result.output\n\t\t\t\temail = result.output.email\n\t\t\t\tif (isFirstRun) {\n\t\t\t\t\t// check that passwords match\n\t\t\t\t\tif (password !== passwordConfirm) {\n\t\t\t\t\t\tlet msg = \"Passwords do not match\"\n\t\t\t\t\t\tsetErrors({ passwordConfirm: msg })\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tawait pb.send(\"/api/beszel/create-user\", {\n\t\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\t\tbody: JSON.stringify({ email, password }),\n\t\t\t\t\t})\n\t\t\t\t\tawait pb.collection(\"users\").authWithPassword(email, password)\n\t\t\t\t} else {\n\t\t\t\t\tawait pb.collection(\"users\").authWithPassword(email, password)\n\t\t\t\t}\n\t\t\t\t$authenticated.set(true)", "n_tokens": 207, "primary_symbol": "", "primary_kind": "", "primary_span": [84, 111], "def_symbols": [], "symbols": ["result", "success", "console", "log", "let", "errors", "for", "const", "issue", "issues", "ignore", "path", "key", "message", "setErrors", "return", "password", "passwordConfirm", "output", "email", "isFirstRun", "check", "that", "passwords", "match", "msg", "Passwords", "not", "await", "send", "api", "beszel", "create", "user", "method", "POST", "body", "JSON", "stringify", "collection", "users", "authWithPassword", "else", "authenticated", "set", "true"], "doc_head": "\t\t\t\tif (!result.success) {\n\t\t\t\t\tconsole.log(result)\n\t\t\t\t\tlet errors = {}\n\t\t\t\t\tfor (const issue of result.issues) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\terrors[issue.path[0].key] = issue.message\n\t\t\t\t\t}\n\t\t\t\t\tsetErrors(errors)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconst { password, passwordConfirm } = result.output\n\t\t\t\temail = result.output.email\n\t\t\t\tif (isFirstRun) {\n\t\t\t\t\t// check that passwords match\n\t\t\t\t\tif (password !== passwordConfirm) {\n\t\t\t\t\t\tlet msg = \"Passwords do not match\"\n\t\t\t\t\t\tsetErrors({ passwordConfirm: msg })\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tawait pb.send(\"/api/beszel/create-user\", {\n\t\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\t\tbody: JSON.stringify({ email, password }),\n\t\t\t\t\t})\n\t\t\t\t\tawait pb.collection(\"users\").authWithPassword(email, password)\n\t\t\t\t} else {\n\t\t\t\t\tawait pb.collection(\"users\").authWithPassword(email, password)\n\t\t\t\t}\n\t\t\t\t$authenticated.set(true)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx", "rel_path": "src/site/src/components/login/auth-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 6, "start_line": 112, "end_line": 142, "text": "\t\t\t} catch (err: any) {\n\t\t\t\tconst mfaId = err?.response?.mfaId\n\t\t\t\tif (!mfaId) {\n\t\t\t\t\tshowLoginFaliedToast()\n\t\t\t\t\tthrow err\n\t\t\t\t}\n\t\t\t\tsetMfaId(mfaId)\n\t\t\t\ttry {\n\t\t\t\t\tconst { otpId } = await pb.collection(\"users\").requestOTP(email)\n\t\t\t\t\tsetOtpId(otpId)\n\t\t\t\t} catch (err) {\n\t\t\t\t\tconsole.log({ err })\n\t\t\t\t\tshowLoginFaliedToast()\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tsetIsLoading(false)\n\t\t\t}\n\t\t},\n\t\t[isFirstRun]\n\t)\n\n\tif (!authMethods) {\n\t\treturn null\n\t}\n\n\tconst authProviders = authMethods.oauth2.providers ?? []\n\tconst oauthEnabled = authMethods.oauth2.enabled && authProviders.length > 0\n\tconst passwordEnabled = authMethods.password.enabled\n\tconst otpEnabled = authMethods.otp.enabled\n\tconst mfaEnabled = authMethods.mfa.enabled\n", "n_tokens": 204, "primary_symbol": "", "primary_kind": "", "primary_span": [112, 142], "def_symbols": [], "symbols": ["catch", "err", "any", "const", "mfaId", "response", "showLoginFaliedToast", "throw", "setMfaId", "try", "otpId", "await", "collection", "users", "requestOTP", "email", "setOtpId", "console", "log", "finally", "setIsLoading", "false", "isFirstRun", "authMethods", "return", "null", "authProviders", "oauth2", "providers", "oauthEnabled", "enabled", "length", "passwordEnabled", "password", "otpEnabled", "otp", "mfaEnabled", "mfa"], "doc_head": "\t\t\t} catch (err: any) {\n\t\t\t\tconst mfaId = err?.response?.mfaId\n\t\t\t\tif (!mfaId) {\n\t\t\t\t\tshowLoginFaliedToast()\n\t\t\t\t\tthrow err\n\t\t\t\t}\n\t\t\t\tsetMfaId(mfaId)\n\t\t\t\ttry {\n\t\t\t\t\tconst { otpId } = await pb.collection(\"users\").requestOTP(email)\n\t\t\t\t\tsetOtpId(otpId)\n\t\t\t\t} catch (err) {\n\t\t\t\t\tconsole.log({ err })\n\t\t\t\t\tshowLoginFaliedToast()\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tsetIsLoading(false)\n\t\t\t}\n\t\t},\n\t\t[isFirstRun]\n\t)\n\tif (!authMethods) {\n\t\treturn null\n\t}\n\tconst authProviders = authMethods.oauth2.providers ?? []\n\tconst oauthEnabled = authMethods.oauth2.enabled && authProviders.length > 0\n\tconst passwordEnabled = authMethods.password.enabled\n\tconst otpEnabled = authMethods.otp.enabled\n\tconst mfaEnabled = authMethods.mfa.enabled"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx", "rel_path": "src/site/src/components/login/auth-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 7, "start_line": 143, "end_line": 164, "text": "\tfunction loginWithOauth(provider: AuthProviderInfo, forcePopup = false) {\n\t\tsetIsOauthLoading(true)\n\t\tconst oAuthOpts: OAuth2AuthConfig = {\n\t\t\tprovider: provider.name,\n\t\t}\n\t\t// https://github.com/pocketbase/pocketbase/discussions/2429#discussioncomment-5943061\n\t\tif (forcePopup || navigator.userAgent.match(/iPhone|iPad|iPod/i)) {\n\t\t\tconst authWindow = window.open()\n\t\t\tif (!authWindow) {\n\t\t\t\tsetIsOauthLoading(false)\n\t\t\t\ttoast({\n\t\t\t\t\ttitle: t`Error`,\n\t\t\t\t\tdescription: t`Please enable pop-ups for this site`,\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t\toAuthOpts.urlCallback = (url) => {\n\t\t\t\tauthWindow.location.href = url\n\t\t\t}\n\t\t}\n\t\tpb.collection(\"users\")\n\t\t\t.authWithOAuth2(oAuthOpts)", "n_tokens": 190, "primary_symbol": "loginWithOauth", "primary_kind": "function", "primary_span": [143, 164], "def_symbols": ["loginWithOauth"], "symbols": ["loginWithOauth", "function", "provider", "AuthProviderInfo", "forcePopup", "false", "setIsOauthLoading", "true", "const", "oAuthOpts", "OAuth2AuthConfig", "name", "https", "github", "com", "pocketbase", "discussions", "discussioncomment", "navigator", "userAgent", "match", "iPhone", "iPad", "iPod", "authWindow", "window", "open", "toast", "title", "Error", "description", "Please", "enable", "pop", "ups", "for", "this", "site", "return", "urlCallback", "url", "location", "href", "collection", "users", "authWithOAuth2"], "doc_head": "\tfunction loginWithOauth(provider: AuthProviderInfo, forcePopup = false) {\n\t\tsetIsOauthLoading(true)\n\t\tconst oAuthOpts: OAuth2AuthConfig = {\n\t\t\tprovider: provider.name,\n\t\t}\n\t\t// https://github.com/pocketbase/pocketbase/discussions/2429#discussioncomment-5943061\n\t\tif (forcePopup || navigator.userAgent.match(/iPhone|iPad|iPod/i)) {\n\t\t\tconst authWindow = window.open()\n\t\t\tif (!authWindow) {\n\t\t\t\tsetIsOauthLoading(false)\n\t\t\t\ttoast({\n\t\t\t\t\ttitle: t`Error`,\n\t\t\t\t\tdescription: t`Please enable pop-ups for this site`,\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t\toAuthOpts.urlCallback = (url) => {\n\t\t\t\tauthWindow.location.href = url\n\t\t\t}\n\t\t}\n\t\tpb.collection(\"users\")\n\t\t\t.authWithOAuth2(oAuthOpts)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx", "rel_path": "src/site/src/components/login/auth-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 8, "start_line": 165, "end_line": 191, "text": "\t\t\t.then(() => {\n\t\t\t\t$authenticated.set(pb.authStore.isValid)\n\t\t\t})\n\t\t\t.catch(showLoginFaliedToast)\n\t\t\t.finally(() => {\n\t\t\t\tsetIsOauthLoading(false)\n\t\t\t})\n\t}\n\n\tuseEffect(() => {\n\t\t// auto login if password disabled and only one auth provider\n\t\tif (!passwordEnabled && authProviders.length === 1 && !sessionStorage.getItem(\"lo\")) {\n\t\t\t// Add a small timeout to ensure browser is ready to handle popups\n\t\t\tsetTimeout(() => {\n\t\t\t\tloginWithOauth(authProviders[0], true)\n\t\t\t}, 300)\n\t\t}\n\t}, [])\n\n\tif (otpId && mfaId) {\n\t\treturn <OtpInputForm otpId={otpId} mfaId={mfaId} />\n\t}\n\n\treturn (\n\t\t<div className={cn(\"grid gap-6\", className)} {...props}>\n\t\t\t{passwordEnabled && (\n\t\t\t\t<>", "n_tokens": 197, "primary_symbol": "", "primary_kind": "", "primary_span": [165, 191], "def_symbols": [], "symbols": ["then", "authenticated", "set", "authStore", "isValid", "catch", "showLoginFaliedToast", "finally", "setIsOauthLoading", "false", "useEffect", "auto", "login", "password", "disabled", "and", "only", "one", "auth", "provider", "passwordEnabled", "authProviders", "length", "sessionStorage", "getItem", "Add", "small", "timeout", "ensure", "browser", "ready", "handle", "popups", "setTimeout", "loginWithOauth", "true", "otpId", "mfaId", "return", "OtpInputForm", "div", "className", "grid", "gap", "props"], "doc_head": "\t\t\t.then(() => {\n\t\t\t\t$authenticated.set(pb.authStore.isValid)\n\t\t\t})\n\t\t\t.catch(showLoginFaliedToast)\n\t\t\t.finally(() => {\n\t\t\t\tsetIsOauthLoading(false)\n\t\t\t})\n\t}\n\tuseEffect(() => {\n\t\t// auto login if password disabled and only one auth provider\n\t\tif (!passwordEnabled && authProviders.length === 1 && !sessionStorage.getItem(\"lo\")) {\n\t\t\t// Add a small timeout to ensure browser is ready to handle popups\n\t\t\tsetTimeout(() => {\n\t\t\t\tloginWithOauth(authProviders[0], true)\n\t\t\t}, 300)\n\t\t}\n\t}, [])\n\tif (otpId && mfaId) {\n\t\treturn <OtpInputForm otpId={otpId} mfaId={mfaId} />\n\t}\n\treturn (\n\t\t<div className={cn(\"grid gap-6\", className)} {...props}>\n\t\t\t{passwordEnabled && (\n\t\t\t\t<>"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx", "rel_path": "src/site/src/components/login/auth-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 9, "start_line": 192, "end_line": 289, "text": "\t\t\t\t\t<form onSubmit={handleSubmit} onChange={() => setErrors({})}>\n\t\t\t\t\t\t<div className=\"grid gap-2.5\">\n\t\t\t\t\t\t\t<div className=\"grid gap-1 relative\">\n\t\t\t\t\t\t\t\t<MailIcon className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t<Label className=\"sr-only\" htmlFor=\"email\">\n\t\t\t\t\t\t\t\t\t<Trans>Email</Trans>\n\t\t\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\tid=\"email\"\n\t\t\t\t\t\t\t\t\tname=\"email\"\n\t\t\t\t\t\t\t\t\trequired\n\t\t\t\t\t\t\t\t\tplaceholder=\"name@example.com\"\n\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\tautoCapitalize=\"none\"\n\t\t\t\t\t\t\t\t\tautoComplete=\"email\"\n\t\t\t\t\t\t\t\t\tautoCorrect=\"off\"\n\t\t\t\t\t\t\t\t\tdisabled={isLoading || isOauthLoading}\n\t\t\t\t\t\t\t\t\tclassName={cn(\"ps-9\", errors?.email && \"border-red-500\")}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t{errors?.email && <p className=\"px-1 text-xs text-red-600\">{errors.email}</p>}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div className=\"grid gap-1 relative\">\n\t\t\t\t\t\t\t\t<LockIcon className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t<Label className=\"sr-only\" htmlFor=\"pass\">\n\t\t\t\t\t\t\t\t\t<Trans>Password</Trans>\n\t\t\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\tid=\"pass\"\n\t\t\t\t\t\t\t\t\tname=\"password\"\n\t\t\t\t\t\t\t\t\tplaceholder={t`Password`}\n\t\t\t\t\t\t\t\t\trequired\n\t\t\t\t\t\t\t\t\ttype=\"password\"\n\t\t\t\t\t\t\t\t\tautoComplete=\"current-password\"\n\t\t\t\t\t\t\t\t\tdisabled={isLoading || isOauthLoading}\n\t\t\t\t\t\t\t\t\tclassName={cn(\"ps-9\", errors?.password && \"border-red-500\")}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t{errors?.password && <p className=\"px-1 text-xs text-red-600\">{errors.password}</p>}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t{isFirstRun && (\n\t\t\t\t\t\t\t\t<div className=\"grid gap-1 relative\">\n\t\t\t\t\t\t\t\t\t<LockIcon className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t\t<Label className=\"sr-only\" htmlFor=\"pass2\">\n\t\t\t\t\t\t\t\t\t\t<Trans>Confirm password</Trans>\n\t\t\t\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\t\tid=\"pass2\"\n\t\t\t\t\t\t\t\t\t\tname=\"passwordConfirm\"\n\t\t\t\t\t\t\t\t\t\tplaceholder={t`Confirm password`}\n\t\t\t\t\t\t\t\t\t\trequired\n\t\t\t\t\t\t\t\t\t\ttype=\"password\"\n\t\t\t\t\t\t\t\t\t\tautoComplete=\"current-password\"\n\t\t\t\t\t\t\t\t\t\tdisabled={isLoading || isOauthLoading}\n\t\t\t\t\t\t\t\t\t\tclassName={cn(\"ps-9\", errors?.password && \"border-red-500\")}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t{errors?.passwordConfirm && <p className=\"px-1 text-xs text-red-600\">{errors.passwordConfirm}</p>}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t<div className=\"sr-only\">\n\t\t\t\t\t\t\t\t{/* honeypot */}\n\t\t\t\t\t\t\t\t<label htmlFor=\"name\"></label>\n\t\t\t\t\t\t\t\t<input id=\"name\" type=\"text\" name=\"name\" tabIndex={-1} autoComplete=\"off\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<button className={cn(buttonVariants())} disabled={isLoading}>\n\t\t\t\t\t\t\t\t{isLoading ? (\n\t\t\t\t\t\t\t\t\t<LoaderCircle className=\"me-2 h-4 w-4 animate-spin\" />\n\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t<LogInIcon className=\"me-2 h-4 w-4\" />\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{isFirstRun ? t`Create account` : t`Sign in`}\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</form>\n\t\t\t\t\t{(isFirstRun || oauthEnabled || (otpEnabled && !mfaEnabled)) && (\n\t\t\t\t\t\t// only show 'continue with' during onboarding or if we have auth providers\n\t\t\t\t\t\t<div className=\"relative\">\n\t\t\t\t\t\t\t<div className=\"absolute inset-0 flex items-center\">\n\t\t\t\t\t\t\t\t<span className=\"w-full border-t\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div className=\"relative flex justify-center text-xs uppercase\">\n\t\t\t\t\t\t\t\t<span className=\"bg-background px-2 text-muted-foreground\">\n\t\t\t\t\t\t\t\t\t<Trans>Or continue with</Trans>\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t</>\n\t\t\t)}\n\t\t\t{/* hide OTP button if MFA is enabled (it will be used as MFA) */}\n\t\t\t{otpEnabled && !mfaEnabled && (\n\t\t\t\t<div className=\"grid gap-2 -mt-1\">\n\t\t\t\t\t<Link href=\"/request-otp\" type=\"button\" className={cn(buttonVariants({ variant: \"outline\" }), \"flex gap-2\")}>\n\t\t\t\t\t\t<KeyIcon className=\"size-4\" />\n\t\t\t\t\t\t<Trans>One-time password</Trans>\n\t\t\t\t\t</Link>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t\t{oauthEnabled && (\n\t\t\t\t<div className=\"grid gap-2 -mt-1\">", "n_tokens": 978, "primary_symbol": "", "primary_kind": "", "primary_span": [192, 289], "def_symbols": [], "symbols": ["form", "onSubmit", "handleSubmit", "onChange", "setErrors", "div", "className", "grid", "gap", "relative", "MailIcon", "absolute", "left", "top", "text", "muted", "foreground", "Label", "only", "htmlFor", "email", "Trans", "Email", "Input", "name", "required", "placeholder", "example", "com", "type", "autoCapitalize", "none", "autoComplete", "autoCorrect", "off", "disabled", "isLoading", "isOauthLoading", "errors", "border", "red", "LockIcon", "pass", "Password", "password", "current", "isFirstRun", "pass2", "Confirm", "passwordConfirm", "honeypot", "label", "input", "tabIndex", "button", "buttonVariants", "LoaderCircle", "animate", "spin", "LogInIcon", "Create", "account", "Sign", "oauthEnabled", "otpEnabled", "mfaEnabled", "show", "continue", "with", "during", "onboarding", "have", "auth", "providers", "inset", "flex", "items", "center", "span", "full", "justify", "uppercase", "background", "hide", "OTP", "MFA", "enabled", "will", "used", "Link", "href", "request", "otp", "variant", "outline", "KeyIcon", "size", "One", "time"], "doc_head": "\t\t\t\t\t<form onSubmit={handleSubmit} onChange={() => setErrors({})}>\n\t\t\t\t\t\t<div className=\"grid gap-2.5\">\n\t\t\t\t\t\t\t<div className=\"grid gap-1 relative\">\n\t\t\t\t\t\t\t\t<MailIcon className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t<Label className=\"sr-only\" htmlFor=\"email\">\n\t\t\t\t\t\t\t\t\t<Trans>Email</Trans>\n\t\t\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\tid=\"email\"\n\t\t\t\t\t\t\t\t\tname=\"email\"\n\t\t\t\t\t\t\t\t\trequired\n\t\t\t\t\t\t\t\t\tplaceholder=\"name@example.com\"\n\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\tautoCapitalize=\"none\"\n\t\t\t\t\t\t\t\t\tautoComplete=\"email\"\n\t\t\t\t\t\t\t\t\tautoCorrect=\"off\"\n\t\t\t\t\t\t\t\t\tdisabled={isLoading || isOauthLoading}\n\t\t\t\t\t\t\t\t\tclassName={cn(\"ps-9\", errors?.email && \"border-red-500\")}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t{errors?.email && <p className=\"px-1 text-xs text-red-600\">{errors.email}</p>}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div className=\"grid gap-1 relative\">\n\t\t\t\t\t\t\t\t<LockIcon className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t<Label className=\"sr-only\" htmlFor=\"pass\">\n\t\t\t\t\t\t\t\t\t<Trans>Password</Trans>\n\t\t\t\t\t\t\t\t</Label>\n\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\tid=\"pass\"\n\t\t\t\t\t\t\t\t\tname=\"password\"\n\t\t\t\t\t\t\t\t\tplaceholder={t`Password`}\n\t\t\t\t\t\t\t\t\trequired\n\t\t\t\t\t\t\t\t\ttype=\"password\"\n\t\t\t\t\t\t\t\t\tautoComplete=\"current-password\"\n\t\t\t\t\t\t\t"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx", "rel_path": "src/site/src/components/login/auth-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 10, "start_line": 290, "end_line": 297, "text": "\t\t\t\t\t{authMethods.oauth2.providers.map((provider) => (\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tkey={provider.name}\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\tclassName={cn(buttonVariants({ variant: \"outline\" }), {\n\t\t\t\t\t\t\t\t\"justify-self-center\": !passwordEnabled,\n\t\t\t\t\t\t\t\t\"px-5\": !passwordEnabled,\n\t\t\t\t\t\t\t})}", "n_tokens": 70, "primary_symbol": "", "primary_kind": "", "primary_span": [290, 297], "def_symbols": [], "symbols": ["authMethods", "oauth2", "providers", "map", "provider", "button", "key", "name", "type", "className", "buttonVariants", "variant", "outline", "justify", "self", "center", "passwordEnabled"], "doc_head": "\t\t\t\t\t{authMethods.oauth2.providers.map((provider) => (\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tkey={provider.name}\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\tclassName={cn(buttonVariants({ variant: \"outline\" }), {\n\t\t\t\t\t\t\t\t\"justify-self-center\": !passwordEnabled,\n\t\t\t\t\t\t\t\t\"px-5\": !passwordEnabled,\n\t\t\t\t\t\t\t})}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/components/login/auth-form.tsx", "rel_path": "src/site/src/components/login/auth-form.tsx", "ext": "tsx", "language": "typescript", "chunk_number": 11, "start_line": 298, "end_line": 364, "text": "\t\t\t\t\t\t\tonClick={() => loginWithOauth(provider)}\n\t\t\t\t\t\t\tdisabled={isLoading || isOauthLoading}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{isOauthLoading ? (\n\t\t\t\t\t\t\t\t<LoaderCircle className=\"me-2 h-4 w-4 animate-spin\" />\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t<img\n\t\t\t\t\t\t\t\t\tclassName=\"me-2 h-4 w-4 dark:brightness-0 dark:invert\"\n\t\t\t\t\t\t\t\t\tsrc={getAuthProviderIcon(provider)}\n\t\t\t\t\t\t\t\t\talt=\"\"\n\t\t\t\t\t\t\t\t\t// onError={(e) => {\n\t\t\t\t\t\t\t\t\t// \te.currentTarget.src = \"/static/lock.svg\"\n\t\t\t\t\t\t\t\t\t// }}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t<span className=\"translate-y-px\">{provider.displayName}</span>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t)}\n\t\t\t{!oauthEnabled && isFirstRun && (\n\t\t\t\t// only show GitHub button / dialog during onboarding\n\t\t\t\t<Dialog>\n\t\t\t\t\t<DialogTrigger asChild>\n\t\t\t\t\t\t<button type=\"button\" className={cn(buttonVariants({ variant: \"outline\" }))}>\n\t\t\t\t\t\t\t<img className=\"me-2 h-4 w-4 dark:invert\" src={prependBasePath(\"/_/images/oauth2/github.svg\")} alt=\"\" />\n\t\t\t\t\t\t\t<span className=\"translate-y-px\">GitHub</span>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</DialogTrigger>\n\t\t\t\t\t<DialogContent style={{ maxWidth: 440, width: \"90%\" }}>\n\t\t\t\t\t\t<DialogHeader>\n\t\t\t\t\t\t\t<DialogTitle>\n\t\t\t\t\t\t\t\t<Trans>OAuth 2 / OIDC support</Trans>\n\t\t\t\t\t\t\t</DialogTitle>\n\t\t\t\t\t\t</DialogHeader>\n\t\t\t\t\t\t<div className=\"text-primary/70 text-[0.95em] contents\">\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t<Trans>Beszel supports OpenID Connect and many OAuth2 authentication providers.</Trans>\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t<Trans>\n\t\t\t\t\t\t\t\t\tPlease see{\" \"}\n\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\thref=\"https://beszel.dev/guide/oauth\"\n\t\t\t\t\t\t\t\t\t\tclassName={cn(buttonVariants({ variant: \"link\" }), \"p-0 h-auto\")}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\tthe documentation\n\t\t\t\t\t\t\t\t\t</a>{\" \"}\n\t\t\t\t\t\t\t\t\tfor instructions.\n\t\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</DialogContent>\n\t\t\t\t</Dialog>\n\t\t\t)}\n\t\t\t{passwordEnabled && !isFirstRun && (\n\t\t\t\t<Link\n\t\t\t\t\thref={getPagePath($router, \"forgot_password\")}\n\t\t\t\t\tclassName=\"text-sm mx-auto hover:text-brand underline underline-offset-4 opacity-70 hover:opacity-100 transition-opacity\"\n\t\t\t\t>\n\t\t\t\t\t<Trans>Forgot password?</Trans>\n\t\t\t\t</Link>\n\t\t\t)}\n\t\t</div>\n\t)\n}\n", "n_tokens": 559, "primary_symbol": "", "primary_kind": "", "primary_span": [298, 364], "def_symbols": [], "symbols": ["onClick", "loginWithOauth", "provider", "disabled", "isLoading", "isOauthLoading", "LoaderCircle", "className", "animate", "spin", "img", "dark", "brightness", "invert", "src", "getAuthProviderIcon", "alt", "onError", "currentTarget", "static", "lock", "svg", "span", "translate", "displayName", "button", "div", "oauthEnabled", "isFirstRun", "only", "show", "GitHub", "dialog", "during", "onboarding", "Dialog", "DialogTrigger", "asChild", "type", "buttonVariants", "variant", "outline", "prependBasePath", "images", "oauth2", "github", "DialogContent", "style", "maxWidth", "width", "DialogHeader", "DialogTitle", "Trans", "OAuth", "OIDC", "support", "text", "primary", "contents", "Beszel", "supports", "OpenID", "Connect", "and", "many", "OAuth2", "authentication", "providers", "Please", "see", "href", "https", "beszel", "dev", "guide", "oauth", "link", "auto", "the", "documentation", "for", "instructions", "passwordEnabled", "Link", "getPagePath", "router", "forgot_password", "hover", "brand", "underline", "offset", "opacity", "transition", "Forgot", "password"], "doc_head": "\t\t\t\t\t\t\tonClick={() => loginWithOauth(provider)}\n\t\t\t\t\t\t\tdisabled={isLoading || isOauthLoading}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{isOauthLoading ? (\n\t\t\t\t\t\t\t\t<LoaderCircle className=\"me-2 h-4 w-4 animate-spin\" />\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t<img\n\t\t\t\t\t\t\t\t\tclassName=\"me-2 h-4 w-4 dark:brightness-0 dark:invert\"\n\t\t\t\t\t\t\t\t\tsrc={getAuthProviderIcon(provider)}\n\t\t\t\t\t\t\t\t\talt=\"\"\n\t\t\t\t\t\t\t\t\t// onError={(e) => {\n\t\t\t\t\t\t\t\t\t// \te.currentTarget.src = \"/static/lock.svg\"\n\t\t\t\t\t\t\t\t\t// }}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t<span className=\"translate-y-px\">{provider.displayName}</span>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t)}\n\t\t\t{!oauthEnabled && isFirstRun && (\n\t\t\t\t// only show GitHub button / dialog during onboarding\n\t\t\t\t<Dialog>\n\t\t\t\t\t<DialogTrigger asChild>\n\t\t\t\t\t\t<button type=\"button\" className={cn(buttonVariants({ variant: \"outline\" }))}>\n\t\t\t\t\t\t\t<img className=\"me-2 h-4 w-4 dark:invert\" src={prependBasePath(\"/_/images/oauth2/github.svg\")} alt=\"\" />\n\t\t\t\t\t\t\t<span className=\"translate-y-px\">GitHub</span>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</DialogTrigger>\n\t\t\t\t\t<DialogContent style={{ maxWidth: 440, width: \"90%\" }}>\n\t\t\t\t\t\t<DialogHeader>\n\t\t\t\t\t\t\t<DialogTitle>\n\t\t\t\t\t\t\t\t<Trans>OAuth 2 / OIDC support</Trans>\n\t\t\t\t\t\t\t</DialogTitle>\n\t\t\t\t\t\t</DialogHeader>\n\t\t\t\t\t\t<"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/languages.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/languages.ts", "rel_path": "src/site/src/lib/languages.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 138, "text": "export default [\n\t{\n\t\tlang: \"ar\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"bg\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"cs\",\n\t\tlabel: \"etina\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"da\",\n\t\tlabel: \"Dansk\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"de\",\n\t\tlabel: \"Deutsch\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"en\",\n\t\tlabel: \"English\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"es\",\n\t\tlabel: \"Espaol\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"fa\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"fr\",\n\t\tlabel: \"Franais\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"hr\",\n\t\tlabel: \"Hrvatski\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"hu\",\n\t\tlabel: \"Magyar\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"it\",\n\t\tlabel: \"Italiano\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"ja\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"ko\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"nl\",\n\t\tlabel: \"Nederlands\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"no\",\n\t\tlabel: \"Norsk\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"pl\",\n\t\tlabel: \"Polski\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"pt\",\n\t\tlabel: \"Portugus\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"tr\",\n\t\tlabel: \"Trke\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"ru\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"sl\",\n\t\tlabel: \"Slovenina\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"sv\",\n\t\tlabel: \"Svenska\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"uk\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"vi\",\n\t\tlabel: \"Ting Vit\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"zh-CN\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"zh-HK\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"zh\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n] as const\n", "n_tokens": 850, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 138], "def_symbols": [], "symbols": ["export", "default", "lang", "label", "Dansk", "Deutsch", "English", "Hrvatski", "Magyar", "Italiano", "Nederlands", "Norsk", "Polski", "Svenska", "const"], "doc_head": "export default [\n\t{\n\t\tlang: \"ar\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"bg\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"cs\",\n\t\tlabel: \"etina\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"da\",\n\t\tlabel: \"Dansk\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"de\",\n\t\tlabel: \"Deutsch\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"en\",\n\t\tlabel: \"English\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"es\",\n\t\tlabel: \"Espaol\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"fa\",\n\t\tlabel: \"\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"fr\",\n\t\tlabel: \"Franais\",\n\t\te: \"\",\n\t},\n\t{\n\t\tlang: \"hr\",\n\t\tlabel: \"Hrvatski\",\n\t\te: \"\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts", "rel_path": "src/site/src/lib/use-intersection-observer.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 12, "text": "import { useEffect, useRef, useState } from \"react\"\n\n// adapted from usehooks-ts/use-intersection-observer\n\n/** The hook internal state. */\ntype State = {\n\t/** A boolean indicating if the element is intersecting. */\n\tisIntersecting: boolean\n\t/** The intersection observer entry. */\n\tentry?: IntersectionObserverEntry\n}\n", "n_tokens": 70, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 12], "def_symbols": [], "symbols": ["import", "useEffect", "useRef", "useState", "from", "react", "adapted", "usehooks", "use", "intersection", "observer", "The", "hook", "internal", "state", "type", "State", "boolean", "indicating", "the", "element", "intersecting", "isIntersecting", "entry", "IntersectionObserverEntry"], "doc_head": "import { useEffect, useRef, useState } from \"react\"\n// adapted from usehooks-ts/use-intersection-observer\n/** The hook internal state. */\ntype State = {\n\t/** A boolean indicating if the element is intersecting. */\n\tisIntersecting: boolean\n\t/** The intersection observer entry. */\n\tentry?: IntersectionObserverEntry\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts", "rel_path": "src/site/src/lib/use-intersection-observer.ts", "ext": "ts", "language": "typescript", "chunk_number": 2, "start_line": 13, "end_line": 56, "text": "/** Represents the options for configuring the Intersection Observer. */\ntype UseIntersectionObserverOptions = {\n\t/**\n\t * The element that is used as the viewport for checking visibility of the target.\n\t * @default null\n\t */\n\troot?: Element | Document | null\n\t/**\n\t * A margin around the root.\n\t * @default '0%'\n\t */\n\trootMargin?: string\n\t/**\n\t * A threshold indicating the percentage of the target's visibility needed to trigger the callback.\n\t * @default 0\n\t */\n\tthreshold?: number | number[]\n\t/**\n\t * If true, freezes the intersection state once the element becomes visible.\n\t * @default true\n\t */\n\tfreeze?: boolean\n\t/**\n\t * A callback function to be invoked when the intersection state changes.\n\t * @param {boolean} isIntersecting - A boolean indicating if the element is intersecting.\n\t * @param {IntersectionObserverEntry} entry - The intersection observer Entry.\n\t * @default undefined\n\t */\n\tonChange?: (isIntersecting: boolean, entry: IntersectionObserverEntry) => void\n\t/**\n\t * The initial state of the intersection.\n\t * @default false\n\t */\n\tinitialIsIntersecting?: boolean\n}\n\n/**\n * The return type of the useIntersectionObserver hook.\n *\n * Supports both tuple and object destructing.\n * @param {(node: Element | null) => void} ref - The ref callback function.\n * @param {boolean} isIntersecting - A boolean indicating if the element is intersecting.\n * @param {IntersectionObserverEntry | undefined} entry - The intersection observer Entry.\n */", "n_tokens": 333, "primary_symbol": "", "primary_kind": "", "primary_span": [13, 56], "def_symbols": [], "symbols": ["Represents", "the", "options", "for", "configuring", "Intersection", "Observer", "type", "UseIntersectionObserverOptions", "The", "element", "that", "used", "viewport", "checking", "visibility", "target", "default", "null", "root", "Element", "Document", "margin", "around", "rootMargin", "string", "threshold", "indicating", "percentage", "needed", "trigger", "callback", "number", "true", "freezes", "intersection", "state", "once", "becomes", "visible", "freeze", "boolean", "function", "invoked", "when", "changes", "param", "isIntersecting", "intersecting", "IntersectionObserverEntry", "entry", "observer", "Entry", "undefined", "onChange", "void", "initial", "false", "initialIsIntersecting", "return", "useIntersectionObserver", "hook", "Supports", "both", "tuple", "and", "object", "destructing", "node", "ref"], "doc_head": "/** Represents the options for configuring the Intersection Observer. */\ntype UseIntersectionObserverOptions = {\n\t/**\n\t * The element that is used as the viewport for checking visibility of the target.\n\t * @default null\n\t */\n\troot?: Element | Document | null\n\t/**\n\t * A margin around the root.\n\t * @default '0%'\n\t */\n\trootMargin?: string\n\t/**\n\t * A threshold indicating the percentage of the target's visibility needed to trigger the callback.\n\t * @default 0\n\t */\n\tthreshold?: number | number[]\n\t/**\n\t * If true, freezes the intersection state once the element becomes visible.\n\t * @default true\n\t */\n\tfreeze?: boolean\n\t/**\n\t * A callback function to be invoked when the intersection state changes.\n\t * @param {boolean} isIntersecting - A boolean indicating if the element is intersecting.\n\t * @param {IntersectionObserverEntry} entry - The intersection observer Entry.\n\t * @default undefined\n\t */\n\tonChange?: (isIntersecting: boolean, entry: IntersectionObserverEntry) => void\n\t/**\n\t * The initial state of the intersection.\n\t * @default false\n\t */\n\tinitialIsIntersecting?: boolean\n}\n/**\n * The return type of the useIntersectionObserver hook.\n *\n * Supports both tuple and object destructing.\n * @p"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts", "rel_path": "src/site/src/lib/use-intersection-observer.ts", "ext": "ts", "language": "typescript", "chunk_number": 3, "start_line": 57, "end_line": 78, "text": "type IntersectionReturn = {\n\tref: (node?: Element | null) => void\n\tisIntersecting: boolean\n\tentry?: IntersectionObserverEntry\n}\n\n/**\n * Custom hook that tracks the intersection of a DOM element with its containing element or the viewport using the [`Intersection Observer API`](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).\n * @param {UseIntersectionObserverOptions} options - The options for the Intersection Observer.\n * @returns {IntersectionReturn} The ref callback, a boolean indicating if the element is intersecting, and the intersection observer entry.\n * @example\n * ```tsx\n * const { ref, isIntersecting, entry } = useIntersectionObserver({ threshold: 0.5 });\n * ```\n */\nexport function useIntersectionObserver({\n\tthreshold = 0,\n\troot = null,\n\trootMargin = \"0%\",\n\tfreeze = true,\n\tinitialIsIntersecting = false,\n\tonChange,", "n_tokens": 191, "primary_symbol": "useIntersectionObserver", "primary_kind": "function", "primary_span": [72, 78], "def_symbols": ["useIntersectionObserver"], "symbols": ["useIntersectionObserver", "type", "IntersectionReturn", "ref", "node", "Element", "null", "void", "isIntersecting", "boolean", "entry", "IntersectionObserverEntry", "Custom", "hook", "that", "tracks", "the", "intersection", "DOM", "element", "with", "its", "containing", "viewport", "using", "Intersection", "Observer", "API", "https", "developer", "mozilla", "org", "docs", "Web", "Intersection_Observer_API", "param", "UseIntersectionObserverOptions", "options", "The", "for", "returns", "callback", "indicating", "intersecting", "and", "observer", "example", "tsx", "const", "threshold", "export", "function", "root", "rootMargin", "freeze", "true", "initialIsIntersecting", "false", "onChange"], "doc_head": "type IntersectionReturn = {\n\tref: (node?: Element | null) => void\n\tisIntersecting: boolean\n\tentry?: IntersectionObserverEntry\n}\n/**\n * Custom hook that tracks the intersection of a DOM element with its containing element or the viewport using the [`Intersection Observer API`](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).\n * @param {UseIntersectionObserverOptions} options - The options for the Intersection Observer.\n * @returns {IntersectionReturn} The ref callback, a boolean indicating if the element is intersecting, and the intersection observer entry.\n * @example\n * ```tsx\n * const { ref, isIntersecting, entry } = useIntersectionObserver({ threshold: 0.5 });\n * ```\n */\nexport function useIntersectionObserver({\n\tthreshold = 0,\n\troot = null,\n\trootMargin = \"0%\",\n\tfreeze = true,\n\tinitialIsIntersecting = false,\n\tonChange,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts", "rel_path": "src/site/src/lib/use-intersection-observer.ts", "ext": "ts", "language": "typescript", "chunk_number": 4, "start_line": 79, "end_line": 108, "text": "}: UseIntersectionObserverOptions = {}): IntersectionReturn {\n\tconst [ref, setRef] = useState<Element | null>(null)\n\n\tconst [state, setState] = useState<State>(() => ({\n\t\tisIntersecting: initialIsIntersecting,\n\t\tentry: undefined,\n\t}))\n\n\tconst callbackRef = useRef<UseIntersectionObserverOptions[\"onChange\"]>(undefined)\n\n\tcallbackRef.current = onChange\n\n\tconst frozen = state.entry?.isIntersecting && freeze\n\n\tuseEffect(() => {\n\t\t// Ensure we have a ref to observe\n\t\tif (!ref) return\n\n\t\t// Ensure the browser supports the Intersection Observer API\n\t\tif (!(\"IntersectionObserver\" in window)) return\n\n\t\t// Skip if frozen\n\t\tif (frozen) return\n\n\t\tlet unobserve: (() => void) | undefined\n\n\t\tconst observer = new IntersectionObserver(\n\t\t\t(entries: IntersectionObserverEntry[]): void => {\n\t\t\t\tconst thresholds = Array.isArray(observer.thresholds) ? observer.thresholds : [observer.thresholds]\n", "n_tokens": 205, "primary_symbol": "", "primary_kind": "", "primary_span": [79, 108], "def_symbols": [], "symbols": ["UseIntersectionObserverOptions", "IntersectionReturn", "const", "ref", "setRef", "useState", "Element", "null", "state", "setState", "State", "isIntersecting", "initialIsIntersecting", "entry", "undefined", "callbackRef", "useRef", "onChange", "current", "frozen", "freeze", "useEffect", "Ensure", "have", "observe", "return", "the", "browser", "supports", "Intersection", "Observer", "API", "IntersectionObserver", "window", "Skip", "let", "unobserve", "void", "observer", "new", "entries", "IntersectionObserverEntry", "thresholds", "Array", "isArray"], "doc_head": "}: UseIntersectionObserverOptions = {}): IntersectionReturn {\n\tconst [ref, setRef] = useState<Element | null>(null)\n\tconst [state, setState] = useState<State>(() => ({\n\t\tisIntersecting: initialIsIntersecting,\n\t\tentry: undefined,\n\t}))\n\tconst callbackRef = useRef<UseIntersectionObserverOptions[\"onChange\"]>(undefined)\n\tcallbackRef.current = onChange\n\tconst frozen = state.entry?.isIntersecting && freeze\n\tuseEffect(() => {\n\t\t// Ensure we have a ref to observe\n\t\tif (!ref) return\n\t\t// Ensure the browser supports the Intersection Observer API\n\t\tif (!(\"IntersectionObserver\" in window)) return\n\t\t// Skip if frozen\n\t\tif (frozen) return\n\t\tlet unobserve: (() => void) | undefined\n\t\tconst observer = new IntersectionObserver(\n\t\t\t(entries: IntersectionObserverEntry[]): void => {\n\t\t\t\tconst thresholds = Array.isArray(observer.thresholds) ? observer.thresholds : [observer.thresholds]"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts", "rel_path": "src/site/src/lib/use-intersection-observer.ts", "ext": "ts", "language": "typescript", "chunk_number": 5, "start_line": 109, "end_line": 129, "text": "\t\t\t\tentries.forEach((entry) => {\n\t\t\t\t\tconst isIntersecting =\n\t\t\t\t\t\tentry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold)\n\n\t\t\t\t\tsetState({ isIntersecting, entry })\n\n\t\t\t\t\tif (callbackRef.current) {\n\t\t\t\t\t\tcallbackRef.current(isIntersecting, entry)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isIntersecting && freeze && unobserve) {\n\t\t\t\t\t\tunobserve()\n\t\t\t\t\t\tunobserve = undefined\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t},\n\t\t\t{ threshold, root, rootMargin }\n\t\t)\n\n\t\tobserver.observe(ref)\n", "n_tokens": 119, "primary_symbol": "", "primary_kind": "", "primary_span": [109, 129], "def_symbols": [], "symbols": ["entries", "forEach", "entry", "const", "isIntersecting", "thresholds", "some", "threshold", "intersectionRatio", "setState", "callbackRef", "current", "freeze", "unobserve", "undefined", "root", "rootMargin", "observer", "observe", "ref"], "doc_head": "\t\t\t\tentries.forEach((entry) => {\n\t\t\t\t\tconst isIntersecting =\n\t\t\t\t\t\tentry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold)\n\t\t\t\t\tsetState({ isIntersecting, entry })\n\t\t\t\t\tif (callbackRef.current) {\n\t\t\t\t\t\tcallbackRef.current(isIntersecting, entry)\n\t\t\t\t\t}\n\t\t\t\t\tif (isIntersecting && freeze && unobserve) {\n\t\t\t\t\t\tunobserve()\n\t\t\t\t\t\tunobserve = undefined\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t},\n\t\t\t{ threshold, root, rootMargin }\n\t\t)\n\t\tobserver.observe(ref)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts", "rel_path": "src/site/src/lib/use-intersection-observer.ts", "ext": "ts", "language": "typescript", "chunk_number": 6, "start_line": 130, "end_line": 148, "text": "\t\treturn () => {\n\t\t\tobserver.disconnect()\n\t\t}\n\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [\n\t\tref,\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\tJSON.stringify(threshold),\n\t\troot,\n\t\trootMargin,\n\t\tfrozen,\n\t\tfreeze,\n\t])\n\n\t// ensures that if the observed element changes, the intersection observer is reinitialized\n\tconst prevRef = useRef<Element | null>(null)\n\n\tuseEffect(() => {", "n_tokens": 106, "primary_symbol": "", "primary_kind": "", "primary_span": [130, 148], "def_symbols": [], "symbols": ["return", "observer", "disconnect", "eslint", "disable", "next", "line", "react", "hooks", "exhaustive", "deps", "ref", "JSON", "stringify", "threshold", "root", "rootMargin", "frozen", "freeze", "ensures", "that", "the", "observed", "element", "changes", "intersection", "reinitialized", "const", "prevRef", "useRef", "Element", "null", "useEffect"], "doc_head": "\t\treturn () => {\n\t\t\tobserver.disconnect()\n\t\t}\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [\n\t\tref,\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\tJSON.stringify(threshold),\n\t\troot,\n\t\trootMargin,\n\t\tfrozen,\n\t\tfreeze,\n\t])\n\t// ensures that if the observed element changes, the intersection observer is reinitialized\n\tconst prevRef = useRef<Element | null>(null)\n\tuseEffect(() => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/use-intersection-observer.ts", "rel_path": "src/site/src/lib/use-intersection-observer.ts", "ext": "ts", "language": "typescript", "chunk_number": 7, "start_line": 149, "end_line": 161, "text": "\t\tif (!ref && state.entry?.target && !freeze && !frozen && prevRef.current !== state.entry.target) {\n\t\t\tprevRef.current = state.entry.target\n\t\t\tsetState({ isIntersecting: initialIsIntersecting, entry: undefined })\n\t\t}\n\t}, [ref, state.entry, freeze, frozen, initialIsIntersecting])\n\n\treturn {\n\t\tref: setRef,\n\t\tisIntersecting: !!state.isIntersecting,\n\t\tentry: state.entry,\n\t} as IntersectionReturn\n}\n", "n_tokens": 108, "primary_symbol": "", "primary_kind": "", "primary_span": [149, 161], "def_symbols": [], "symbols": ["ref", "state", "entry", "target", "freeze", "frozen", "prevRef", "current", "setState", "isIntersecting", "initialIsIntersecting", "undefined", "return", "setRef", "IntersectionReturn"], "doc_head": "\t\tif (!ref && state.entry?.target && !freeze && !frozen && prevRef.current !== state.entry.target) {\n\t\t\tprevRef.current = state.entry.target\n\t\t\tsetState({ isIntersecting: initialIsIntersecting, entry: undefined })\n\t\t}\n\t}, [ref, state.entry, freeze, frozen, initialIsIntersecting])\n\treturn {\n\t\tref: setRef,\n\t\tisIntersecting: !!state.isIntersecting,\n\t\tentry: state.entry,\n\t} as IntersectionReturn\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/i18n.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/i18n.ts", "rel_path": "src/site/src/lib/i18n.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 23, "text": "import { $direction } from \"./stores\"\nimport { i18n } from \"@lingui/core\"\nimport type { Messages } from \"@lingui/core\"\nimport languages from \"@/lib/languages\"\nimport { detect, fromStorage, fromNavigator } from \"@lingui/detect-locale\"\nimport { messages as enMessages } from \"@/locales/en/en\"\nimport { BatteryState } from \"./enums\"\nimport { t } from \"@lingui/core/macro\"\n\n// activates locale\nfunction activateLocale(locale: string, messages: Messages = enMessages) {\n\ti18n.load(locale, messages)\n\ti18n.activate(locale)\n\tdocument.documentElement.lang = locale\n\tlocalStorage.setItem(\"lang\", locale)\n\t$direction.set(locale.startsWith(\"ar\") || locale.startsWith(\"fa\") ? \"rtl\" : \"ltr\")\n}\n\n// dynamically loads translations for the given locale\nexport async function dynamicActivate(locale: string) {\n\tif (locale == \"en\") {\n\t\tactivateLocale(locale)\n\t} else {", "n_tokens": 201, "primary_symbol": "activateLocale", "primary_kind": "function", "primary_span": [11, 23], "def_symbols": ["activateLocale", "dynamicActivate"], "symbols": ["activateLocale", "dynamicActivate", "import", "direction", "from", "stores", "i18n", "lingui", "core", "type", "Messages", "languages", "lib", "detect", "fromStorage", "fromNavigator", "locale", "messages", "enMessages", "locales", "BatteryState", "enums", "macro", "activates", "function", "string", "load", "activate", "document", "documentElement", "lang", "localStorage", "setItem", "set", "startsWith", "rtl", "ltr", "dynamically", "loads", "translations", "for", "the", "given", "export", "async", "else"], "doc_head": "import { $direction } from \"./stores\"\nimport { i18n } from \"@lingui/core\"\nimport type { Messages } from \"@lingui/core\"\nimport languages from \"@/lib/languages\"\nimport { detect, fromStorage, fromNavigator } from \"@lingui/detect-locale\"\nimport { messages as enMessages } from \"@/locales/en/en\"\nimport { BatteryState } from \"./enums\"\nimport { t } from \"@lingui/core/macro\"\n// activates locale\nfunction activateLocale(locale: string, messages: Messages = enMessages) {\n\ti18n.load(locale, messages)\n\ti18n.activate(locale)\n\tdocument.documentElement.lang = locale\n\tlocalStorage.setItem(\"lang\", locale)\n\t$direction.set(locale.startsWith(\"ar\") || locale.startsWith(\"fa\") ? \"rtl\" : \"ltr\")\n}\n// dynamically loads translations for the given locale\nexport async function dynamicActivate(locale: string) {\n\tif (locale == \"en\") {\n\t\tactivateLocale(locale)\n\t} else {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/i18n.ts#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/i18n.ts", "rel_path": "src/site/src/lib/i18n.ts", "ext": "ts", "language": "typescript", "chunk_number": 2, "start_line": 24, "end_line": 40, "text": "\t\ttry {\n\t\t\tconst { messages }: { messages: Messages } = await import(`../locales/${locale}/${locale}.ts`)\n\t\t\tactivateLocale(locale, messages)\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error loading ${locale}`, error)\n\t\t\tactivateLocale(\"en\")\n\t\t}\n\t}\n}\n\nexport function getLocale() {\n\t// let locale = detect(fromUrl(\"lang\"), fromStorage(\"lang\"), fromNavigator(), \"en\")\n\tlet locale = detect(fromStorage(\"lang\"), fromNavigator(), \"en\")\n\t// log if dev\n\tif (import.meta.env.DEV) {\n\t\tconsole.log(\"detected locale\", locale)\n\t}", "n_tokens": 136, "primary_symbol": "getLocale", "primary_kind": "function", "primary_span": [34, 40], "def_symbols": ["getLocale"], "symbols": ["getLocale", "try", "const", "messages", "Messages", "await", "import", "locales", "locale", "activateLocale", "catch", "error", "console", "Error", "loading", "export", "function", "let", "detect", "fromUrl", "lang", "fromStorage", "fromNavigator", "log", "dev", "meta", "env", "DEV", "detected"], "doc_head": "\t\ttry {\n\t\t\tconst { messages }: { messages: Messages } = await import(`../locales/${locale}/${locale}.ts`)\n\t\t\tactivateLocale(locale, messages)\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error loading ${locale}`, error)\n\t\t\tactivateLocale(\"en\")\n\t\t}\n\t}\n}\nexport function getLocale() {\n\t// let locale = detect(fromUrl(\"lang\"), fromStorage(\"lang\"), fromNavigator(), \"en\")\n\tlet locale = detect(fromStorage(\"lang\"), fromNavigator(), \"en\")\n\t// log if dev\n\tif (import.meta.env.DEV) {\n\t\tconsole.log(\"detected locale\", locale)\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/i18n.ts#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/i18n.ts", "rel_path": "src/site/src/lib/i18n.ts", "ext": "ts", "language": "typescript", "chunk_number": 3, "start_line": 41, "end_line": 63, "text": "\t// handle zh variants\n\tif (locale?.startsWith(\"zh-\")) {\n\t\t// map zh variants to zh-CN\n\t\tconst zhVariantMap: Record<string, string> = {\n\t\t\t\"zh-HK\": \"zh-HK\",\n\t\t\t\"zh-TW\": \"zh\",\n\t\t\t\"zh-MO\": \"zh\",\n\t\t\t\"zh-Hant\": \"zh\",\n\t\t}\n\t\treturn zhVariantMap[locale] || \"zh-CN\"\n\t}\n\tlocale = (locale || \"en\").split(\"-\")[0]\n\t// use en if locale is not in languages\n\tif (!languages.some((l) => l.lang === locale)) {\n\t\tlocale = \"en\"\n\t}\n\treturn locale\n}\n\n////////////////////////////////////////////////////////\n\nexport const batteryStateTranslations = {\n\t[BatteryState.Unknown]: () => t({ message: \"Unknown\", comment: \"Context: Battery state\" }),", "n_tokens": 184, "primary_symbol": "", "primary_kind": "", "primary_span": [41, 63], "def_symbols": [], "symbols": ["handle", "variants", "locale", "startsWith", "map", "const", "zhVariantMap", "Record", "string", "Hant", "return", "split", "use", "not", "languages", "some", "lang", "export", "batteryStateTranslations", "BatteryState", "Unknown", "message", "comment", "Context", "Battery", "state"], "doc_head": "\t// handle zh variants\n\tif (locale?.startsWith(\"zh-\")) {\n\t\t// map zh variants to zh-CN\n\t\tconst zhVariantMap: Record<string, string> = {\n\t\t\t\"zh-HK\": \"zh-HK\",\n\t\t\t\"zh-TW\": \"zh\",\n\t\t\t\"zh-MO\": \"zh\",\n\t\t\t\"zh-Hant\": \"zh\",\n\t\t}\n\t\treturn zhVariantMap[locale] || \"zh-CN\"\n\t}\n\tlocale = (locale || \"en\").split(\"-\")[0]\n\t// use en if locale is not in languages\n\tif (!languages.some((l) => l.lang === locale)) {\n\t\tlocale = \"en\"\n\t}\n\treturn locale\n}\n////////////////////////////////////////////////////////\nexport const batteryStateTranslations = {\n\t[BatteryState.Unknown]: () => t({ message: \"Unknown\", comment: \"Context: Battery state\" }),"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/i18n.ts#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/i18n.ts", "rel_path": "src/site/src/lib/i18n.ts", "ext": "ts", "language": "typescript", "chunk_number": 4, "start_line": 64, "end_line": 70, "text": "\t[BatteryState.Empty]: () => t({ message: \"Empty\", comment: \"Context: Battery state\" }),\n\t[BatteryState.Full]: () => t({ message: \"Full\", comment: \"Context: Battery state\" }),\n\t[BatteryState.Charging]: () => t({ message: \"Charging\", comment: \"Context: Battery state\" }),\n\t[BatteryState.Discharging]: () => t({ message: \"Discharging\", comment: \"Context: Battery state\" }),\n\t[BatteryState.Idle]: () => t({ message: \"Idle\", comment: \"Context: Battery state\" }),\n} as const\n", "n_tokens": 129, "primary_symbol": "", "primary_kind": "", "primary_span": [64, 70], "def_symbols": [], "symbols": ["BatteryState", "Empty", "message", "comment", "Context", "Battery", "state", "Full", "Charging", "Discharging", "Idle", "const"], "doc_head": "\t[BatteryState.Empty]: () => t({ message: \"Empty\", comment: \"Context: Battery state\" }),\n\t[BatteryState.Full]: () => t({ message: \"Full\", comment: \"Context: Battery state\" }),\n\t[BatteryState.Charging]: () => t({ message: \"Charging\", comment: \"Context: Battery state\" }),\n\t[BatteryState.Discharging]: () => t({ message: \"Discharging\", comment: \"Context: Battery state\" }),\n\t[BatteryState.Idle]: () => t({ message: \"Idle\", comment: \"Context: Battery state\" }),\n} as const"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 19, "text": "import { t } from \"@lingui/core/macro\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\nimport { $copyContent, $userSettings } from \"./stores\"\nimport type { ChartTimeData, FingerprintRecord, SemVer, SystemRecord } from \"@/types\"\nimport { timeDay, timeHour } from \"d3-time\"\nimport { useEffect, useState } from \"react\"\nimport { MeterState, Unit } from \"./enums\"\nimport { prependBasePath } from \"@/components/router\"\n\nexport const FAVICON_DEFAULT = \"favicon.svg\"\nexport const FAVICON_GREEN = \"favicon-green.svg\"\nexport const FAVICON_RED = \"favicon-red.svg\"\n\nexport function cn(...inputs: ClassValue[]) {\n\treturn twMerge(clsx(inputs))\n}\n", "n_tokens": 183, "primary_symbol": "cn", "primary_kind": "function", "primary_span": [16, 19], "def_symbols": ["cn"], "symbols": ["cn", "import", "from", "lingui", "core", "macro", "toast", "components", "use", "type", "ClassValue", "clsx", "twMerge", "tailwind", "merge", "copyContent", "userSettings", "stores", "ChartTimeData", "FingerprintRecord", "SemVer", "SystemRecord", "types", "timeDay", "timeHour", "time", "useEffect", "useState", "react", "MeterState", "Unit", "enums", "prependBasePath", "router", "export", "const", "FAVICON_DEFAULT", "favicon", "svg", "FAVICON_GREEN", "green", "FAVICON_RED", "red", "function", "inputs", "return"], "doc_head": "import { t } from \"@lingui/core/macro\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\nimport { $copyContent, $userSettings } from \"./stores\"\nimport type { ChartTimeData, FingerprintRecord, SemVer, SystemRecord } from \"@/types\"\nimport { timeDay, timeHour } from \"d3-time\"\nimport { useEffect, useState } from \"react\"\nimport { MeterState, Unit } from \"./enums\"\nimport { prependBasePath } from \"@/components/router\"\nexport const FAVICON_DEFAULT = \"favicon.svg\"\nexport const FAVICON_GREEN = \"favicon-green.svg\"\nexport const FAVICON_RED = \"favicon-red.svg\"\nexport function cn(...inputs: ClassValue[]) {\n\treturn twMerge(clsx(inputs))\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 2, "start_line": 20, "end_line": 42, "text": "/** Adds event listener to node and returns function that removes the listener */\nexport function listen<T extends Event = Event>(node: Node, event: string, handler: (event: T) => void) {\n\tnode.addEventListener(event, handler as EventListener)\n\treturn () => node.removeEventListener(event, handler as EventListener)\n}\n\nexport async function copyToClipboard(content: string) {\n\tconst duration = 1500\n\ttry {\n\t\tawait navigator.clipboard.writeText(content)\n\t\ttoast({\n\t\t\tduration,\n\t\t\tdescription: t`Copied to clipboard`,\n\t\t})\n\t} catch (e: any) {\n\t\t$copyContent.set(content)\n\t}\n}\n\nconst hourWithMinutesFormatter = new Intl.DateTimeFormat(undefined, {\n\thour: \"numeric\",\n\tminute: \"numeric\",\n})", "n_tokens": 159, "primary_symbol": "copyToClipboard", "primary_kind": "function", "primary_span": [26, 42], "def_symbols": ["copyToClipboard"], "symbols": ["copyToClipboard", "Adds", "event", "listener", "node", "and", "returns", "function", "that", "removes", "the", "export", "listen", "extends", "Event", "Node", "string", "handler", "void", "addEventListener", "EventListener", "return", "removeEventListener", "async", "content", "const", "duration", "try", "await", "navigator", "clipboard", "writeText", "toast", "description", "Copied", "catch", "any", "copyContent", "set", "hourWithMinutesFormatter", "new", "Intl", "DateTimeFormat", "undefined", "hour", "numeric", "minute"], "doc_head": "/** Adds event listener to node and returns function that removes the listener */\nexport function listen<T extends Event = Event>(node: Node, event: string, handler: (event: T) => void) {\n\tnode.addEventListener(event, handler as EventListener)\n\treturn () => node.removeEventListener(event, handler as EventListener)\n}\nexport async function copyToClipboard(content: string) {\n\tconst duration = 1500\n\ttry {\n\t\tawait navigator.clipboard.writeText(content)\n\t\ttoast({\n\t\t\tduration,\n\t\t\tdescription: t`Copied to clipboard`,\n\t\t})\n\t} catch (e: any) {\n\t\t$copyContent.set(content)\n\t}\n}\nconst hourWithMinutesFormatter = new Intl.DateTimeFormat(undefined, {\n\thour: \"numeric\",\n\tminute: \"numeric\",\n})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 3, "start_line": 43, "end_line": 68, "text": "export const hourWithMinutes = (timestamp: string) => {\n\treturn hourWithMinutesFormatter.format(new Date(timestamp))\n}\n\nconst shortDateFormatter = new Intl.DateTimeFormat(undefined, {\n\tday: \"numeric\",\n\tmonth: \"short\",\n\thour: \"numeric\",\n\tminute: \"numeric\",\n})\nexport const formatShortDate = (timestamp: string) => {\n\treturn shortDateFormatter.format(new Date(timestamp))\n}\n\nconst dayFormatter = new Intl.DateTimeFormat(undefined, {\n\tday: \"numeric\",\n\tmonth: \"short\",\n})\nexport const formatDay = (timestamp: string) => {\n\treturn dayFormatter.format(new Date(timestamp))\n}\n\nexport const updateFavicon = (newIcon: string) => {\n\t;(document.querySelector(\"link[rel='icon']\") as HTMLLinkElement).href = prependBasePath(`/static/${newIcon}`)\n}\n", "n_tokens": 170, "primary_symbol": "", "primary_kind": "", "primary_span": [43, 68], "def_symbols": [], "symbols": ["export", "const", "hourWithMinutes", "timestamp", "string", "return", "hourWithMinutesFormatter", "format", "new", "Date", "shortDateFormatter", "Intl", "DateTimeFormat", "undefined", "day", "numeric", "month", "short", "hour", "minute", "formatShortDate", "dayFormatter", "formatDay", "updateFavicon", "newIcon", "document", "querySelector", "link", "rel", "icon", "HTMLLinkElement", "href", "prependBasePath", "static"], "doc_head": "export const hourWithMinutes = (timestamp: string) => {\n\treturn hourWithMinutesFormatter.format(new Date(timestamp))\n}\nconst shortDateFormatter = new Intl.DateTimeFormat(undefined, {\n\tday: \"numeric\",\n\tmonth: \"short\",\n\thour: \"numeric\",\n\tminute: \"numeric\",\n})\nexport const formatShortDate = (timestamp: string) => {\n\treturn shortDateFormatter.format(new Date(timestamp))\n}\nconst dayFormatter = new Intl.DateTimeFormat(undefined, {\n\tday: \"numeric\",\n\tmonth: \"short\",\n})\nexport const formatDay = (timestamp: string) => {\n\treturn dayFormatter.format(new Date(timestamp))\n}\nexport const updateFavicon = (newIcon: string) => {\n\t;(document.querySelector(\"link[rel='icon']\") as HTMLLinkElement).href = prependBasePath(`/static/${newIcon}`)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 4, "start_line": 69, "end_line": 89, "text": "export const chartTimeData: ChartTimeData = {\n\t\"1h\": {\n\t\ttype: \"1m\",\n\t\texpectedInterval: 60_000,\n\t\tlabel: () => t`1 hour`,\n\t\t// ticks: 12,\n\t\tformat: (timestamp: string) => hourWithMinutes(timestamp),\n\t\tgetOffset: (endTime: Date) => timeHour.offset(endTime, -1),\n\t},\n\t\"12h\": {\n\t\ttype: \"10m\",\n\t\texpectedInterval: 60_000 * 10,\n\t\tlabel: () => t`12 hours`,\n\t\tticks: 12,\n\t\tformat: (timestamp: string) => hourWithMinutes(timestamp),\n\t\tgetOffset: (endTime: Date) => timeHour.offset(endTime, -12),\n\t},\n\t\"24h\": {\n\t\ttype: \"20m\",\n\t\texpectedInterval: 60_000 * 20,\n\t\tlabel: () => t`24 hours`,", "n_tokens": 198, "primary_symbol": "", "primary_kind": "", "primary_span": [69, 89], "def_symbols": [], "symbols": ["export", "const", "chartTimeData", "ChartTimeData", "type", "expectedInterval", "label", "hour", "ticks", "format", "timestamp", "string", "hourWithMinutes", "getOffset", "endTime", "Date", "timeHour", "offset", "hours"], "doc_head": "export const chartTimeData: ChartTimeData = {\n\t\"1h\": {\n\t\ttype: \"1m\",\n\t\texpectedInterval: 60_000,\n\t\tlabel: () => t`1 hour`,\n\t\t// ticks: 12,\n\t\tformat: (timestamp: string) => hourWithMinutes(timestamp),\n\t\tgetOffset: (endTime: Date) => timeHour.offset(endTime, -1),\n\t},\n\t\"12h\": {\n\t\ttype: \"10m\",\n\t\texpectedInterval: 60_000 * 10,\n\t\tlabel: () => t`12 hours`,\n\t\tticks: 12,\n\t\tformat: (timestamp: string) => hourWithMinutes(timestamp),\n\t\tgetOffset: (endTime: Date) => timeHour.offset(endTime, -12),\n\t},\n\t\"24h\": {\n\t\ttype: \"20m\",\n\t\texpectedInterval: 60_000 * 20,\n\t\tlabel: () => t`24 hours`,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 5, "start_line": 90, "end_line": 110, "text": "\t\tformat: (timestamp: string) => hourWithMinutes(timestamp),\n\t\tgetOffset: (endTime: Date) => timeHour.offset(endTime, -24),\n\t},\n\t\"1w\": {\n\t\ttype: \"120m\",\n\t\texpectedInterval: 60_000 * 120,\n\t\tlabel: () => t`1 week`,\n\t\tticks: 7,\n\t\tformat: (timestamp: string) => formatDay(timestamp),\n\t\tgetOffset: (endTime: Date) => timeDay.offset(endTime, -7),\n\t},\n\t\"30d\": {\n\t\ttype: \"480m\",\n\t\texpectedInterval: 60_000 * 480,\n\t\tlabel: () => t`30 days`,\n\t\tticks: 30,\n\t\tformat: (timestamp: string) => formatDay(timestamp),\n\t\tgetOffset: (endTime: Date) => timeDay.offset(endTime, -30),\n\t},\n}\n", "n_tokens": 188, "primary_symbol": "", "primary_kind": "", "primary_span": [90, 110], "def_symbols": [], "symbols": ["format", "timestamp", "string", "hourWithMinutes", "getOffset", "endTime", "Date", "timeHour", "offset", "type", "expectedInterval", "label", "week", "ticks", "formatDay", "timeDay", "days"], "doc_head": "\t\tformat: (timestamp: string) => hourWithMinutes(timestamp),\n\t\tgetOffset: (endTime: Date) => timeHour.offset(endTime, -24),\n\t},\n\t\"1w\": {\n\t\ttype: \"120m\",\n\t\texpectedInterval: 60_000 * 120,\n\t\tlabel: () => t`1 week`,\n\t\tticks: 7,\n\t\tformat: (timestamp: string) => formatDay(timestamp),\n\t\tgetOffset: (endTime: Date) => timeDay.offset(endTime, -7),\n\t},\n\t\"30d\": {\n\t\ttype: \"480m\",\n\t\texpectedInterval: 60_000 * 480,\n\t\tlabel: () => t`30 days`,\n\t\tticks: 30,\n\t\tformat: (timestamp: string) => formatDay(timestamp),\n\t\tgetOffset: (endTime: Date) => timeDay.offset(endTime, -30),\n\t},\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 6, "start_line": 111, "end_line": 132, "text": "/** Format number to x decimal places, without trailing zeros */\nexport function toFixedFloat(num: number, digits: number) {\n\treturn parseFloat((digits === 0 ? Math.ceil(num) : num).toFixed(digits))\n}\n\nlet decimalFormatters: Map<number, Intl.NumberFormat> = new Map()\n/** Format number to x decimal places, maintaining trailing zeros */\nexport function decimalString(num: number, digits = 2) {\n\tif (digits === 0) {\n\t\treturn Math.ceil(num).toString()\n\t}\n\tlet formatter = decimalFormatters.get(digits)\n\tif (!formatter) {\n\t\tformatter = new Intl.NumberFormat(undefined, {\n\t\t\tminimumFractionDigits: digits,\n\t\t\tmaximumFractionDigits: digits,\n\t\t})\n\t\tdecimalFormatters.set(digits, formatter)\n\t}\n\treturn formatter.format(num)\n}\n", "n_tokens": 167, "primary_symbol": "toFixedFloat", "primary_kind": "function", "primary_span": [112, 132], "def_symbols": ["toFixedFloat", "decimalString"], "symbols": ["toFixedFloat", "decimalString", "Format", "number", "decimal", "places", "without", "trailing", "zeros", "export", "function", "num", "digits", "return", "parseFloat", "Math", "ceil", "toFixed", "let", "decimalFormatters", "Map", "Intl", "NumberFormat", "new", "maintaining", "toString", "formatter", "get", "undefined", "minimumFractionDigits", "maximumFractionDigits", "set", "format"], "doc_head": "/** Format number to x decimal places, without trailing zeros */\nexport function toFixedFloat(num: number, digits: number) {\n\treturn parseFloat((digits === 0 ? Math.ceil(num) : num).toFixed(digits))\n}\nlet decimalFormatters: Map<number, Intl.NumberFormat> = new Map()\n/** Format number to x decimal places, maintaining trailing zeros */\nexport function decimalString(num: number, digits = 2) {\n\tif (digits === 0) {\n\t\treturn Math.ceil(num).toString()\n\t}\n\tlet formatter = decimalFormatters.get(digits)\n\tif (!formatter) {\n\t\tformatter = new Intl.NumberFormat(undefined, {\n\t\t\tminimumFractionDigits: digits,\n\t\t\tmaximumFractionDigits: digits,\n\t\t})\n\t\tdecimalFormatters.set(digits, formatter)\n\t}\n\treturn formatter.format(num)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 7, "start_line": 133, "end_line": 156, "text": "/** Get value from local or session storage */\nfunction getStorageValue(key: string, defaultValue: any, storageInterface: Storage = localStorage) {\n\tconst saved = storageInterface?.getItem(key)\n\treturn saved ? JSON.parse(saved) : defaultValue\n}\n\n/** Hook to sync value in local or session storage */\nexport function useBrowserStorage<T>(key: string, defaultValue: T, storageInterface: Storage = localStorage) {\n\tkey = `besz-${key}`\n\tconst [value, setValue] = useState(() => {\n\t\treturn getStorageValue(key, defaultValue, storageInterface)\n\t})\n\tuseEffect(() => {\n\t\tstorageInterface?.setItem(key, JSON.stringify(value))\n\t}, [key, value])\n\n\treturn [value, setValue]\n}\n\n/** Format temperature to user's preferred unit */\nexport function formatTemperature(celsius: number, unit?: Unit): { value: number; unit: string } {\n\tif (!unit) {\n\t\tunit = $userSettings.get().unitTemp || Unit.Celsius\n\t}", "n_tokens": 201, "primary_symbol": "getStorageValue", "primary_kind": "function", "primary_span": [134, 156], "def_symbols": ["getStorageValue", "formatTemperature"], "symbols": ["getStorageValue", "formatTemperature", "Get", "value", "from", "local", "session", "storage", "function", "key", "string", "defaultValue", "any", "storageInterface", "Storage", "localStorage", "const", "saved", "getItem", "return", "JSON", "parse", "Hook", "sync", "export", "useBrowserStorage", "besz", "setValue", "useState", "useEffect", "setItem", "stringify", "Format", "temperature", "user", "preferred", "unit", "celsius", "number", "Unit", "userSettings", "get", "unitTemp", "Celsius"], "doc_head": "/** Get value from local or session storage */\nfunction getStorageValue(key: string, defaultValue: any, storageInterface: Storage = localStorage) {\n\tconst saved = storageInterface?.getItem(key)\n\treturn saved ? JSON.parse(saved) : defaultValue\n}\n/** Hook to sync value in local or session storage */\nexport function useBrowserStorage<T>(key: string, defaultValue: T, storageInterface: Storage = localStorage) {\n\tkey = `besz-${key}`\n\tconst [value, setValue] = useState(() => {\n\t\treturn getStorageValue(key, defaultValue, storageInterface)\n\t})\n\tuseEffect(() => {\n\t\tstorageInterface?.setItem(key, JSON.stringify(value))\n\t}, [key, value])\n\treturn [value, setValue]\n}\n/** Format temperature to user's preferred unit */\nexport function formatTemperature(celsius: number, unit?: Unit): { value: number; unit: string } {\n\tif (!unit) {\n\t\tunit = $userSettings.get().unitTemp || Unit.Celsius\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 8, "start_line": 157, "end_line": 179, "text": "\t// need loose equality check due to form data being strings\n\tif (unit == Unit.Fahrenheit) {\n\t\treturn {\n\t\t\tvalue: celsius * 1.8 + 32,\n\t\t\tunit: \"F\",\n\t\t}\n\t}\n\treturn {\n\t\tvalue: celsius,\n\t\tunit: \"C\",\n\t}\n}\n\n/** Format bytes to user's preferred unit */\nexport function formatBytes(\n\tsize: number,\n\tperSecond = false,\n\tunit = Unit.Bytes,\n\tisMegabytes = false\n): { value: number; unit: string } {\n\t// Convert MB to bytes if isMegabytes is true\n\tif (isMegabytes) size *= 1024 * 1024\n", "n_tokens": 144, "primary_symbol": "formatBytes", "primary_kind": "function", "primary_span": [171, 179], "def_symbols": ["formatBytes"], "symbols": ["formatBytes", "need", "loose", "equality", "check", "due", "form", "data", "being", "strings", "unit", "Unit", "Fahrenheit", "return", "value", "celsius", "Format", "bytes", "user", "preferred", "export", "function", "size", "number", "perSecond", "false", "Bytes", "isMegabytes", "string", "Convert", "true"], "doc_head": "\t// need loose equality check due to form data being strings\n\tif (unit == Unit.Fahrenheit) {\n\t\treturn {\n\t\t\tvalue: celsius * 1.8 + 32,\n\t\t\tunit: \"F\",\n\t\t}\n\t}\n\treturn {\n\t\tvalue: celsius,\n\t\tunit: \"C\",\n\t}\n}\n/** Format bytes to user's preferred unit */\nexport function formatBytes(\n\tsize: number,\n\tperSecond = false,\n\tunit = Unit.Bytes,\n\tisMegabytes = false\n): { value: number; unit: string } {\n\t// Convert MB to bytes if isMegabytes is true\n\tif (isMegabytes) size *= 1024 * 1024"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 9, "start_line": 180, "end_line": 220, "text": "\t// need loose equality check due to form data being strings\n\tif (unit == Unit.Bits) {\n\t\tconst bits = size * 8\n\t\tconst suffix = perSecond ? \"ps\" : \"\"\n\t\tif (bits < 1000) return { value: bits, unit: `b${suffix}` }\n\t\tif (bits < 1_000_000) return { value: bits / 1_000, unit: `Kb${suffix}` }\n\t\tif (bits < 1_000_000_000)\n\t\t\treturn {\n\t\t\t\tvalue: bits / 1_000_000,\n\t\t\t\tunit: `Mb${suffix}`,\n\t\t\t}\n\t\tif (bits < 1_000_000_000_000)\n\t\t\treturn {\n\t\t\t\tvalue: bits / 1_000_000_000,\n\t\t\t\tunit: `Gb${suffix}`,\n\t\t\t}\n\t\treturn {\n\t\t\tvalue: bits / 1_000_000_000_000,\n\t\t\tunit: `Tb${suffix}`,\n\t\t}\n\t}\n\t// bytes\n\tconst suffix = perSecond ? \"/s\" : \"\"\n\tif (size < 100) return { value: size, unit: `B${suffix}` }\n\tif (size < 1000 * 1024) return { value: size / 1024, unit: `KB${suffix}` }\n\tif (size < 1000 * 1024 ** 2)\n\t\treturn {\n\t\t\tvalue: size / 1024 ** 2,\n\t\t\tunit: `MB${suffix}`,\n\t\t}\n\tif (size < 1000 * 1024 ** 3)\n\t\treturn {\n\t\t\tvalue: size / 1024 ** 3,\n\t\t\tunit: `GB${suffix}`,\n\t\t}\n\treturn {\n\t\tvalue: size / 1024 ** 4,\n\t\tunit: `TB${suffix}`,\n\t}\n}\n", "n_tokens": 388, "primary_symbol": "", "primary_kind": "", "primary_span": [180, 220], "def_symbols": [], "symbols": ["need", "loose", "equality", "check", "due", "form", "data", "being", "strings", "unit", "Unit", "Bits", "const", "bits", "size", "suffix", "perSecond", "return", "value", "bytes"], "doc_head": "\t// need loose equality check due to form data being strings\n\tif (unit == Unit.Bits) {\n\t\tconst bits = size * 8\n\t\tconst suffix = perSecond ? \"ps\" : \"\"\n\t\tif (bits < 1000) return { value: bits, unit: `b${suffix}` }\n\t\tif (bits < 1_000_000) return { value: bits / 1_000, unit: `Kb${suffix}` }\n\t\tif (bits < 1_000_000_000)\n\t\t\treturn {\n\t\t\t\tvalue: bits / 1_000_000,\n\t\t\t\tunit: `Mb${suffix}`,\n\t\t\t}\n\t\tif (bits < 1_000_000_000_000)\n\t\t\treturn {\n\t\t\t\tvalue: bits / 1_000_000_000,\n\t\t\t\tunit: `Gb${suffix}`,\n\t\t\t}\n\t\treturn {\n\t\t\tvalue: bits / 1_000_000_000_000,\n\t\t\tunit: `Tb${suffix}`,\n\t\t}\n\t}\n\t// bytes\n\tconst suffix = perSecond ? \"/s\" : \"\"\n\tif (size < 100) return { value: size, unit: `B${suffix}` }\n\tif (size < 1000 * 1024) return { value: size / 1024, unit: `KB${suffix}` }\n\tif (size < 1000 * 1024 ** 2)\n\t\treturn {\n\t\t\tvalue: size / 1024 ** 2,\n\t\t\tunit: `MB${suffix}`,\n\t\t}\n\tif (size < 1000 * 1024 ** 3)\n\t\treturn {\n\t\t\tvalue: size / 1024 ** 3,\n\t\t\tunit: `GB${suffix}`,\n\t\t}\n\treturn {\n\t\tvalue: size / 1024 ** 4,\n\t\tunit: `TB${suffix}`,\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 10, "start_line": 221, "end_line": 228, "text": "export const chartMargin = { top: 12 }\n\n/**\n * Retuns value of system host, truncating full path if socket.\n * @example\n * // Assuming system.host is \"/var/run/beszel.sock\"\n * const hostname = getHostDisplayValue(system) // hostname will be \"beszel.sock\"\n */", "n_tokens": 65, "primary_symbol": "", "primary_kind": "", "primary_span": [221, 228], "def_symbols": [], "symbols": ["export", "const", "chartMargin", "top", "Retuns", "value", "system", "host", "truncating", "full", "path", "socket", "example", "Assuming", "var", "run", "beszel", "sock", "hostname", "getHostDisplayValue", "will"], "doc_head": "export const chartMargin = { top: 12 }\n/**\n * Retuns value of system host, truncating full path if socket.\n * @example\n * // Assuming system.host is \"/var/run/beszel.sock\"\n * const hostname = getHostDisplayValue(system) // hostname will be \"beszel.sock\"\n */"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 11, "start_line": 229, "end_line": 245, "text": "export const getHostDisplayValue = (system: SystemRecord): string => system.host.slice(system.host.lastIndexOf(\"/\") + 1)\n\n// export function formatUptimeString(uptimeSeconds: number): string {\n// \tif (!uptimeSeconds || isNaN(uptimeSeconds)) return \"\"\n// \tif (uptimeSeconds < 3600) {\n// \t\tconst minutes = Math.trunc(uptimeSeconds / 60)\n// \t\treturn plural({ minutes }, { one: \"# minute\", other: \"# minutes\" })\n// \t} else if (uptimeSeconds < 172800) {\n// \t\tconst hours = Math.trunc(uptimeSeconds / 3600)\n// \t\tconsole.log(hours)\n// \t\treturn plural({ hours }, { one: \"# hour\", other: \"# hours\" })\n// \t} else {\n// \t\tconst days = Math.trunc(uptimeSeconds / 86400)\n// \t\treturn plural({ days }, { one: \"# day\", other: \"# days\" })\n// \t}\n// }\n", "n_tokens": 204, "primary_symbol": "", "primary_kind": "", "primary_span": [229, 245], "def_symbols": [], "symbols": ["export", "const", "getHostDisplayValue", "system", "SystemRecord", "string", "host", "slice", "lastIndexOf", "function", "formatUptimeString", "uptimeSeconds", "number", "isNaN", "return", "minutes", "Math", "trunc", "plural", "one", "minute", "other", "else", "hours", "console", "log", "hour", "days", "day"], "doc_head": "export const getHostDisplayValue = (system: SystemRecord): string => system.host.slice(system.host.lastIndexOf(\"/\") + 1)\n// export function formatUptimeString(uptimeSeconds: number): string {\n// \tif (!uptimeSeconds || isNaN(uptimeSeconds)) return \"\"\n// \tif (uptimeSeconds < 3600) {\n// \t\tconst minutes = Math.trunc(uptimeSeconds / 60)\n// \t\treturn plural({ minutes }, { one: \"# minute\", other: \"# minutes\" })\n// \t} else if (uptimeSeconds < 172800) {\n// \t\tconst hours = Math.trunc(uptimeSeconds / 3600)\n// \t\tconsole.log(hours)\n// \t\treturn plural({ hours }, { one: \"# hour\", other: \"# hours\" })\n// \t} else {\n// \t\tconst days = Math.trunc(uptimeSeconds / 86400)\n// \t\treturn plural({ days }, { one: \"# day\", other: \"# days\" })\n// \t}\n// }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 12, "start_line": 246, "end_line": 264, "text": "/** Generate a random token for the agent */\nexport const generateToken = () => {\n\ttry {\n\t\treturn crypto?.randomUUID()\n\t} catch (e) {\n\t\treturn Array.from({ length: 2 }, () => (performance.now() * Math.random()).toString(16).replace(\".\", \"-\")).join(\"-\")\n\t}\n}\n\n/** Get the hub URL from the global BESZEL object */\nexport const getHubURL = () => BESZEL?.HUB_URL || window.location.origin\n\n/** Map of system IDs to their corresponding tokens (used to avoid fetching in add-system dialog) */\nexport const tokenMap = new Map<SystemRecord[\"id\"], FingerprintRecord[\"token\"]>()\n\n/** Calculate duration between two dates and format as human-readable string */\nexport function formatDuration(\n\tcreatedDate: string | null | undefined,\n\tresolvedDate: string | null | undefined", "n_tokens": 178, "primary_symbol": "formatDuration", "primary_kind": "function", "primary_span": [262, 264], "def_symbols": ["formatDuration"], "symbols": ["formatDuration", "Generate", "random", "token", "for", "the", "agent", "export", "const", "generateToken", "try", "return", "crypto", "randomUUID", "catch", "Array", "from", "length", "performance", "now", "Math", "toString", "replace", "join", "Get", "hub", "URL", "global", "BESZEL", "object", "getHubURL", "HUB_URL", "window", "location", "origin", "Map", "system", "IDs", "their", "corresponding", "tokens", "used", "avoid", "fetching", "add", "dialog", "tokenMap", "new", "SystemRecord", "FingerprintRecord", "Calculate", "duration", "between", "two", "dates", "and", "format", "human", "readable", "string", "function", "createdDate", "null", "undefined", "resolvedDate"], "doc_head": "/** Generate a random token for the agent */\nexport const generateToken = () => {\n\ttry {\n\t\treturn crypto?.randomUUID()\n\t} catch (e) {\n\t\treturn Array.from({ length: 2 }, () => (performance.now() * Math.random()).toString(16).replace(\".\", \"-\")).join(\"-\")\n\t}\n}\n/** Get the hub URL from the global BESZEL object */\nexport const getHubURL = () => BESZEL?.HUB_URL || window.location.origin\n/** Map of system IDs to their corresponding tokens (used to avoid fetching in add-system dialog) */\nexport const tokenMap = new Map<SystemRecord[\"id\"], FingerprintRecord[\"token\"]>()\n/** Calculate duration between two dates and format as human-readable string */\nexport function formatDuration(\n\tcreatedDate: string | null | undefined,\n\tresolvedDate: string | null | undefined"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 13, "start_line": 265, "end_line": 289, "text": "): string {\n\tconst created = createdDate ? new Date(createdDate) : null\n\tconst resolved = resolvedDate ? new Date(resolvedDate) : null\n\n\tif (!created || !resolved) return \"\"\n\n\tconst diffMs = resolved.getTime() - created.getTime()\n\tif (diffMs < 0) return \"\"\n\n\tconst totalSeconds = Math.floor(diffMs / 1000)\n\tlet hours = Math.floor(totalSeconds / 3600)\n\tlet minutes = Math.floor((totalSeconds % 3600) / 60)\n\tlet seconds = totalSeconds % 60\n\n\t// if seconds are close to 60, round up to next minute\n\t// if minutes are close to 60, round up to next hour\n\tif (seconds >= 58) {\n\t\tminutes += 1\n\t\tseconds = 0\n\t}\n\tif (minutes >= 60) {\n\t\thours += 1\n\t\tminutes = 0\n\t}\n", "n_tokens": 193, "primary_symbol": "", "primary_kind": "", "primary_span": [265, 289], "def_symbols": [], "symbols": ["string", "const", "created", "createdDate", "new", "Date", "null", "resolved", "resolvedDate", "return", "diffMs", "getTime", "totalSeconds", "Math", "floor", "let", "hours", "minutes", "seconds", "are", "close", "round", "next", "minute", "hour"], "doc_head": "): string {\n\tconst created = createdDate ? new Date(createdDate) : null\n\tconst resolved = resolvedDate ? new Date(resolvedDate) : null\n\tif (!created || !resolved) return \"\"\n\tconst diffMs = resolved.getTime() - created.getTime()\n\tif (diffMs < 0) return \"\"\n\tconst totalSeconds = Math.floor(diffMs / 1000)\n\tlet hours = Math.floor(totalSeconds / 3600)\n\tlet minutes = Math.floor((totalSeconds % 3600) / 60)\n\tlet seconds = totalSeconds % 60\n\t// if seconds are close to 60, round up to next minute\n\t// if minutes are close to 60, round up to next hour\n\tif (seconds >= 58) {\n\t\tminutes += 1\n\t\tseconds = 0\n\t}\n\tif (minutes >= 60) {\n\t\thours += 1\n\t\tminutes = 0\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 14, "start_line": 290, "end_line": 300, "text": "\t// For durations over 1 hour, omit seconds for cleaner display\n\tif (hours > 0) {\n\t\treturn [hours ? `${hours}h` : null, minutes ? `${minutes}m` : null].filter(Boolean).join(\" \")\n\t}\n\n\treturn [hours ? `${hours}h` : null, minutes ? `${minutes}m` : null, seconds ? `${seconds}s` : null]\n\t\t.filter(Boolean)\n\t\t.join(\" \")\n}\n\nexport const parseSemVer = (semVer = \"\"): SemVer => {", "n_tokens": 112, "primary_symbol": "", "primary_kind": "", "primary_span": [290, 300], "def_symbols": [], "symbols": ["For", "durations", "over", "hour", "omit", "seconds", "for", "cleaner", "display", "hours", "return", "null", "minutes", "filter", "Boolean", "join", "export", "const", "parseSemVer", "semVer", "SemVer"], "doc_head": "\t// For durations over 1 hour, omit seconds for cleaner display\n\tif (hours > 0) {\n\t\treturn [hours ? `${hours}h` : null, minutes ? `${minutes}m` : null].filter(Boolean).join(\" \")\n\t}\n\treturn [hours ? `${hours}h` : null, minutes ? `${minutes}m` : null, seconds ? `${seconds}s` : null]\n\t\t.filter(Boolean)\n\t\t.join(\" \")\n}\nexport const parseSemVer = (semVer = \"\"): SemVer => {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 15, "start_line": 301, "end_line": 316, "text": "\t// if (semVer.startsWith(\"v\")) {\n\t// \tsemVer = semVer.slice(1)\n\t// }\n\tif (semVer.includes(\"-\")) {\n\t\tsemVer = semVer.slice(0, semVer.indexOf(\"-\"))\n\t}\n\tconst parts = semVer.split(\".\").map(Number)\n\treturn { major: parts?.[0] ?? 0, minor: parts?.[1] ?? 0, patch: parts?.[2] ?? 0 }\n}\n\n/** Get meter state from 0-100 value. Used for color coding meters. */\nexport function getMeterState(value: number): MeterState {\n\tconst { colorWarn = 65, colorCrit = 90 } = $userSettings.get()\n\treturn value >= colorCrit ? MeterState.Crit : value >= colorWarn ? MeterState.Warn : MeterState.Good\n}\n", "n_tokens": 174, "primary_symbol": "getMeterState", "primary_kind": "function", "primary_span": [312, 316], "def_symbols": ["getMeterState"], "symbols": ["getMeterState", "semVer", "startsWith", "slice", "includes", "indexOf", "const", "parts", "split", "map", "Number", "return", "major", "minor", "patch", "Get", "meter", "state", "from", "value", "Used", "for", "color", "coding", "meters", "export", "function", "number", "MeterState", "colorWarn", "colorCrit", "userSettings", "get", "Crit", "Warn", "Good"], "doc_head": "\t// if (semVer.startsWith(\"v\")) {\n\t// \tsemVer = semVer.slice(1)\n\t// }\n\tif (semVer.includes(\"-\")) {\n\t\tsemVer = semVer.slice(0, semVer.indexOf(\"-\"))\n\t}\n\tconst parts = semVer.split(\".\").map(Number)\n\treturn { major: parts?.[0] ?? 0, minor: parts?.[1] ?? 0, patch: parts?.[2] ?? 0 }\n}\n/** Get meter state from 0-100 value. Used for color coding meters. */\nexport function getMeterState(value: number): MeterState {\n\tconst { colorWarn = 65, colorCrit = 90 } = $userSettings.get()\n\treturn value >= colorCrit ? MeterState.Crit : value >= colorWarn ? MeterState.Warn : MeterState.Good\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#16", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 16, "start_line": 317, "end_line": 334, "text": "export function debounce<T extends (...args: any[]) => any>(func: T, wait: number): (...args: Parameters<T>) => void {\n\tlet timeout: ReturnType<typeof setTimeout>\n\treturn (...args: Parameters<T>) => {\n\t\tclearTimeout(timeout)\n\t\ttimeout = setTimeout(() => func(...args), wait)\n\t}\n}\n\n// Cache for runOnce\nconst runOnceCache = new WeakMap<Function, { done: boolean; result: unknown }>()\n/** Run a function only once */\nexport function runOnce<T extends (...args: any[]) => any>(fn: T): T {\n\treturn ((...args: Parameters<T>) => {\n\t\tlet state = runOnceCache.get(fn)\n\t\tif (!state) {\n\t\t\tstate = { done: false, result: undefined }\n\t\t\trunOnceCache.set(fn, state)\n\t\t}", "n_tokens": 170, "primary_symbol": "", "primary_kind": "", "primary_span": [317, 334], "def_symbols": [], "symbols": ["export", "function", "debounce", "extends", "args", "any", "func", "wait", "number", "Parameters", "void", "let", "timeout", "ReturnType", "typeof", "setTimeout", "return", "clearTimeout", "Cache", "for", "runOnce", "const", "runOnceCache", "new", "WeakMap", "Function", "done", "boolean", "result", "unknown", "Run", "only", "once", "state", "get", "false", "undefined", "set"], "doc_head": "export function debounce<T extends (...args: any[]) => any>(func: T, wait: number): (...args: Parameters<T>) => void {\n\tlet timeout: ReturnType<typeof setTimeout>\n\treturn (...args: Parameters<T>) => {\n\t\tclearTimeout(timeout)\n\t\ttimeout = setTimeout(() => func(...args), wait)\n\t}\n}\n// Cache for runOnce\nconst runOnceCache = new WeakMap<Function, { done: boolean; result: unknown }>()\n/** Run a function only once */\nexport function runOnce<T extends (...args: any[]) => any>(fn: T): T {\n\treturn ((...args: Parameters<T>) => {\n\t\tlet state = runOnceCache.get(fn)\n\t\tif (!state) {\n\t\t\tstate = { done: false, result: undefined }\n\t\t\trunOnceCache.set(fn, state)\n\t\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts#17", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/utils.ts", "rel_path": "src/site/src/lib/utils.ts", "ext": "ts", "language": "typescript", "chunk_number": 17, "start_line": 335, "end_line": 342, "text": "\t\tif (!state.done) {\n\t\t\tstate.result = fn(...args)\n\t\t\tstate.done = true\n\t\t}\n\t\treturn state.result\n\t}) as T\n}\n", "n_tokens": 35, "primary_symbol": "", "primary_kind": "", "primary_span": [335, 342], "def_symbols": [], "symbols": ["state", "done", "result", "args", "true", "return"], "doc_head": "\t\tif (!state.done) {\n\t\t\tstate.result = fn(...args)\n\t\t\tstate.done = true\n\t\t}\n\t\treturn state.result\n\t}) as T\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/api.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/api.ts", "rel_path": "src/site/src/lib/api.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 27, "text": "import { ChartTimes, UserSettings } from \"@/types\"\nimport { $alerts, $allSystemsByName, $userSettings } from \"./stores\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport { t } from \"@lingui/core/macro\"\nimport { chartTimeData } from \"./utils\"\nimport PocketBase from \"pocketbase\"\nimport { basePath } from \"@/components/router\"\n\n/** PocketBase JS Client */\nexport const pb = new PocketBase(basePath)\n\nexport const isAdmin = () => pb.authStore.record?.role === \"admin\"\nexport const isReadOnlyUser = () => pb.authStore.record?.role === \"readonly\"\n\nexport const verifyAuth = () => {\n\tpb.collection(\"users\")\n\t\t.authRefresh()\n\t\t.catch(() => {\n\t\t\tlogOut()\n\t\t\ttoast({\n\t\t\t\ttitle: t`Failed to authenticate`,\n\t\t\t\tdescription: t`Please log in again`,\n\t\t\t\tvariant: \"destructive\",\n\t\t\t})\n\t\t})\n}\n", "n_tokens": 198, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 27], "def_symbols": [], "symbols": ["import", "ChartTimes", "UserSettings", "from", "types", "alerts", "allSystemsByName", "userSettings", "stores", "toast", "components", "use", "lingui", "core", "macro", "chartTimeData", "utils", "PocketBase", "pocketbase", "basePath", "router", "Client", "export", "const", "new", "isAdmin", "authStore", "record", "role", "admin", "isReadOnlyUser", "readonly", "verifyAuth", "collection", "users", "authRefresh", "catch", "logOut", "title", "Failed", "authenticate", "description", "Please", "log", "again", "variant", "destructive"], "doc_head": "import { ChartTimes, UserSettings } from \"@/types\"\nimport { $alerts, $allSystemsByName, $userSettings } from \"./stores\"\nimport { toast } from \"@/components/ui/use-toast\"\nimport { t } from \"@lingui/core/macro\"\nimport { chartTimeData } from \"./utils\"\nimport PocketBase from \"pocketbase\"\nimport { basePath } from \"@/components/router\"\n/** PocketBase JS Client */\nexport const pb = new PocketBase(basePath)\nexport const isAdmin = () => pb.authStore.record?.role === \"admin\"\nexport const isReadOnlyUser = () => pb.authStore.record?.role === \"readonly\"\nexport const verifyAuth = () => {\n\tpb.collection(\"users\")\n\t\t.authRefresh()\n\t\t.catch(() => {\n\t\t\tlogOut()\n\t\t\ttoast({\n\t\t\t\ttitle: t`Failed to authenticate`,\n\t\t\t\tdescription: t`Please log in again`,\n\t\t\t\tvariant: \"destructive\",\n\t\t\t})\n\t\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/api.ts#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/api.ts", "rel_path": "src/site/src/lib/api.ts", "ext": "ts", "language": "typescript", "chunk_number": 2, "start_line": 28, "end_line": 50, "text": "/** Logs the user out by clearing the auth store and unsubscribing from realtime updates. */\nexport async function logOut() {\n\t$allSystemsByName.set({})\n\t$alerts.set({})\n\t$userSettings.set({} as UserSettings)\n\tsessionStorage.setItem(\"lo\", \"t\") // prevent auto login on logout\n\tpb.authStore.clear()\n\tpb.realtime.unsubscribe()\n}\n\n/** Fetch or create user settings in database */\nexport async function updateUserSettings() {\n\ttry {\n\t\tconst req = await pb.collection(\"user_settings\").getFirstListItem(\"\", { fields: \"settings\" })\n\t\t$userSettings.set(req.settings)\n\t\treturn\n\t} catch (e) {\n\t\tconsole.error(\"get settings\", e)\n\t}\n\t// create user settings if error fetching existing\n\ttry {\n\t\tconst createdSettings = await pb.collection(\"user_settings\").create({ user: pb.authStore.record!.id })\n\t\t$userSettings.set(createdSettings.settings)", "n_tokens": 190, "primary_symbol": "logOut", "primary_kind": "function", "primary_span": [29, 50], "def_symbols": ["logOut", "updateUserSettings"], "symbols": ["logOut", "updateUserSettings", "Logs", "the", "user", "out", "clearing", "auth", "store", "and", "unsubscribing", "from", "realtime", "updates", "export", "async", "function", "allSystemsByName", "set", "alerts", "userSettings", "UserSettings", "sessionStorage", "setItem", "prevent", "auto", "login", "logout", "authStore", "clear", "unsubscribe", "Fetch", "create", "settings", "database", "try", "const", "req", "await", "collection", "user_settings", "getFirstListItem", "fields", "return", "catch", "console", "error", "get", "fetching", "existing", "createdSettings", "record"], "doc_head": "/** Logs the user out by clearing the auth store and unsubscribing from realtime updates. */\nexport async function logOut() {\n\t$allSystemsByName.set({})\n\t$alerts.set({})\n\t$userSettings.set({} as UserSettings)\n\tsessionStorage.setItem(\"lo\", \"t\") // prevent auto login on logout\n\tpb.authStore.clear()\n\tpb.realtime.unsubscribe()\n}\n/** Fetch or create user settings in database */\nexport async function updateUserSettings() {\n\ttry {\n\t\tconst req = await pb.collection(\"user_settings\").getFirstListItem(\"\", { fields: \"settings\" })\n\t\t$userSettings.set(req.settings)\n\t\treturn\n\t} catch (e) {\n\t\tconsole.error(\"get settings\", e)\n\t}\n\t// create user settings if error fetching existing\n\ttry {\n\t\tconst createdSettings = await pb.collection(\"user_settings\").create({ user: pb.authStore.record!.id })\n\t\t$userSettings.set(createdSettings.settings)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/api.ts#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/api.ts", "rel_path": "src/site/src/lib/api.ts", "ext": "ts", "language": "typescript", "chunk_number": 3, "start_line": 51, "end_line": 67, "text": "\t} catch (e) {\n\t\tconsole.error(\"create settings\", e)\n\t}\n}\n\nexport function getPbTimestamp(timeString: ChartTimes, d?: Date) {\n\td ||= chartTimeData[timeString].getOffset(new Date())\n\tconst year = d.getUTCFullYear()\n\tconst month = String(d.getUTCMonth() + 1).padStart(2, \"0\")\n\tconst day = String(d.getUTCDate()).padStart(2, \"0\")\n\tconst hours = String(d.getUTCHours()).padStart(2, \"0\")\n\tconst minutes = String(d.getUTCMinutes()).padStart(2, \"0\")\n\tconst seconds = String(d.getUTCSeconds()).padStart(2, \"0\")\n\n\treturn `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`\n}\n", "n_tokens": 164, "primary_symbol": "getPbTimestamp", "primary_kind": "function", "primary_span": [56, 67], "def_symbols": ["getPbTimestamp"], "symbols": ["getPbTimestamp", "catch", "console", "error", "create", "settings", "export", "function", "timeString", "ChartTimes", "Date", "chartTimeData", "getOffset", "new", "const", "year", "getUTCFullYear", "month", "String", "getUTCMonth", "padStart", "day", "getUTCDate", "hours", "getUTCHours", "minutes", "getUTCMinutes", "seconds", "getUTCSeconds", "return"], "doc_head": "\t} catch (e) {\n\t\tconsole.error(\"create settings\", e)\n\t}\n}\nexport function getPbTimestamp(timeString: ChartTimes, d?: Date) {\n\td ||= chartTimeData[timeString].getOffset(new Date())\n\tconst year = d.getUTCFullYear()\n\tconst month = String(d.getUTCMonth() + 1).padStart(2, \"0\")\n\tconst day = String(d.getUTCDate()).padStart(2, \"0\")\n\tconst hours = String(d.getUTCHours()).padStart(2, \"0\")\n\tconst minutes = String(d.getUTCMinutes()).padStart(2, \"0\")\n\tconst seconds = String(d.getUTCSeconds()).padStart(2, \"0\")\n\treturn `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/stores.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/stores.ts", "rel_path": "src/site/src/lib/stores.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 18, "text": "import { atom, computed, map, ReadableAtom } from \"nanostores\"\nimport { AlertMap, ChartTimes, SystemRecord, UserSettings } from \"@/types\"\nimport { Unit } from \"./enums\"\nimport { pb } from \"./api\"\n\n/** Store if user is authenticated */\nexport const $authenticated = atom(pb.authStore.isValid)\n\n/** Map of system records by name */\nexport const $allSystemsByName = map<Record<string, SystemRecord>>({})\n/** Map of system records by id */\nexport const $allSystemsById = map<Record<string, SystemRecord>>({})\n/** Map of up systems by id */\nexport const $upSystems = map<Record<string, SystemRecord>>({})\n/** Map of down systems by id */\nexport const $downSystems = map<Record<string, SystemRecord>>({})\n/** Map of paused systems by id */\nexport const $pausedSystems = map<Record<string, SystemRecord>>({})", "n_tokens": 187, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 18], "def_symbols": [], "symbols": ["import", "atom", "computed", "map", "ReadableAtom", "from", "nanostores", "AlertMap", "ChartTimes", "SystemRecord", "UserSettings", "types", "Unit", "enums", "api", "Store", "user", "authenticated", "export", "const", "authStore", "isValid", "Map", "system", "records", "name", "allSystemsByName", "Record", "string", "allSystemsById", "systems", "upSystems", "down", "downSystems", "paused", "pausedSystems"], "doc_head": "import { atom, computed, map, ReadableAtom } from \"nanostores\"\nimport { AlertMap, ChartTimes, SystemRecord, UserSettings } from \"@/types\"\nimport { Unit } from \"./enums\"\nimport { pb } from \"./api\"\n/** Store if user is authenticated */\nexport const $authenticated = atom(pb.authStore.isValid)\n/** Map of system records by name */\nexport const $allSystemsByName = map<Record<string, SystemRecord>>({})\n/** Map of system records by id */\nexport const $allSystemsById = map<Record<string, SystemRecord>>({})\n/** Map of up systems by id */\nexport const $upSystems = map<Record<string, SystemRecord>>({})\n/** Map of down systems by id */\nexport const $downSystems = map<Record<string, SystemRecord>>({})\n/** Map of paused systems by id */\nexport const $pausedSystems = map<Record<string, SystemRecord>>({})"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/stores.ts#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/stores.ts", "rel_path": "src/site/src/lib/stores.ts", "ext": "ts", "language": "typescript", "chunk_number": 2, "start_line": 19, "end_line": 30, "text": "/** List of all system records */\nexport const $systems: ReadableAtom<SystemRecord[]> = computed($allSystemsById, Object.values)\n\n/** Map of alert records by system id and alert name */\nexport const $alerts = map<AlertMap>({})\n\n/** SSH public key */\nexport const $publicKey = atom(\"\")\n\n/** Chart time period */\nexport const $chartTime = atom<ChartTimes>(\"1h\")\n", "n_tokens": 85, "primary_symbol": "", "primary_kind": "", "primary_span": [19, 30], "def_symbols": [], "symbols": ["List", "all", "system", "records", "export", "const", "systems", "ReadableAtom", "SystemRecord", "computed", "allSystemsById", "Object", "values", "Map", "alert", "and", "name", "alerts", "map", "AlertMap", "SSH", "public", "key", "publicKey", "atom", "Chart", "time", "period", "chartTime", "ChartTimes"], "doc_head": "/** List of all system records */\nexport const $systems: ReadableAtom<SystemRecord[]> = computed($allSystemsById, Object.values)\n/** Map of alert records by system id and alert name */\nexport const $alerts = map<AlertMap>({})\n/** SSH public key */\nexport const $publicKey = atom(\"\")\n/** Chart time period */\nexport const $chartTime = atom<ChartTimes>(\"1h\")"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/stores.ts#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/stores.ts", "rel_path": "src/site/src/lib/stores.ts", "ext": "ts", "language": "typescript", "chunk_number": 3, "start_line": 31, "end_line": 44, "text": "/** Whether to display average or max chart values */\nexport const $maxValues = atom(false)\n\n// export const UserSettingsSchema = v.object({\n// \tchartTime: v.picklist([\"1h\", \"12h\", \"24h\", \"1w\", \"30d\"]),\n// \temails: v.optional(v.array(v.pipe(v.string(), v.email())), [pb?.authStore?.record?.email ?? \"\"]),\n// \twebhooks: v.optional(v.array(v.string())),\n// \tcolorWarn: v.optional(v.pipe(v.number(), v.minValue(1), v.maxValue(100))),\n// \tcolorDanger: v.optional(v.pipe(v.number(), v.minValue(1), v.maxValue(100))),\n// \tunitTemp: v.optional(v.enum(Unit)),\n// \tunitNet: v.optional(v.enum(Unit)),\n// \tunitDisk: v.optional(v.enum(Unit)),\n// })\n", "n_tokens": 182, "primary_symbol": "", "primary_kind": "", "primary_span": [31, 44], "def_symbols": [], "symbols": ["Whether", "display", "average", "max", "chart", "values", "export", "const", "maxValues", "atom", "false", "UserSettingsSchema", "object", "chartTime", "picklist", "emails", "optional", "array", "pipe", "string", "email", "authStore", "record", "webhooks", "colorWarn", "number", "minValue", "maxValue", "colorDanger", "unitTemp", "enum", "Unit", "unitNet", "unitDisk"], "doc_head": "/** Whether to display average or max chart values */\nexport const $maxValues = atom(false)\n// export const UserSettingsSchema = v.object({\n// \tchartTime: v.picklist([\"1h\", \"12h\", \"24h\", \"1w\", \"30d\"]),\n// \temails: v.optional(v.array(v.pipe(v.string(), v.email())), [pb?.authStore?.record?.email ?? \"\"]),\n// \twebhooks: v.optional(v.array(v.string())),\n// \tcolorWarn: v.optional(v.pipe(v.number(), v.minValue(1), v.maxValue(100))),\n// \tcolorDanger: v.optional(v.pipe(v.number(), v.minValue(1), v.maxValue(100))),\n// \tunitTemp: v.optional(v.enum(Unit)),\n// \tunitNet: v.optional(v.enum(Unit)),\n// \tunitDisk: v.optional(v.enum(Unit)),\n// })"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/stores.ts#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/stores.ts", "rel_path": "src/site/src/lib/stores.ts", "ext": "ts", "language": "typescript", "chunk_number": 4, "start_line": 45, "end_line": 71, "text": "/** User settings */\nexport const $userSettings = map<UserSettings>({\n\tchartTime: \"1h\",\n\temails: [pb.authStore.record?.email || \"\"],\n\tunitNet: Unit.Bytes,\n\tunitTemp: Unit.Celsius,\n})\n// update chart time on change\n$userSettings.subscribe((value) => $chartTime.set(value.chartTime))\n\n/** Container chart filter */\nexport const $containerFilter = atom(\"\")\n\n/** Temperature chart filter */\nexport const $temperatureFilter = atom(\"\")\n\n/** Fallback copy to clipboard dialog content */\nexport const $copyContent = atom(\"\")\n\n/** Direction for localization */\nexport const $direction = atom<\"ltr\" | \"rtl\">(\"ltr\")\n\n/** Longest system name length. Used to set table column width. I know this\n *  is stupid but the table is virtualized and I know this will work.\n */\nexport const $longestSystemNameLen = atom(8)\n", "n_tokens": 187, "primary_symbol": "", "primary_kind": "", "primary_span": [45, 71], "def_symbols": [], "symbols": ["User", "settings", "export", "const", "userSettings", "map", "UserSettings", "chartTime", "emails", "authStore", "record", "email", "unitNet", "Unit", "Bytes", "unitTemp", "Celsius", "update", "chart", "time", "change", "subscribe", "value", "set", "Container", "filter", "containerFilter", "atom", "Temperature", "temperatureFilter", "Fallback", "copy", "clipboard", "dialog", "content", "copyContent", "Direction", "for", "localization", "direction", "ltr", "rtl", "Longest", "system", "name", "length", "Used", "table", "column", "width", "know", "this", "stupid", "but", "the", "virtualized", "and", "will", "work", "longestSystemNameLen"], "doc_head": "/** User settings */\nexport const $userSettings = map<UserSettings>({\n\tchartTime: \"1h\",\n\temails: [pb.authStore.record?.email || \"\"],\n\tunitNet: Unit.Bytes,\n\tunitTemp: Unit.Celsius,\n})\n// update chart time on change\n$userSettings.subscribe((value) => $chartTime.set(value.chartTime))\n/** Container chart filter */\nexport const $containerFilter = atom(\"\")\n/** Temperature chart filter */\nexport const $temperatureFilter = atom(\"\")\n/** Fallback copy to clipboard dialog content */\nexport const $copyContent = atom(\"\")\n/** Direction for localization */\nexport const $direction = atom<\"ltr\" | \"rtl\">(\"ltr\")\n/** Longest system name length. Used to set table column width. I know this\n *  is stupid but the table is virtualized and I know this will work.\n */\nexport const $longestSystemNameLen = atom(8)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts", "rel_path": "src/site/src/lib/systemsManager.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 30, "text": "import { SystemRecord } from \"@/types\"\nimport { PreinitializedMapStore } from \"nanostores\"\nimport { pb, verifyAuth } from \"@/lib/api\"\nimport {\n\t$allSystemsByName,\n\t$upSystems,\n\t$downSystems,\n\t$pausedSystems,\n\t$allSystemsById,\n\t$longestSystemNameLen,\n} from \"@/lib/stores\"\nimport { updateFavicon, FAVICON_DEFAULT, FAVICON_GREEN, FAVICON_RED } from \"@/lib/utils\"\nimport { SystemStatus } from \"./enums\"\n\nconst COLLECTION = pb.collection<SystemRecord>(\"systems\")\nconst FIELDS_DEFAULT = \"id,name,host,port,info,status\"\n\n/** Maximum system name length for display purposes */\nconst MAX_SYSTEM_NAME_LENGTH = 20\n\nlet initialized = false\nlet unsub: (() => void) | undefined | void\n\n/** Initialize the systems manager and set up listeners */\nexport function init() {\n\tif (initialized) {\n\t\treturn\n\t}\n\tinitialized = true\n", "n_tokens": 203, "primary_symbol": "init", "primary_kind": "function", "primary_span": [25, 30], "def_symbols": ["init"], "symbols": ["init", "import", "SystemRecord", "from", "types", "PreinitializedMapStore", "nanostores", "verifyAuth", "lib", "api", "allSystemsByName", "upSystems", "downSystems", "pausedSystems", "allSystemsById", "longestSystemNameLen", "stores", "updateFavicon", "FAVICON_DEFAULT", "FAVICON_GREEN", "FAVICON_RED", "utils", "SystemStatus", "enums", "const", "COLLECTION", "collection", "systems", "FIELDS_DEFAULT", "name", "host", "port", "info", "status", "Maximum", "system", "length", "for", "display", "purposes", "MAX_SYSTEM_NAME_LENGTH", "let", "initialized", "false", "unsub", "void", "undefined", "Initialize", "the", "manager", "and", "set", "listeners", "export", "function", "return", "true"], "doc_head": "import { SystemRecord } from \"@/types\"\nimport { PreinitializedMapStore } from \"nanostores\"\nimport { pb, verifyAuth } from \"@/lib/api\"\nimport {\n\t$allSystemsByName,\n\t$upSystems,\n\t$downSystems,\n\t$pausedSystems,\n\t$allSystemsById,\n\t$longestSystemNameLen,\n} from \"@/lib/stores\"\nimport { updateFavicon, FAVICON_DEFAULT, FAVICON_GREEN, FAVICON_RED } from \"@/lib/utils\"\nimport { SystemStatus } from \"./enums\"\nconst COLLECTION = pb.collection<SystemRecord>(\"systems\")\nconst FIELDS_DEFAULT = \"id,name,host,port,info,status\"\n/** Maximum system name length for display purposes */\nconst MAX_SYSTEM_NAME_LENGTH = 20\nlet initialized = false\nlet unsub: (() => void) | undefined | void\n/** Initialize the systems manager and set up listeners */\nexport function init() {\n\tif (initialized) {\n\t\treturn\n\t}\n\tinitialized = true"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts", "rel_path": "src/site/src/lib/systemsManager.ts", "ext": "ts", "language": "typescript", "chunk_number": 2, "start_line": 31, "end_line": 53, "text": "\t// sync system stores on change\n\t$allSystemsById.listen((newSystems, oldSystems, changedKey) => {\n\t\tconst oldSystem = oldSystems[changedKey]\n\t\tconst newSystem = newSystems[changedKey]\n\n\t\t// if system is undefined (deleted), remove it from the stores\n\t\tif (oldSystem && !newSystem?.id) {\n\t\t\tremoveFromStore(oldSystem, $upSystems)\n\t\t\tremoveFromStore(oldSystem, $downSystems)\n\t\t\tremoveFromStore(oldSystem, $pausedSystems)\n\t\t\tremoveFromStore(oldSystem, $allSystemsById)\n\t\t}\n\n\t\tif (!newSystem) {\n\t\t\tonSystemsChanged(newSystems, undefined)\n\t\t\treturn\n\t\t}\n\n\t\tconst newStatus = newSystem.status\n\t\tif (newStatus === SystemStatus.Up) {\n\t\t\t$upSystems.setKey(newSystem.id, newSystem)\n\t\t\tremoveFromStore(newSystem, $downSystems)\n\t\t\tremoveFromStore(newSystem, $pausedSystems)", "n_tokens": 203, "primary_symbol": "", "primary_kind": "", "primary_span": [31, 53], "def_symbols": [], "symbols": ["sync", "system", "stores", "change", "allSystemsById", "listen", "newSystems", "oldSystems", "changedKey", "const", "oldSystem", "newSystem", "undefined", "deleted", "remove", "from", "the", "removeFromStore", "upSystems", "downSystems", "pausedSystems", "onSystemsChanged", "return", "newStatus", "status", "SystemStatus", "setKey"], "doc_head": "\t// sync system stores on change\n\t$allSystemsById.listen((newSystems, oldSystems, changedKey) => {\n\t\tconst oldSystem = oldSystems[changedKey]\n\t\tconst newSystem = newSystems[changedKey]\n\t\t// if system is undefined (deleted), remove it from the stores\n\t\tif (oldSystem && !newSystem?.id) {\n\t\t\tremoveFromStore(oldSystem, $upSystems)\n\t\t\tremoveFromStore(oldSystem, $downSystems)\n\t\t\tremoveFromStore(oldSystem, $pausedSystems)\n\t\t\tremoveFromStore(oldSystem, $allSystemsById)\n\t\t}\n\t\tif (!newSystem) {\n\t\t\tonSystemsChanged(newSystems, undefined)\n\t\t\treturn\n\t\t}\n\t\tconst newStatus = newSystem.status\n\t\tif (newStatus === SystemStatus.Up) {\n\t\t\t$upSystems.setKey(newSystem.id, newSystem)\n\t\t\tremoveFromStore(newSystem, $downSystems)\n\t\t\tremoveFromStore(newSystem, $pausedSystems)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts", "rel_path": "src/site/src/lib/systemsManager.ts", "ext": "ts", "language": "typescript", "chunk_number": 3, "start_line": 54, "end_line": 72, "text": "\t\t} else if (newStatus === SystemStatus.Down) {\n\t\t\t$downSystems.setKey(newSystem.id, newSystem)\n\t\t\tremoveFromStore(newSystem, $upSystems)\n\t\t\tremoveFromStore(newSystem, $pausedSystems)\n\t\t} else if (newStatus === SystemStatus.Paused) {\n\t\t\t$pausedSystems.setKey(newSystem.id, newSystem)\n\t\t\tremoveFromStore(newSystem, $upSystems)\n\t\t\tremoveFromStore(newSystem, $downSystems)\n\t\t} else if (newStatus === SystemStatus.Pending) {\n\t\t\tremoveFromStore(newSystem, $upSystems)\n\t\t\tremoveFromStore(newSystem, $downSystems)\n\t\t\tremoveFromStore(newSystem, $pausedSystems)\n\t\t}\n\n\t\t// run things that need to be done when systems change\n\t\tonSystemsChanged(newSystems, newSystem)\n\t})\n}\n", "n_tokens": 179, "primary_symbol": "", "primary_kind": "", "primary_span": [54, 72], "def_symbols": [], "symbols": ["else", "newStatus", "SystemStatus", "Down", "downSystems", "setKey", "newSystem", "removeFromStore", "upSystems", "pausedSystems", "Paused", "Pending", "run", "things", "that", "need", "done", "when", "systems", "change", "onSystemsChanged", "newSystems"], "doc_head": "\t\t} else if (newStatus === SystemStatus.Down) {\n\t\t\t$downSystems.setKey(newSystem.id, newSystem)\n\t\t\tremoveFromStore(newSystem, $upSystems)\n\t\t\tremoveFromStore(newSystem, $pausedSystems)\n\t\t} else if (newStatus === SystemStatus.Paused) {\n\t\t\t$pausedSystems.setKey(newSystem.id, newSystem)\n\t\t\tremoveFromStore(newSystem, $upSystems)\n\t\t\tremoveFromStore(newSystem, $downSystems)\n\t\t} else if (newStatus === SystemStatus.Pending) {\n\t\t\tremoveFromStore(newSystem, $upSystems)\n\t\t\tremoveFromStore(newSystem, $downSystems)\n\t\t\tremoveFromStore(newSystem, $pausedSystems)\n\t\t}\n\t\t// run things that need to be done when systems change\n\t\tonSystemsChanged(newSystems, newSystem)\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts", "rel_path": "src/site/src/lib/systemsManager.ts", "ext": "ts", "language": "typescript", "chunk_number": 4, "start_line": 73, "end_line": 91, "text": "/** Update the longest system name length and favicon based on system status */\nfunction onSystemsChanged(_: Record<string, SystemRecord>, changedSystem: SystemRecord | undefined) {\n\tconst upSystemsStore = $upSystems.get()\n\tconst downSystemsStore = $downSystems.get()\n\tconst upSystems = Object.values(upSystemsStore)\n\tconst downSystems = Object.values(downSystemsStore)\n\n\t// Update longest system name length\n\tconst longestName = $longestSystemNameLen.get()\n\tconst nameLen = Math.min(MAX_SYSTEM_NAME_LENGTH, changedSystem?.name.length || 0)\n\tif (nameLen > longestName) {\n\t\t$longestSystemNameLen.set(nameLen)\n\t}\n\n\t// Update favicon based on system status\n\tif (downSystems.length > 0) {\n\t\tupdateFavicon(FAVICON_RED)\n\t} else if (upSystems.length > 0) {\n\t\tupdateFavicon(FAVICON_GREEN)", "n_tokens": 189, "primary_symbol": "onSystemsChanged", "primary_kind": "function", "primary_span": [74, 91], "def_symbols": ["onSystemsChanged"], "symbols": ["onSystemsChanged", "Update", "the", "longest", "system", "name", "length", "and", "favicon", "based", "status", "function", "Record", "string", "SystemRecord", "changedSystem", "undefined", "const", "upSystemsStore", "upSystems", "get", "downSystemsStore", "downSystems", "Object", "values", "longestName", "longestSystemNameLen", "nameLen", "Math", "min", "MAX_SYSTEM_NAME_LENGTH", "set", "updateFavicon", "FAVICON_RED", "else", "FAVICON_GREEN"], "doc_head": "/** Update the longest system name length and favicon based on system status */\nfunction onSystemsChanged(_: Record<string, SystemRecord>, changedSystem: SystemRecord | undefined) {\n\tconst upSystemsStore = $upSystems.get()\n\tconst downSystemsStore = $downSystems.get()\n\tconst upSystems = Object.values(upSystemsStore)\n\tconst downSystems = Object.values(downSystemsStore)\n\t// Update longest system name length\n\tconst longestName = $longestSystemNameLen.get()\n\tconst nameLen = Math.min(MAX_SYSTEM_NAME_LENGTH, changedSystem?.name.length || 0)\n\tif (nameLen > longestName) {\n\t\t$longestSystemNameLen.set(nameLen)\n\t}\n\t// Update favicon based on system status\n\tif (downSystems.length > 0) {\n\t\tupdateFavicon(FAVICON_RED)\n\t} else if (upSystems.length > 0) {\n\t\tupdateFavicon(FAVICON_GREEN)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts", "rel_path": "src/site/src/lib/systemsManager.ts", "ext": "ts", "language": "typescript", "chunk_number": 5, "start_line": 92, "end_line": 122, "text": "\t} else {\n\t\tupdateFavicon(FAVICON_DEFAULT)\n\t}\n}\n\n/** Fetch systems from collection */\nasync function fetchSystems(): Promise<SystemRecord[]> {\n\ttry {\n\t\treturn await COLLECTION.getFullList({ sort: \"+name\", fields: FIELDS_DEFAULT })\n\t} catch (error) {\n\t\tconsole.error(\"Failed to fetch systems:\", error)\n\t\treturn []\n\t}\n}\n\n/** Add system to both name and ID stores */\nexport function add(system: SystemRecord) {\n\t$allSystemsByName.setKey(system.name, system)\n\t$allSystemsById.setKey(system.id, system)\n}\n\n/** Update system in stores */\nexport function update(system: SystemRecord) {\n\t// if name changed, make sure old name is removed from the name store\n\tconst oldName = $allSystemsById.get()[system.id]?.name\n\tif (oldName !== system.name) {\n\t\t$allSystemsByName.setKey(oldName, undefined as any)\n\t}\n\tadd(system)\n}\n", "n_tokens": 199, "primary_symbol": "fetchSystems", "primary_kind": "function", "primary_span": [98, 122], "def_symbols": ["fetchSystems", "add", "update"], "symbols": ["fetchSystems", "add", "update", "else", "updateFavicon", "FAVICON_DEFAULT", "Fetch", "systems", "from", "collection", "async", "function", "Promise", "SystemRecord", "try", "return", "await", "COLLECTION", "getFullList", "sort", "name", "fields", "FIELDS_DEFAULT", "catch", "error", "console", "Failed", "fetch", "Add", "system", "both", "and", "stores", "export", "allSystemsByName", "setKey", "allSystemsById", "Update", "changed", "make", "sure", "old", "removed", "the", "store", "const", "oldName", "get", "undefined", "any"], "doc_head": "\t} else {\n\t\tupdateFavicon(FAVICON_DEFAULT)\n\t}\n}\n/** Fetch systems from collection */\nasync function fetchSystems(): Promise<SystemRecord[]> {\n\ttry {\n\t\treturn await COLLECTION.getFullList({ sort: \"+name\", fields: FIELDS_DEFAULT })\n\t} catch (error) {\n\t\tconsole.error(\"Failed to fetch systems:\", error)\n\t\treturn []\n\t}\n}\n/** Add system to both name and ID stores */\nexport function add(system: SystemRecord) {\n\t$allSystemsByName.setKey(system.name, system)\n\t$allSystemsById.setKey(system.id, system)\n}\n/** Update system in stores */\nexport function update(system: SystemRecord) {\n\t// if name changed, make sure old name is removed from the name store\n\tconst oldName = $allSystemsById.get()[system.id]?.name\n\tif (oldName !== system.name) {\n\t\t$allSystemsByName.setKey(oldName, undefined as any)\n\t}\n\tadd(system)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts", "rel_path": "src/site/src/lib/systemsManager.ts", "ext": "ts", "language": "typescript", "chunk_number": 6, "start_line": 123, "end_line": 147, "text": "/** Remove system from stores */\nexport function remove(system: SystemRecord) {\n\tremoveFromStore(system, $allSystemsByName)\n\tremoveFromStore(system, $allSystemsById)\n\tremoveFromStore(system, $upSystems)\n\tremoveFromStore(system, $downSystems)\n\tremoveFromStore(system, $pausedSystems)\n}\n\n/** Remove system from specific store */\nfunction removeFromStore(system: SystemRecord, store: PreinitializedMapStore<Record<string, SystemRecord>>) {\n\tconst key = store === $allSystemsByName ? system.name : system.id\n\tstore.setKey(key, undefined as any)\n}\n\n/** Action functions for subscription */\nconst actionFns: Record<string, (system: SystemRecord) => void> = {\n\tcreate: add,\n\tupdate: update,\n\tdelete: remove,\n}\n\n/** Subscribe to real-time system updates from the collection */\nexport async function subscribe() {\n\ttry {", "n_tokens": 175, "primary_symbol": "remove", "primary_kind": "function", "primary_span": [124, 147], "def_symbols": ["remove", "removeFromStore", "subscribe"], "symbols": ["remove", "removeFromStore", "subscribe", "Remove", "system", "from", "stores", "export", "function", "SystemRecord", "allSystemsByName", "allSystemsById", "upSystems", "downSystems", "pausedSystems", "specific", "store", "PreinitializedMapStore", "Record", "string", "const", "key", "name", "setKey", "undefined", "any", "Action", "functions", "for", "subscription", "actionFns", "void", "create", "add", "update", "delete", "Subscribe", "real", "time", "updates", "the", "collection", "async", "try"], "doc_head": "/** Remove system from stores */\nexport function remove(system: SystemRecord) {\n\tremoveFromStore(system, $allSystemsByName)\n\tremoveFromStore(system, $allSystemsById)\n\tremoveFromStore(system, $upSystems)\n\tremoveFromStore(system, $downSystems)\n\tremoveFromStore(system, $pausedSystems)\n}\n/** Remove system from specific store */\nfunction removeFromStore(system: SystemRecord, store: PreinitializedMapStore<Record<string, SystemRecord>>) {\n\tconst key = store === $allSystemsByName ? system.name : system.id\n\tstore.setKey(key, undefined as any)\n}\n/** Action functions for subscription */\nconst actionFns: Record<string, (system: SystemRecord) => void> = {\n\tcreate: add,\n\tupdate: update,\n\tdelete: remove,\n}\n/** Subscribe to real-time system updates from the collection */\nexport async function subscribe() {\n\ttry {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/systemsManager.ts", "rel_path": "src/site/src/lib/systemsManager.ts", "ext": "ts", "language": "typescript", "chunk_number": 7, "start_line": 148, "end_line": 175, "text": "\t\tunsub = await COLLECTION.subscribe(\"*\", ({ action, record }) => actionFns[action]?.(record), {\n\t\t\tfields: FIELDS_DEFAULT,\n\t\t})\n\t} catch (error) {\n\t\tconsole.error(\"Failed to subscribe to systems collection:\", error)\n\t}\n}\n\n/** Refresh all systems with latest data from the hub */\nexport async function refresh() {\n\ttry {\n\t\tconst records = await fetchSystems()\n\t\tif (!records.length) {\n\t\t\t// No systems found, verify authentication\n\t\t\tverifyAuth()\n\t\t\treturn\n\t\t}\n\t\tfor (const record of records) {\n\t\t\tadd(record)\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(\"Failed to refresh systems:\", error)\n\t}\n}\n\n/** Unsubscribe from real-time system updates */\nexport const unsubscribe = () => (unsub = unsub?.())\n", "n_tokens": 170, "primary_symbol": "refresh", "primary_kind": "function", "primary_span": [157, 175], "def_symbols": ["refresh"], "symbols": ["refresh", "unsub", "await", "COLLECTION", "subscribe", "action", "record", "actionFns", "fields", "FIELDS_DEFAULT", "catch", "error", "console", "Failed", "systems", "collection", "Refresh", "all", "with", "latest", "data", "from", "the", "hub", "export", "async", "function", "try", "const", "records", "fetchSystems", "length", "found", "verify", "authentication", "verifyAuth", "return", "for", "add", "Unsubscribe", "real", "time", "system", "updates", "unsubscribe"], "doc_head": "\t\tunsub = await COLLECTION.subscribe(\"*\", ({ action, record }) => actionFns[action]?.(record), {\n\t\t\tfields: FIELDS_DEFAULT,\n\t\t})\n\t} catch (error) {\n\t\tconsole.error(\"Failed to subscribe to systems collection:\", error)\n\t}\n}\n/** Refresh all systems with latest data from the hub */\nexport async function refresh() {\n\ttry {\n\t\tconst records = await fetchSystems()\n\t\tif (!records.length) {\n\t\t\t// No systems found, verify authentication\n\t\t\tverifyAuth()\n\t\t\treturn\n\t\t}\n\t\tfor (const record of records) {\n\t\t\tadd(record)\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(\"Failed to refresh systems:\", error)\n\t}\n}\n/** Unsubscribe from real-time system updates */\nexport const unsubscribe = () => (unsub = unsub?.())"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/enums.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/enums.ts", "rel_path": "src/site/src/lib/enums.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 49, "text": "/** Operating system */\nexport enum Os {\n\tLinux = 0,\n\tDarwin,\n\tWindows,\n\tFreeBSD,\n}\n\n/** Type of chart */\nexport enum ChartType {\n\tMemory,\n\tDisk,\n\tNetwork,\n\tCPU,\n}\n\n/** Unit of measurement */\nexport enum Unit {\n\tBytes,\n\tBits,\n\tCelsius,\n\tFahrenheit,\n}\n\n/** Meter state for color */\nexport enum MeterState {\n\tGood,\n\tWarn,\n\tCrit,\n}\n\n/** System status states */\nexport enum SystemStatus {\n\tUp = \"up\",\n\tDown = \"down\",\n\tPending = \"pending\",\n\tPaused = \"paused\",\n}\n\n/** Battery state */\nexport enum BatteryState {\n\tUnknown,\n\tEmpty,\n\tFull,\n\tCharging,\n\tDischarging,\n\tIdle,\n}\n", "n_tokens": 158, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 49], "def_symbols": [], "symbols": ["Operating", "system", "export", "enum", "Linux", "Darwin", "Windows", "FreeBSD", "Type", "chart", "ChartType", "Memory", "Disk", "Network", "CPU", "Unit", "measurement", "Bytes", "Bits", "Celsius", "Fahrenheit", "Meter", "state", "for", "color", "MeterState", "Good", "Warn", "Crit", "System", "status", "states", "SystemStatus", "Down", "down", "Pending", "pending", "Paused", "paused", "Battery", "BatteryState", "Unknown", "Empty", "Full", "Charging", "Discharging", "Idle"], "doc_head": "/** Operating system */\nexport enum Os {\n\tLinux = 0,\n\tDarwin,\n\tWindows,\n\tFreeBSD,\n}\n/** Type of chart */\nexport enum ChartType {\n\tMemory,\n\tDisk,\n\tNetwork,\n\tCPU,\n}\n/** Unit of measurement */\nexport enum Unit {\n\tBytes,\n\tBits,\n\tCelsius,\n\tFahrenheit,\n}\n/** Meter state for color */\nexport enum MeterState {\n\tGood,\n\tWarn,\n\tCrit,\n}\n/** System status states */\nexport enum SystemStatus {\n\tUp = \"up\",\n\tDown = \"down\",\n\tPending = \"pending\",\n\tPaused = \"paused\",\n}\n/** Battery state */\nexport enum BatteryState {\n\tUnknown,\n\tEmpty,\n\tFull,\n\tCharging,\n\tDischarging,\n\tIdle,\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts", "rel_path": "src/site/src/lib/alerts.ts", "ext": "ts", "language": "typescript", "chunk_number": 1, "start_line": 1, "end_line": 15, "text": "import type { AlertInfo, AlertRecord } from \"@/types\"\nimport type { RecordSubscription } from \"pocketbase\"\nimport { $alerts } from \"@/lib/stores\"\nimport { EthernetIcon } from \"@/components/ui/icons\"\nimport { ServerIcon, CpuIcon, MemoryStickIcon, HardDriveIcon, ThermometerIcon, HourglassIcon } from \"lucide-react\"\nimport { t } from \"@lingui/core/macro\"\nimport { pb } from \"./api\"\n\n/** Alert info for each alert type */\nexport const alertInfo: Record<string, AlertInfo> = {\n\tStatus: {\n\t\tname: () => t`Status`,\n\t\tunit: \"\",\n\t\ticon: ServerIcon,\n\t\tdesc: () => t`Triggers when status switches between up and down`,", "n_tokens": 159, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 15], "def_symbols": [], "symbols": ["import", "type", "AlertInfo", "AlertRecord", "from", "types", "RecordSubscription", "pocketbase", "alerts", "lib", "stores", "EthernetIcon", "components", "icons", "ServerIcon", "CpuIcon", "MemoryStickIcon", "HardDriveIcon", "ThermometerIcon", "HourglassIcon", "lucide", "react", "lingui", "core", "macro", "api", "Alert", "info", "for", "each", "alert", "export", "const", "alertInfo", "Record", "string", "Status", "name", "unit", "icon", "desc", "Triggers", "when", "status", "switches", "between", "and", "down"], "doc_head": "import type { AlertInfo, AlertRecord } from \"@/types\"\nimport type { RecordSubscription } from \"pocketbase\"\nimport { $alerts } from \"@/lib/stores\"\nimport { EthernetIcon } from \"@/components/ui/icons\"\nimport { ServerIcon, CpuIcon, MemoryStickIcon, HardDriveIcon, ThermometerIcon, HourglassIcon } from \"lucide-react\"\nimport { t } from \"@lingui/core/macro\"\nimport { pb } from \"./api\"\n/** Alert info for each alert type */\nexport const alertInfo: Record<string, AlertInfo> = {\n\tStatus: {\n\t\tname: () => t`Status`,\n\t\tunit: \"\",\n\t\ticon: ServerIcon,\n\t\tdesc: () => t`Triggers when status switches between up and down`,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts", "rel_path": "src/site/src/lib/alerts.ts", "ext": "ts", "language": "typescript", "chunk_number": 2, "start_line": 16, "end_line": 40, "text": "\t\t/** \"for x minutes\" is appended to desc when only one value */\n\t\tsingleDesc: () => t`System` + \" \" + t`Down`,\n\t},\n\tCPU: {\n\t\tname: () => t`CPU Usage`,\n\t\tunit: \"%\",\n\t\ticon: CpuIcon,\n\t\tdesc: () => t`Triggers when CPU usage exceeds a threshold`,\n\t},\n\tMemory: {\n\t\tname: () => t`Memory Usage`,\n\t\tunit: \"%\",\n\t\ticon: MemoryStickIcon,\n\t\tdesc: () => t`Triggers when memory usage exceeds a threshold`,\n\t},\n\tDisk: {\n\t\tname: () => t`Disk Usage`,\n\t\tunit: \"%\",\n\t\ticon: HardDriveIcon,\n\t\tdesc: () => t`Triggers when usage of any disk exceeds a threshold`,\n\t},\n\tBandwidth: {\n\t\tname: () => t`Bandwidth`,\n\t\tunit: \" MB/s\",\n\t\ticon: EthernetIcon,", "n_tokens": 200, "primary_symbol": "", "primary_kind": "", "primary_span": [16, 40], "def_symbols": [], "symbols": ["for", "minutes", "appended", "desc", "when", "only", "one", "value", "singleDesc", "System", "Down", "CPU", "name", "Usage", "unit", "icon", "CpuIcon", "Triggers", "usage", "exceeds", "threshold", "Memory", "MemoryStickIcon", "memory", "Disk", "HardDriveIcon", "any", "disk", "Bandwidth", "EthernetIcon"], "doc_head": "\t\t/** \"for x minutes\" is appended to desc when only one value */\n\t\tsingleDesc: () => t`System` + \" \" + t`Down`,\n\t},\n\tCPU: {\n\t\tname: () => t`CPU Usage`,\n\t\tunit: \"%\",\n\t\ticon: CpuIcon,\n\t\tdesc: () => t`Triggers when CPU usage exceeds a threshold`,\n\t},\n\tMemory: {\n\t\tname: () => t`Memory Usage`,\n\t\tunit: \"%\",\n\t\ticon: MemoryStickIcon,\n\t\tdesc: () => t`Triggers when memory usage exceeds a threshold`,\n\t},\n\tDisk: {\n\t\tname: () => t`Disk Usage`,\n\t\tunit: \"%\",\n\t\ticon: HardDriveIcon,\n\t\tdesc: () => t`Triggers when usage of any disk exceeds a threshold`,\n\t},\n\tBandwidth: {\n\t\tname: () => t`Bandwidth`,\n\t\tunit: \" MB/s\",\n\t\ticon: EthernetIcon,"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts", "rel_path": "src/site/src/lib/alerts.ts", "ext": "ts", "language": "typescript", "chunk_number": 3, "start_line": 41, "end_line": 60, "text": "\t\tdesc: () => t`Triggers when combined up/down exceeds a threshold`,\n\t\tmax: 125,\n\t},\n\tTemperature: {\n\t\tname: () => t`Temperature`,\n\t\tunit: \"C\",\n\t\ticon: ThermometerIcon,\n\t\tdesc: () => t`Triggers when any sensor exceeds a threshold`,\n\t},\n\tLoadAvg1: {\n\t\tname: () => t`Load Average 1m`,\n\t\tunit: \"\",\n\t\ticon: HourglassIcon,\n\t\tmax: 100,\n\t\tmin: 0.1,\n\t\tstart: 10,\n\t\tstep: 0.1,\n\t\tdesc: () => t`Triggers when 1 minute load average exceeds a threshold`,\n\t},\n\tLoadAvg5: {", "n_tokens": 155, "primary_symbol": "", "primary_kind": "", "primary_span": [41, 60], "def_symbols": [], "symbols": ["desc", "Triggers", "when", "combined", "down", "exceeds", "threshold", "max", "Temperature", "name", "unit", "icon", "ThermometerIcon", "any", "sensor", "LoadAvg1", "Load", "Average", "HourglassIcon", "min", "start", "step", "minute", "load", "average", "LoadAvg5"], "doc_head": "\t\tdesc: () => t`Triggers when combined up/down exceeds a threshold`,\n\t\tmax: 125,\n\t},\n\tTemperature: {\n\t\tname: () => t`Temperature`,\n\t\tunit: \"C\",\n\t\ticon: ThermometerIcon,\n\t\tdesc: () => t`Triggers when any sensor exceeds a threshold`,\n\t},\n\tLoadAvg1: {\n\t\tname: () => t`Load Average 1m`,\n\t\tunit: \"\",\n\t\ticon: HourglassIcon,\n\t\tmax: 100,\n\t\tmin: 0.1,\n\t\tstart: 10,\n\t\tstep: 0.1,\n\t\tdesc: () => t`Triggers when 1 minute load average exceeds a threshold`,\n\t},\n\tLoadAvg5: {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts", "rel_path": "src/site/src/lib/alerts.ts", "ext": "ts", "language": "typescript", "chunk_number": 4, "start_line": 61, "end_line": 81, "text": "\t\tname: () => t`Load Average 5m`,\n\t\tunit: \"\",\n\t\ticon: HourglassIcon,\n\t\tmax: 100,\n\t\tmin: 0.1,\n\t\tstart: 10,\n\t\tstep: 0.1,\n\t\tdesc: () => t`Triggers when 5 minute load average exceeds a threshold`,\n\t},\n\tLoadAvg15: {\n\t\tname: () => t`Load Average 15m`,\n\t\tunit: \"\",\n\t\ticon: HourglassIcon,\n\t\tmin: 0.1,\n\t\tmax: 100,\n\t\tstart: 10,\n\t\tstep: 0.1,\n\t\tdesc: () => t`Triggers when 15 minute load average exceeds a threshold`,\n\t},\n} as const\n", "n_tokens": 156, "primary_symbol": "", "primary_kind": "", "primary_span": [61, 81], "def_symbols": [], "symbols": ["name", "Load", "Average", "unit", "icon", "HourglassIcon", "max", "min", "start", "step", "desc", "Triggers", "when", "minute", "load", "average", "exceeds", "threshold", "LoadAvg15", "const"], "doc_head": "\t\tname: () => t`Load Average 5m`,\n\t\tunit: \"\",\n\t\ticon: HourglassIcon,\n\t\tmax: 100,\n\t\tmin: 0.1,\n\t\tstart: 10,\n\t\tstep: 0.1,\n\t\tdesc: () => t`Triggers when 5 minute load average exceeds a threshold`,\n\t},\n\tLoadAvg15: {\n\t\tname: () => t`Load Average 15m`,\n\t\tunit: \"\",\n\t\ticon: HourglassIcon,\n\t\tmin: 0.1,\n\t\tmax: 100,\n\t\tstart: 10,\n\t\tstep: 0.1,\n\t\tdesc: () => t`Triggers when 15 minute load average exceeds a threshold`,\n\t},\n} as const"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts", "rel_path": "src/site/src/lib/alerts.ts", "ext": "ts", "language": "typescript", "chunk_number": 5, "start_line": 82, "end_line": 105, "text": "/** Helper to manage user alerts */\nexport const alertManager = (() => {\n\tconst collection = pb.collection<AlertRecord>(\"alerts\")\n\tlet unsub: () => void\n\n\t/** Fields to fetch from alerts collection */\n\tconst fields = \"id,name,system,value,min,triggered\"\n\n\t/** Fetch alerts from collection */\n\tasync function fetchAlerts(): Promise<AlertRecord[]> {\n\t\treturn await collection.getFullList<AlertRecord>({ fields, sort: \"updated\" })\n\t}\n\n\t/** Format alerts into a map of system id to alert name to alert record */\n\tfunction add(alerts: AlertRecord[]) {\n\t\tfor (const alert of alerts) {\n\t\t\tconst systemId = alert.system\n\t\t\tconst systemAlerts = $alerts.get()[systemId] ?? new Map()\n\t\t\tconst newAlerts = new Map(systemAlerts)\n\t\t\tnewAlerts.set(alert.name, alert)\n\t\t\t$alerts.setKey(systemId, newAlerts)\n\t\t}\n\t}\n", "n_tokens": 196, "primary_symbol": "fetchAlerts", "primary_kind": "function", "primary_span": [91, 105], "def_symbols": ["fetchAlerts", "add"], "symbols": ["fetchAlerts", "add", "Helper", "manage", "user", "alerts", "export", "const", "alertManager", "collection", "AlertRecord", "let", "unsub", "void", "Fields", "fetch", "from", "fields", "name", "system", "value", "min", "triggered", "Fetch", "async", "function", "Promise", "return", "await", "getFullList", "sort", "updated", "Format", "into", "map", "alert", "record", "for", "systemId", "systemAlerts", "get", "new", "Map", "newAlerts", "set", "setKey"], "doc_head": "/** Helper to manage user alerts */\nexport const alertManager = (() => {\n\tconst collection = pb.collection<AlertRecord>(\"alerts\")\n\tlet unsub: () => void\n\t/** Fields to fetch from alerts collection */\n\tconst fields = \"id,name,system,value,min,triggered\"\n\t/** Fetch alerts from collection */\n\tasync function fetchAlerts(): Promise<AlertRecord[]> {\n\t\treturn await collection.getFullList<AlertRecord>({ fields, sort: \"updated\" })\n\t}\n\t/** Format alerts into a map of system id to alert name to alert record */\n\tfunction add(alerts: AlertRecord[]) {\n\t\tfor (const alert of alerts) {\n\t\t\tconst systemId = alert.system\n\t\t\tconst systemAlerts = $alerts.get()[systemId] ?? new Map()\n\t\t\tconst newAlerts = new Map(systemAlerts)\n\t\t\tnewAlerts.set(alert.name, alert)\n\t\t\t$alerts.setKey(systemId, newAlerts)\n\t\t}\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts", "rel_path": "src/site/src/lib/alerts.ts", "ext": "ts", "language": "typescript", "chunk_number": 6, "start_line": 106, "end_line": 130, "text": "\tfunction remove(alerts: Pick<AlertRecord, \"name\" | \"system\">[]) {\n\t\tfor (const alert of alerts) {\n\t\t\tconst systemId = alert.system\n\t\t\tconst systemAlerts = $alerts.get()[systemId]\n\t\t\tconst newAlerts = new Map(systemAlerts)\n\t\t\tnewAlerts.delete(alert.name)\n\t\t\t$alerts.setKey(systemId, newAlerts)\n\t\t}\n\t}\n\n\tconst actionFns = {\n\t\tcreate: add,\n\t\tupdate: add,\n\t\tdelete: remove,\n\t}\n\n\t// batch alert updates to prevent unnecessary re-renders when adding many alerts at once\n\tconst batchUpdate = (() => {\n\t\tconst batch = new Map<string, RecordSubscription<AlertRecord>>()\n\t\tlet timeout: ReturnType<typeof setTimeout>\n\n\t\treturn (data: RecordSubscription<AlertRecord>) => {\n\t\t\tconst { record } = data\n\t\t\tbatch.set(`${record.system}${record.name}`, data)\n\t\t\tclearTimeout(timeout!)", "n_tokens": 198, "primary_symbol": "remove", "primary_kind": "function", "primary_span": [106, 130], "def_symbols": ["remove", "batchUpdate"], "symbols": ["remove", "batchUpdate", "function", "alerts", "Pick", "AlertRecord", "name", "system", "for", "const", "alert", "systemId", "systemAlerts", "get", "newAlerts", "new", "Map", "delete", "setKey", "actionFns", "create", "add", "update", "batch", "updates", "prevent", "unnecessary", "renders", "when", "adding", "many", "once", "string", "RecordSubscription", "let", "timeout", "ReturnType", "typeof", "setTimeout", "return", "data", "record", "set", "clearTimeout"], "doc_head": "\tfunction remove(alerts: Pick<AlertRecord, \"name\" | \"system\">[]) {\n\t\tfor (const alert of alerts) {\n\t\t\tconst systemId = alert.system\n\t\t\tconst systemAlerts = $alerts.get()[systemId]\n\t\t\tconst newAlerts = new Map(systemAlerts)\n\t\t\tnewAlerts.delete(alert.name)\n\t\t\t$alerts.setKey(systemId, newAlerts)\n\t\t}\n\t}\n\tconst actionFns = {\n\t\tcreate: add,\n\t\tupdate: add,\n\t\tdelete: remove,\n\t}\n\t// batch alert updates to prevent unnecessary re-renders when adding many alerts at once\n\tconst batchUpdate = (() => {\n\t\tconst batch = new Map<string, RecordSubscription<AlertRecord>>()\n\t\tlet timeout: ReturnType<typeof setTimeout>\n\t\treturn (data: RecordSubscription<AlertRecord>) => {\n\t\t\tconst { record } = data\n\t\t\tbatch.set(`${record.system}${record.name}`, data)\n\t\t\tclearTimeout(timeout!)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts", "rel_path": "src/site/src/lib/alerts.ts", "ext": "ts", "language": "typescript", "chunk_number": 7, "start_line": 131, "end_line": 153, "text": "\t\t\ttimeout = setTimeout(() => {\n\t\t\t\tconst groups = { create: [], update: [], delete: [] } as Record<string, AlertRecord[]>\n\t\t\t\tfor (const { action, record } of batch.values()) {\n\t\t\t\t\tgroups[action]?.push(record)\n\t\t\t\t}\n\t\t\t\tfor (const key in groups) {\n\t\t\t\t\tif (groups[key].length) {\n\t\t\t\t\t\tactionFns[key as keyof typeof actionFns]?.(groups[key])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbatch.clear()\n\t\t\t}, 50)\n\t\t}\n\t})()\n\n\tasync function subscribe() {\n\t\tunsub = await collection.subscribe(\"*\", batchUpdate, { fields })\n\t}\n\n\tfunction unsubscribe() {\n\t\tunsub?.()\n\t}\n", "n_tokens": 144, "primary_symbol": "subscribe", "primary_kind": "function", "primary_span": [146, 153], "def_symbols": ["subscribe", "unsubscribe"], "symbols": ["subscribe", "unsubscribe", "timeout", "setTimeout", "const", "groups", "create", "update", "delete", "Record", "string", "AlertRecord", "for", "action", "record", "batch", "values", "push", "key", "length", "actionFns", "keyof", "typeof", "clear", "async", "function", "unsub", "await", "collection", "batchUpdate", "fields"], "doc_head": "\t\t\ttimeout = setTimeout(() => {\n\t\t\t\tconst groups = { create: [], update: [], delete: [] } as Record<string, AlertRecord[]>\n\t\t\t\tfor (const { action, record } of batch.values()) {\n\t\t\t\t\tgroups[action]?.push(record)\n\t\t\t\t}\n\t\t\t\tfor (const key in groups) {\n\t\t\t\t\tif (groups[key].length) {\n\t\t\t\t\t\tactionFns[key as keyof typeof actionFns]?.(groups[key])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbatch.clear()\n\t\t\t}, 50)\n\t\t}\n\t})()\n\tasync function subscribe() {\n\t\tunsub = await collection.subscribe(\"*\", batchUpdate, { fields })\n\t}\n\tfunction unsubscribe() {\n\t\tunsub?.()\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/site/src/lib/alerts.ts", "rel_path": "src/site/src/lib/alerts.ts", "ext": "ts", "language": "typescript", "chunk_number": 8, "start_line": 154, "end_line": 172, "text": "\tasync function refresh() {\n\t\tconst records = await fetchAlerts()\n\t\tadd(records)\n\t}\n\n\treturn {\n\t\t/** Add alerts to store */\n\t\tadd,\n\t\t/** Remove alerts from store */\n\t\tremove,\n\t\t/** Subscribe to alerts */\n\t\tsubscribe,\n\t\t/** Unsubscribe from alerts */\n\t\tunsubscribe,\n\t\t/** Refresh alerts with latest data from hub */\n\t\trefresh,\n\t}\n})()\n", "n_tokens": 86, "primary_symbol": "refresh", "primary_kind": "function", "primary_span": [154, 172], "def_symbols": ["refresh"], "symbols": ["refresh", "async", "function", "const", "records", "await", "fetchAlerts", "add", "return", "Add", "alerts", "store", "Remove", "from", "remove", "Subscribe", "subscribe", "Unsubscribe", "unsubscribe", "Refresh", "with", "latest", "data", "hub"], "doc_head": "\tasync function refresh() {\n\t\tconst records = await fetchAlerts()\n\t\tadd(records)\n\t}\n\treturn {\n\t\t/** Add alerts to store */\n\t\tadd,\n\t\t/** Remove alerts from store */\n\t\tremove,\n\t\t/** Subscribe to alerts */\n\t\tsubscribe,\n\t\t/** Unsubscribe from alerts */\n\t\tunsubscribe,\n\t\t/** Refresh alerts with latest data from hub */\n\t\trefresh,\n\t}\n})()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_development.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_development.go", "rel_path": "src/hub/server_development.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 25, "text": "//go:build development\n\npackage hub\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/henrygd/beszel\"\n\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tools/osutils\"\n)\n\n// Wraps http.RoundTripper to modify dev proxy HTML responses\ntype responseModifier struct {\n\ttransport http.RoundTripper\n\thub       *Hub\n}\n", "n_tokens": 110, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 25], "def_symbols": [], "symbols": ["build", "development", "package", "hub", "import", "fmt", "log", "slog", "net", "http", "httputil", "url", "strings", "github", "com", "henrygd", "beszel", "pocketbase", "core", "tools", "osutils", "Wraps", "RoundTripper", "modify", "dev", "proxy", "HTML", "responses", "type", "responseModifier", "struct", "transport", "Hub"], "doc_head": "//go:build development\npackage hub\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"strings\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tools/osutils\"\n)\n// Wraps http.RoundTripper to modify dev proxy HTML responses\ntype responseModifier struct {\n\ttransport http.RoundTripper\n\thub       *Hub\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_development.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_development.go", "rel_path": "src/hub/server_development.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 26, "end_line": 49, "text": "func (rm *responseModifier) RoundTrip(req *http.Request) (*http.Response, error) {\n\tresp, err := rm.transport.RoundTrip(req)\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\t// Only modify HTML responses\n\tcontentType := resp.Header.Get(\"Content-Type\")\n\tif !strings.Contains(contentType, \"text/html\") {\n\t\treturn resp, nil\n\t}\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\tresp.Body.Close()\n\t// Create a new response with the modified body\n\tmodifiedBody := rm.modifyHTML(string(body))\n\tresp.Body = io.NopCloser(strings.NewReader(modifiedBody))\n\tresp.ContentLength = int64(len(modifiedBody))\n\tresp.Header.Set(\"Content-Length\", fmt.Sprintf(\"%d\", len(modifiedBody)))\n\n\treturn resp, nil\n}\n", "n_tokens": 176, "primary_symbol": "RoundTrip", "primary_kind": "function", "primary_span": [26, 49], "def_symbols": ["RoundTrip"], "symbols": ["RoundTrip", "func", "responseModifier", "req", "http", "Request", "Response", "error", "resp", "err", "transport", "nil", "return", "Only", "modify", "HTML", "responses", "contentType", "Header", "Get", "Content", "Type", "strings", "Contains", "text", "html", "body", "ReadAll", "Body", "Close", "Create", "new", "response", "with", "the", "modified", "modifiedBody", "modifyHTML", "string", "NopCloser", "NewReader", "ContentLength", "int64", "len", "Set", "Length", "fmt", "Sprintf"], "doc_head": "func (rm *responseModifier) RoundTrip(req *http.Request) (*http.Response, error) {\n\tresp, err := rm.transport.RoundTrip(req)\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\t// Only modify HTML responses\n\tcontentType := resp.Header.Get(\"Content-Type\")\n\tif !strings.Contains(contentType, \"text/html\") {\n\t\treturn resp, nil\n\t}\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\tresp.Body.Close()\n\t// Create a new response with the modified body\n\tmodifiedBody := rm.modifyHTML(string(body))\n\tresp.Body = io.NopCloser(strings.NewReader(modifiedBody))\n\tresp.ContentLength = int64(len(modifiedBody))\n\tresp.Header.Set(\"Content-Length\", fmt.Sprintf(\"%d\", len(modifiedBody)))\n\treturn resp, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_development.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_development.go", "rel_path": "src/hub/server_development.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 50, "end_line": 62, "text": "func (rm *responseModifier) modifyHTML(html string) string {\n\tparsedURL, err := url.Parse(rm.hub.appURL)\n\tif err != nil {\n\t\treturn html\n\t}\n\t// fix base paths in html if using subpath\n\tbasePath := strings.TrimSuffix(parsedURL.Path, \"/\") + \"/\"\n\thtml = strings.ReplaceAll(html, \"./\", basePath)\n\thtml = strings.Replace(html, \"{{V}}\", beszel.Version, 1)\n\thtml = strings.Replace(html, \"{{HUB_URL}}\", rm.hub.appURL, 1)\n\treturn html\n}\n", "n_tokens": 119, "primary_symbol": "modifyHTML", "primary_kind": "function", "primary_span": [50, 62], "def_symbols": ["modifyHTML"], "symbols": ["modifyHTML", "func", "responseModifier", "html", "string", "parsedURL", "err", "url", "Parse", "hub", "appURL", "nil", "return", "fix", "base", "paths", "using", "subpath", "basePath", "strings", "TrimSuffix", "Path", "ReplaceAll", "Replace", "beszel", "Version", "HUB_URL"], "doc_head": "func (rm *responseModifier) modifyHTML(html string) string {\n\tparsedURL, err := url.Parse(rm.hub.appURL)\n\tif err != nil {\n\t\treturn html\n\t}\n\t// fix base paths in html if using subpath\n\tbasePath := strings.TrimSuffix(parsedURL.Path, \"/\") + \"/\"\n\thtml = strings.ReplaceAll(html, \"./\", basePath)\n\thtml = strings.Replace(html, \"{{V}}\", beszel.Version, 1)\n\thtml = strings.Replace(html, \"{{HUB_URL}}\", rm.hub.appURL, 1)\n\treturn html\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_development.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_development.go", "rel_path": "src/hub/server_development.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 63, "end_line": 83, "text": "// startServer sets up the development server for Beszel\nfunc (h *Hub) startServer(se *core.ServeEvent) error {\n\tslog.Info(\"starting server\", \"appURL\", h.appURL)\n\tproxy := httputil.NewSingleHostReverseProxy(&url.URL{\n\t\tScheme: \"http\",\n\t\tHost:   \"localhost:5173\",\n\t})\n\n\tproxy.Transport = &responseModifier{\n\t\ttransport: http.DefaultTransport,\n\t\thub:       h,\n\t}\n\n\tse.Router.GET(\"/{path...}\", func(e *core.RequestEvent) error {\n\t\tproxy.ServeHTTP(e.Response, e.Request)\n\t\treturn nil\n\t})\n\t_ = osutils.LaunchURL(h.appURL)\n\treturn nil\n}\n", "n_tokens": 152, "primary_symbol": "startServer", "primary_kind": "function", "primary_span": [64, 83], "def_symbols": ["startServer"], "symbols": ["startServer", "sets", "the", "development", "server", "for", "Beszel", "func", "Hub", "core", "ServeEvent", "error", "slog", "Info", "starting", "appURL", "proxy", "httputil", "NewSingleHostReverseProxy", "url", "URL", "Scheme", "http", "Host", "localhost", "Transport", "responseModifier", "transport", "DefaultTransport", "hub", "Router", "GET", "path", "RequestEvent", "ServeHTTP", "Response", "Request", "return", "nil", "osutils", "LaunchURL"], "doc_head": "// startServer sets up the development server for Beszel\nfunc (h *Hub) startServer(se *core.ServeEvent) error {\n\tslog.Info(\"starting server\", \"appURL\", h.appURL)\n\tproxy := httputil.NewSingleHostReverseProxy(&url.URL{\n\t\tScheme: \"http\",\n\t\tHost:   \"localhost:5173\",\n\t})\n\tproxy.Transport = &responseModifier{\n\t\ttransport: http.DefaultTransport,\n\t\thub:       h,\n\t}\n\tse.Router.GET(\"/{path...}\", func(e *core.RequestEvent) error {\n\t\tproxy.ServeHTTP(e.Response, e.Request)\n\t\treturn nil\n\t})\n\t_ = osutils.LaunchURL(h.appURL)\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/update.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/update.go", "rel_path": "src/hub/update.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 12, "text": "package hub\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\n\t\"github.com/henrygd/beszel/src/ghupdate\"\n\t\"github.com/spf13/cobra\"\n)\n", "n_tokens": 43, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 12], "def_symbols": [], "symbols": ["package", "hub", "import", "fmt", "log", "exec", "github", "com", "henrygd", "beszel", "src", "ghupdate", "spf13", "cobra"], "doc_head": "package hub\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"github.com/henrygd/beszel/src/ghupdate\"\n\t\"github.com/spf13/cobra\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/update.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/update.go", "rel_path": "src/hub/update.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 13, "end_line": 48, "text": "// Update updates beszel to the latest version\nfunc Update(cmd *cobra.Command, _ []string) {\n\tdataDir := os.TempDir()\n\n\t// set dataDir to ./beszel_data if it exists\n\tif _, err := os.Stat(\"./beszel_data\"); err == nil {\n\t\tdataDir = \"./beszel_data\"\n\t}\n\n\t// Check if china-mirrors flag is set\n\tuseMirror, _ := cmd.Flags().GetBool(\"china-mirrors\")\n\n\tupdated, err := ghupdate.Update(ghupdate.Config{\n\t\tArchiveExecutable: \"beszel\",\n\t\tDataDir:           dataDir,\n\t\tUseMirror:         useMirror,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif !updated {\n\t\treturn\n\t}\n\n\t// make sure the file is executable\n\texePath, err := os.Executable()\n\tif err == nil {\n\t\tif err := os.Chmod(exePath, 0755); err != nil {\n\t\t\tfmt.Printf(\"Warning: failed to set executable permissions: %v\\n\", err)\n\t\t}\n\t}\n\n\t// Try to restart the service if it's running\n\trestartService()\n}\n", "n_tokens": 241, "primary_symbol": "Update", "primary_kind": "function", "primary_span": [14, 48], "def_symbols": ["Update"], "symbols": ["Update", "updates", "beszel", "the", "latest", "version", "func", "cmd", "cobra", "Command", "string", "dataDir", "TempDir", "set", "beszel_data", "exists", "err", "Stat", "nil", "Check", "china", "mirrors", "flag", "useMirror", "Flags", "GetBool", "updated", "ghupdate", "Config", "ArchiveExecutable", "DataDir", "UseMirror", "log", "Fatal", "return", "make", "sure", "file", "executable", "exePath", "Executable", "Chmod", "fmt", "Printf", "Warning", "failed", "permissions", "Try", "restart", "service", "running", "restartService"], "doc_head": "// Update updates beszel to the latest version\nfunc Update(cmd *cobra.Command, _ []string) {\n\tdataDir := os.TempDir()\n\t// set dataDir to ./beszel_data if it exists\n\tif _, err := os.Stat(\"./beszel_data\"); err == nil {\n\t\tdataDir = \"./beszel_data\"\n\t}\n\t// Check if china-mirrors flag is set\n\tuseMirror, _ := cmd.Flags().GetBool(\"china-mirrors\")\n\tupdated, err := ghupdate.Update(ghupdate.Config{\n\t\tArchiveExecutable: \"beszel\",\n\t\tDataDir:           dataDir,\n\t\tUseMirror:         useMirror,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif !updated {\n\t\treturn\n\t}\n\t// make sure the file is executable\n\texePath, err := os.Executable()\n\tif err == nil {\n\t\tif err := os.Chmod(exePath, 0755); err != nil {\n\t\t\tfmt.Printf(\"Warning: failed to set executable permissions: %v\\n\", err)\n\t\t}\n\t}\n\t// Try to restart the service if it's running\n\trestartService()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/update.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/update.go", "rel_path": "src/hub/update.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 49, "end_line": 86, "text": "// restartService attempts to restart the beszel service\nfunc restartService() {\n\t// Check if we're running as a service by looking for systemd\n\tif _, err := exec.LookPath(\"systemctl\"); err == nil {\n\t\t// Check if beszel service exists and is active\n\t\tcmd := exec.Command(\"systemctl\", \"is-active\", \"beszel.service\")\n\t\tif err := cmd.Run(); err == nil {\n\t\t\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel service...\")\n\t\t\trestartCmd := exec.Command(\"systemctl\", \"restart\", \"beszel.service\")\n\t\t\tif err := restartCmd.Run(); err != nil {\n\t\t\t\tghupdate.ColorPrintf(ghupdate.ColorYellow, \"Warning: Failed to restart service: %v\\n\", err)\n\t\t\t\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Please restart the service manually: sudo systemctl restart beszel\")\n\t\t\t} else {\n\t\t\t\tghupdate.ColorPrint(ghupdate.ColorGreen, \"Service restarted successfully\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Check for OpenRC (Alpine Linux)\n\tif _, err := exec.LookPath(\"rc-service\"); err == nil {\n\t\tcmd := exec.Command(\"rc-service\", \"beszel\", \"status\")\n\t\tif err := cmd.Run(); err == nil {\n\t\t\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel service...\")\n\t\t\trestartCmd := exec.Command(\"rc-service\", \"beszel\", \"restart\")\n\t\t\tif err := restartCmd.Run(); err != nil {\n\t\t\t\tghupdate.ColorPrintf(ghupdate.ColorYellow, \"Warning: Failed to restart service: %v\\n\", err)\n\t\t\t\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Please restart the service manually: sudo rc-service beszel restart\")\n\t\t\t} else {\n\t\t\t\tghupdate.ColorPrint(ghupdate.ColorGreen, \"Service restarted successfully\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Service restart not attempted. If running as a service, restart manually.\")\n}\n", "n_tokens": 436, "primary_symbol": "restartService", "primary_kind": "function", "primary_span": [50, 86], "def_symbols": ["restartService"], "symbols": ["restartService", "attempts", "restart", "the", "beszel", "service", "func", "Check", "running", "looking", "for", "systemd", "err", "exec", "LookPath", "systemctl", "nil", "exists", "and", "active", "cmd", "Command", "Run", "ghupdate", "ColorPrint", "ColorYellow", "Restarting", "restartCmd", "ColorPrintf", "Warning", "Failed", "Please", "manually", "sudo", "else", "ColorGreen", "Service", "restarted", "successfully", "return", "OpenRC", "Alpine", "Linux", "status", "not", "attempted"], "doc_head": "// restartService attempts to restart the beszel service\nfunc restartService() {\n\t// Check if we're running as a service by looking for systemd\n\tif _, err := exec.LookPath(\"systemctl\"); err == nil {\n\t\t// Check if beszel service exists and is active\n\t\tcmd := exec.Command(\"systemctl\", \"is-active\", \"beszel.service\")\n\t\tif err := cmd.Run(); err == nil {\n\t\t\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel service...\")\n\t\t\trestartCmd := exec.Command(\"systemctl\", \"restart\", \"beszel.service\")\n\t\t\tif err := restartCmd.Run(); err != nil {\n\t\t\t\tghupdate.ColorPrintf(ghupdate.ColorYellow, \"Warning: Failed to restart service: %v\\n\", err)\n\t\t\t\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Please restart the service manually: sudo systemctl restart beszel\")\n\t\t\t} else {\n\t\t\t\tghupdate.ColorPrint(ghupdate.ColorGreen, \"Service restarted successfully\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\t// Check for OpenRC (Alpine Linux)\n\tif _, err := exec.LookPath(\"rc-service\"); err == nil {\n\t\tcmd := exec.Command(\"rc-service\", \"beszel\", \"status\")\n\t\tif err := cmd.Run(); err == nil {\n\t\t\tghupdate.ColorPrint(ghupdate.ColorYellow, \"Restarting beszel service...\")\n\t\t\trestartCmd := exec.Command(\"rc-service\", \"beszel\", \"restart\")\n\t\t\tif"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 20, "text": "package hub\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/common\"\n\t\"github.com/henrygd/beszel/src/hub/expirymap\"\n\t\"github.com/henrygd/beszel/src/hub/ws\"\n\n\t\"github.com/blang/semver\"\n\t\"github.com/lxzan/gws\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n", "n_tokens": 109, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 20], "def_symbols": [], "symbols": ["package", "hub", "import", "errors", "net", "http", "strings", "sync", "time", "github", "com", "henrygd", "beszel", "src", "common", "expirymap", "blang", "semver", "lxzan", "gws", "pocketbase", "dbx", "core"], "doc_head": "package hub\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/common\"\n\t\"github.com/henrygd/beszel/src/hub/expirymap\"\n\t\"github.com/henrygd/beszel/src/hub/ws\"\n\t\"github.com/blang/semver\"\n\t\"github.com/lxzan/gws\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 21, "end_line": 49, "text": "// agentConnectRequest holds information related to an agent's connection attempt.\ntype agentConnectRequest struct {\n\thub         *Hub\n\treq         *http.Request\n\tres         http.ResponseWriter\n\ttoken       string\n\tagentSemVer semver.Version\n\t// isUniversalToken is true if the token is a universal token.\n\tisUniversalToken bool\n\t// userId is the user ID associated with the universal token.\n\tuserId string\n}\n\n// universalTokenMap stores active universal tokens and their associated user IDs.\nvar universalTokenMap tokenMap\n\ntype tokenMap struct {\n\tstore *expirymap.ExpiryMap[string]\n\tonce  sync.Once\n}\n\n// getMap returns the expirymap, creating it if necessary.\nfunc (tm *tokenMap) GetMap() *expirymap.ExpiryMap[string] {\n\ttm.once.Do(func() {\n\t\ttm.store = expirymap.New[string](time.Hour)\n\t})\n\treturn tm.store\n}\n", "n_tokens": 196, "primary_symbol": "GetMap", "primary_kind": "function", "primary_span": [43, 49], "def_symbols": ["GetMap"], "symbols": ["GetMap", "agentConnectRequest", "holds", "information", "related", "agent", "connection", "attempt", "type", "struct", "hub", "Hub", "req", "http", "Request", "res", "ResponseWriter", "token", "string", "agentSemVer", "semver", "Version", "isUniversalToken", "true", "the", "universal", "bool", "userId", "user", "associated", "with", "universalTokenMap", "stores", "active", "tokens", "and", "their", "IDs", "var", "tokenMap", "store", "expirymap", "ExpiryMap", "once", "sync", "Once", "getMap", "returns", "creating", "necessary", "func", "New", "time", "Hour", "return"], "doc_head": "// agentConnectRequest holds information related to an agent's connection attempt.\ntype agentConnectRequest struct {\n\thub         *Hub\n\treq         *http.Request\n\tres         http.ResponseWriter\n\ttoken       string\n\tagentSemVer semver.Version\n\t// isUniversalToken is true if the token is a universal token.\n\tisUniversalToken bool\n\t// userId is the user ID associated with the universal token.\n\tuserId string\n}\n// universalTokenMap stores active universal tokens and their associated user IDs.\nvar universalTokenMap tokenMap\ntype tokenMap struct {\n\tstore *expirymap.ExpiryMap[string]\n\tonce  sync.Once\n}\n// getMap returns the expirymap, creating it if necessary.\nfunc (tm *tokenMap) GetMap() *expirymap.ExpiryMap[string] {\n\ttm.once.Do(func() {\n\t\ttm.store = expirymap.New[string](time.Hour)\n\t})\n\treturn tm.store\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 50, "end_line": 56, "text": "// handleAgentConnect is the HTTP handler for an agent's connection request.\nfunc (h *Hub) handleAgentConnect(e *core.RequestEvent) error {\n\tagentRequest := agentConnectRequest{req: e.Request, res: e.Response, hub: h}\n\t_ = agentRequest.agentConnect()\n\treturn nil\n}\n", "n_tokens": 66, "primary_symbol": "handleAgentConnect", "primary_kind": "function", "primary_span": [51, 56], "def_symbols": ["handleAgentConnect"], "symbols": ["handleAgentConnect", "the", "HTTP", "handler", "for", "agent", "connection", "request", "func", "Hub", "core", "RequestEvent", "error", "agentRequest", "agentConnectRequest", "req", "Request", "res", "Response", "hub", "agentConnect", "return", "nil"], "doc_head": "// handleAgentConnect is the HTTP handler for an agent's connection request.\nfunc (h *Hub) handleAgentConnect(e *core.RequestEvent) error {\n\tagentRequest := agentConnectRequest{req: e.Request, res: e.Response, hub: h}\n\t_ = agentRequest.agentConnect()\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 57, "end_line": 92, "text": "// agentConnect validates agent credentials and upgrades the connection to a WebSocket.\nfunc (acr *agentConnectRequest) agentConnect() (err error) {\n\tvar agentVersion string\n\n\tacr.token, agentVersion, err = acr.validateAgentHeaders(acr.req.Header)\n\tif err != nil {\n\t\treturn acr.sendResponseError(acr.res, http.StatusBadRequest, \"\")\n\t}\n\n\t// Check if token is an active universal token\n\tacr.userId, acr.isUniversalToken = universalTokenMap.GetMap().GetOk(acr.token)\n\n\t// Find matching fingerprint records for this token\n\tfpRecords := getFingerprintRecordsByToken(acr.token, acr.hub)\n\tif len(fpRecords) == 0 && !acr.isUniversalToken {\n\t\t// Invalid token - no records found and not a universal token\n\t\treturn acr.sendResponseError(acr.res, http.StatusUnauthorized, \"Invalid token\")\n\t}\n\n\t// Validate agent version\n\tacr.agentSemVer, err = semver.Parse(agentVersion)\n\tif err != nil {\n\t\treturn acr.sendResponseError(acr.res, http.StatusUnauthorized, \"Invalid agent version\")\n\t}\n\n\t// Upgrade connection to WebSocket\n\tconn, err := ws.GetUpgrader().Upgrade(acr.res, acr.req)\n\tif err != nil {\n\t\treturn acr.sendResponseError(acr.res, http.StatusInternalServerError, \"WebSocket upgrade failed\")\n\t}\n\n\tgo acr.verifyWsConn(conn, fpRecords)\n\n\treturn nil\n}\n", "n_tokens": 302, "primary_symbol": "agentConnect", "primary_kind": "function", "primary_span": [58, 92], "def_symbols": ["agentConnect"], "symbols": ["agentConnect", "validates", "agent", "credentials", "and", "upgrades", "the", "connection", "WebSocket", "func", "acr", "agentConnectRequest", "err", "error", "var", "agentVersion", "string", "token", "validateAgentHeaders", "req", "Header", "nil", "return", "sendResponseError", "res", "http", "StatusBadRequest", "Check", "active", "universal", "userId", "isUniversalToken", "universalTokenMap", "GetMap", "GetOk", "Find", "matching", "fingerprint", "records", "for", "this", "fpRecords", "getFingerprintRecordsByToken", "hub", "len", "Invalid", "found", "not", "StatusUnauthorized", "Validate", "version", "agentSemVer", "semver", "Parse", "Upgrade", "conn", "GetUpgrader", "StatusInternalServerError", "upgrade", "failed", "verifyWsConn"], "doc_head": "// agentConnect validates agent credentials and upgrades the connection to a WebSocket.\nfunc (acr *agentConnectRequest) agentConnect() (err error) {\n\tvar agentVersion string\n\tacr.token, agentVersion, err = acr.validateAgentHeaders(acr.req.Header)\n\tif err != nil {\n\t\treturn acr.sendResponseError(acr.res, http.StatusBadRequest, \"\")\n\t}\n\t// Check if token is an active universal token\n\tacr.userId, acr.isUniversalToken = universalTokenMap.GetMap().GetOk(acr.token)\n\t// Find matching fingerprint records for this token\n\tfpRecords := getFingerprintRecordsByToken(acr.token, acr.hub)\n\tif len(fpRecords) == 0 && !acr.isUniversalToken {\n\t\t// Invalid token - no records found and not a universal token\n\t\treturn acr.sendResponseError(acr.res, http.StatusUnauthorized, \"Invalid token\")\n\t}\n\t// Validate agent version\n\tacr.agentSemVer, err = semver.Parse(agentVersion)\n\tif err != nil {\n\t\treturn acr.sendResponseError(acr.res, http.StatusUnauthorized, \"Invalid agent version\")\n\t}\n\t// Upgrade connection to WebSocket\n\tconn, err := ws.GetUpgrader().Upgrade(acr.res, acr.req)\n\tif err != nil {\n\t\treturn acr.sendResponseError(acr.res, http.StatusInternalServerError, \"WebSocket upgrade failed\")\n\t}\n\tgo acr.verifyWsConn("}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 93, "end_line": 128, "text": "// verifyWsConn verifies the WebSocket connection using the agent's fingerprint and\n// SSH key signature, then adds the system to the system manager.\nfunc (acr *agentConnectRequest) verifyWsConn(conn *gws.Conn, fpRecords []ws.FingerprintRecord) (err error) {\n\twsConn := ws.NewWsConnection(conn)\n\n\t// must set wsConn in connection store before the read loop\n\tconn.Session().Store(\"wsConn\", wsConn)\n\n\t// make sure connection is closed if there is an error\n\tdefer func() {\n\t\tif err != nil {\n\t\t\twsConn.Close([]byte(err.Error()))\n\t\t}\n\t}()\n\n\tgo conn.ReadLoop()\n\n\tsigner, err := acr.hub.GetSSHKey(\"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tagentFingerprint, err := wsConn.GetFingerprint(acr.token, signer, acr.isUniversalToken)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Find or create the appropriate system for this token and fingerprint\n\tfpRecord, err := acr.findOrCreateSystemForToken(fpRecords, agentFingerprint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn acr.hub.sm.AddWebSocketSystem(fpRecord.SystemId, acr.agentSemVer, wsConn)\n}\n", "n_tokens": 264, "primary_symbol": "verifyWsConn", "primary_kind": "function", "primary_span": [95, 128], "def_symbols": ["verifyWsConn"], "symbols": ["verifyWsConn", "verifies", "the", "WebSocket", "connection", "using", "agent", "fingerprint", "and", "SSH", "key", "signature", "then", "adds", "system", "manager", "func", "acr", "agentConnectRequest", "conn", "gws", "Conn", "fpRecords", "FingerprintRecord", "err", "error", "wsConn", "NewWsConnection", "must", "set", "store", "before", "read", "loop", "Session", "Store", "make", "sure", "closed", "there", "defer", "nil", "Close", "byte", "Error", "ReadLoop", "signer", "hub", "GetSSHKey", "return", "agentFingerprint", "GetFingerprint", "token", "isUniversalToken", "Find", "create", "appropriate", "for", "this", "fpRecord", "findOrCreateSystemForToken", "AddWebSocketSystem", "SystemId", "agentSemVer"], "doc_head": "// verifyWsConn verifies the WebSocket connection using the agent's fingerprint and\n// SSH key signature, then adds the system to the system manager.\nfunc (acr *agentConnectRequest) verifyWsConn(conn *gws.Conn, fpRecords []ws.FingerprintRecord) (err error) {\n\twsConn := ws.NewWsConnection(conn)\n\t// must set wsConn in connection store before the read loop\n\tconn.Session().Store(\"wsConn\", wsConn)\n\t// make sure connection is closed if there is an error\n\tdefer func() {\n\t\tif err != nil {\n\t\t\twsConn.Close([]byte(err.Error()))\n\t\t}\n\t}()\n\tgo conn.ReadLoop()\n\tsigner, err := acr.hub.GetSSHKey(\"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tagentFingerprint, err := wsConn.GetFingerprint(acr.token, signer, acr.isUniversalToken)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Find or create the appropriate system for this token and fingerprint\n\tfpRecord, err := acr.findOrCreateSystemForToken(fpRecords, agentFingerprint)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn acr.hub.sm.AddWebSocketSystem(fpRecord.SystemId, acr.agentSemVer, wsConn)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 129, "end_line": 148, "text": "// validateAgentHeaders extracts and validates the token and agent version from HTTP headers.\nfunc (acr *agentConnectRequest) validateAgentHeaders(headers http.Header) (string, string, error) {\n\ttoken := headers.Get(\"X-Token\")\n\tagentVersion := headers.Get(\"X-Beszel\")\n\n\tif agentVersion == \"\" || token == \"\" || len(token) > 64 {\n\t\treturn \"\", \"\", errors.New(\"\")\n\t}\n\treturn token, agentVersion, nil\n}\n\n// sendResponseError writes an HTTP error response.\nfunc (acr *agentConnectRequest) sendResponseError(res http.ResponseWriter, code int, message string) error {\n\tres.WriteHeader(code)\n\tif message != \"\" {\n\t\tres.Write([]byte(message))\n\t}\n\treturn nil\n}\n", "n_tokens": 149, "primary_symbol": "validateAgentHeaders", "primary_kind": "function", "primary_span": [130, 148], "def_symbols": ["validateAgentHeaders", "sendResponseError"], "symbols": ["validateAgentHeaders", "sendResponseError", "extracts", "and", "validates", "the", "token", "agent", "version", "from", "HTTP", "headers", "func", "acr", "agentConnectRequest", "http", "Header", "string", "error", "Get", "Token", "agentVersion", "Beszel", "len", "return", "errors", "New", "nil", "writes", "response", "res", "ResponseWriter", "code", "int", "message", "WriteHeader", "Write", "byte"], "doc_head": "// validateAgentHeaders extracts and validates the token and agent version from HTTP headers.\nfunc (acr *agentConnectRequest) validateAgentHeaders(headers http.Header) (string, string, error) {\n\ttoken := headers.Get(\"X-Token\")\n\tagentVersion := headers.Get(\"X-Beszel\")\n\tif agentVersion == \"\" || token == \"\" || len(token) > 64 {\n\t\treturn \"\", \"\", errors.New(\"\")\n\t}\n\treturn token, agentVersion, nil\n}\n// sendResponseError writes an HTTP error response.\nfunc (acr *agentConnectRequest) sendResponseError(res http.ResponseWriter, code int, message string) error {\n\tres.WriteHeader(code)\n\tif message != \"\" {\n\t\tres.Write([]byte(message))\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 149, "end_line": 160, "text": "// getFingerprintRecordsByToken retrieves all fingerprint records associated with a given token.\nfunc getFingerprintRecordsByToken(token string, h *Hub) []ws.FingerprintRecord {\n\tvar records []ws.FingerprintRecord\n\t// All will populate empty slice even on error\n\t_ = h.DB().NewQuery(\"SELECT id, system, fingerprint, token FROM fingerprints WHERE token = {:token}\").\n\t\tBind(dbx.Params{\n\t\t\t\"token\": token,\n\t\t}).\n\t\tAll(&records)\n\treturn records\n}\n", "n_tokens": 110, "primary_symbol": "getFingerprintRecordsByToken", "primary_kind": "function", "primary_span": [150, 160], "def_symbols": ["getFingerprintRecordsByToken"], "symbols": ["getFingerprintRecordsByToken", "retrieves", "all", "fingerprint", "records", "associated", "with", "given", "token", "func", "string", "Hub", "FingerprintRecord", "var", "All", "will", "populate", "empty", "slice", "even", "error", "NewQuery", "SELECT", "system", "FROM", "fingerprints", "WHERE", "Bind", "dbx", "Params", "return"], "doc_head": "// getFingerprintRecordsByToken retrieves all fingerprint records associated with a given token.\nfunc getFingerprintRecordsByToken(token string, h *Hub) []ws.FingerprintRecord {\n\tvar records []ws.FingerprintRecord\n\t// All will populate empty slice even on error\n\t_ = h.DB().NewQuery(\"SELECT id, system, fingerprint, token FROM fingerprints WHERE token = {:token}\").\n\t\tBind(dbx.Params{\n\t\t\t\"token\": token,\n\t\t}).\n\t\tAll(&records)\n\treturn records\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 161, "end_line": 177, "text": "// findOrCreateSystemForToken finds an existing system matching the token and fingerprint,\n// or creates a new one for a universal token.\nfunc (acr *agentConnectRequest) findOrCreateSystemForToken(fpRecords []ws.FingerprintRecord, agentFingerprint common.FingerprintResponse) (ws.FingerprintRecord, error) {\n\t// No records - only valid for active universal tokens\n\tif len(fpRecords) == 0 {\n\t\treturn acr.handleNoRecords(agentFingerprint)\n\t}\n\n\t// Single record - handle as regular token\n\tif len(fpRecords) == 1 && !acr.isUniversalToken {\n\t\treturn acr.handleSingleRecord(fpRecords[0], agentFingerprint)\n\t}\n\n\t// Multiple records or universal token - look for matching fingerprint\n\treturn acr.handleMultipleRecordsOrUniversalToken(fpRecords, agentFingerprint)\n}\n", "n_tokens": 172, "primary_symbol": "findOrCreateSystemForToken", "primary_kind": "function", "primary_span": [163, 177], "def_symbols": ["findOrCreateSystemForToken"], "symbols": ["findOrCreateSystemForToken", "finds", "existing", "system", "matching", "the", "token", "and", "fingerprint", "creates", "new", "one", "for", "universal", "func", "acr", "agentConnectRequest", "fpRecords", "FingerprintRecord", "agentFingerprint", "common", "FingerprintResponse", "error", "records", "only", "valid", "active", "tokens", "len", "return", "handleNoRecords", "Single", "record", "handle", "regular", "isUniversalToken", "handleSingleRecord", "Multiple", "look", "handleMultipleRecordsOrUniversalToken"], "doc_head": "// findOrCreateSystemForToken finds an existing system matching the token and fingerprint,\n// or creates a new one for a universal token.\nfunc (acr *agentConnectRequest) findOrCreateSystemForToken(fpRecords []ws.FingerprintRecord, agentFingerprint common.FingerprintResponse) (ws.FingerprintRecord, error) {\n\t// No records - only valid for active universal tokens\n\tif len(fpRecords) == 0 {\n\t\treturn acr.handleNoRecords(agentFingerprint)\n\t}\n\t// Single record - handle as regular token\n\tif len(fpRecords) == 1 && !acr.isUniversalToken {\n\t\treturn acr.handleSingleRecord(fpRecords[0], agentFingerprint)\n\t}\n\t// Multiple records or universal token - look for matching fingerprint\n\treturn acr.handleMultipleRecordsOrUniversalToken(fpRecords, agentFingerprint)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 178, "end_line": 189, "text": "// handleNoRecords handles the case where no fingerprint records are found for a token.\n// A new system is created if the token is a valid universal token.\nfunc (acr *agentConnectRequest) handleNoRecords(agentFingerprint common.FingerprintResponse) (ws.FingerprintRecord, error) {\n\tvar fpRecord ws.FingerprintRecord\n\n\tif !acr.isUniversalToken || acr.userId == \"\" {\n\t\treturn fpRecord, errors.New(\"no matching fingerprints\")\n\t}\n\n\treturn acr.createNewSystemForUniversalToken(agentFingerprint)\n}\n", "n_tokens": 108, "primary_symbol": "handleNoRecords", "primary_kind": "function", "primary_span": [180, 189], "def_symbols": ["handleNoRecords"], "symbols": ["handleNoRecords", "handles", "the", "case", "where", "fingerprint", "records", "are", "found", "for", "token", "new", "system", "created", "valid", "universal", "func", "acr", "agentConnectRequest", "agentFingerprint", "common", "FingerprintResponse", "FingerprintRecord", "error", "var", "fpRecord", "isUniversalToken", "userId", "return", "errors", "New", "matching", "fingerprints", "createNewSystemForUniversalToken"], "doc_head": "// handleNoRecords handles the case where no fingerprint records are found for a token.\n// A new system is created if the token is a valid universal token.\nfunc (acr *agentConnectRequest) handleNoRecords(agentFingerprint common.FingerprintResponse) (ws.FingerprintRecord, error) {\n\tvar fpRecord ws.FingerprintRecord\n\tif !acr.isUniversalToken || acr.userId == \"\" {\n\t\treturn fpRecord, errors.New(\"no matching fingerprints\")\n\t}\n\treturn acr.createNewSystemForUniversalToken(agentFingerprint)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 190, "end_line": 210, "text": "// handleSingleRecord handles the case with a single fingerprint record. It validates\n// the agent's fingerprint against the stored one, or sets it on first connect.\nfunc (acr *agentConnectRequest) handleSingleRecord(fpRecord ws.FingerprintRecord, agentFingerprint common.FingerprintResponse) (ws.FingerprintRecord, error) {\n\t// If no current fingerprint, update with new fingerprint (first time connecting)\n\tif fpRecord.Fingerprint == \"\" {\n\t\tif err := acr.hub.SetFingerprint(&fpRecord, agentFingerprint.Fingerprint); err != nil {\n\t\t\treturn fpRecord, err\n\t\t}\n\t\t// Update the record with the fingerprint that was set\n\t\tfpRecord.Fingerprint = agentFingerprint.Fingerprint\n\t\treturn fpRecord, nil\n\t}\n\n\t// Abort if fingerprint exists but doesn't match (different machine)\n\tif fpRecord.Fingerprint != agentFingerprint.Fingerprint {\n\t\treturn fpRecord, errors.New(\"fingerprint mismatch\")\n\t}\n\n\treturn fpRecord, nil\n}\n", "n_tokens": 208, "primary_symbol": "handleSingleRecord", "primary_kind": "function", "primary_span": [192, 210], "def_symbols": ["handleSingleRecord"], "symbols": ["handleSingleRecord", "handles", "the", "case", "with", "single", "fingerprint", "record", "validates", "agent", "against", "stored", "one", "sets", "first", "connect", "func", "acr", "agentConnectRequest", "fpRecord", "FingerprintRecord", "agentFingerprint", "common", "FingerprintResponse", "error", "current", "update", "new", "time", "connecting", "Fingerprint", "err", "hub", "SetFingerprint", "nil", "return", "Update", "that", "was", "set", "Abort", "exists", "but", "doesn", "match", "different", "machine", "errors", "New", "mismatch"], "doc_head": "// handleSingleRecord handles the case with a single fingerprint record. It validates\n// the agent's fingerprint against the stored one, or sets it on first connect.\nfunc (acr *agentConnectRequest) handleSingleRecord(fpRecord ws.FingerprintRecord, agentFingerprint common.FingerprintResponse) (ws.FingerprintRecord, error) {\n\t// If no current fingerprint, update with new fingerprint (first time connecting)\n\tif fpRecord.Fingerprint == \"\" {\n\t\tif err := acr.hub.SetFingerprint(&fpRecord, agentFingerprint.Fingerprint); err != nil {\n\t\t\treturn fpRecord, err\n\t\t}\n\t\t// Update the record with the fingerprint that was set\n\t\tfpRecord.Fingerprint = agentFingerprint.Fingerprint\n\t\treturn fpRecord, nil\n\t}\n\t// Abort if fingerprint exists but doesn't match (different machine)\n\tif fpRecord.Fingerprint != agentFingerprint.Fingerprint {\n\t\treturn fpRecord, errors.New(\"fingerprint mismatch\")\n\t}\n\treturn fpRecord, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 211, "end_line": 229, "text": "// handleMultipleRecordsOrUniversalToken finds a matching fingerprint from multiple records.\n// If no match is found and the token is a universal token, a new system is created.\nfunc (acr *agentConnectRequest) handleMultipleRecordsOrUniversalToken(fpRecords []ws.FingerprintRecord, agentFingerprint common.FingerprintResponse) (ws.FingerprintRecord, error) {\n\t// Return existing record with matching fingerprint if found\n\tfor i := range fpRecords {\n\t\tif fpRecords[i].Fingerprint == agentFingerprint.Fingerprint {\n\t\t\treturn fpRecords[i], nil\n\t\t}\n\t}\n\n\t// No matching fingerprint record found, but it's\n\t// an active universal token so create a new system\n\tif acr.isUniversalToken {\n\t\treturn acr.createNewSystemForUniversalToken(agentFingerprint)\n\t}\n\n\treturn ws.FingerprintRecord{}, errors.New(\"fingerprint mismatch\")\n}\n", "n_tokens": 180, "primary_symbol": "handleMultipleRecordsOrUniversalToken", "primary_kind": "function", "primary_span": [213, 229], "def_symbols": ["handleMultipleRecordsOrUniversalToken"], "symbols": ["handleMultipleRecordsOrUniversalToken", "finds", "matching", "fingerprint", "from", "multiple", "records", "match", "found", "and", "the", "token", "universal", "new", "system", "created", "func", "acr", "agentConnectRequest", "fpRecords", "FingerprintRecord", "agentFingerprint", "common", "FingerprintResponse", "error", "Return", "existing", "record", "with", "for", "range", "Fingerprint", "return", "nil", "but", "active", "create", "isUniversalToken", "createNewSystemForUniversalToken", "errors", "New", "mismatch"], "doc_head": "// handleMultipleRecordsOrUniversalToken finds a matching fingerprint from multiple records.\n// If no match is found and the token is a universal token, a new system is created.\nfunc (acr *agentConnectRequest) handleMultipleRecordsOrUniversalToken(fpRecords []ws.FingerprintRecord, agentFingerprint common.FingerprintResponse) (ws.FingerprintRecord, error) {\n\t// Return existing record with matching fingerprint if found\n\tfor i := range fpRecords {\n\t\tif fpRecords[i].Fingerprint == agentFingerprint.Fingerprint {\n\t\t\treturn fpRecords[i], nil\n\t\t}\n\t}\n\t// No matching fingerprint record found, but it's\n\t// an active universal token so create a new system\n\tif acr.isUniversalToken {\n\t\treturn acr.createNewSystemForUniversalToken(agentFingerprint)\n\t}\n\treturn ws.FingerprintRecord{}, errors.New(\"fingerprint mismatch\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 230, "end_line": 255, "text": "// createNewSystemForUniversalToken creates a new system and fingerprint record for a universal token.\nfunc (acr *agentConnectRequest) createNewSystemForUniversalToken(agentFingerprint common.FingerprintResponse) (ws.FingerprintRecord, error) {\n\tvar fpRecord ws.FingerprintRecord\n\tif !acr.isUniversalToken || acr.userId == \"\" {\n\t\treturn fpRecord, errors.New(\"invalid token\")\n\t}\n\n\tfpRecord.Token = acr.token\n\n\tsystemId, err := acr.createSystem(agentFingerprint)\n\tif err != nil {\n\t\treturn fpRecord, err\n\t}\n\tfpRecord.SystemId = systemId\n\n\t// Set the fingerprint for the new system\n\tif err := acr.hub.SetFingerprint(&fpRecord, agentFingerprint.Fingerprint); err != nil {\n\t\treturn fpRecord, err\n\t}\n\n\t// Update the record with the fingerprint that was set\n\tfpRecord.Fingerprint = agentFingerprint.Fingerprint\n\n\treturn fpRecord, nil\n}\n", "n_tokens": 200, "primary_symbol": "createNewSystemForUniversalToken", "primary_kind": "function", "primary_span": [231, 255], "def_symbols": ["createNewSystemForUniversalToken"], "symbols": ["createNewSystemForUniversalToken", "creates", "new", "system", "and", "fingerprint", "record", "for", "universal", "token", "func", "acr", "agentConnectRequest", "agentFingerprint", "common", "FingerprintResponse", "FingerprintRecord", "error", "var", "fpRecord", "isUniversalToken", "userId", "return", "errors", "New", "invalid", "Token", "systemId", "err", "createSystem", "nil", "SystemId", "Set", "the", "hub", "SetFingerprint", "Fingerprint", "Update", "with", "that", "was", "set"], "doc_head": "// createNewSystemForUniversalToken creates a new system and fingerprint record for a universal token.\nfunc (acr *agentConnectRequest) createNewSystemForUniversalToken(agentFingerprint common.FingerprintResponse) (ws.FingerprintRecord, error) {\n\tvar fpRecord ws.FingerprintRecord\n\tif !acr.isUniversalToken || acr.userId == \"\" {\n\t\treturn fpRecord, errors.New(\"invalid token\")\n\t}\n\tfpRecord.Token = acr.token\n\tsystemId, err := acr.createSystem(agentFingerprint)\n\tif err != nil {\n\t\treturn fpRecord, err\n\t}\n\tfpRecord.SystemId = systemId\n\t// Set the fingerprint for the new system\n\tif err := acr.hub.SetFingerprint(&fpRecord, agentFingerprint.Fingerprint); err != nil {\n\t\treturn fpRecord, err\n\t}\n\t// Update the record with the fingerprint that was set\n\tfpRecord.Fingerprint = agentFingerprint.Fingerprint\n\treturn fpRecord, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 13, "start_line": 256, "end_line": 279, "text": "// createSystem creates a new system record in the database using details from the agent.\nfunc (acr *agentConnectRequest) createSystem(agentFingerprint common.FingerprintResponse) (recordId string, err error) {\n\tsystemsCollection, err := acr.hub.FindCachedCollectionByNameOrId(\"systems\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tremoteAddr := getRealIP(acr.req)\n\t// separate port from address\n\tif agentFingerprint.Hostname == \"\" {\n\t\tagentFingerprint.Hostname = remoteAddr\n\t}\n\tif agentFingerprint.Port == \"\" {\n\t\tagentFingerprint.Port = \"45876\"\n\t}\n\t// create new record\n\tsystemRecord := core.NewRecord(systemsCollection)\n\tsystemRecord.Set(\"name\", agentFingerprint.Hostname)\n\tsystemRecord.Set(\"host\", remoteAddr)\n\tsystemRecord.Set(\"port\", agentFingerprint.Port)\n\tsystemRecord.Set(\"users\", []string{acr.userId})\n\n\treturn systemRecord.Id, acr.hub.Save(systemRecord)\n}\n", "n_tokens": 210, "primary_symbol": "createSystem", "primary_kind": "function", "primary_span": [257, 279], "def_symbols": ["createSystem"], "symbols": ["createSystem", "creates", "new", "system", "record", "the", "database", "using", "details", "from", "agent", "func", "acr", "agentConnectRequest", "agentFingerprint", "common", "FingerprintResponse", "recordId", "string", "err", "error", "systemsCollection", "hub", "FindCachedCollectionByNameOrId", "systems", "nil", "return", "remoteAddr", "getRealIP", "req", "separate", "port", "address", "Hostname", "Port", "create", "systemRecord", "core", "NewRecord", "Set", "name", "host", "users", "userId", "Save"], "doc_head": "// createSystem creates a new system record in the database using details from the agent.\nfunc (acr *agentConnectRequest) createSystem(agentFingerprint common.FingerprintResponse) (recordId string, err error) {\n\tsystemsCollection, err := acr.hub.FindCachedCollectionByNameOrId(\"systems\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tremoteAddr := getRealIP(acr.req)\n\t// separate port from address\n\tif agentFingerprint.Hostname == \"\" {\n\t\tagentFingerprint.Hostname = remoteAddr\n\t}\n\tif agentFingerprint.Port == \"\" {\n\t\tagentFingerprint.Port = \"45876\"\n\t}\n\t// create new record\n\tsystemRecord := core.NewRecord(systemsCollection)\n\tsystemRecord.Set(\"name\", agentFingerprint.Hostname)\n\tsystemRecord.Set(\"host\", remoteAddr)\n\tsystemRecord.Set(\"port\", agentFingerprint.Port)\n\tsystemRecord.Set(\"users\", []string{acr.userId})\n\treturn systemRecord.Id, acr.hub.Save(systemRecord)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 14, "start_line": 280, "end_line": 300, "text": "// SetFingerprint creates or updates a fingerprint record in the database.\nfunc (h *Hub) SetFingerprint(fpRecord *ws.FingerprintRecord, fingerprint string) (err error) {\n\t// // can't use raw query here because it doesn't trigger SSE\n\tvar record *core.Record\n\tswitch fpRecord.Id {\n\tcase \"\":\n\t\t// create new record for universal token\n\t\tcollection, _ := h.FindCachedCollectionByNameOrId(\"fingerprints\")\n\t\trecord = core.NewRecord(collection)\n\t\trecord.Set(\"system\", fpRecord.SystemId)\n\tdefault:\n\t\trecord, err = h.FindRecordById(\"fingerprints\", fpRecord.Id)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\trecord.Set(\"token\", fpRecord.Token)\n\trecord.Set(\"fingerprint\", fingerprint)\n\treturn h.SaveNoValidate(record)\n}\n", "n_tokens": 171, "primary_symbol": "SetFingerprint", "primary_kind": "function", "primary_span": [281, 300], "def_symbols": ["SetFingerprint"], "symbols": ["SetFingerprint", "creates", "updates", "fingerprint", "record", "the", "database", "func", "Hub", "fpRecord", "FingerprintRecord", "string", "err", "error", "can", "use", "raw", "query", "here", "because", "doesn", "trigger", "SSE", "var", "core", "Record", "switch", "case", "create", "new", "for", "universal", "token", "collection", "FindCachedCollectionByNameOrId", "fingerprints", "NewRecord", "Set", "system", "SystemId", "default", "FindRecordById", "nil", "return", "Token", "SaveNoValidate"], "doc_head": "// SetFingerprint creates or updates a fingerprint record in the database.\nfunc (h *Hub) SetFingerprint(fpRecord *ws.FingerprintRecord, fingerprint string) (err error) {\n\t// // can't use raw query here because it doesn't trigger SSE\n\tvar record *core.Record\n\tswitch fpRecord.Id {\n\tcase \"\":\n\t\t// create new record for universal token\n\t\tcollection, _ := h.FindCachedCollectionByNameOrId(\"fingerprints\")\n\t\trecord = core.NewRecord(collection)\n\t\trecord.Set(\"system\", fpRecord.SystemId)\n\tdefault:\n\t\trecord, err = h.FindRecordById(\"fingerprints\", fpRecord.Id)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\trecord.Set(\"token\", fpRecord.Token)\n\trecord.Set(\"fingerprint\", fingerprint)\n\treturn h.SaveNoValidate(record)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect.go", "rel_path": "src/hub/agent_connect.go", "ext": "go", "language": "go", "chunk_number": 15, "start_line": 301, "end_line": 322, "text": "// getRealIP extracts the client's real IP address from request headers,\n// checking common proxy headers before falling back to the remote address.\nfunc getRealIP(r *http.Request) string {\n\tif ip := r.Header.Get(\"CF-Connecting-IP\"); ip != \"\" {\n\t\treturn ip\n\t}\n\tif ip := r.Header.Get(\"X-Forwarded-For\"); ip != \"\" {\n\t\t// X-Forwarded-For can contain a comma-separated list: \"client_ip, proxy1, proxy2\"\n\t\t// Take the first one\n\t\tips := strings.Split(ip, \",\")\n\t\tif len(ips) > 0 {\n\t\t\treturn strings.TrimSpace(ips[0])\n\t\t}\n\t}\n\t// Fallback to RemoteAddr\n\tip, _, err := net.SplitHostPort(r.RemoteAddr)\n\tif err != nil {\n\t\treturn r.RemoteAddr\n\t}\n\treturn ip\n}\n", "n_tokens": 186, "primary_symbol": "getRealIP", "primary_kind": "function", "primary_span": [303, 322], "def_symbols": ["getRealIP"], "symbols": ["getRealIP", "extracts", "the", "client", "real", "address", "from", "request", "headers", "checking", "common", "proxy", "before", "falling", "back", "remote", "func", "http", "Request", "string", "Header", "Get", "Connecting", "return", "Forwarded", "For", "can", "contain", "comma", "separated", "list", "client_ip", "proxy1", "proxy2", "Take", "first", "one", "ips", "strings", "Split", "len", "TrimSpace", "Fallback", "RemoteAddr", "err", "net", "SplitHostPort", "nil"], "doc_head": "// getRealIP extracts the client's real IP address from request headers,\n// checking common proxy headers before falling back to the remote address.\nfunc getRealIP(r *http.Request) string {\n\tif ip := r.Header.Get(\"CF-Connecting-IP\"); ip != \"\" {\n\t\treturn ip\n\t}\n\tif ip := r.Header.Get(\"X-Forwarded-For\"); ip != \"\" {\n\t\t// X-Forwarded-For can contain a comma-separated list: \"client_ip, proxy1, proxy2\"\n\t\t// Take the first one\n\t\tips := strings.Split(ip, \",\")\n\t\tif len(ips) > 0 {\n\t\t\treturn strings.TrimSpace(ips[0])\n\t\t}\n\t}\n\t// Fallback to RemoteAddr\n\tip, _, err := net.SplitHostPort(r.RemoteAddr)\n\tif err != nil {\n\t\treturn r.RemoteAddr\n\t}\n\treturn ip\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go", "rel_path": "src/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 28, "text": "// Package hub handles updating systems and serving the web UI.\npackage hub\n\nimport (\n\t\"crypto/ed25519\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/alerts\"\n\t\"github.com/henrygd/beszel/src/hub/config\"\n\t\"github.com/henrygd/beszel/src/hub/systems\"\n\t\"github.com/henrygd/beszel/src/records\"\n\t\"github.com/henrygd/beszel/src/users\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/pocketbase/pocketbase\"\n\t\"github.com/pocketbase/pocketbase/apis\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"golang.org/x/crypto/ssh\"\n)\n", "n_tokens": 184, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 28], "def_symbols": [], "symbols": ["Package", "hub", "handles", "updating", "systems", "and", "serving", "the", "web", "package", "import", "crypto", "ed25519", "encoding", "pem", "fmt", "net", "http", "url", "path", "strings", "time", "github", "com", "henrygd", "beszel", "src", "alerts", "config", "records", "users", "google", "uuid", "pocketbase", "apis", "core", "golang", "org", "ssh"], "doc_head": "// Package hub handles updating systems and serving the web UI.\npackage hub\nimport (\n\t\"crypto/ed25519\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/alerts\"\n\t\"github.com/henrygd/beszel/src/hub/config\"\n\t\"github.com/henrygd/beszel/src/hub/systems\"\n\t\"github.com/henrygd/beszel/src/records\"\n\t\"github.com/henrygd/beszel/src/users\"\n\t\"github.com/google/uuid\"\n\t\"github.com/pocketbase/pocketbase\"\n\t\"github.com/pocketbase/pocketbase/apis\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"golang.org/x/crypto/ssh\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go", "rel_path": "src/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 29, "end_line": 52, "text": "type Hub struct {\n\tcore.App\n\t*alerts.AlertManager\n\tum     *users.UserManager\n\trm     *records.RecordManager\n\tsm     *systems.SystemManager\n\tpubKey string\n\tsigner ssh.Signer\n\tappURL string\n}\n\n// NewHub creates a new Hub instance with default configuration\nfunc NewHub(app core.App) *Hub {\n\thub := &Hub{}\n\thub.App = app\n\n\thub.AlertManager = alerts.NewAlertManager(hub)\n\thub.um = users.NewUserManager(hub)\n\thub.rm = records.NewRecordManager(hub)\n\thub.sm = systems.NewSystemManager(hub)\n\thub.appURL, _ = GetEnv(\"APP_URL\")\n\treturn hub\n}\n", "n_tokens": 146, "primary_symbol": "NewHub", "primary_kind": "function", "primary_span": [41, 52], "def_symbols": ["NewHub"], "symbols": ["NewHub", "type", "Hub", "struct", "core", "App", "alerts", "AlertManager", "users", "UserManager", "records", "RecordManager", "systems", "SystemManager", "pubKey", "string", "signer", "ssh", "Signer", "appURL", "creates", "new", "instance", "with", "default", "configuration", "func", "app", "hub", "NewAlertManager", "NewUserManager", "NewRecordManager", "NewSystemManager", "GetEnv", "APP_URL", "return"], "doc_head": "type Hub struct {\n\tcore.App\n\t*alerts.AlertManager\n\tum     *users.UserManager\n\trm     *records.RecordManager\n\tsm     *systems.SystemManager\n\tpubKey string\n\tsigner ssh.Signer\n\tappURL string\n}\n// NewHub creates a new Hub instance with default configuration\nfunc NewHub(app core.App) *Hub {\n\thub := &Hub{}\n\thub.App = app\n\thub.AlertManager = alerts.NewAlertManager(hub)\n\thub.um = users.NewUserManager(hub)\n\thub.rm = records.NewRecordManager(hub)\n\thub.sm = systems.NewSystemManager(hub)\n\thub.appURL, _ = GetEnv(\"APP_URL\")\n\treturn hub\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go", "rel_path": "src/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 53, "end_line": 61, "text": "// GetEnv retrieves an environment variable with a \"BESZEL_HUB_\" prefix, or falls back to the unprefixed key.\nfunc GetEnv(key string) (value string, exists bool) {\n\tif value, exists = os.LookupEnv(\"BESZEL_HUB_\" + key); exists {\n\t\treturn value, exists\n\t}\n\t// Fallback to the old unprefixed key\n\treturn os.LookupEnv(key)\n}\n", "n_tokens": 91, "primary_symbol": "GetEnv", "primary_kind": "function", "primary_span": [54, 61], "def_symbols": ["GetEnv"], "symbols": ["GetEnv", "retrieves", "environment", "variable", "with", "BESZEL_HUB_", "prefix", "falls", "back", "the", "unprefixed", "key", "func", "string", "value", "exists", "bool", "LookupEnv", "return", "Fallback", "old"], "doc_head": "// GetEnv retrieves an environment variable with a \"BESZEL_HUB_\" prefix, or falls back to the unprefixed key.\nfunc GetEnv(key string) (value string, exists bool) {\n\tif value, exists = os.LookupEnv(\"BESZEL_HUB_\" + key); exists {\n\t\treturn value, exists\n\t}\n\t// Fallback to the old unprefixed key\n\treturn os.LookupEnv(key)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go", "rel_path": "src/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 62, "end_line": 106, "text": "func (h *Hub) StartHub() error {\n\th.App.OnServe().BindFunc(func(e *core.ServeEvent) error {\n\t\t// initialize settings / collections\n\t\tif err := h.initialize(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// sync systems with config\n\t\tif err := config.SyncSystems(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// register api routes\n\t\tif err := h.registerApiRoutes(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// register cron jobs\n\t\tif err := h.registerCronJobs(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// start server\n\t\tif err := h.startServer(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// start system updates\n\t\tif err := h.sm.Initialize(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn e.Next()\n\t})\n\n\t// TODO: move to users package\n\t// handle default values for user / user_settings creation\n\th.App.OnRecordCreate(\"users\").BindFunc(h.um.InitializeUserRole)\n\th.App.OnRecordCreate(\"user_settings\").BindFunc(h.um.InitializeUserSettings)\n\n\tif pb, ok := h.App.(*pocketbase.PocketBase); ok {\n\t\t// log.Println(\"Starting pocketbase\")\n\t\terr := pb.Start()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n", "n_tokens": 303, "primary_symbol": "StartHub", "primary_kind": "function", "primary_span": [62, 106], "def_symbols": ["StartHub"], "symbols": ["StartHub", "func", "Hub", "error", "App", "OnServe", "BindFunc", "core", "ServeEvent", "initialize", "settings", "collections", "err", "nil", "return", "sync", "systems", "with", "config", "SyncSystems", "register", "api", "routes", "registerApiRoutes", "cron", "jobs", "registerCronJobs", "start", "server", "startServer", "system", "updates", "Initialize", "Next", "TODO", "move", "users", "package", "handle", "default", "values", "for", "user", "user_settings", "creation", "OnRecordCreate", "InitializeUserRole", "InitializeUserSettings", "pocketbase", "PocketBase", "log", "Println", "Starting", "Start"], "doc_head": "func (h *Hub) StartHub() error {\n\th.App.OnServe().BindFunc(func(e *core.ServeEvent) error {\n\t\t// initialize settings / collections\n\t\tif err := h.initialize(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// sync systems with config\n\t\tif err := config.SyncSystems(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// register api routes\n\t\tif err := h.registerApiRoutes(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// register cron jobs\n\t\tif err := h.registerCronJobs(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// start server\n\t\tif err := h.startServer(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// start system updates\n\t\tif err := h.sm.Initialize(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn e.Next()\n\t})\n\t// TODO: move to users package\n\t// handle default values for user / user_settings creation\n\th.App.OnRecordCreate(\"users\").BindFunc(h.um.InitializeUserRole)\n\th.App.OnRecordCreate(\"user_settings\").BindFunc(h.um.InitializeUserSettings)\n\tif pb, ok := h.App.(*pocketbase.PocketBase); ok {\n\t\t// log.Println(\"Starting pocketbase\")\n\t\terr := pb.Start()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go", "rel_path": "src/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 107, "end_line": 164, "text": "// initialize sets up initial configuration (collections, settings, etc.)\nfunc (h *Hub) initialize(e *core.ServeEvent) error {\n\t// set general settings\n\tsettings := e.App.Settings()\n\t// batch requests (for global alerts)\n\tsettings.Batch.Enabled = true\n\t// set URL if BASE_URL env is set\n\tif h.appURL != \"\" {\n\t\tsettings.Meta.AppURL = h.appURL\n\t}\n\tif err := e.App.Save(settings); err != nil {\n\t\treturn err\n\t}\n\t// set auth settings\n\tusersCollection, err := e.App.FindCollectionByNameOrId(\"users\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t// disable email auth if DISABLE_PASSWORD_AUTH env var is set\n\tdisablePasswordAuth, _ := GetEnv(\"DISABLE_PASSWORD_AUTH\")\n\tusersCollection.PasswordAuth.Enabled = disablePasswordAuth != \"true\"\n\tusersCollection.PasswordAuth.IdentityFields = []string{\"email\"}\n\t// disable oauth if no providers are configured (todo: remove this in post 0.9.0 release)\n\tif usersCollection.OAuth2.Enabled {\n\t\tusersCollection.OAuth2.Enabled = len(usersCollection.OAuth2.Providers) > 0\n\t}\n\t// allow oauth user creation if USER_CREATION is set\n\tif userCreation, _ := GetEnv(\"USER_CREATION\"); userCreation == \"true\" {\n\t\tcr := \"@request.context = 'oauth2'\"\n\t\tusersCollection.CreateRule = &cr\n\t} else {\n\t\tusersCollection.CreateRule = nil\n\t}\n\tif err := e.App.Save(usersCollection); err != nil {\n\t\treturn err\n\t}\n\t// allow all users to access systems if SHARE_ALL_SYSTEMS is set\n\tsystemsCollection, err := e.App.FindCachedCollectionByNameOrId(\"systems\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tshareAllSystems, _ := GetEnv(\"SHARE_ALL_SYSTEMS\")\n\tsystemsReadRule := \"@request.auth.id != \\\"\\\"\"\n\tif shareAllSystems != \"true\" {\n\t\t// default is to only show systems that the user id is assigned to\n\t\tsystemsReadRule += \" && users.id ?= @request.auth.id\"\n\t}\n\tupdateDeleteRule := systemsReadRule + \" && @request.auth.role != \\\"readonly\\\"\"\n\tsystemsCollection.ListRule = &systemsReadRule\n\tsystemsCollection.ViewRule = &systemsReadRule\n\tsystemsCollection.UpdateRule = &updateDeleteRule\n\tsystemsCollection.DeleteRule = &updateDeleteRule\n\tif err := e.App.Save(systemsCollection); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "n_tokens": 533, "primary_symbol": "initialize", "primary_kind": "function", "primary_span": [108, 164], "def_symbols": ["initialize"], "symbols": ["initialize", "sets", "initial", "configuration", "collections", "settings", "etc", "func", "Hub", "core", "ServeEvent", "error", "set", "general", "App", "Settings", "batch", "requests", "for", "global", "alerts", "Batch", "Enabled", "true", "URL", "BASE_URL", "env", "appURL", "Meta", "AppURL", "err", "Save", "nil", "return", "auth", "usersCollection", "FindCollectionByNameOrId", "users", "disable", "email", "DISABLE_PASSWORD_AUTH", "var", "disablePasswordAuth", "GetEnv", "PasswordAuth", "IdentityFields", "string", "oauth", "providers", "are", "configured", "todo", "remove", "this", "post", "release", "OAuth2", "len", "Providers", "allow", "user", "creation", "USER_CREATION", "userCreation", "request", "context", "oauth2", "CreateRule", "else", "all", "access", "systems", "SHARE_ALL_SYSTEMS", "systemsCollection", "FindCachedCollectionByNameOrId", "shareAllSystems", "systemsReadRule", "default", "only", "show", "that", "the", "assigned", "updateDeleteRule", "role", "readonly", "ListRule", "ViewRule", "UpdateRule", "DeleteRule"], "doc_head": "// initialize sets up initial configuration (collections, settings, etc.)\nfunc (h *Hub) initialize(e *core.ServeEvent) error {\n\t// set general settings\n\tsettings := e.App.Settings()\n\t// batch requests (for global alerts)\n\tsettings.Batch.Enabled = true\n\t// set URL if BASE_URL env is set\n\tif h.appURL != \"\" {\n\t\tsettings.Meta.AppURL = h.appURL\n\t}\n\tif err := e.App.Save(settings); err != nil {\n\t\treturn err\n\t}\n\t// set auth settings\n\tusersCollection, err := e.App.FindCollectionByNameOrId(\"users\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t// disable email auth if DISABLE_PASSWORD_AUTH env var is set\n\tdisablePasswordAuth, _ := GetEnv(\"DISABLE_PASSWORD_AUTH\")\n\tusersCollection.PasswordAuth.Enabled = disablePasswordAuth != \"true\"\n\tusersCollection.PasswordAuth.IdentityFields = []string{\"email\"}\n\t// disable oauth if no providers are configured (todo: remove this in post 0.9.0 release)\n\tif usersCollection.OAuth2.Enabled {\n\t\tusersCollection.OAuth2.Enabled = len(usersCollection.OAuth2.Providers) > 0\n\t}\n\t// allow oauth user creation if USER_CREATION is set\n\tif userCreation, _ := GetEnv(\"USER_CREATION\"); userCreation == \"true\" {\n\t\tcr := \"@request.context = 'oauth2'\"\n\t\tusersCollection.CreateRule = &cr\n\t} else "}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go", "rel_path": "src/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 165, "end_line": 173, "text": "// registerCronJobs sets up scheduled tasks\nfunc (h *Hub) registerCronJobs(_ *core.ServeEvent) error {\n\t// delete old system_stats and alerts_history records once every hour\n\th.Cron().MustAdd(\"delete old records\", \"8 * * * *\", h.rm.DeleteOldRecords)\n\t// create longer records every 10 minutes\n\th.Cron().MustAdd(\"create longer records\", \"*/10 * * * *\", h.rm.CreateLongerRecords)\n\treturn nil\n}\n", "n_tokens": 106, "primary_symbol": "registerCronJobs", "primary_kind": "function", "primary_span": [166, 173], "def_symbols": ["registerCronJobs"], "symbols": ["registerCronJobs", "sets", "scheduled", "tasks", "func", "Hub", "core", "ServeEvent", "error", "delete", "old", "system_stats", "and", "alerts_history", "records", "once", "every", "hour", "Cron", "MustAdd", "DeleteOldRecords", "create", "longer", "minutes", "CreateLongerRecords", "return", "nil"], "doc_head": "// registerCronJobs sets up scheduled tasks\nfunc (h *Hub) registerCronJobs(_ *core.ServeEvent) error {\n\t// delete old system_stats and alerts_history records once every hour\n\th.Cron().MustAdd(\"delete old records\", \"8 * * * *\", h.rm.DeleteOldRecords)\n\t// create longer records every 10 minutes\n\th.Cron().MustAdd(\"create longer records\", \"*/10 * * * *\", h.rm.CreateLongerRecords)\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go", "rel_path": "src/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 174, "end_line": 209, "text": "// custom api routes\nfunc (h *Hub) registerApiRoutes(se *core.ServeEvent) error {\n\t// auth protected routes\n\tapiAuth := se.Router.Group(\"/api/beszel\")\n\tapiAuth.Bind(apis.RequireAuth())\n\t// auth optional routes\n\tapiNoAuth := se.Router.Group(\"/api/beszel\")\n\n\t// create first user endpoint only needed if no users exist\n\tif totalUsers, _ := se.App.CountRecords(\"users\"); totalUsers == 0 {\n\t\tapiNoAuth.POST(\"/create-user\", h.um.CreateFirstUser)\n\t}\n\t// check if first time setup on login page\n\tapiNoAuth.GET(\"/first-run\", func(e *core.RequestEvent) error {\n\t\ttotal, err := e.App.CountRecords(\"users\")\n\t\treturn e.JSON(http.StatusOK, map[string]bool{\"firstRun\": err == nil && total == 0})\n\t})\n\t// get public key and version\n\tapiAuth.GET(\"/getkey\", func(e *core.RequestEvent) error {\n\t\treturn e.JSON(http.StatusOK, map[string]string{\"key\": h.pubKey, \"v\": beszel.Version})\n\t})\n\t// send test notification\n\tapiAuth.POST(\"/test-notification\", h.SendTestNotification)\n\t// get config.yml content\n\tapiAuth.GET(\"/config-yaml\", config.GetYamlConfig)\n\t// handle agent websocket connection\n\tapiNoAuth.GET(\"/agent-connect\", h.handleAgentConnect)\n\t// get or create universal tokens\n\tapiAuth.GET(\"/universal-token\", h.getUniversalToken)\n\t// update / delete user alerts\n\tapiAuth.POST(\"/user-alerts\", alerts.UpsertUserAlerts)\n\tapiAuth.DELETE(\"/user-alerts\", alerts.DeleteUserAlerts)\n\n\treturn nil\n}\n", "n_tokens": 352, "primary_symbol": "registerApiRoutes", "primary_kind": "function", "primary_span": [175, 209], "def_symbols": ["registerApiRoutes"], "symbols": ["registerApiRoutes", "custom", "api", "routes", "func", "Hub", "core", "ServeEvent", "error", "auth", "protected", "apiAuth", "Router", "Group", "beszel", "Bind", "apis", "RequireAuth", "optional", "apiNoAuth", "create", "first", "user", "endpoint", "only", "needed", "users", "exist", "totalUsers", "App", "CountRecords", "POST", "CreateFirstUser", "check", "time", "setup", "login", "page", "GET", "run", "RequestEvent", "total", "err", "return", "JSON", "http", "StatusOK", "map", "string", "bool", "firstRun", "nil", "get", "public", "key", "and", "version", "getkey", "pubKey", "Version", "send", "test", "notification", "SendTestNotification", "config", "yml", "content", "yaml", "GetYamlConfig", "handle", "agent", "websocket", "connection", "connect", "handleAgentConnect", "universal", "tokens", "token", "getUniversalToken", "update", "delete", "alerts", "UpsertUserAlerts", "DELETE", "DeleteUserAlerts"], "doc_head": "// custom api routes\nfunc (h *Hub) registerApiRoutes(se *core.ServeEvent) error {\n\t// auth protected routes\n\tapiAuth := se.Router.Group(\"/api/beszel\")\n\tapiAuth.Bind(apis.RequireAuth())\n\t// auth optional routes\n\tapiNoAuth := se.Router.Group(\"/api/beszel\")\n\t// create first user endpoint only needed if no users exist\n\tif totalUsers, _ := se.App.CountRecords(\"users\"); totalUsers == 0 {\n\t\tapiNoAuth.POST(\"/create-user\", h.um.CreateFirstUser)\n\t}\n\t// check if first time setup on login page\n\tapiNoAuth.GET(\"/first-run\", func(e *core.RequestEvent) error {\n\t\ttotal, err := e.App.CountRecords(\"users\")\n\t\treturn e.JSON(http.StatusOK, map[string]bool{\"firstRun\": err == nil && total == 0})\n\t})\n\t// get public key and version\n\tapiAuth.GET(\"/getkey\", func(e *core.RequestEvent) error {\n\t\treturn e.JSON(http.StatusOK, map[string]string{\"key\": h.pubKey, \"v\": beszel.Version})\n\t})\n\t// send test notification\n\tapiAuth.POST(\"/test-notification\", h.SendTestNotification)\n\t// get config.yml content\n\tapiAuth.GET(\"/config-yaml\", config.GetYamlConfig)\n\t// handle agent websocket connection\n\tapiNoAuth.GET(\"/agent-connect\", h.handleAgentConnect)\n\t// get or create universal tokens\n\tapiAuth.GET(\"/universal-token\", h.getUn"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go", "rel_path": "src/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 210, "end_line": 236, "text": "// Handler for universal token API endpoint (create, read, delete)\nfunc (h *Hub) getUniversalToken(e *core.RequestEvent) error {\n\ttokenMap := universalTokenMap.GetMap()\n\tuserID := e.Auth.Id\n\tquery := e.Request.URL.Query()\n\ttoken := query.Get(\"token\")\n\n\tif token == \"\" {\n\t\t// return existing token if it exists\n\t\tif token, _, ok := tokenMap.GetByValue(userID); ok {\n\t\t\treturn e.JSON(http.StatusOK, map[string]any{\"token\": token, \"active\": true})\n\t\t}\n\t\t// if no token is provided, generate a new one\n\t\ttoken = uuid.New().String()\n\t}\n\tresponse := map[string]any{\"token\": token}\n\n\tswitch query.Get(\"enable\") {\n\tcase \"1\":\n\t\ttokenMap.Set(token, userID, time.Hour)\n\tcase \"0\":\n\t\ttokenMap.RemovebyValue(userID)\n\t}\n\t_, response[\"active\"] = tokenMap.GetOk(token)\n\treturn e.JSON(http.StatusOK, response)\n}\n", "n_tokens": 209, "primary_symbol": "getUniversalToken", "primary_kind": "function", "primary_span": [211, 236], "def_symbols": ["getUniversalToken"], "symbols": ["getUniversalToken", "Handler", "for", "universal", "token", "API", "endpoint", "create", "read", "delete", "func", "Hub", "core", "RequestEvent", "error", "tokenMap", "universalTokenMap", "GetMap", "userID", "Auth", "query", "Request", "URL", "Query", "Get", "return", "existing", "exists", "GetByValue", "JSON", "http", "StatusOK", "map", "string", "any", "active", "true", "provided", "generate", "new", "one", "uuid", "New", "String", "response", "switch", "enable", "case", "Set", "time", "Hour", "RemovebyValue", "GetOk"], "doc_head": "// Handler for universal token API endpoint (create, read, delete)\nfunc (h *Hub) getUniversalToken(e *core.RequestEvent) error {\n\ttokenMap := universalTokenMap.GetMap()\n\tuserID := e.Auth.Id\n\tquery := e.Request.URL.Query()\n\ttoken := query.Get(\"token\")\n\tif token == \"\" {\n\t\t// return existing token if it exists\n\t\tif token, _, ok := tokenMap.GetByValue(userID); ok {\n\t\t\treturn e.JSON(http.StatusOK, map[string]any{\"token\": token, \"active\": true})\n\t\t}\n\t\t// if no token is provided, generate a new one\n\t\ttoken = uuid.New().String()\n\t}\n\tresponse := map[string]any{\"token\": token}\n\tswitch query.Get(\"enable\") {\n\tcase \"1\":\n\t\ttokenMap.Set(token, userID, time.Hour)\n\tcase \"0\":\n\t\ttokenMap.RemovebyValue(userID)\n\t}\n\t_, response[\"active\"] = tokenMap.GetOk(token)\n\treturn e.JSON(http.StatusOK, response)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go", "rel_path": "src/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 237, "end_line": 288, "text": "// generates key pair if it doesn't exist and returns signer\nfunc (h *Hub) GetSSHKey(dataDir string) (ssh.Signer, error) {\n\tif h.signer != nil {\n\t\treturn h.signer, nil\n\t}\n\n\tif dataDir == \"\" {\n\t\tdataDir = h.DataDir()\n\t}\n\n\tprivateKeyPath := path.Join(dataDir, \"id_ed25519\")\n\n\t// check if the key pair already exists\n\texistingKey, err := os.ReadFile(privateKeyPath)\n\tif err == nil {\n\t\tprivate, err := ssh.ParsePrivateKey(existingKey)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse private key: %s\", err)\n\t\t}\n\t\tpubKeyBytes := ssh.MarshalAuthorizedKey(private.PublicKey())\n\t\th.pubKey = strings.TrimSuffix(string(pubKeyBytes), \"\\n\")\n\t\treturn private, nil\n\t} else if !os.IsNotExist(err) {\n\t\t// File exists but couldn't be read for some other reason\n\t\treturn nil, fmt.Errorf(\"failed to read %s: %w\", privateKeyPath, err)\n\t}\n\n\t// Generate the Ed25519 key pair\n\t_, privKey, err := ed25519.GenerateKey(nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprivKeyPem, err := ssh.MarshalPrivateKey(privKey, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := os.WriteFile(privateKeyPath, pem.EncodeToMemory(privKeyPem), 0600); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write private key to %q: err: %w\", privateKeyPath, err)\n\t}\n\n\t// These are fine to ignore the errors on, as we've literally just created a crypto.PublicKey | crypto.Signer\n\tsshPrivate, _ := ssh.NewSignerFromSigner(privKey)\n\tpubKeyBytes := ssh.MarshalAuthorizedKey(sshPrivate.PublicKey())\n\th.pubKey = strings.TrimSuffix(string(pubKeyBytes), \"\\n\")\n\n\th.Logger().Info(\"ed25519 key pair generated successfully.\")\n\th.Logger().Info(\"Saved to: \" + privateKeyPath)\n\n\treturn sshPrivate, err\n}\n", "n_tokens": 454, "primary_symbol": "GetSSHKey", "primary_kind": "function", "primary_span": [238, 288], "def_symbols": ["GetSSHKey"], "symbols": ["GetSSHKey", "generates", "key", "pair", "doesn", "exist", "and", "returns", "signer", "func", "Hub", "dataDir", "string", "ssh", "Signer", "error", "nil", "return", "DataDir", "privateKeyPath", "path", "Join", "id_ed25519", "check", "the", "already", "exists", "existingKey", "err", "ReadFile", "private", "ParsePrivateKey", "fmt", "Errorf", "failed", "parse", "pubKeyBytes", "MarshalAuthorizedKey", "PublicKey", "pubKey", "strings", "TrimSuffix", "else", "IsNotExist", "File", "but", "couldn", "read", "for", "some", "other", "reason", "Generate", "Ed25519", "privKey", "ed25519", "GenerateKey", "privKeyPem", "MarshalPrivateKey", "WriteFile", "pem", "EncodeToMemory", "write", "These", "are", "fine", "ignore", "errors", "literally", "just", "created", "crypto", "sshPrivate", "NewSignerFromSigner", "Logger", "Info", "generated", "successfully", "Saved"], "doc_head": "// generates key pair if it doesn't exist and returns signer\nfunc (h *Hub) GetSSHKey(dataDir string) (ssh.Signer, error) {\n\tif h.signer != nil {\n\t\treturn h.signer, nil\n\t}\n\tif dataDir == \"\" {\n\t\tdataDir = h.DataDir()\n\t}\n\tprivateKeyPath := path.Join(dataDir, \"id_ed25519\")\n\t// check if the key pair already exists\n\texistingKey, err := os.ReadFile(privateKeyPath)\n\tif err == nil {\n\t\tprivate, err := ssh.ParsePrivateKey(existingKey)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse private key: %s\", err)\n\t\t}\n\t\tpubKeyBytes := ssh.MarshalAuthorizedKey(private.PublicKey())\n\t\th.pubKey = strings.TrimSuffix(string(pubKeyBytes), \"\\n\")\n\t\treturn private, nil\n\t} else if !os.IsNotExist(err) {\n\t\t// File exists but couldn't be read for some other reason\n\t\treturn nil, fmt.Errorf(\"failed to read %s: %w\", privateKeyPath, err)\n\t}\n\t// Generate the Ed25519 key pair\n\t_, privKey, err := ed25519.GenerateKey(nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprivKeyPem, err := ssh.MarshalPrivateKey(privKey, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := os.WriteFile(privateKeyPath, pem.EncodeToMemory(privKeyPem), 0600); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write private key to %q: err: %w\", "}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub.go", "rel_path": "src/hub/hub.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 289, "end_line": 301, "text": "// MakeLink formats a link with the app URL and path segments.\n// Only path segments should be provided.\nfunc (h *Hub) MakeLink(parts ...string) string {\n\tbase := strings.TrimSuffix(h.Settings().Meta.AppURL, \"/\")\n\tfor _, part := range parts {\n\t\tif part == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tbase = fmt.Sprintf(\"%s/%s\", base, url.PathEscape(part))\n\t}\n\treturn base\n}\n", "n_tokens": 92, "primary_symbol": "MakeLink", "primary_kind": "function", "primary_span": [291, 301], "def_symbols": ["MakeLink"], "symbols": ["MakeLink", "formats", "link", "with", "the", "app", "URL", "and", "path", "segments", "Only", "should", "provided", "func", "Hub", "parts", "string", "base", "strings", "TrimSuffix", "Settings", "Meta", "AppURL", "for", "part", "range", "continue", "fmt", "Sprintf", "url", "PathEscape", "return"], "doc_head": "// MakeLink formats a link with the app URL and path segments.\n// Only path segments should be provided.\nfunc (h *Hub) MakeLink(parts ...string) string {\n\tbase := strings.TrimSuffix(h.Settings().Meta.AppURL, \"/\")\n\tfor _, part := range parts {\n\t\tif part == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tbase = fmt.Sprintf(\"%s/%s\", base, url.PathEscape(part))\n\t}\n\treturn base\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_production.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_production.go", "rel_path": "src/hub/server_production.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 17, "text": "//go:build !development\n\npackage hub\n\nimport (\n\t\"io/fs\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/site\"\n\n\t\"github.com/pocketbase/pocketbase/apis\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)\n", "n_tokens": 74, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 17], "def_symbols": [], "symbols": ["build", "development", "package", "hub", "import", "net", "http", "url", "strings", "github", "com", "henrygd", "beszel", "src", "site", "pocketbase", "apis", "core"], "doc_head": "//go:build !development\npackage hub\nimport (\n\t\"io/fs\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/henrygd/beszel/src/site\"\n\t\"github.com/pocketbase/pocketbase/apis\"\n\t\"github.com/pocketbase/pocketbase/core\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_production.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/server_production.go", "rel_path": "src/hub/server_production.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 18, "end_line": 53, "text": "// startServer sets up the production server for Beszel\nfunc (h *Hub) startServer(se *core.ServeEvent) error {\n\t// parse app url\n\tparsedURL, err := url.Parse(h.appURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// fix base paths in html if using subpath\n\tbasePath := strings.TrimSuffix(parsedURL.Path, \"/\") + \"/\"\n\tindexFile, _ := fs.ReadFile(site.DistDirFS, \"index.html\")\n\thtml := strings.ReplaceAll(string(indexFile), \"./\", basePath)\n\thtml = strings.Replace(html, \"{{V}}\", beszel.Version, 1)\n\thtml = strings.Replace(html, \"{{HUB_URL}}\", h.appURL, 1)\n\t// set up static asset serving\n\tstaticPaths := [2]string{\"/static/\", \"/assets/\"}\n\tserveStatic := apis.Static(site.DistDirFS, false)\n\t// get CSP configuration\n\tcsp, cspExists := GetEnv(\"CSP\")\n\t// add route\n\tse.Router.GET(\"/{path...}\", func(e *core.RequestEvent) error {\n\t\t// serve static assets if path is in staticPaths\n\t\tfor i := range staticPaths {\n\t\t\tif strings.Contains(e.Request.URL.Path, staticPaths[i]) {\n\t\t\t\te.Response.Header().Set(\"Cache-Control\", \"public, max-age=2592000\")\n\t\t\t\treturn serveStatic(e)\n\t\t\t}\n\t\t}\n\t\tif cspExists {\n\t\t\te.Response.Header().Del(\"X-Frame-Options\")\n\t\t\te.Response.Header().Set(\"Content-Security-Policy\", csp)\n\t\t}\n\t\treturn e.HTML(http.StatusOK, html)\n\t})\n\treturn nil\n}\n", "n_tokens": 345, "primary_symbol": "startServer", "primary_kind": "function", "primary_span": [19, 53], "def_symbols": ["startServer"], "symbols": ["startServer", "sets", "the", "production", "server", "for", "Beszel", "func", "Hub", "core", "ServeEvent", "error", "parse", "app", "url", "parsedURL", "err", "Parse", "appURL", "nil", "return", "fix", "base", "paths", "html", "using", "subpath", "basePath", "strings", "TrimSuffix", "Path", "indexFile", "ReadFile", "site", "DistDirFS", "index", "ReplaceAll", "string", "Replace", "beszel", "Version", "HUB_URL", "set", "static", "asset", "serving", "staticPaths", "assets", "serveStatic", "apis", "Static", "false", "get", "CSP", "configuration", "csp", "cspExists", "GetEnv", "add", "route", "Router", "GET", "path", "RequestEvent", "serve", "range", "Contains", "Request", "URL", "Response", "Header", "Set", "Cache", "Control", "public", "max", "age", "Del", "Frame", "Options", "Content", "Security", "Policy", "HTML", "http", "StatusOK"], "doc_head": "// startServer sets up the production server for Beszel\nfunc (h *Hub) startServer(se *core.ServeEvent) error {\n\t// parse app url\n\tparsedURL, err := url.Parse(h.appURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// fix base paths in html if using subpath\n\tbasePath := strings.TrimSuffix(parsedURL.Path, \"/\") + \"/\"\n\tindexFile, _ := fs.ReadFile(site.DistDirFS, \"index.html\")\n\thtml := strings.ReplaceAll(string(indexFile), \"./\", basePath)\n\thtml = strings.Replace(html, \"{{V}}\", beszel.Version, 1)\n\thtml = strings.Replace(html, \"{{HUB_URL}}\", h.appURL, 1)\n\t// set up static asset serving\n\tstaticPaths := [2]string{\"/static/\", \"/assets/\"}\n\tserveStatic := apis.Static(site.DistDirFS, false)\n\t// get CSP configuration\n\tcsp, cspExists := GetEnv(\"CSP\")\n\t// add route\n\tse.Router.GET(\"/{path...}\", func(e *core.RequestEvent) error {\n\t\t// serve static assets if path is in staticPaths\n\t\tfor i := range staticPaths {\n\t\t\tif strings.Contains(e.Request.URL.Path, staticPaths[i]) {\n\t\t\t\te.Response.Header().Set(\"Cache-Control\", \"public, max-age=2592000\")\n\t\t\t\treturn serveStatic(e)\n\t\t\t}\n\t\t}\n\t\tif cspExists {\n\t\t\te.Response.Header().Del(\"X-Frame-Options\")\n\t\t\te.Response.Header().Set(\"Content-Security-Policy\", csp)\n\t\t}\n\t\treturn e.H"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test_helpers.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test_helpers.go", "rel_path": "src/hub/hub_test_helpers.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "//go:build testing\n// +build testing\n\npackage hub\n\nimport \"github.com/henrygd/beszel/src/hub/systems\"\n\n// TESTING ONLY: GetSystemManager returns the system manager\nfunc (h *Hub) GetSystemManager() *systems.SystemManager {\n\treturn h.sm\n}\n\n// TESTING ONLY: GetPubkey returns the public key\nfunc (h *Hub) GetPubkey() string {\n\treturn h.pubKey\n}\n\n// TESTING ONLY: SetPubkey sets the public key\nfunc (h *Hub) SetPubkey(pubkey string) {\n\th.pubKey = pubkey\n}\n", "n_tokens": 126, "primary_symbol": "GetSystemManager", "primary_kind": "function", "primary_span": [9, 22], "def_symbols": ["GetSystemManager", "GetPubkey", "SetPubkey"], "symbols": ["GetSystemManager", "GetPubkey", "SetPubkey", "build", "testing", "package", "hub", "import", "github", "com", "henrygd", "beszel", "src", "systems", "TESTING", "ONLY", "returns", "the", "system", "manager", "func", "Hub", "SystemManager", "return", "public", "key", "string", "pubKey", "sets", "pubkey"], "doc_head": "//go:build testing\n// +build testing\npackage hub\nimport \"github.com/henrygd/beszel/src/hub/systems\"\n// TESTING ONLY: GetSystemManager returns the system manager\nfunc (h *Hub) GetSystemManager() *systems.SystemManager {\n\treturn h.sm\n}\n// TESTING ONLY: GetPubkey returns the public key\nfunc (h *Hub) GetPubkey() string {\n\treturn h.pubKey\n}\n// TESTING ONLY: SetPubkey sets the public key\nfunc (h *Hub) SetPubkey(pubkey string) {\n\th.pubKey = pubkey\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 27, "text": "//go:build testing\n// +build testing\n\npackage hub\n\nimport (\n\t\"crypto/ed25519\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/agent\"\n\t\"github.com/henrygd/beszel/src/common\"\n\t\"github.com/henrygd/beszel/src/hub/ws\"\n\n\t\"github.com/pocketbase/pocketbase/core\"\n\tpbtests \"github.com/pocketbase/pocketbase/tests\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)\n", "n_tokens": 144, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 27], "def_symbols": [], "symbols": ["build", "testing", "package", "hub", "import", "crypto", "ed25519", "fmt", "net", "http", "httptest", "path", "filepath", "strings", "time", "github", "com", "henrygd", "beszel", "agent", "src", "common", "pocketbase", "core", "pbtests", "tests", "stretchr", "testify", "assert", "require", "golang", "org", "ssh"], "doc_head": "//go:build testing\n// +build testing\npackage hub\nimport (\n\t\"crypto/ed25519\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/agent\"\n\t\"github.com/henrygd/beszel/src/common\"\n\t\"github.com/henrygd/beszel/src/hub/ws\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\tpbtests \"github.com/pocketbase/pocketbase/tests\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 28, "end_line": 51, "text": "// Helper function to create a test hub without import cycle\nfunc createTestHub(t testing.TB) (*Hub, *pbtests.TestApp, error) {\n\ttestDataDir := t.TempDir()\n\ttestApp, err := pbtests.NewTestApp(testDataDir)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn NewHub(testApp), testApp, nil\n}\n\n// Helper function to create a test record\nfunc createTestRecord(app core.App, collection string, data map[string]any) (*core.Record, error) {\n\tcol, err := app.FindCachedCollectionByNameOrId(collection)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trecord := core.NewRecord(col)\n\tfor key, value := range data {\n\t\trecord.Set(key, value)\n\t}\n\n\treturn record, app.Save(record)\n}\n", "n_tokens": 173, "primary_symbol": "createTestHub", "primary_kind": "function", "primary_span": [29, 51], "def_symbols": ["createTestHub", "createTestRecord"], "symbols": ["createTestHub", "createTestRecord", "Helper", "function", "create", "test", "hub", "without", "import", "cycle", "func", "testing", "Hub", "pbtests", "TestApp", "error", "testDataDir", "TempDir", "testApp", "err", "NewTestApp", "nil", "return", "NewHub", "record", "app", "core", "App", "collection", "string", "data", "map", "any", "Record", "col", "FindCachedCollectionByNameOrId", "NewRecord", "for", "key", "value", "range", "Set", "Save"], "doc_head": "// Helper function to create a test hub without import cycle\nfunc createTestHub(t testing.TB) (*Hub, *pbtests.TestApp, error) {\n\ttestDataDir := t.TempDir()\n\ttestApp, err := pbtests.NewTestApp(testDataDir)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn NewHub(testApp), testApp, nil\n}\n// Helper function to create a test record\nfunc createTestRecord(app core.App, collection string, data map[string]any) (*core.Record, error) {\n\tcol, err := app.FindCachedCollectionByNameOrId(collection)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trecord := core.NewRecord(col)\n\tfor key, value := range data {\n\t\trecord.Set(key, value)\n\t}\n\treturn record, app.Save(record)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 52, "end_line": 68, "text": "// Helper function to create a test user\nfunc createTestUser(app core.App) (*core.Record, error) {\n\tuserRecord, err := createTestRecord(app, \"users\", map[string]any{\n\t\t\"email\":    \"test@test.com\",\n\t\t\"password\": \"testtesttest\",\n\t})\n\treturn userRecord, err\n}\n\n// TestValidateAgentHeaders tests the validateAgentHeaders function\nfunc TestValidateAgentHeaders(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n", "n_tokens": 126, "primary_symbol": "createTestUser", "primary_kind": "function", "primary_span": [53, 68], "def_symbols": ["createTestUser", "TestValidateAgentHeaders"], "symbols": ["createTestUser", "TestValidateAgentHeaders", "Helper", "function", "create", "test", "user", "func", "app", "core", "App", "Record", "error", "userRecord", "err", "createTestRecord", "users", "map", "string", "any", "email", "com", "password", "testtesttest", "return", "tests", "the", "validateAgentHeaders", "testing", "hub", "testApp", "createTestHub", "nil", "Fatal", "defer", "Cleanup"], "doc_head": "// Helper function to create a test user\nfunc createTestUser(app core.App) (*core.Record, error) {\n\tuserRecord, err := createTestRecord(app, \"users\", map[string]any{\n\t\t\"email\":    \"test@test.com\",\n\t\t\"password\": \"testtesttest\",\n\t})\n\treturn userRecord, err\n}\n// TestValidateAgentHeaders tests the validateAgentHeaders function\nfunc TestValidateAgentHeaders(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 69, "end_line": 141, "text": "\ttestCases := []struct {\n\t\tname          string\n\t\theaders       http.Header\n\t\texpectError   bool\n\t\texpectedToken string\n\t\texpectedAgent string\n\t}{\n\t\t{\n\t\t\tname: \"valid headers\",\n\t\t\theaders: http.Header{\n\t\t\t\t\"X-Token\":  []string{\"valid-token-123\"},\n\t\t\t\t\"X-Beszel\": []string{\"0.5.0\"},\n\t\t\t},\n\t\t\texpectError:   false,\n\t\t\texpectedToken: \"valid-token-123\",\n\t\t\texpectedAgent: \"0.5.0\",\n\t\t},\n\t\t{\n\t\t\tname: \"missing token\",\n\t\t\theaders: http.Header{\n\t\t\t\t\"X-Beszel\": []string{\"0.5.0\"},\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing agent version\",\n\t\t\theaders: http.Header{\n\t\t\t\t\"X-Token\": []string{\"valid-token-123\"},\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty token\",\n\t\t\theaders: http.Header{\n\t\t\t\t\"X-Token\":  []string{\"\"},\n\t\t\t\t\"X-Beszel\": []string{\"0.5.0\"},\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty agent version\",\n\t\t\theaders: http.Header{\n\t\t\t\t\"X-Token\":  []string{\"valid-token-123\"},\n\t\t\t\t\"X-Beszel\": []string{\"\"},\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"token too long\",\n\t\t\theaders: http.Header{\n\t\t\t\t\"X-Token\":  []string{strings.Repeat(\"a\", 65)},\n\t\t\t\t\"X-Beszel\": []string{\"0.5.0\"},\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tacr := &agentConnectRequest{hub: hub}\n\t\t\ttoken, agentVersion, err := acr.validateAgentHeaders(tc.headers)\n\n\t\t\tif tc.expectError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, tc.expectedToken, token)\n\t\t\t\tassert.Equal(t, tc.expectedAgent, agentVersion)\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 493, "primary_symbol": "", "primary_kind": "", "primary_span": [69, 141], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "headers", "http", "Header", "expectError", "bool", "expectedToken", "expectedAgent", "valid", "Token", "token", "Beszel", "false", "missing", "true", "agent", "version", "empty", "too", "long", "strings", "Repeat", "for", "range", "Run", "func", "testing", "acr", "agentConnectRequest", "hub", "agentVersion", "err", "validateAgentHeaders", "assert", "Error", "else", "require", "NoError", "Equal"], "doc_head": "\ttestCases := []struct {\n\t\tname          string\n\t\theaders       http.Header\n\t\texpectError   bool\n\t\texpectedToken string\n\t\texpectedAgent string\n\t}{\n\t\t{\n\t\t\tname: \"valid headers\",\n\t\t\theaders: http.Header{\n\t\t\t\t\"X-Token\":  []string{\"valid-token-123\"},\n\t\t\t\t\"X-Beszel\": []string{\"0.5.0\"},\n\t\t\t},\n\t\t\texpectError:   false,\n\t\t\texpectedToken: \"valid-token-123\",\n\t\t\texpectedAgent: \"0.5.0\",\n\t\t},\n\t\t{\n\t\t\tname: \"missing token\",\n\t\t\theaders: http.Header{\n\t\t\t\t\"X-Beszel\": []string{\"0.5.0\"},\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing agent version\",\n\t\t\theaders: http.Header{\n\t\t\t\t\"X-Token\": []string{\"valid-token-123\"},\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty token\",\n\t\t\theaders: http.Header{\n\t\t\t\t\"X-Token\":  []string{\"\"},\n\t\t\t\t\"X-Beszel\": []string{\"0.5.0\"},\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty agent version\",\n\t\t\theaders: http.Header{\n\t\t\t\t\"X-Token\":  []string{\"valid-token-123\"},\n\t\t\t\t\"X-Beszel\": []string{\"\"},\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"token too long\",\n\t\t\theaders: http.Header{"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 142, "end_line": 190, "text": "// TestGetAllFingerprintRecordsByToken tests the getAllFingerprintRecordsByToken function\nfunc TestGetAllFingerprintRecordsByToken(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\n\t// create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create test data\n\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"pending\",\n\t\t\"users\":  []string{userRecord.Id},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfingerprintRecord, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\"system\":      systemRecord.Id,\n\t\t\"token\":       \"test-token-123\",\n\t\t\"fingerprint\": \"test-fingerprint\",\n\t})\n\tfor i := range 3 {\n\t\tsystemRecord, _ := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\t\"name\":   fmt.Sprintf(\"test-system-%d\", i),\n\t\t\t\"host\":   \"localhost\",\n\t\t\t\"port\":   \"45876\",\n\t\t\t\"status\": \"pending\",\n\t\t\t\"users\":  []string{userRecord.Id},\n\t\t})\n\t\tcreateTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\t\"system\":      systemRecord.Id,\n\t\t\t\"token\":       \"duplicate-token\",\n\t\t\t\"fingerprint\": fmt.Sprintf(\"test-fingerprint-%d\", i),\n\t\t})\n\t}\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n", "n_tokens": 391, "primary_symbol": "TestGetAllFingerprintRecordsByToken", "primary_kind": "function", "primary_span": [143, 190], "def_symbols": ["TestGetAllFingerprintRecordsByToken"], "symbols": ["TestGetAllFingerprintRecordsByToken", "tests", "the", "getAllFingerprintRecordsByToken", "function", "func", "testing", "hub", "testApp", "err", "createTestHub", "nil", "Fatal", "defer", "Cleanup", "create", "test", "user", "userRecord", "createTestUser", "Create", "data", "systemRecord", "createTestRecord", "systems", "map", "string", "any", "name", "system", "host", "localhost", "port", "status", "pending", "users", "fingerprintRecord", "fingerprints", "token", "fingerprint", "for", "range", "fmt", "Sprintf", "duplicate"], "doc_head": "// TestGetAllFingerprintRecordsByToken tests the getAllFingerprintRecordsByToken function\nfunc TestGetAllFingerprintRecordsByToken(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\t// create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Create test data\n\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"pending\",\n\t\t\"users\":  []string{userRecord.Id},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfingerprintRecord, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\"system\":      systemRecord.Id,\n\t\t\"token\":       \"test-token-123\",\n\t\t\"fingerprint\": \"test-fingerprint\",\n\t})\n\tfor i := range 3 {\n\t\tsystemRecord, _ := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\t\"name\":   fmt.Sprintf(\"test-system-%d\", i),\n\t\t\t\"host\":   \"localhost\",\n\t\t\t\"port\":   \"45876\",\n\t\t\t\"status\": \"pending\",\n\t\t\t\"users\":  []string{userRecord.Id},\n\t\t})\n\t\tcreateTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\t\"system\":      systemRecord.Id,\n\t\t\t\"token\":       \"duplicate-token\",\n\t\t\t"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 191, "end_line": 231, "text": "\ttestCases := []struct {\n\t\tname       string\n\t\ttoken      string\n\t\texpectedId string\n\t\texpectLen  int\n\t}{\n\t\t{\n\t\t\tname:       \"valid token\",\n\t\t\ttoken:      \"test-token-123\",\n\t\t\texpectLen:  1,\n\t\t\texpectedId: fingerprintRecord.Id,\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid token\",\n\t\t\ttoken:     \"invalid-token\",\n\t\t\texpectLen: 0,\n\t\t},\n\t\t{\n\t\t\tname:      \"empty token\",\n\t\t\ttoken:     \"\",\n\t\t\texpectLen: 0,\n\t\t},\n\t\t{\n\t\t\tname:      \"duplicate token\",\n\t\t\ttoken:     \"duplicate-token\",\n\t\t\texpectLen: 3,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\trecords := getFingerprintRecordsByToken(tc.token, hub)\n\n\t\t\trequire.Len(t, records, tc.expectLen)\n\t\t\tif tc.expectedId != \"\" {\n\t\t\t\tassert.Equal(t, tc.expectedId, records[0].Id)\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 234, "primary_symbol": "", "primary_kind": "", "primary_span": [191, 231], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "token", "expectedId", "expectLen", "int", "valid", "test", "fingerprintRecord", "invalid", "empty", "duplicate", "for", "range", "Run", "func", "testing", "records", "getFingerprintRecordsByToken", "hub", "require", "Len", "assert", "Equal"], "doc_head": "\ttestCases := []struct {\n\t\tname       string\n\t\ttoken      string\n\t\texpectedId string\n\t\texpectLen  int\n\t}{\n\t\t{\n\t\t\tname:       \"valid token\",\n\t\t\ttoken:      \"test-token-123\",\n\t\t\texpectLen:  1,\n\t\t\texpectedId: fingerprintRecord.Id,\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid token\",\n\t\t\ttoken:     \"invalid-token\",\n\t\t\texpectLen: 0,\n\t\t},\n\t\t{\n\t\t\tname:      \"empty token\",\n\t\t\ttoken:     \"\",\n\t\t\texpectLen: 0,\n\t\t},\n\t\t{\n\t\t\tname:      \"duplicate token\",\n\t\t\ttoken:     \"duplicate-token\",\n\t\t\texpectLen: 3,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\trecords := getFingerprintRecordsByToken(tc.token, hub)\n\t\t\trequire.Len(t, records, tc.expectLen)\n\t\t\tif tc.expectedId != \"\" {\n\t\t\t\tassert.Equal(t, tc.expectedId, records[0].Id)\n\t\t\t}\n\t\t})\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 232, "end_line": 267, "text": "// TestSetFingerprint tests the SetFingerprint function\nfunc TestSetFingerprint(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create test system\n\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"pending\",\n\t\t\"users\":  []string{userRecord.Id},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create fingerprint record\n\tfingerprintRecord, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\"system\":      systemRecord.Id,\n\t\t\"token\":       \"test-token-123\",\n\t\t\"fingerprint\": \"\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n", "n_tokens": 240, "primary_symbol": "TestSetFingerprint", "primary_kind": "function", "primary_span": [233, 267], "def_symbols": ["TestSetFingerprint"], "symbols": ["TestSetFingerprint", "tests", "the", "SetFingerprint", "function", "func", "testing", "hub", "testApp", "err", "createTestHub", "nil", "Fatal", "defer", "Cleanup", "Create", "test", "user", "userRecord", "createTestUser", "system", "systemRecord", "createTestRecord", "systems", "map", "string", "any", "name", "host", "localhost", "port", "status", "pending", "users", "fingerprint", "record", "fingerprintRecord", "fingerprints", "token"], "doc_head": "// TestSetFingerprint tests the SetFingerprint function\nfunc TestSetFingerprint(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Create test system\n\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"pending\",\n\t\t\"users\":  []string{userRecord.Id},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Create fingerprint record\n\tfingerprintRecord, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\"system\":      systemRecord.Id,\n\t\t\"token\":       \"test-token-123\",\n\t\t\"fingerprint\": \"\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 268, "end_line": 311, "text": "\ttestCases := []struct {\n\t\tname           string\n\t\trecordId       string\n\t\tnewFingerprint string\n\t\texpectError    bool\n\t}{\n\t\t{\n\t\t\tname:           \"successful fingerprint update\",\n\t\t\trecordId:       fingerprintRecord.Id,\n\t\t\tnewFingerprint: \"new-test-fingerprint\",\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"empty fingerprint\",\n\t\t\trecordId:       fingerprintRecord.Id,\n\t\t\tnewFingerprint: \"\",\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid record ID\",\n\t\t\trecordId:       \"invalid-id\",\n\t\t\tnewFingerprint: \"fingerprint\",\n\t\t\texpectError:    true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\terr := hub.SetFingerprint(&ws.FingerprintRecord{Id: tc.recordId, Token: \"test-token-123\"}, tc.newFingerprint)\n\n\t\t\tif tc.expectError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t// Verify fingerprint was updated\n\t\t\t\tupdatedRecord, err := testApp.FindRecordById(\"fingerprints\", tc.recordId)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, tc.newFingerprint, updatedRecord.GetString(\"fingerprint\"))\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 290, "primary_symbol": "", "primary_kind": "", "primary_span": [268, 311], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "recordId", "newFingerprint", "expectError", "bool", "successful", "fingerprint", "update", "fingerprintRecord", "new", "test", "false", "empty", "invalid", "record", "true", "for", "range", "Run", "func", "testing", "err", "hub", "SetFingerprint", "FingerprintRecord", "Token", "token", "assert", "Error", "else", "require", "NoError", "Verify", "was", "updated", "updatedRecord", "testApp", "FindRecordById", "fingerprints", "Equal", "GetString"], "doc_head": "\ttestCases := []struct {\n\t\tname           string\n\t\trecordId       string\n\t\tnewFingerprint string\n\t\texpectError    bool\n\t}{\n\t\t{\n\t\t\tname:           \"successful fingerprint update\",\n\t\t\trecordId:       fingerprintRecord.Id,\n\t\t\tnewFingerprint: \"new-test-fingerprint\",\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"empty fingerprint\",\n\t\t\trecordId:       fingerprintRecord.Id,\n\t\t\tnewFingerprint: \"\",\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid record ID\",\n\t\t\trecordId:       \"invalid-id\",\n\t\t\tnewFingerprint: \"fingerprint\",\n\t\t\texpectError:    true,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\terr := hub.SetFingerprint(&ws.FingerprintRecord{Id: tc.recordId, Token: \"test-token-123\"}, tc.newFingerprint)\n\t\t\tif tc.expectError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\t// Verify fingerprint was updated\n\t\t\t\tupdatedRecord, err := testApp.FindRecordById(\"fingerprints\", tc.recordId)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, tc.newFingerprint, updatedRecord.GetString(\"fingerprint\"))\n\t\t\t}\n\t\t})\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 312, "end_line": 325, "text": "// TestCreateSystemFromAgentData tests the createSystemFromAgentData function\nfunc TestCreateSystemFromAgentData(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n", "n_tokens": 89, "primary_symbol": "TestCreateSystemFromAgentData", "primary_kind": "function", "primary_span": [313, 325], "def_symbols": ["TestCreateSystemFromAgentData"], "symbols": ["TestCreateSystemFromAgentData", "tests", "the", "createSystemFromAgentData", "function", "func", "testing", "hub", "testApp", "err", "createTestHub", "nil", "Fatal", "defer", "Cleanup", "Create", "test", "user", "userRecord", "createTestUser"], "doc_head": "// TestCreateSystemFromAgentData tests the createSystemFromAgentData function\nfunc TestCreateSystemFromAgentData(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 326, "end_line": 421, "text": "\ttestCases := []struct {\n\t\tname          string\n\t\tagentConnReq  agentConnectRequest\n\t\tfingerprint   common.FingerprintResponse\n\t\texpectError   bool\n\t\texpectedName  string\n\t\texpectedHost  string\n\t\texpectedPort  string\n\t\texpectedUsers []string\n\t}{\n\t\t{\n\t\t\tname: \"successful system creation with all fields\",\n\t\t\tagentConnReq: agentConnectRequest{\n\t\t\t\thub:    hub,\n\t\t\t\tuserId: userRecord.Id,\n\t\t\t\treq: &http.Request{\n\t\t\t\t\tRemoteAddr: \"192.168.0.1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tfingerprint: common.FingerprintResponse{\n\t\t\t\tHostname: \"test-server\",\n\t\t\t\tPort:     \"8080\",\n\t\t\t},\n\t\t\texpectError:   false,\n\t\t\texpectedName:  \"test-server\",\n\t\t\texpectedHost:  \"192.168.0.1\", // This will be the parsed IP from the mock request\n\t\t\texpectedPort:  \"8080\",\n\t\t\texpectedUsers: []string{userRecord.Id},\n\t\t},\n\t\t{\n\t\t\tname: \"system creation with default port\",\n\t\t\tagentConnReq: agentConnectRequest{\n\t\t\t\thub:    hub,\n\t\t\t\tuserId: userRecord.Id,\n\t\t\t\treq: &http.Request{\n\t\t\t\t\tRemoteAddr: \"192.168.0.1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tfingerprint: common.FingerprintResponse{\n\t\t\t\tHostname: \"default-port-server\",\n\t\t\t\tPort:     \"\", // Empty port should default to 45876\n\t\t\t},\n\t\t\texpectError:   false,\n\t\t\texpectedName:  \"default-port-server\",\n\t\t\texpectedHost:  \"192.168.0.1\", // This will be the parsed IP from the mock request\n\t\t\texpectedPort:  \"45876\",\n\t\t\texpectedUsers: []string{userRecord.Id},\n\t\t},\n\t\t{\n\t\t\tname: \"system creation with empty hostname\",\n\t\t\tagentConnReq: agentConnectRequest{\n\t\t\t\thub:    hub,\n\t\t\t\tuserId: userRecord.Id,\n\t\t\t\treq: &http.Request{\n\t\t\t\t\tRemoteAddr: \"192.168.0.1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tfingerprint: common.FingerprintResponse{\n\t\t\t\tHostname: \"\",\n\t\t\t\tPort:     \"9090\",\n\t\t\t},\n\t\t\texpectError:   false,\n\t\t\texpectedName:  \"192.168.0.1\", // Should fall back to host IP when hostname is empty\n\t\t\texpectedHost:  \"192.168.0.1\", // This will be the parsed IP from the mock request\n\t\t\texpectedPort:  \"9090\",\n\t\t\texpectedUsers: []string{userRecord.Id},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\trecordId, err := tc.agentConnReq.createSystem(tc.fingerprint)\n\n\t\t\tif tc.expectError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.NotEmpty(t, recordId, \"Record ID should not be empty\")\n\n\t\t\t// Verify the created system record\n\t\t\tsystemRecord, err := testApp.FindRecordById(\"systems\", recordId)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, tc.expectedName, systemRecord.GetString(\"name\"))\n\t\t\tassert.Equal(t, tc.expectedHost, systemRecord.GetString(\"host\"))\n\t\t\tassert.Equal(t, tc.expectedPort, systemRecord.GetString(\"port\"))\n\n\t\t\t// Verify users array\n\t\t\tusers := systemRecord.Get(\"users\")\n\t\t\tassert.Equal(t, tc.expectedUsers, users)\n\t\t})\n\t}\n}\n", "n_tokens": 753, "primary_symbol": "", "primary_kind": "", "primary_span": [326, 421], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "agentConnReq", "agentConnectRequest", "fingerprint", "common", "FingerprintResponse", "expectError", "bool", "expectedName", "expectedHost", "expectedPort", "expectedUsers", "successful", "system", "creation", "with", "all", "fields", "hub", "userId", "userRecord", "req", "http", "Request", "RemoteAddr", "Hostname", "test", "server", "Port", "false", "This", "will", "the", "parsed", "from", "mock", "request", "default", "port", "Empty", "should", "empty", "hostname", "Should", "fall", "back", "host", "when", "for", "range", "Run", "func", "testing", "recordId", "err", "createSystem", "assert", "Error", "return", "require", "NoError", "NotEmpty", "Record", "not", "Verify", "created", "record", "systemRecord", "testApp", "FindRecordById", "systems", "Equal", "GetString", "users", "array", "Get"], "doc_head": "\ttestCases := []struct {\n\t\tname          string\n\t\tagentConnReq  agentConnectRequest\n\t\tfingerprint   common.FingerprintResponse\n\t\texpectError   bool\n\t\texpectedName  string\n\t\texpectedHost  string\n\t\texpectedPort  string\n\t\texpectedUsers []string\n\t}{\n\t\t{\n\t\t\tname: \"successful system creation with all fields\",\n\t\t\tagentConnReq: agentConnectRequest{\n\t\t\t\thub:    hub,\n\t\t\t\tuserId: userRecord.Id,\n\t\t\t\treq: &http.Request{\n\t\t\t\t\tRemoteAddr: \"192.168.0.1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tfingerprint: common.FingerprintResponse{\n\t\t\t\tHostname: \"test-server\",\n\t\t\t\tPort:     \"8080\",\n\t\t\t},\n\t\t\texpectError:   false,\n\t\t\texpectedName:  \"test-server\",\n\t\t\texpectedHost:  \"192.168.0.1\", // This will be the parsed IP from the mock request\n\t\t\texpectedPort:  \"8080\",\n\t\t\texpectedUsers: []string{userRecord.Id},\n\t\t},\n\t\t{\n\t\t\tname: \"system creation with default port\",\n\t\t\tagentConnReq: agentConnectRequest{\n\t\t\t\thub:    hub,\n\t\t\t\tuserId: userRecord.Id,\n\t\t\t\treq: &http.Request{\n\t\t\t\t\tRemoteAddr: \"192.168.0.1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tfingerprint: common.FingerprintResponse{\n\t\t\t\tHostname: \"default-port-server\",\n\t\t\t\tPort:     \"\", // Empty port should default to 45876\n\t\t\t},\n\t\t\texpectError:   false,\n\t\t\texpectedName:  \"default-port-server\",\n\t\t\texpectedHost:"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 422, "end_line": 440, "text": "// TestUniversalTokenFlow tests the complete universal token authentication flow\nfunc TestUniversalTokenFlow(t *testing.T) {\n\t_, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Set up universal token in the token map\n\tuniversalToken := \"universal-token-123\"\n\n\tuniversalTokenMap.GetMap().Set(universalToken, userRecord.Id, time.Hour)\n", "n_tokens": 123, "primary_symbol": "TestUniversalTokenFlow", "primary_kind": "function", "primary_span": [423, 440], "def_symbols": ["TestUniversalTokenFlow"], "symbols": ["TestUniversalTokenFlow", "tests", "the", "complete", "universal", "token", "authentication", "flow", "func", "testing", "testApp", "err", "createTestHub", "nil", "Fatal", "defer", "Cleanup", "Create", "test", "user", "userRecord", "createTestUser", "Set", "map", "universalToken", "universalTokenMap", "GetMap", "time", "Hour"], "doc_head": "// TestUniversalTokenFlow tests the complete universal token authentication flow\nfunc TestUniversalTokenFlow(t *testing.T) {\n\t_, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Set up universal token in the token map\n\tuniversalToken := \"universal-token-123\"\n\tuniversalTokenMap.GetMap().Set(universalToken, userRecord.Id, time.Hour)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 441, "end_line": 489, "text": "\ttestCases := []struct {\n\t\tname                string\n\t\ttoken               string\n\t\texpectUniversalAuth bool\n\t\texpectError         bool\n\t\tdescription         string\n\t}{\n\t\t{\n\t\t\tname:                \"valid universal token\",\n\t\t\ttoken:               universalToken,\n\t\t\texpectUniversalAuth: true,\n\t\t\texpectError:         false,\n\t\t\tdescription:         \"Should recognize valid universal token\",\n\t\t},\n\t\t{\n\t\t\tname:                \"invalid universal token\",\n\t\t\ttoken:               \"invalid-universal-token\",\n\t\t\texpectUniversalAuth: false,\n\t\t\texpectError:         true,\n\t\t\tdescription:         \"Should reject invalid universal token\",\n\t\t},\n\t\t{\n\t\t\tname:                \"empty token\",\n\t\t\ttoken:               \"\",\n\t\t\texpectUniversalAuth: false,\n\t\t\texpectError:         true,\n\t\t\tdescription:         \"Should reject empty token\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tacr := &agentConnectRequest{}\n\n\t\t\tacr.userId, acr.isUniversalToken = universalTokenMap.GetMap().GetOk(tc.token)\n\n\t\t\tif tc.expectError {\n\t\t\t\tassert.False(t, acr.isUniversalToken)\n\t\t\t\tassert.Empty(t, acr.userId)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, tc.expectUniversalAuth, acr.isUniversalToken)\n\t\t\t\tif tc.expectUniversalAuth {\n\t\t\t\t\tassert.Equal(t, userRecord.Id, acr.userId)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 308, "primary_symbol": "", "primary_kind": "", "primary_span": [441, 489], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "token", "expectUniversalAuth", "bool", "expectError", "description", "valid", "universal", "universalToken", "true", "false", "Should", "recognize", "invalid", "reject", "empty", "for", "range", "Run", "func", "testing", "acr", "agentConnectRequest", "userId", "isUniversalToken", "universalTokenMap", "GetMap", "GetOk", "assert", "False", "Empty", "else", "Equal", "userRecord"], "doc_head": "\ttestCases := []struct {\n\t\tname                string\n\t\ttoken               string\n\t\texpectUniversalAuth bool\n\t\texpectError         bool\n\t\tdescription         string\n\t}{\n\t\t{\n\t\t\tname:                \"valid universal token\",\n\t\t\ttoken:               universalToken,\n\t\t\texpectUniversalAuth: true,\n\t\t\texpectError:         false,\n\t\t\tdescription:         \"Should recognize valid universal token\",\n\t\t},\n\t\t{\n\t\t\tname:                \"invalid universal token\",\n\t\t\ttoken:               \"invalid-universal-token\",\n\t\t\texpectUniversalAuth: false,\n\t\t\texpectError:         true,\n\t\t\tdescription:         \"Should reject invalid universal token\",\n\t\t},\n\t\t{\n\t\t\tname:                \"empty token\",\n\t\t\ttoken:               \"\",\n\t\t\texpectUniversalAuth: false,\n\t\t\texpectError:         true,\n\t\t\tdescription:         \"Should reject empty token\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tacr := &agentConnectRequest{}\n\t\t\tacr.userId, acr.isUniversalToken = universalTokenMap.GetMap().GetOk(tc.token)\n\t\t\tif tc.expectError {\n\t\t\t\tassert.False(t, acr.isUniversalToken)\n\t\t\t\tassert.Empty(t, acr.userId)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, tc.expectUniversalAuth, acr.isUniversalToken)\n\t\t\t\tif tc.expect"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 13, "start_line": 490, "end_line": 526, "text": "// TestAgentConnect tests the agentConnect function with various scenarios\nfunc TestAgentConnect(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create test system\n\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"pending\",\n\t\t\"users\":  []string{userRecord.Id},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create fingerprint record\n\ttestToken := \"test-token-456\"\n\t_, err = createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\"system\":      systemRecord.Id,\n\t\t\"token\":       testToken,\n\t\t\"fingerprint\": \"\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n", "n_tokens": 244, "primary_symbol": "TestAgentConnect", "primary_kind": "function", "primary_span": [490, 526], "def_symbols": ["TestAgentConnect"], "symbols": ["TestAgentConnect", "tests", "the", "agentConnect", "function", "with", "various", "scenarios", "func", "testing", "hub", "testApp", "err", "createTestHub", "nil", "Fatal", "defer", "Cleanup", "Create", "test", "user", "userRecord", "createTestUser", "system", "systemRecord", "createTestRecord", "systems", "map", "string", "any", "name", "host", "localhost", "port", "status", "pending", "users", "fingerprint", "record", "testToken", "token", "fingerprints"], "doc_head": "// TestAgentConnect tests the agentConnect function with various scenarios\nfunc TestAgentConnect(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Create test system\n\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"pending\",\n\t\t\"users\":  []string{userRecord.Id},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Create fingerprint record\n\ttestToken := \"test-token-456\"\n\t_, err = createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\"system\":      systemRecord.Id,\n\t\t\"token\":       testToken,\n\t\t\"fingerprint\": \"\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 14, "start_line": 527, "end_line": 611, "text": "\ttestCases := []struct {\n\t\tname           string\n\t\theaders        map[string]string\n\t\texpectedStatus int\n\t\tdescription    string\n\t\terrorMessage   string\n\t}{\n\t\t{\n\t\t\tname: \"missing token header\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Beszel\": \"0.5.0\",\n\t\t\t},\n\t\t\texpectedStatus: http.StatusBadRequest,\n\t\t\tdescription:    \"Should fail due to missing token\",\n\t\t\terrorMessage:   \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"missing agent version header\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Token\": testToken,\n\t\t\t},\n\t\t\texpectedStatus: http.StatusBadRequest,\n\t\t\tdescription:    \"Should fail due to missing agent version\",\n\t\t\terrorMessage:   \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid token\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Token\":  \"invalid-token\",\n\t\t\t\t\"X-Beszel\": \"0.5.0\",\n\t\t\t},\n\t\t\texpectedStatus: http.StatusUnauthorized,\n\t\t\tdescription:    \"Should fail due to invalid token\",\n\t\t\terrorMessage:   \"Invalid token\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid agent version\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Token\":  testToken,\n\t\t\t\t\"X-Beszel\": \"0.5.0.0.0\",\n\t\t\t},\n\t\t\texpectedStatus: http.StatusUnauthorized,\n\t\t\tdescription:    \"Should fail due to invalid agent version\",\n\t\t\terrorMessage:   \"Invalid agent version\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid headers but websocket upgrade will fail in test\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Token\":  testToken,\n\t\t\t\t\"X-Beszel\": \"0.5.0\",\n\t\t\t},\n\t\t\texpectedStatus: http.StatusInternalServerError,\n\t\t\tdescription:    \"Should pass validation but fail at WebSocket upgrade due to test limitations\",\n\t\t\terrorMessage:   \"WebSocket upgrade failed\",\n\t\t},\n\t\t{\n\t\t\tname:           \"Token too long\",\n\t\t\theaders:        map[string]string{\"X-Token\": strings.Repeat(\"a\", 65), \"X-Beszel\": \"0.5.0\"},\n\t\t\texpectedStatus: http.StatusBadRequest,\n\t\t\tdescription:    \"Should reject token exceeding 64 characters\",\n\t\t\terrorMessage:   \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(\"GET\", \"/api/beszel/agent-connect\", nil)\n\t\t\tfor key, value := range tc.headers {\n\t\t\t\treq.Header.Set(key, value)\n\t\t\t}\n\n\t\t\trecorder := httptest.NewRecorder()\n\t\t\tacr := &agentConnectRequest{\n\t\t\t\thub: hub,\n\t\t\t\treq: req,\n\t\t\t\tres: recorder,\n\t\t\t}\n\t\t\terr = acr.agentConnect()\n\n\t\t\tassert.Equal(t, tc.expectedStatus, recorder.Code, tc.description)\n\t\t\tassert.Equal(t, tc.errorMessage, recorder.Body.String(), tc.description)\n\t\t})\n\t}\n}\n", "n_tokens": 631, "primary_symbol": "", "primary_kind": "", "primary_span": [527, 611], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "headers", "map", "expectedStatus", "int", "description", "errorMessage", "missing", "token", "header", "Beszel", "http", "StatusBadRequest", "Should", "fail", "due", "agent", "version", "Token", "testToken", "invalid", "StatusUnauthorized", "Invalid", "valid", "but", "websocket", "upgrade", "will", "test", "StatusInternalServerError", "pass", "validation", "WebSocket", "limitations", "failed", "too", "long", "strings", "Repeat", "reject", "exceeding", "characters", "for", "range", "Run", "func", "testing", "req", "httptest", "NewRequest", "GET", "api", "beszel", "connect", "nil", "key", "value", "Header", "Set", "recorder", "NewRecorder", "acr", "agentConnectRequest", "hub", "res", "err", "agentConnect", "assert", "Equal", "Code", "Body", "String"], "doc_head": "\ttestCases := []struct {\n\t\tname           string\n\t\theaders        map[string]string\n\t\texpectedStatus int\n\t\tdescription    string\n\t\terrorMessage   string\n\t}{\n\t\t{\n\t\t\tname: \"missing token header\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Beszel\": \"0.5.0\",\n\t\t\t},\n\t\t\texpectedStatus: http.StatusBadRequest,\n\t\t\tdescription:    \"Should fail due to missing token\",\n\t\t\terrorMessage:   \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"missing agent version header\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Token\": testToken,\n\t\t\t},\n\t\t\texpectedStatus: http.StatusBadRequest,\n\t\t\tdescription:    \"Should fail due to missing agent version\",\n\t\t\terrorMessage:   \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid token\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Token\":  \"invalid-token\",\n\t\t\t\t\"X-Beszel\": \"0.5.0\",\n\t\t\t},\n\t\t\texpectedStatus: http.StatusUnauthorized,\n\t\t\tdescription:    \"Should fail due to invalid token\",\n\t\t\terrorMessage:   \"Invalid token\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid agent version\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Token\":  testToken,\n\t\t\t\t\"X-Beszel\": \"0.5.0.0.0\",\n\t\t\t},\n\t\t\texpectedStatus: http.StatusUnauthorized,\n\t\t\tdescription:    \"Should fail due to invalid agent version\",\n\t\t\terrorMessage:   \"Invalid agent version\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid header"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 15, "start_line": 612, "end_line": 613, "text": "// TestSendResponseError tests the sendResponseError function\nfunc TestSendResponseError(t *testing.T) {", "n_tokens": 23, "primary_symbol": "TestSendResponseError", "primary_kind": "function", "primary_span": [613, 613], "def_symbols": ["TestSendResponseError"], "symbols": ["TestSendResponseError", "tests", "the", "sendResponseError", "function", "func", "testing"], "doc_head": "// TestSendResponseError tests the sendResponseError function\nfunc TestSendResponseError(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#16", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 16, "start_line": 614, "end_line": 648, "text": "\ttestCases := []struct {\n\t\tname           string\n\t\tstatusCode     int\n\t\tmessage        string\n\t\texpectedStatus int\n\t\texpectedBody   string\n\t}{\n\t\t{\n\t\t\tname:           \"unauthorized error\",\n\t\t\tstatusCode:     http.StatusUnauthorized,\n\t\t\tmessage:        \"Invalid token\",\n\t\t\texpectedStatus: http.StatusUnauthorized,\n\t\t\texpectedBody:   \"Invalid token\",\n\t\t},\n\t\t{\n\t\t\tname:           \"bad request error\",\n\t\t\tstatusCode:     http.StatusBadRequest,\n\t\t\tmessage:        \"Missing required header\",\n\t\t\texpectedStatus: http.StatusBadRequest,\n\t\t\texpectedBody:   \"Missing required header\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\trecorder := httptest.NewRecorder()\n\t\t\tacr := &agentConnectRequest{}\n\t\t\tacr.sendResponseError(recorder, tc.statusCode, tc.message)\n\n\t\t\tassert.Equal(t, tc.expectedStatus, recorder.Code)\n\t\t\tassert.Equal(t, tc.expectedBody, recorder.Body.String())\n\t\t})\n\t}\n}\n", "n_tokens": 220, "primary_symbol": "", "primary_kind": "", "primary_span": [614, 648], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "statusCode", "int", "message", "expectedStatus", "expectedBody", "unauthorized", "error", "http", "StatusUnauthorized", "Invalid", "token", "bad", "request", "StatusBadRequest", "Missing", "required", "header", "for", "range", "Run", "func", "testing", "recorder", "httptest", "NewRecorder", "acr", "agentConnectRequest", "sendResponseError", "assert", "Equal", "Code", "Body", "String"], "doc_head": "\ttestCases := []struct {\n\t\tname           string\n\t\tstatusCode     int\n\t\tmessage        string\n\t\texpectedStatus int\n\t\texpectedBody   string\n\t}{\n\t\t{\n\t\t\tname:           \"unauthorized error\",\n\t\t\tstatusCode:     http.StatusUnauthorized,\n\t\t\tmessage:        \"Invalid token\",\n\t\t\texpectedStatus: http.StatusUnauthorized,\n\t\t\texpectedBody:   \"Invalid token\",\n\t\t},\n\t\t{\n\t\t\tname:           \"bad request error\",\n\t\t\tstatusCode:     http.StatusBadRequest,\n\t\t\tmessage:        \"Missing required header\",\n\t\t\texpectedStatus: http.StatusBadRequest,\n\t\t\texpectedBody:   \"Missing required header\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\trecorder := httptest.NewRecorder()\n\t\t\tacr := &agentConnectRequest{}\n\t\t\tacr.sendResponseError(recorder, tc.statusCode, tc.message)\n\t\t\tassert.Equal(t, tc.expectedStatus, recorder.Code)\n\t\t\tassert.Equal(t, tc.expectedBody, recorder.Body.String())\n\t\t})\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#17", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 17, "start_line": 649, "end_line": 685, "text": "// TestHandleAgentConnect tests the HTTP handler\nfunc TestHandleAgentConnect(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create test system\n\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"pending\",\n\t\t\"users\":  []string{userRecord.Id},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create fingerprint record\n\ttestToken := \"test-token-789\"\n\t_, err = createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\"system\":      systemRecord.Id,\n\t\t\"token\":       testToken,\n\t\t\"fingerprint\": \"\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n", "n_tokens": 242, "primary_symbol": "TestHandleAgentConnect", "primary_kind": "function", "primary_span": [650, 685], "def_symbols": ["TestHandleAgentConnect"], "symbols": ["TestHandleAgentConnect", "tests", "the", "HTTP", "handler", "func", "testing", "hub", "testApp", "err", "createTestHub", "nil", "Fatal", "defer", "Cleanup", "Create", "test", "user", "userRecord", "createTestUser", "system", "systemRecord", "createTestRecord", "systems", "map", "string", "any", "name", "host", "localhost", "port", "status", "pending", "users", "fingerprint", "record", "testToken", "token", "fingerprints"], "doc_head": "// TestHandleAgentConnect tests the HTTP handler\nfunc TestHandleAgentConnect(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testApp.Cleanup()\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Create test system\n\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\"name\":   \"test-system\",\n\t\t\"host\":   \"localhost\",\n\t\t\"port\":   \"45876\",\n\t\t\"status\": \"pending\",\n\t\t\"users\":  []string{userRecord.Id},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Create fingerprint record\n\ttestToken := \"test-token-789\"\n\t_, err = createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\"system\":      systemRecord.Id,\n\t\t\"token\":       testToken,\n\t\t\"fingerprint\": \"\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#18", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 18, "start_line": 686, "end_line": 734, "text": "\ttestCases := []struct {\n\t\tname           string\n\t\tmethod         string\n\t\theaders        map[string]string\n\t\texpectedStatus int\n\t\tdescription    string\n\t}{\n\t\t{\n\t\t\tname:   \"GET with invalid token\",\n\t\t\tmethod: \"GET\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Token\":  \"invalid\",\n\t\t\t\t\"X-Beszel\": \"0.5.0\",\n\t\t\t},\n\t\t\texpectedStatus: http.StatusUnauthorized,\n\t\t\tdescription:    \"Should reject invalid token\",\n\t\t},\n\t\t{\n\t\t\tname:   \"GET with valid token\",\n\t\t\tmethod: \"GET\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Token\":  testToken,\n\t\t\t\t\"X-Beszel\": \"0.5.0\",\n\t\t\t},\n\t\t\texpectedStatus: http.StatusInternalServerError, // WebSocket upgrade fails in test\n\t\t\tdescription:    \"Should pass validation but fail at WebSocket upgrade\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(tc.method, \"/api/beszel/agent-connect\", nil)\n\t\t\tfor key, value := range tc.headers {\n\t\t\t\treq.Header.Set(key, value)\n\t\t\t}\n\n\t\t\trecorder := httptest.NewRecorder()\n\t\t\tacr := &agentConnectRequest{\n\t\t\t\thub: hub,\n\t\t\t\treq: req,\n\t\t\t\tres: recorder,\n\t\t\t}\n\t\t\terr = acr.agentConnect()\n\n\t\t\tassert.Equal(t, tc.expectedStatus, recorder.Code, tc.description)\n\t\t})\n\t}\n}\n", "n_tokens": 325, "primary_symbol": "", "primary_kind": "", "primary_span": [686, 734], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "method", "headers", "map", "expectedStatus", "int", "description", "GET", "with", "invalid", "token", "Token", "Beszel", "http", "StatusUnauthorized", "Should", "reject", "valid", "testToken", "StatusInternalServerError", "WebSocket", "upgrade", "fails", "test", "pass", "validation", "but", "fail", "for", "range", "Run", "func", "testing", "req", "httptest", "NewRequest", "api", "beszel", "agent", "connect", "nil", "key", "value", "Header", "Set", "recorder", "NewRecorder", "acr", "agentConnectRequest", "hub", "res", "err", "agentConnect", "assert", "Equal", "Code"], "doc_head": "\ttestCases := []struct {\n\t\tname           string\n\t\tmethod         string\n\t\theaders        map[string]string\n\t\texpectedStatus int\n\t\tdescription    string\n\t}{\n\t\t{\n\t\t\tname:   \"GET with invalid token\",\n\t\t\tmethod: \"GET\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Token\":  \"invalid\",\n\t\t\t\t\"X-Beszel\": \"0.5.0\",\n\t\t\t},\n\t\t\texpectedStatus: http.StatusUnauthorized,\n\t\t\tdescription:    \"Should reject invalid token\",\n\t\t},\n\t\t{\n\t\t\tname:   \"GET with valid token\",\n\t\t\tmethod: \"GET\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Token\":  testToken,\n\t\t\t\t\"X-Beszel\": \"0.5.0\",\n\t\t\t},\n\t\t\texpectedStatus: http.StatusInternalServerError, // WebSocket upgrade fails in test\n\t\t\tdescription:    \"Should pass validation but fail at WebSocket upgrade\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(tc.method, \"/api/beszel/agent-connect\", nil)\n\t\t\tfor key, value := range tc.headers {\n\t\t\t\treq.Header.Set(key, value)\n\t\t\t}\n\t\t\trecorder := httptest.NewRecorder()\n\t\t\tacr := &agentConnectRequest{\n\t\t\t\thub: hub,\n\t\t\t\treq: req,\n\t\t\t\tres: recorder,\n\t\t\t}\n\t\t\terr = acr.agentConnect()\n\t\t\tassert.Equal(t, tc.expectedStatus, recorder.Code, tc.description)\n\t\t})\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#19", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 19, "start_line": 735, "end_line": 771, "text": "// TestAgentWebSocketIntegration tests WebSocket connection scenarios with an actual agent\nfunc TestAgentWebSocketIntegration(t *testing.T) {\n\t// Create hub and test app\n\thub, testApp, err := createTestHub(t)\n\trequire.NoError(t, err)\n\tdefer testApp.Cleanup()\n\n\t// Get the hub's SSH key\n\thubSigner, err := hub.GetSSHKey(\"\")\n\trequire.NoError(t, err)\n\tgoodPubKey := hubSigner.PublicKey()\n\n\t// Generate bad key pair (should be rejected)\n\t_, badPrivKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tbadPubKey, err := ssh.NewPublicKey(badPrivKey.Public().(ed25519.PublicKey))\n\trequire.NoError(t, err)\n\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\trequire.NoError(t, err)\n\n\t// Create HTTP server with the actual API route\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path == \"/api/beszel/agent-connect\" {\n\t\t\tacr := &agentConnectRequest{\n\t\t\t\thub: hub,\n\t\t\t\treq: r,\n\t\t\t\tres: w,\n\t\t\t}\n\t\t\tacr.agentConnect()\n\t\t} else {\n\t\t\thttp.NotFound(w, r)\n\t\t}\n\t}))\n\tdefer ts.Close()\n", "n_tokens": 281, "primary_symbol": "TestAgentWebSocketIntegration", "primary_kind": "function", "primary_span": [736, 771], "def_symbols": ["TestAgentWebSocketIntegration"], "symbols": ["TestAgentWebSocketIntegration", "tests", "WebSocket", "connection", "scenarios", "with", "actual", "agent", "func", "testing", "Create", "hub", "and", "test", "app", "testApp", "err", "createTestHub", "require", "NoError", "defer", "Cleanup", "Get", "the", "SSH", "key", "hubSigner", "GetSSHKey", "goodPubKey", "PublicKey", "Generate", "bad", "pair", "should", "rejected", "badPrivKey", "ed25519", "GenerateKey", "nil", "badPubKey", "ssh", "NewPublicKey", "Public", "user", "userRecord", "createTestUser", "HTTP", "server", "API", "route", "httptest", "NewServer", "http", "HandlerFunc", "ResponseWriter", "Request", "URL", "Path", "api", "beszel", "connect", "acr", "agentConnectRequest", "req", "res", "agentConnect", "else", "NotFound", "Close"], "doc_head": "// TestAgentWebSocketIntegration tests WebSocket connection scenarios with an actual agent\nfunc TestAgentWebSocketIntegration(t *testing.T) {\n\t// Create hub and test app\n\thub, testApp, err := createTestHub(t)\n\trequire.NoError(t, err)\n\tdefer testApp.Cleanup()\n\t// Get the hub's SSH key\n\thubSigner, err := hub.GetSSHKey(\"\")\n\trequire.NoError(t, err)\n\tgoodPubKey := hubSigner.PublicKey()\n\t// Generate bad key pair (should be rejected)\n\t_, badPrivKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tbadPubKey, err := ssh.NewPublicKey(badPrivKey.Public().(ed25519.PublicKey))\n\trequire.NoError(t, err)\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\trequire.NoError(t, err)\n\t// Create HTTP server with the actual API route\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path == \"/api/beszel/agent-connect\" {\n\t\t\tacr := &agentConnectRequest{\n\t\t\t\thub: hub,\n\t\t\t\treq: r,\n\t\t\t\tres: w,\n\t\t\t}\n\t\t\tacr.agentConnect()\n\t\t} else {\n\t\t\thttp.NotFound(w, r)\n\t\t}\n\t}))\n\tdefer ts.Close()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#20", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 20, "start_line": 772, "end_line": 973, "text": "\ttestCases := []struct {\n\t\tname               string\n\t\tagentToken         string // Token agent will send\n\t\tdbToken            string // Token in database (empty means no record created)\n\t\tagentFingerprint   string // Fingerprint agent will send (empty means agent generates its own)\n\t\tdbFingerprint      string // Fingerprint in database\n\t\tagentSSHKey        ssh.PublicKey\n\t\texpectConnection   bool\n\t\texpectFingerprint  string // \"empty\", \"unchanged\", or \"updated\"\n\t\texpectSystemStatus string\n\t\tdescription        string\n\t}{\n\t\t{\n\t\t\tname:               \"empty fingerprint - agent sets fingerprint on first connection\",\n\t\t\tagentToken:         \"test-token-1\",\n\t\t\tdbToken:            \"test-token-1\",\n\t\t\tagentFingerprint:   \"agent-fingerprint-1\",\n\t\t\tdbFingerprint:      \"\",\n\t\t\tagentSSHKey:        goodPubKey,\n\t\t\texpectConnection:   true,\n\t\t\texpectFingerprint:  \"updated\",\n\t\t\texpectSystemStatus: \"up\",\n\t\t\tdescription:        \"Agent should connect and set its fingerprint when DB fingerprint is empty\",\n\t\t},\n\t\t{\n\t\t\tname:               \"matching fingerprint should be accepted\",\n\t\t\tagentToken:         \"test-token-2\",\n\t\t\tdbToken:            \"test-token-2\",\n\t\t\tagentFingerprint:   \"matching-fingerprint-123\",\n\t\t\tdbFingerprint:      \"matching-fingerprint-123\",\n\t\t\tagentSSHKey:        goodPubKey,\n\t\t\texpectConnection:   true,\n\t\t\texpectFingerprint:  \"unchanged\",\n\t\t\texpectSystemStatus: \"up\",\n\t\t\tdescription:        \"Agent should connect when its fingerprint matches existing DB fingerprint\",\n\t\t},\n\t\t{\n\t\t\tname:               \"fingerprint mismatch should be rejected\",\n\t\t\tagentToken:         \"test-token-3\",\n\t\t\tdbToken:            \"test-token-3\",\n\t\t\tagentFingerprint:   \"different-fingerprint-456\",\n\t\t\tdbFingerprint:      \"original-fingerprint-123\",\n\t\t\tagentSSHKey:        goodPubKey,\n\t\t\texpectConnection:   false,\n\t\t\texpectFingerprint:  \"unchanged\",\n\t\t\texpectSystemStatus: \"pending\",\n\t\t\tdescription:        \"Agent should be rejected when its fingerprint doesn't match existing DB fingerprint\",\n\t\t},\n\t\t{\n\t\t\tname:               \"invalid token should be rejected\",\n\t\t\tagentToken:         \"invalid-token-999\",\n\t\t\tdbToken:            \"test-token-4\",\n\t\t\tagentFingerprint:   \"matching-fingerprint-456\",\n\t\t\tdbFingerprint:      \"matching-fingerprint-456\",\n\t\t\tagentSSHKey:        goodPubKey,\n\t\t\texpectConnection:   false,\n\t\t\texpectFingerprint:  \"unchanged\",\n\t\t\texpectSystemStatus: \"pending\",\n\t\t\tdescription:        \"Connection should fail when using invalid token\",\n\t\t},\n\t\t{\n\t\t\t// This is more for the agent side, but might as well test it here\n\t\t\tname:               \"wrong SSH key should be rejected\",\n\t\t\tagentToken:         \"test-token-5\",\n\t\t\tdbToken:            \"test-token-5\",\n\t\t\tagentFingerprint:   \"matching-fingerprint-789\",\n\t\t\tdbFingerprint:      \"matching-fingerprint-789\",\n\t\t\tagentSSHKey:        badPubKey,\n\t\t\texpectConnection:   false,\n\t\t\texpectFingerprint:  \"unchanged\",\n\t\t\texpectSystemStatus: \"pending\",\n\t\t\tdescription:        \"Connection should fail when agent uses wrong SSH key\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Create test system with unique port for each test\n\t\t\tportNum := 45000 + len(tc.name) // Use name length to get unique port\n\t\t\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\t\t\"name\":   fmt.Sprintf(\"test-system-%s\", tc.name),\n\t\t\t\t\"host\":   \"localhost\",\n\t\t\t\t\"port\":   fmt.Sprintf(\"%d\", portNum),\n\t\t\t\t\"status\": \"pending\",\n\t\t\t\t\"users\":  []string{userRecord.Id},\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Always create fingerprint record for this test's system\n\t\t\tfingerprintRecord, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\t\t\"system\":      systemRecord.Id,\n\t\t\t\t\"token\":       tc.dbToken,\n\t\t\t\t\"fingerprint\": tc.dbFingerprint,\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Create and configure agent\n\t\t\tagentDataDir := t.TempDir()\n\n\t\t\t// Set up agent fingerprint if specified\n\t\t\terr = os.WriteFile(filepath.Join(agentDataDir, \"fingerprint\"), []byte(tc.agentFingerprint), 0644)\n\t\t\trequire.NoError(t, err)\n\t\t\tt.Logf(\"Pre-created fingerprint file for agent: %s\", tc.agentFingerprint)\n\n\t\t\ttestAgent, err := agent.NewAgent(agentDataDir)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Set up environment variables for the agent\n\t\t\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", ts.URL)\n\t\t\tos.Setenv(\"BESZEL_AGENT_TOKEN\", tc.agentToken)\n\t\t\tdefer func() {\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t\t\t}()\n\n\t\t\t// Start agent in background\n\t\t\tdone := make(chan error, 1)\n\t\t\tgo func() {\n\t\t\t\tserverOptions := agent.ServerOptions{\n\t\t\t\t\tNetwork: \"tcp\",\n\t\t\t\t\tAddr:    fmt.Sprintf(\"127.0.0.1:%d\", portNum),\n\t\t\t\t\tKeys:    []ssh.PublicKey{tc.agentSSHKey},\n\t\t\t\t}\n\t\t\t\tdone <- testAgent.Start(serverOptions)\n\t\t\t}()\n\n\t\t\t// Wait for connection result\n\t\t\tmaxWait := 2 * time.Second\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t\tcheckInterval := 20 * time.Millisecond\n\t\t\ttimeout := time.After(maxWait)\n\t\t\tticker := time.Tick(checkInterval)\n\n\t\t\tconnectionManager := testAgent.GetConnectionManager()\n\n\t\t\tconnectionResult := false\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-timeout:\n\t\t\t\t\t// Timeout reached\n\t\t\t\t\tif tc.expectConnection {\n\t\t\t\t\t\tt.Fatalf(\"Expected connection to succeed but timed out - agent state: %d\", connectionManager.State)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Logf(\"Connection properly rejected (timeout) - agent state: %d\", connectionManager.State)\n\t\t\t\t\t}\n\t\t\t\t\tconnectionResult = false\n\t\t\t\tcase <-ticker:\n\t\t\t\t\tif connectionManager.State == agent.WebSocketConnected {\n\t\t\t\t\t\tif tc.expectConnection {\n\t\t\t\t\t\t\tt.Logf(\"WebSocket connection successful - agent state: %d\", connectionManager.State)\n\t\t\t\t\t\t\tconnectionResult = true\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.Errorf(\"Unexpected: Connection succeeded when it should have been rejected\")\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase err := <-done:\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tif !tc.expectConnection {\n\t\t\t\t\t\t\tt.Logf(\"Agent connection properly rejected: %v\", err)\n\t\t\t\t\t\t\tconnectionResult = false\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.Fatalf(\"Agent failed to start: %v\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Break if we got the expected result or timed out\n\t\t\t\tif connectionResult == tc.expectConnection || connectionResult {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Verify fingerprint state by re-reading the specific record\n\t\t\tupdatedFingerprintRecord, err := testApp.FindRecordById(\"fingerprints\", fingerprintRecord.Id)\n\t\t\trequire.NoError(t, err)\n\t\t\tfinalFingerprint := updatedFingerprintRecord.GetString(\"fingerprint\")\n\n\t\t\tswitch tc.expectFingerprint {\n\t\t\tcase \"empty\":\n\t\t\t\tassert.Empty(t, finalFingerprint, \"Fingerprint should be empty\")\n\t\t\tcase \"unchanged\":\n\t\t\t\tassert.Equal(t, tc.dbFingerprint, finalFingerprint, \"Fingerprint should not change when connection is rejected\")\n\t\t\tcase \"updated\":\n\t\t\t\tif tc.dbFingerprint == \"\" {\n\t\t\t\t\tassert.NotEmpty(t, finalFingerprint, \"Fingerprint should be updated after successful connection\")\n\t\t\t\t} else {\n\t\t\t\t\tassert.NotEqual(t, tc.dbFingerprint, finalFingerprint, \"Fingerprint should be updated after successful connection\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Verify system status\n\t\t\tupdatedSystemRecord, err := testApp.FindRecordById(\"systems\", systemRecord.Id)\n\t\t\trequire.NoError(t, err)\n\t\t\tstatus := updatedSystemRecord.GetString(\"status\")\n\t\t\tassert.Equal(t, tc.expectSystemStatus, status, \"System status should match expected value\")\n\n\t\t\tt.Logf(\"%s - System status: %s, Fingerprint: %s\", tc.description, status, finalFingerprint)\n\t\t})\n\t}\n}\n", "n_tokens": 1836, "primary_symbol": "", "primary_kind": "", "primary_span": [772, 973], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "agentToken", "Token", "agent", "will", "send", "dbToken", "database", "empty", "means", "record", "created", "agentFingerprint", "Fingerprint", "generates", "its", "own", "dbFingerprint", "agentSSHKey", "ssh", "PublicKey", "expectConnection", "bool", "expectFingerprint", "unchanged", "updated", "expectSystemStatus", "description", "fingerprint", "sets", "first", "connection", "test", "token", "goodPubKey", "true", "Agent", "should", "connect", "and", "set", "when", "matching", "accepted", "matches", "existing", "mismatch", "rejected", "different", "original", "false", "pending", "doesn", "match", "invalid", "Connection", "fail", "using", "This", "more", "for", "the", "side", "but", "might", "well", "here", "wrong", "SSH", "key", "badPubKey", "uses", "range", "Run", "func", "testing", "Create", "system", "with", "unique", "port", "each", "portNum", "len", "Use", "length", "get", "systemRecord", "err", "createTestRecord", "testApp", "systems", "map", "any", "fmt", "Sprintf", "host", "localhost", "status", "users", "userRecord", "require", "NoError", "Always", "create", "this", "fingerprintRecord", "fingerprints", "configure", "agentDataDir", "TempDir", "Set", "specified", "WriteFile", "filepath", "Join", "byte", "Logf", "Pre", "file", "testAgent", "NewAgent", "environment", "variables", "Setenv", "BESZEL_AGENT_HUB_URL", "URL", "BESZEL_AGENT_TOKEN", "defer", "Unsetenv", "Start", "background", "done", "make", "chan", "error", "serverOptions", "ServerOptions", "Network", "tcp", "Addr", "Keys", "Wait", "result", "maxWait", "time", "Second", "Sleep", "Millisecond", "checkInterval", "timeout", "After", "ticker", "Tick", "connectionManager", "GetConnectionManager", "connectionResult", "select", "case", "Timeout", "reached", "Fatalf", "Expected", "succeed", "timed", "out", "state", "State", "else", "properly", "WebSocketConnected", "WebSocket", "successful", "Errorf", "Unexpected", "succeeded", "have", "been", "return", "nil", "failed", "start", "Break", "got", "expected", "break", "Verify", "reading", "specific", "updatedFingerprintRecord", "FindRecordById", "finalFingerprint", "GetString", "switch", "assert", "Empty", "Equal", "not", "change", "NotEmpty", "after", "NotEqual", "updatedSystemRecord", "System", "value"], "doc_head": "\ttestCases := []struct {\n\t\tname               string\n\t\tagentToken         string // Token agent will send\n\t\tdbToken            string // Token in database (empty means no record created)\n\t\tagentFingerprint   string // Fingerprint agent will send (empty means agent generates its own)\n\t\tdbFingerprint      string // Fingerprint in database\n\t\tagentSSHKey        ssh.PublicKey\n\t\texpectConnection   bool\n\t\texpectFingerprint  string // \"empty\", \"unchanged\", or \"updated\"\n\t\texpectSystemStatus string\n\t\tdescription        string\n\t}{\n\t\t{\n\t\t\tname:               \"empty fingerprint - agent sets fingerprint on first connection\",\n\t\t\tagentToken:         \"test-token-1\",\n\t\t\tdbToken:            \"test-token-1\",\n\t\t\tagentFingerprint:   \"agent-fingerprint-1\",\n\t\t\tdbFingerprint:      \"\",\n\t\t\tagentSSHKey:        goodPubKey,\n\t\t\texpectConnection:   true,\n\t\t\texpectFingerprint:  \"updated\",\n\t\t\texpectSystemStatus: \"up\",\n\t\t\tdescription:        \"Agent should connect and set its fingerprint when DB fingerprint is empty\",\n\t\t},\n\t\t{\n\t\t\tname:               \"matching fingerprint should be accepted\",\n\t\t\tagentToken:         \"test-token-2\",\n\t\t\tdbToken:            \"test-token-2\",\n\t\t\tagentFingerprint:   \"matching-fingerprint-123\","}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#21", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 21, "start_line": 974, "end_line": 1008, "text": "// TestMultipleSystemsWithSameUniversalToken tests that multiple systems can share the same universal token\nfunc TestMultipleSystemsWithSameUniversalToken(t *testing.T) {\n\t// Create hub and test app\n\thub, testApp, err := createTestHub(t)\n\trequire.NoError(t, err)\n\tdefer testApp.Cleanup()\n\n\t// Get the hub's SSH key\n\thubSigner, err := hub.GetSSHKey(\"\")\n\trequire.NoError(t, err)\n\tgoodPubKey := hubSigner.PublicKey()\n\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\trequire.NoError(t, err)\n\n\t// Set up universal token in the token map\n\tuniversalToken := \"shared-universal-token-123\"\n\tuniversalTokenMap.GetMap().Set(universalToken, userRecord.Id, time.Hour)\n\n\t// Create HTTP server with the actual API route\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path == \"/api/beszel/agent-connect\" {\n\t\t\tacr := &agentConnectRequest{\n\t\t\t\thub: hub,\n\t\t\t\treq: r,\n\t\t\t\tres: w,\n\t\t\t}\n\t\t\tacr.agentConnect()\n\t\t} else {\n\t\t\thttp.NotFound(w, r)\n\t\t}\n\t}))\n\tdefer ts.Close()\n", "n_tokens": 270, "primary_symbol": "TestMultipleSystemsWithSameUniversalToken", "primary_kind": "function", "primary_span": [975, 1008], "def_symbols": ["TestMultipleSystemsWithSameUniversalToken"], "symbols": ["TestMultipleSystemsWithSameUniversalToken", "tests", "that", "multiple", "systems", "can", "share", "the", "same", "universal", "token", "func", "testing", "Create", "hub", "and", "test", "app", "testApp", "err", "createTestHub", "require", "NoError", "defer", "Cleanup", "Get", "SSH", "key", "hubSigner", "GetSSHKey", "goodPubKey", "PublicKey", "user", "userRecord", "createTestUser", "Set", "map", "universalToken", "shared", "universalTokenMap", "GetMap", "time", "Hour", "HTTP", "server", "with", "actual", "API", "route", "httptest", "NewServer", "http", "HandlerFunc", "ResponseWriter", "Request", "URL", "Path", "api", "beszel", "agent", "connect", "acr", "agentConnectRequest", "req", "res", "agentConnect", "else", "NotFound", "Close"], "doc_head": "// TestMultipleSystemsWithSameUniversalToken tests that multiple systems can share the same universal token\nfunc TestMultipleSystemsWithSameUniversalToken(t *testing.T) {\n\t// Create hub and test app\n\thub, testApp, err := createTestHub(t)\n\trequire.NoError(t, err)\n\tdefer testApp.Cleanup()\n\t// Get the hub's SSH key\n\thubSigner, err := hub.GetSSHKey(\"\")\n\trequire.NoError(t, err)\n\tgoodPubKey := hubSigner.PublicKey()\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\trequire.NoError(t, err)\n\t// Set up universal token in the token map\n\tuniversalToken := \"shared-universal-token-123\"\n\tuniversalTokenMap.GetMap().Set(universalToken, userRecord.Id, time.Hour)\n\t// Create HTTP server with the actual API route\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path == \"/api/beszel/agent-connect\" {\n\t\t\tacr := &agentConnectRequest{\n\t\t\t\thub: hub,\n\t\t\t\treq: r,\n\t\t\t\tres: w,\n\t\t\t}\n\t\t\tacr.agentConnect()\n\t\t} else {\n\t\t\thttp.NotFound(w, r)\n\t\t}\n\t}))\n\tdefer ts.Close()"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#22", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 22, "start_line": 1009, "end_line": 1171, "text": "\t// Test scenarios for universal tokens\n\ttestCases := []struct {\n\t\tname               string\n\t\tagentFingerprint   string\n\t\texpectConnection   bool\n\t\texpectSystemStatus string\n\t\texpectNewSystem    bool // Whether we expect a new system to be created\n\t\tdescription        string\n\t}{\n\t\t{\n\t\t\tname:               \"first system with universal token\",\n\t\t\tagentFingerprint:   \"system-1-fingerprint\",\n\t\t\texpectConnection:   true,\n\t\t\texpectSystemStatus: \"up\",\n\t\t\texpectNewSystem:    true,\n\t\t\tdescription:        \"First system should create a new system\",\n\t\t},\n\t\t{\n\t\t\tname:               \"same system reconnecting with same fingerprint\",\n\t\t\tagentFingerprint:   \"system-1-fingerprint\", // Same fingerprint as first\n\t\t\texpectConnection:   true,\n\t\t\texpectSystemStatus: \"up\",\n\t\t\texpectNewSystem:    false, // Should reuse existing system\n\t\t\tdescription:        \"Same system should reuse existing system record\",\n\t\t},\n\t\t{\n\t\t\tname:               \"different system with same universal token\",\n\t\t\tagentFingerprint:   \"system-2-fingerprint\", // Different fingerprint\n\t\t\texpectConnection:   true,\n\t\t\texpectSystemStatus: \"up\",\n\t\t\texpectNewSystem:    true, // Should create new system\n\t\t\tdescription:        \"Different system should create a new system record\",\n\t\t},\n\t}\n\n\tvar systemCount int\n\tfor i, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Create unique port for each test\n\t\t\tportNum := 46000 + i\n\n\t\t\t// Create and configure agent\n\t\t\tagentDataDir := t.TempDir()\n\n\t\t\t// Set up agent fingerprint\n\t\t\terr = os.WriteFile(filepath.Join(agentDataDir, \"fingerprint\"), []byte(tc.agentFingerprint), 0644)\n\t\t\trequire.NoError(t, err)\n\n\t\t\ttestAgent, err := agent.NewAgent(agentDataDir)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Set up environment variables for the agent\n\t\t\tos.Setenv(\"BESZEL_AGENT_HUB_URL\", ts.URL)\n\t\t\tos.Setenv(\"BESZEL_AGENT_TOKEN\", universalToken)\n\t\t\tdefer func() {\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_HUB_URL\")\n\t\t\t\tos.Unsetenv(\"BESZEL_AGENT_TOKEN\")\n\t\t\t}()\n\n\t\t\t// Count systems before connection\n\t\t\tsystemsBefore, err := testApp.FindRecordsByFilter(\"systems\", \"users ~ {:userId}\", \"\", -1, 0, map[string]any{\"userId\": userRecord.Id})\n\t\t\trequire.NoError(t, err)\n\t\t\tsystemsBeforeCount := len(systemsBefore)\n\n\t\t\t// Start agent in background\n\t\t\tdone := make(chan error, 1)\n\t\t\tgo func() {\n\t\t\t\tserverOptions := agent.ServerOptions{\n\t\t\t\t\tNetwork: \"tcp\",\n\t\t\t\t\tAddr:    fmt.Sprintf(\"127.0.0.1:%d\", portNum),\n\t\t\t\t\tKeys:    []ssh.PublicKey{goodPubKey},\n\t\t\t\t}\n\t\t\t\tdone <- testAgent.Start(serverOptions)\n\t\t\t}()\n\n\t\t\t// Wait for connection result\n\t\t\tmaxWait := 2 * time.Second\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t\tcheckInterval := 20 * time.Millisecond\n\t\t\ttimeout := time.After(maxWait)\n\t\t\tticker := time.Tick(checkInterval)\n\n\t\t\tconnectionManager := testAgent.GetConnectionManager()\n\t\t\tconnectionResult := false\n\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-timeout:\n\t\t\t\t\tif tc.expectConnection {\n\t\t\t\t\t\tt.Fatalf(\"Expected connection to succeed but timed out - agent state: %d\", connectionManager.State)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Logf(\"Connection properly rejected (timeout) - agent state: %d\", connectionManager.State)\n\t\t\t\t\t}\n\t\t\t\t\tconnectionResult = false\n\t\t\t\tcase <-ticker:\n\t\t\t\t\tif connectionManager.State == agent.WebSocketConnected {\n\t\t\t\t\t\tif tc.expectConnection {\n\t\t\t\t\t\t\tt.Logf(\"WebSocket connection successful - agent state: %d\", connectionManager.State)\n\t\t\t\t\t\t\tconnectionResult = true\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.Errorf(\"Unexpected: Connection succeeded when it should have been rejected\")\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase err := <-done:\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tif !tc.expectConnection {\n\t\t\t\t\t\t\tt.Logf(\"Agent connection properly rejected: %v\", err)\n\t\t\t\t\t\t\tconnectionResult = false\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.Fatalf(\"Agent failed to start: %v\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif connectionResult == tc.expectConnection || connectionResult {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Verify system creation/reuse behavior\n\t\t\tif tc.expectConnection {\n\t\t\t\t// Count systems after connection\n\t\t\t\tsystemsAfter, err := testApp.FindRecordsByFilter(\"systems\", \"users ~ {:userId}\", \"\", -1, 0, map[string]any{\"userId\": userRecord.Id})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tsystemsAfterCount := len(systemsAfter)\n\n\t\t\t\tif tc.expectNewSystem {\n\t\t\t\t\t// Should have created a new system\n\t\t\t\t\tsystemCount++\n\t\t\t\t\tassert.Equal(t, systemsBeforeCount+1, systemsAfterCount, \"Should have created a new system\")\n\t\t\t\t\tassert.Equal(t, systemCount, systemsAfterCount, \"Total system count should match expected\")\n\t\t\t\t} else {\n\t\t\t\t\t// Should have reused existing system\n\t\t\t\t\tassert.Equal(t, systemsBeforeCount, systemsAfterCount, \"Should not have created a new system\")\n\t\t\t\t\tassert.Equal(t, systemCount, systemsAfterCount, \"Total system count should remain the same\")\n\t\t\t\t}\n\n\t\t\t\t// Verify that a fingerprint record exists for this fingerprint\n\t\t\t\tfingerprints, err := testApp.FindRecordsByFilter(\"fingerprints\", \"token = {:token} && fingerprint = {:fingerprint}\", \"\", -1, 0, map[string]any{\n\t\t\t\t\t\"token\":       universalToken,\n\t\t\t\t\t\"fingerprint\": tc.agentFingerprint,\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.Len(t, fingerprints, 1, \"Should have exactly one fingerprint record for this token+fingerprint combination\")\n\n\t\t\t\tfingerprint := fingerprints[0]\n\t\t\t\tassert.Equal(t, universalToken, fingerprint.GetString(\"token\"), \"Fingerprint should have the universal token\")\n\t\t\t\tassert.Equal(t, tc.agentFingerprint, fingerprint.GetString(\"fingerprint\"), \"Fingerprint should match agent's fingerprint\")\n\n\t\t\t\t// Verify system status\n\t\t\t\tsystemId := fingerprint.GetString(\"system\")\n\t\t\t\tsystem, err := testApp.FindRecordById(\"systems\", systemId)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tstatus := system.GetString(\"status\")\n\t\t\t\tassert.Equal(t, tc.expectSystemStatus, status, \"System status should match expected value\")\n\n\t\t\t\tt.Logf(\"%s - System ID: %s, Status: %s, New System: %v\", tc.description, systemId, status, tc.expectNewSystem)\n\t\t\t}\n\t\t})\n\t}\n}\n", "n_tokens": 1441, "primary_symbol": "", "primary_kind": "", "primary_span": [1009, 1171], "def_symbols": [], "symbols": ["Test", "scenarios", "for", "universal", "tokens", "testCases", "struct", "name", "string", "agentFingerprint", "expectConnection", "bool", "expectSystemStatus", "expectNewSystem", "Whether", "expect", "new", "system", "created", "description", "first", "with", "token", "fingerprint", "true", "First", "should", "create", "same", "reconnecting", "Same", "false", "Should", "reuse", "existing", "record", "different", "Different", "var", "systemCount", "int", "range", "Run", "func", "testing", "Create", "unique", "port", "each", "test", "portNum", "and", "configure", "agent", "agentDataDir", "TempDir", "Set", "err", "WriteFile", "filepath", "Join", "byte", "require", "NoError", "testAgent", "NewAgent", "environment", "variables", "the", "Setenv", "BESZEL_AGENT_HUB_URL", "URL", "BESZEL_AGENT_TOKEN", "universalToken", "defer", "Unsetenv", "Count", "systems", "before", "connection", "systemsBefore", "testApp", "FindRecordsByFilter", "users", "userId", "map", "any", "userRecord", "systemsBeforeCount", "len", "Start", "background", "done", "make", "chan", "error", "serverOptions", "ServerOptions", "Network", "tcp", "Addr", "fmt", "Sprintf", "Keys", "ssh", "PublicKey", "goodPubKey", "Wait", "result", "maxWait", "time", "Second", "Sleep", "Millisecond", "checkInterval", "timeout", "After", "ticker", "Tick", "connectionManager", "GetConnectionManager", "connectionResult", "select", "case", "Fatalf", "Expected", "succeed", "but", "timed", "out", "state", "State", "else", "Logf", "Connection", "properly", "rejected", "WebSocketConnected", "WebSocket", "successful", "Errorf", "Unexpected", "succeeded", "when", "have", "been", "return", "nil", "Agent", "failed", "start", "break", "Verify", "creation", "behavior", "after", "systemsAfter", "systemsAfterCount", "assert", "Equal", "Total", "count", "match", "expected", "reused", "not", "remain", "that", "exists", "this", "fingerprints", "Len", "exactly", "one", "combination", "GetString", "Fingerprint", "status", "systemId", "FindRecordById", "System", "value", "Status", "New"], "doc_head": "\t// Test scenarios for universal tokens\n\ttestCases := []struct {\n\t\tname               string\n\t\tagentFingerprint   string\n\t\texpectConnection   bool\n\t\texpectSystemStatus string\n\t\texpectNewSystem    bool // Whether we expect a new system to be created\n\t\tdescription        string\n\t}{\n\t\t{\n\t\t\tname:               \"first system with universal token\",\n\t\t\tagentFingerprint:   \"system-1-fingerprint\",\n\t\t\texpectConnection:   true,\n\t\t\texpectSystemStatus: \"up\",\n\t\t\texpectNewSystem:    true,\n\t\t\tdescription:        \"First system should create a new system\",\n\t\t},\n\t\t{\n\t\t\tname:               \"same system reconnecting with same fingerprint\",\n\t\t\tagentFingerprint:   \"system-1-fingerprint\", // Same fingerprint as first\n\t\t\texpectConnection:   true,\n\t\t\texpectSystemStatus: \"up\",\n\t\t\texpectNewSystem:    false, // Should reuse existing system\n\t\t\tdescription:        \"Same system should reuse existing system record\",\n\t\t},\n\t\t{\n\t\t\tname:               \"different system with same universal token\",\n\t\t\tagentFingerprint:   \"system-2-fingerprint\", // Different fingerprint\n\t\t\texpectConnection:   true,\n\t\t\texpectSystemStatus: \"up\",\n\t\t\texpectNewSystem:    true, // Should create new system\n\t\t\tdescription:        \"Different syst"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#23", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 23, "start_line": 1172, "end_line": 1181, "text": "// TestFindOrCreateSystemForToken tests the findOrCreateSystemForToken function\nfunc TestFindOrCreateSystemForToken(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\trequire.NoError(t, err)\n\tdefer testApp.Cleanup()\n\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\trequire.NoError(t, err)\n", "n_tokens": 77, "primary_symbol": "TestFindOrCreateSystemForToken", "primary_kind": "function", "primary_span": [1173, 1181], "def_symbols": ["TestFindOrCreateSystemForToken"], "symbols": ["TestFindOrCreateSystemForToken", "tests", "the", "findOrCreateSystemForToken", "function", "func", "testing", "hub", "testApp", "err", "createTestHub", "require", "NoError", "defer", "Cleanup", "Create", "test", "user", "userRecord", "createTestUser"], "doc_head": "// TestFindOrCreateSystemForToken tests the findOrCreateSystemForToken function\nfunc TestFindOrCreateSystemForToken(t *testing.T) {\n\thub, testApp, err := createTestHub(t)\n\trequire.NoError(t, err)\n\tdefer testApp.Cleanup()\n\t// Create test user\n\tuserRecord, err := createTestUser(testApp)\n\trequire.NoError(t, err)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#24", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 24, "start_line": 1182, "end_line": 1618, "text": "\ttype testCase struct {\n\t\tname                string\n\t\tsetup               func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord)\n\t\tagentFingerprint    common.FingerprintResponse\n\t\texpectError         bool\n\t\texpectNewSystem     bool\n\t\texpectedFingerprint string\n\t\tdescription         string\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname: \"universal token - existing fingerprint match\",\n\t\t\tsetup: func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord) {\n\t\t\t\t// Create test system\n\t\t\t\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\t\t\t\"name\":   \"existing-system\",\n\t\t\t\t\t\"host\":   \"192.168.1.100\",\n\t\t\t\t\t\"port\":   \"45876\",\n\t\t\t\t\t\"status\": \"pending\",\n\t\t\t\t\t\"users\":  []string{userRecord.Id},\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t// Create fingerprint record\n\t\t\t\tfpRecord, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\t\t\t\"system\":      systemRecord.Id,\n\t\t\t\t\t\"token\":       \"universal-token-123\",\n\t\t\t\t\t\"fingerprint\": \"existing-fingerprint\",\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tacr := agentConnectRequest{\n\t\t\t\t\thub:              hub,\n\t\t\t\t\ttoken:            \"universal-token-123\",\n\t\t\t\t\tisUniversalToken: true,\n\t\t\t\t\tuserId:           userRecord.Id,\n\t\t\t\t\treq: &http.Request{\n\t\t\t\t\t\tRemoteAddr: \"192.168.1.100\",\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tfpRecords := []ws.FingerprintRecord{\n\t\t\t\t\t{\n\t\t\t\t\t\tId:          fpRecord.Id,\n\t\t\t\t\t\tSystemId:    systemRecord.Id,\n\t\t\t\t\t\tFingerprint: \"existing-fingerprint\",\n\t\t\t\t\t\tToken:       \"universal-token-123\",\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\treturn acr, fpRecords\n\t\t\t},\n\t\t\tagentFingerprint: common.FingerprintResponse{\n\t\t\t\tFingerprint: \"existing-fingerprint\",\n\t\t\t\tHostname:    \"test-host\",\n\t\t\t\tPort:        \"8080\",\n\t\t\t},\n\t\t\texpectError:         false,\n\t\t\texpectNewSystem:     false,\n\t\t\texpectedFingerprint: \"existing-fingerprint\",\n\t\t\tdescription:         \"Should reuse existing system with matching fingerprint\",\n\t\t},\n\t\t{\n\t\t\tname: \"universal token - new fingerprint\",\n\t\t\tsetup: func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord) {\n\t\t\t\t// Create test system\n\t\t\t\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\t\t\t\"name\":   \"existing-system-2\",\n\t\t\t\t\t\"host\":   \"192.168.1.101\",\n\t\t\t\t\t\"port\":   \"45876\",\n\t\t\t\t\t\"status\": \"pending\",\n\t\t\t\t\t\"users\":  []string{userRecord.Id},\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t// Create fingerprint record\n\t\t\t\tfpRecord, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\t\t\t\"system\":      systemRecord.Id,\n\t\t\t\t\t\"token\":       \"universal-token-123\",\n\t\t\t\t\t\"fingerprint\": \"existing-fingerprint\",\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tacr := agentConnectRequest{\n\t\t\t\t\thub:              hub,\n\t\t\t\t\ttoken:            \"universal-token-123\",\n\t\t\t\t\tisUniversalToken: true,\n\t\t\t\t\tuserId:           userRecord.Id,\n\t\t\t\t\treq: &http.Request{\n\t\t\t\t\t\tRemoteAddr: \"192.168.1.200\",\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tfpRecords := []ws.FingerprintRecord{\n\t\t\t\t\t{\n\t\t\t\t\t\tId:          fpRecord.Id,\n\t\t\t\t\t\tSystemId:    systemRecord.Id,\n\t\t\t\t\t\tFingerprint: \"existing-fingerprint\",\n\t\t\t\t\t\tToken:       \"universal-token-123\",\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\treturn acr, fpRecords\n\t\t\t},\n\t\t\tagentFingerprint: common.FingerprintResponse{\n\t\t\t\tFingerprint: \"new-fingerprint\",\n\t\t\t\tHostname:    \"new-host\",\n\t\t\t\tPort:        \"9090\",\n\t\t\t},\n\t\t\texpectError:         false,\n\t\t\texpectNewSystem:     true,\n\t\t\texpectedFingerprint: \"new-fingerprint\",\n\t\t\tdescription:         \"Should create new system with different fingerprint\",\n\t\t},\n\t\t{\n\t\t\tname: \"universal token - no existing records\",\n\t\t\tsetup: func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord) {\n\t\t\t\tacr := agentConnectRequest{\n\t\t\t\t\thub:              hub,\n\t\t\t\t\ttoken:            \"universal-token-456\",\n\t\t\t\t\tisUniversalToken: true,\n\t\t\t\t\tuserId:           userRecord.Id,\n\t\t\t\t\treq: &http.Request{\n\t\t\t\t\t\tRemoteAddr: \"192.168.1.300\",\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tfpRecords := []ws.FingerprintRecord{}\n\n\t\t\t\treturn acr, fpRecords\n\t\t\t},\n\t\t\tagentFingerprint: common.FingerprintResponse{\n\t\t\t\tFingerprint: \"first-fingerprint\",\n\t\t\t\tHostname:    \"first-host\",\n\t\t\t\tPort:        \"7070\",\n\t\t\t},\n\t\t\texpectError:         false,\n\t\t\texpectNewSystem:     true,\n\t\t\texpectedFingerprint: \"first-fingerprint\",\n\t\t\tdescription:         \"Should create new system when no existing records\",\n\t\t},\n\t\t{\n\t\t\tname: \"regular token - empty fingerprint\",\n\t\t\tsetup: func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord) {\n\t\t\t\t// Create test system\n\t\t\t\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\t\t\t\"name\":   \"regular-system\",\n\t\t\t\t\t\"host\":   \"192.168.1.200\",\n\t\t\t\t\t\"port\":   \"45876\",\n\t\t\t\t\t\"status\": \"pending\",\n\t\t\t\t\t\"users\":  []string{userRecord.Id},\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t// Create fingerprint record with empty fingerprint\n\t\t\t\tfpRecord, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\t\t\t\"system\":      systemRecord.Id,\n\t\t\t\t\t\"token\":       \"regular-token-123\",\n\t\t\t\t\t\"fingerprint\": \"\",\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tacr := agentConnectRequest{\n\t\t\t\t\thub:              hub,\n\t\t\t\t\ttoken:            \"regular-token-123\",\n\t\t\t\t\tisUniversalToken: false,\n\t\t\t\t}\n\n\t\t\t\tfpRecords := []ws.FingerprintRecord{\n\t\t\t\t\t{\n\t\t\t\t\t\tId:          fpRecord.Id,\n\t\t\t\t\t\tSystemId:    systemRecord.Id,\n\t\t\t\t\t\tFingerprint: \"\",\n\t\t\t\t\t\tToken:       \"regular-token-123\",\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\treturn acr, fpRecords\n\t\t\t},\n\t\t\tagentFingerprint: common.FingerprintResponse{\n\t\t\t\tFingerprint: \"agent-fingerprint\",\n\t\t\t\tHostname:    \"agent-host\",\n\t\t\t\tPort:        \"6060\",\n\t\t\t},\n\t\t\texpectError:         false,\n\t\t\texpectNewSystem:     false,\n\t\t\texpectedFingerprint: \"agent-fingerprint\",\n\t\t\tdescription:         \"Should update empty fingerprint for regular token\",\n\t\t},\n\t\t{\n\t\t\tname: \"regular token - fingerprint mismatch\",\n\t\t\tsetup: func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord) {\n\t\t\t\t// Create test system\n\t\t\t\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\t\t\t\"name\":   \"regular-system-2\",\n\t\t\t\t\t\"host\":   \"192.168.1.250\",\n\t\t\t\t\t\"port\":   \"45876\",\n\t\t\t\t\t\"status\": \"pending\",\n\t\t\t\t\t\"users\":  []string{userRecord.Id},\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t// Create fingerprint record with different fingerprint\n\t\t\t\tfpRecord, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\t\t\t\"system\":      systemRecord.Id,\n\t\t\t\t\t\"token\":       \"regular-token-456\",\n\t\t\t\t\t\"fingerprint\": \"different-fingerprint\",\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tacr := agentConnectRequest{\n\t\t\t\t\thub:              hub,\n\t\t\t\t\ttoken:            \"regular-token-456\",\n\t\t\t\t\tisUniversalToken: false,\n\t\t\t\t}\n\n\t\t\t\tfpRecords := []ws.FingerprintRecord{\n\t\t\t\t\t{\n\t\t\t\t\t\tId:          fpRecord.Id,\n\t\t\t\t\t\tSystemId:    systemRecord.Id,\n\t\t\t\t\t\tFingerprint: \"different-fingerprint\",\n\t\t\t\t\t\tToken:       \"regular-token-456\",\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\treturn acr, fpRecords\n\t\t\t},\n\t\t\tagentFingerprint: common.FingerprintResponse{\n\t\t\t\tFingerprint: \"agent-fingerprint\",\n\t\t\t\tHostname:    \"agent-host\",\n\t\t\t\tPort:        \"5050\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t\tdescription: \"Should reject fingerprint mismatch for regular token\",\n\t\t},\n\t\t{\n\t\t\tname: \"universal token - missing user ID\",\n\t\t\tsetup: func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord) {\n\t\t\t\tacr := agentConnectRequest{\n\t\t\t\t\thub:              hub,\n\t\t\t\t\ttoken:            \"universal-token-789\",\n\t\t\t\t\tisUniversalToken: true,\n\t\t\t\t\tuserId:           \"\", // Missing user ID\n\t\t\t\t\treq: &http.Request{\n\t\t\t\t\t\tRemoteAddr: \"192.168.1.400\",\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tfpRecords := []ws.FingerprintRecord{}\n\n\t\t\t\treturn acr, fpRecords\n\t\t\t},\n\t\t\tagentFingerprint: common.FingerprintResponse{\n\t\t\t\tFingerprint: \"some-fingerprint\",\n\t\t\t\tHostname:    \"some-host\",\n\t\t\t\tPort:        \"4040\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t\tdescription: \"Should reject universal token without user ID\",\n\t\t},\n\t\t{\n\t\t\tname: \"expired universal token - matching fingerprint\",\n\t\t\tsetup: func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord) {\n\t\t\t\t// Create test systems\n\t\t\t\tsystemRecord1, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\t\t\t\"name\":   \"expired-system-1\",\n\t\t\t\t\t\"host\":   \"192.168.1.500\",\n\t\t\t\t\t\"port\":   \"45876\",\n\t\t\t\t\t\"status\": \"pending\",\n\t\t\t\t\t\"users\":  []string{userRecord.Id},\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tsystemRecord2, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\t\t\t\"name\":   \"expired-system-2\",\n\t\t\t\t\t\"host\":   \"192.168.1.501\",\n\t\t\t\t\t\"port\":   \"45876\",\n\t\t\t\t\t\"status\": \"pending\",\n\t\t\t\t\t\"users\":  []string{userRecord.Id},\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t// Create fingerprint records\n\t\t\t\tfpRecord1, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\t\t\t\"system\":      systemRecord1.Id,\n\t\t\t\t\t\"token\":       \"expired-universal-token-123\",\n\t\t\t\t\t\"fingerprint\": \"expired-fingerprint-1\",\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfpRecord2, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\t\t\t\"system\":      systemRecord2.Id,\n\t\t\t\t\t\"token\":       \"expired-universal-token-123\",\n\t\t\t\t\t\"fingerprint\": \"expired-fingerprint-2\",\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tacr := agentConnectRequest{\n\t\t\t\t\thub:              hub,\n\t\t\t\t\ttoken:            \"expired-universal-token-123\",\n\t\t\t\t\tisUniversalToken: false, // Token is no longer active\n\t\t\t\t\tuserId:           \"\",    // No user ID since token is expired\n\t\t\t\t}\n\n\t\t\t\tfpRecords := []ws.FingerprintRecord{\n\t\t\t\t\t{\n\t\t\t\t\t\tId:          fpRecord1.Id,\n\t\t\t\t\t\tSystemId:    systemRecord1.Id,\n\t\t\t\t\t\tFingerprint: \"expired-fingerprint-1\",\n\t\t\t\t\t\tToken:       \"expired-universal-token-123\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tId:          fpRecord2.Id,\n\t\t\t\t\t\tSystemId:    systemRecord2.Id,\n\t\t\t\t\t\tFingerprint: \"expired-fingerprint-2\",\n\t\t\t\t\t\tToken:       \"expired-universal-token-123\",\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\treturn acr, fpRecords\n\t\t\t},\n\t\t\tagentFingerprint: common.FingerprintResponse{\n\t\t\t\tFingerprint: \"expired-fingerprint-1\", // Matches first record\n\t\t\t\tHostname:    \"expired-host\",\n\t\t\t\tPort:        \"3030\",\n\t\t\t},\n\t\t\texpectError:         false,\n\t\t\texpectNewSystem:     false,\n\t\t\texpectedFingerprint: \"expired-fingerprint-1\",\n\t\t\tdescription:         \"Should allow connection with expired universal token if fingerprint matches\",\n\t\t},\n\t\t{\n\t\t\tname: \"expired universal token - no matching fingerprint\",\n\t\t\tsetup: func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord) {\n\t\t\t\t// Create test system\n\t\t\t\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\t\t\t\"name\":   \"expired-system-3\",\n\t\t\t\t\t\"host\":   \"192.168.1.600\",\n\t\t\t\t\t\"port\":   \"45876\",\n\t\t\t\t\t\"status\": \"pending\",\n\t\t\t\t\t\"users\":  []string{userRecord.Id},\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t// Create fingerprint record\n\t\t\t\tfpRecord, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\t\t\t\"system\":      systemRecord.Id,\n\t\t\t\t\t\"token\":       \"expired-universal-token-456\",\n\t\t\t\t\t\"fingerprint\": \"expired-fingerprint-3\",\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tacr := agentConnectRequest{\n\t\t\t\t\thub:              hub,\n\t\t\t\t\ttoken:            \"expired-universal-token-456\",\n\t\t\t\t\tisUniversalToken: false, // Token is no longer active\n\t\t\t\t\tuserId:           \"\",    // No user ID since token is expired\n\t\t\t\t\treq: &http.Request{\n\t\t\t\t\t\tRemoteAddr: \"192.168.1.600\",\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tfpRecords := []ws.FingerprintRecord{\n\t\t\t\t\t{\n\t\t\t\t\t\tId:          fpRecord.Id,\n\t\t\t\t\t\tSystemId:    systemRecord.Id,\n\t\t\t\t\t\tFingerprint: \"expired-fingerprint-3\",\n\t\t\t\t\t\tToken:       \"expired-universal-token-456\",\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\treturn acr, fpRecords\n\t\t\t},\n\t\t\tagentFingerprint: common.FingerprintResponse{\n\t\t\t\tFingerprint: \"different-fingerprint\", // Doesn't match any existing record\n\t\t\t\tHostname:    \"different-host\",\n\t\t\t\tPort:        \"2020\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t\tdescription: \"Should reject connection with expired universal token if no fingerprint matches\",\n\t\t},\n\t\t{\n\t\t\tname: \"regular token - no existing records\",\n\t\t\tsetup: func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord) {\n\t\t\t\tacr := agentConnectRequest{\n\t\t\t\t\thub:              hub,\n\t\t\t\t\ttoken:            \"regular-token-no-record\",\n\t\t\t\t\tisUniversalToken: false,\n\t\t\t\t}\n\t\t\t\treturn acr, []ws.FingerprintRecord{}\n\t\t\t},\n\t\t\tagentFingerprint: common.FingerprintResponse{\n\t\t\t\tFingerprint: \"some-fingerprint\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t\tdescription: \"Should reject regular token with no fingerprint record\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tacr, fpRecords := tc.setup(t, hub, testApp, userRecord)\n\t\t\tresult, err := acr.findOrCreateSystemForToken(fpRecords, tc.agentFingerprint)\n\n\t\t\tif tc.expectError {\n\t\t\t\tassert.Error(t, err, tc.description)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.NoError(t, err, tc.description)\n\n\t\t\t// Verify expected fingerprint\n\t\t\tif tc.expectedFingerprint != \"\" {\n\t\t\t\tassert.Equal(t, tc.expectedFingerprint, result.Fingerprint, \"Fingerprint should match expected\")\n\t\t\t}\n\n\t\t\t// For new systems, verify they were actually created\n\t\t\tif tc.expectNewSystem {\n\t\t\t\tassert.NotEmpty(t, result.SystemId, \"New system should have a system ID\")\n\n\t\t\t\t// Verify system was created in database\n\t\t\t\tsystem, err := testApp.FindRecordById(\"systems\", result.SystemId)\n\t\t\t\trequire.NoError(t, err, \"New system should exist in database\")\n\n\t\t\t\t// Verify system properties\n\t\t\t\tassert.Equal(t, tc.agentFingerprint.Hostname, system.GetString(\"name\"), \"System name should match hostname\")\n\t\t\t\tassert.Equal(t, getRealIP(acr.req), system.GetString(\"host\"), \"System host should match remote address\")\n\t\t\t\tassert.Equal(t, tc.agentFingerprint.Port, system.GetString(\"port\"), \"System port should match agent port\")\n\t\t\t\tassert.Equal(t, []string{acr.userId}, system.Get(\"users\"), \"System users should match\")\n\t\t\t}\n\n\t\t\tt.Logf(\"%s - Result: SystemId=%s, Fingerprint=%s\", tc.description, result.SystemId, result.Fingerprint)\n\t\t})\n\t}\n}\n", "n_tokens": 3757, "primary_symbol": "", "primary_kind": "", "primary_span": [1182, 1618], "def_symbols": [], "symbols": ["type", "testCase", "struct", "name", "string", "setup", "func", "testing", "hub", "Hub", "testApp", "pbtests", "TestApp", "userRecord", "core", "Record", "agentConnectRequest", "FingerprintRecord", "agentFingerprint", "common", "FingerprintResponse", "expectError", "bool", "expectNewSystem", "expectedFingerprint", "description", "testCases", "universal", "token", "existing", "fingerprint", "match", "Create", "test", "system", "systemRecord", "err", "createTestRecord", "systems", "map", "any", "host", "port", "status", "pending", "users", "require", "NoError", "record", "fpRecord", "fingerprints", "acr", "isUniversalToken", "true", "userId", "req", "http", "Request", "RemoteAddr", "fpRecords", "SystemId", "Fingerprint", "Token", "return", "Hostname", "Port", "false", "Should", "reuse", "with", "matching", "new", "create", "different", "records", "first", "when", "regular", "empty", "agent", "update", "for", "mismatch", "reject", "missing", "user", "Missing", "some", "without", "expired", "systemRecord1", "systemRecord2", "fpRecord1", "fpRecord2", "longer", "active", "since", "Matches", "allow", "connection", "matches", "Doesn", "range", "Run", "result", "findOrCreateSystemForToken", "assert", "Error", "Verify", "expected", "Equal", "should", "For", "verify", "they", "were", "actually", "created", "NotEmpty", "New", "have", "was", "database", "FindRecordById", "exist", "properties", "GetString", "System", "hostname", "getRealIP", "remote", "address", "Get", "Logf", "Result"], "doc_head": "\ttype testCase struct {\n\t\tname                string\n\t\tsetup               func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord)\n\t\tagentFingerprint    common.FingerprintResponse\n\t\texpectError         bool\n\t\texpectNewSystem     bool\n\t\texpectedFingerprint string\n\t\tdescription         string\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname: \"universal token - existing fingerprint match\",\n\t\t\tsetup: func(t *testing.T, hub *Hub, testApp *pbtests.TestApp, userRecord *core.Record) (agentConnectRequest, []ws.FingerprintRecord) {\n\t\t\t\t// Create test system\n\t\t\t\tsystemRecord, err := createTestRecord(testApp, \"systems\", map[string]any{\n\t\t\t\t\t\"name\":   \"existing-system\",\n\t\t\t\t\t\"host\":   \"192.168.1.100\",\n\t\t\t\t\t\"port\":   \"45876\",\n\t\t\t\t\t\"status\": \"pending\",\n\t\t\t\t\t\"users\":  []string{userRecord.Id},\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\t// Create fingerprint record\n\t\t\t\tfpRecord, err := createTestRecord(testApp, \"fingerprints\", map[string]any{\n\t\t\t\t\t\"system\":      systemRecord.Id,\n\t\t\t\t\t\"token\":       \"universal-token-123\",\n\t\t\t\t\t\"fingerprint\": \"existing-fingerprint\",\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tacr := agentConnectRequest{\n\t\t\t\t\thub:   "}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#25", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 25, "start_line": 1619, "end_line": 1620, "text": "// TestGetRealIP tests the getRealIP function\nfunc TestGetRealIP(t *testing.T) {", "n_tokens": 23, "primary_symbol": "TestGetRealIP", "primary_kind": "function", "primary_span": [1620, 1620], "def_symbols": ["TestGetRealIP"], "symbols": ["TestGetRealIP", "tests", "the", "getRealIP", "function", "func", "testing"], "doc_head": "// TestGetRealIP tests the getRealIP function\nfunc TestGetRealIP(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go#26", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/agent_connect_test.go", "rel_path": "src/hub/agent_connect_test.go", "ext": "go", "language": "go", "chunk_number": 26, "start_line": 1621, "end_line": 1702, "text": "\ttestCases := []struct {\n\t\tname       string\n\t\theaders    map[string]string\n\t\tremoteAddr string\n\t\texpectedIP string\n\t}{\n\t\t{\n\t\t\tname:       \"CF-Connecting-IP header\",\n\t\t\theaders:    map[string]string{\"CF-Connecting-IP\": \"192.168.1.1\"},\n\t\t\tremoteAddr: \"127.0.0.1:12345\",\n\t\t\texpectedIP: \"192.168.1.1\",\n\t\t},\n\t\t{\n\t\t\tname:       \"X-Forwarded-For header with single IP\",\n\t\t\theaders:    map[string]string{\"X-Forwarded-For\": \"192.168.1.2\"},\n\t\t\tremoteAddr: \"127.0.0.1:12345\",\n\t\t\texpectedIP: \"192.168.1.2\",\n\t\t},\n\t\t{\n\t\t\tname:       \"X-Forwarded-For header with multiple IPs\",\n\t\t\theaders:    map[string]string{\"X-Forwarded-For\": \"192.168.1.3, 10.0.0.1, 172.16.0.1\"},\n\t\t\tremoteAddr: \"127.0.0.1:12345\",\n\t\t\texpectedIP: \"192.168.1.3\",\n\t\t},\n\t\t{\n\t\t\tname:       \"X-Forwarded-For header with spaces\",\n\t\t\theaders:    map[string]string{\"X-Forwarded-For\": \"  192.168.1.4  \"},\n\t\t\tremoteAddr: \"127.0.0.1:12345\",\n\t\t\texpectedIP: \"192.168.1.4\",\n\t\t},\n\t\t{\n\t\t\tname:       \"No headers, fallback to RemoteAddr with port\",\n\t\t\theaders:    map[string]string{},\n\t\t\tremoteAddr: \"192.168.1.5:54321\",\n\t\t\texpectedIP: \"192.168.1.5\",\n\t\t},\n\t\t{\n\t\t\tname:       \"No headers, fallback to RemoteAddr without port\",\n\t\t\theaders:    map[string]string{},\n\t\t\tremoteAddr: \"192.168.1.6\",\n\t\t\texpectedIP: \"192.168.1.6\",\n\t\t},\n\t\t{\n\t\t\tname:       \"Both headers present, CF takes precedence\",\n\t\t\theaders:    map[string]string{\"CF-Connecting-IP\": \"192.168.1.1\", \"X-Forwarded-For\": \"192.168.1.2\"},\n\t\t\tremoteAddr: \"127.0.0.1:12345\",\n\t\t\texpectedIP: \"192.168.1.1\",\n\t\t},\n\t\t{\n\t\t\tname:       \"X-Forwarded-For present, takes precedence over RemoteAddr\",\n\t\t\theaders:    map[string]string{\"X-Forwarded-For\": \"192.168.1.2\"},\n\t\t\tremoteAddr: \"192.168.1.5:54321\",\n\t\t\texpectedIP: \"192.168.1.2\",\n\t\t},\n\t\t{\n\t\t\tname:       \"Empty X-Forwarded-For, fallback to RemoteAddr\",\n\t\t\theaders:    map[string]string{\"X-Forwarded-For\": \"\"},\n\t\t\tremoteAddr: \"192.168.1.7:12345\",\n\t\t\texpectedIP: \"192.168.1.7\",\n\t\t},\n\t\t{\n\t\t\tname:       \"Empty CF-Connecting-IP, fallback to X-Forwarded-For\",\n\t\t\theaders:    map[string]string{\"CF-Connecting-IP\": \"\", \"X-Forwarded-For\": \"192.168.1.8\"},\n\t\t\tremoteAddr: \"127.0.0.1:12345\",\n\t\t\texpectedIP: \"192.168.1.8\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(\"GET\", \"/\", nil)\n\t\t\tfor key, value := range tc.headers {\n\t\t\t\treq.Header.Set(key, value)\n\t\t\t}\n\t\t\treq.RemoteAddr = tc.remoteAddr\n\n\t\t\tip := getRealIP(req)\n\t\t\tassert.Equal(t, tc.expectedIP, ip)\n\t\t})\n\t}\n}\n", "n_tokens": 883, "primary_symbol": "", "primary_kind": "", "primary_span": [1621, 1702], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "headers", "map", "remoteAddr", "expectedIP", "Connecting", "header", "Forwarded", "For", "with", "single", "multiple", "IPs", "spaces", "fallback", "RemoteAddr", "port", "without", "Both", "present", "takes", "precedence", "over", "Empty", "for", "range", "Run", "func", "testing", "req", "httptest", "NewRequest", "GET", "nil", "key", "value", "Header", "Set", "getRealIP", "assert", "Equal"], "doc_head": "\ttestCases := []struct {\n\t\tname       string\n\t\theaders    map[string]string\n\t\tremoteAddr string\n\t\texpectedIP string\n\t}{\n\t\t{\n\t\t\tname:       \"CF-Connecting-IP header\",\n\t\t\theaders:    map[string]string{\"CF-Connecting-IP\": \"192.168.1.1\"},\n\t\t\tremoteAddr: \"127.0.0.1:12345\",\n\t\t\texpectedIP: \"192.168.1.1\",\n\t\t},\n\t\t{\n\t\t\tname:       \"X-Forwarded-For header with single IP\",\n\t\t\theaders:    map[string]string{\"X-Forwarded-For\": \"192.168.1.2\"},\n\t\t\tremoteAddr: \"127.0.0.1:12345\",\n\t\t\texpectedIP: \"192.168.1.2\",\n\t\t},\n\t\t{\n\t\t\tname:       \"X-Forwarded-For header with multiple IPs\",\n\t\t\theaders:    map[string]string{\"X-Forwarded-For\": \"192.168.1.3, 10.0.0.1, 172.16.0.1\"},\n\t\t\tremoteAddr: \"127.0.0.1:12345\",\n\t\t\texpectedIP: \"192.168.1.3\",\n\t\t},\n\t\t{\n\t\t\tname:       \"X-Forwarded-For header with spaces\",\n\t\t\theaders:    map[string]string{\"X-Forwarded-For\": \"  192.168.1.4  \"},\n\t\t\tremoteAddr: \"127.0.0.1:12345\",\n\t\t\texpectedIP: \"192.168.1.4\",\n\t\t},\n\t\t{\n\t\t\tname:       \"No headers, fallback to RemoteAddr with port\",\n\t\t\theaders:    map[string]string{},\n\t\t\tremoteAddr: \"192.168.1.5:54321\",\n\t\t\texpectedIP: \"192.168.1.5\",\n\t\t},\n\t\t{\n\t\t\tname:       \"No headers, fallback to RemoteAddr without port\",\n\t\t\theaders:    map[string]string{},"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go", "rel_path": "src/hub/hub_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 36, "text": "//go:build testing\n// +build testing\n\npackage hub_test\n\nimport (\n\t\"bytes\"\n\t\"crypto/ed25519\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/henrygd/beszel/src/migrations\"\n\tbeszelTests \"github.com/henrygd/beszel/src/tests\"\n\n\t\"github.com/pocketbase/pocketbase/core\"\n\tpbTests \"github.com/pocketbase/pocketbase/tests\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)\n\n// marshal to json and return an io.Reader (for use in ApiScenario.Body)\nfunc jsonReader(v any) io.Reader {\n\tdata, err := json.Marshal(v)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn bytes.NewReader(data)\n}\n", "n_tokens": 188, "primary_symbol": "jsonReader", "primary_kind": "function", "primary_span": [29, 36], "def_symbols": ["jsonReader"], "symbols": ["jsonReader", "build", "testing", "package", "hub_test", "import", "bytes", "crypto", "ed25519", "encoding", "json", "pem", "net", "http", "path", "filepath", "strings", "github", "com", "henrygd", "beszel", "src", "migrations", "beszelTests", "tests", "pocketbase", "core", "pbTests", "stretchr", "testify", "assert", "require", "golang", "org", "ssh", "marshal", "and", "return", "Reader", "for", "use", "ApiScenario", "Body", "func", "any", "data", "err", "Marshal", "nil", "panic", "NewReader"], "doc_head": "//go:build testing\n// +build testing\npackage hub_test\nimport (\n\t\"bytes\"\n\t\"crypto/ed25519\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"github.com/henrygd/beszel/src/migrations\"\n\tbeszelTests \"github.com/henrygd/beszel/src/tests\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\tpbTests \"github.com/pocketbase/pocketbase/tests\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)\n// marshal to json and return an io.Reader (for use in ApiScenario.Body)\nfunc jsonReader(v any) io.Reader {\n\tdata, err := json.Marshal(v)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn bytes.NewReader(data)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go", "rel_path": "src/hub/hub_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 37, "end_line": 39, "text": "func TestMakeLink(t *testing.T) {\n\thub, _ := beszelTests.NewTestHub(t.TempDir())\n", "n_tokens": 25, "primary_symbol": "TestMakeLink", "primary_kind": "function", "primary_span": [37, 39], "def_symbols": ["TestMakeLink"], "symbols": ["TestMakeLink", "func", "testing", "hub", "beszelTests", "NewTestHub", "TempDir"], "doc_head": "func TestMakeLink(t *testing.T) {\n\thub, _ := beszelTests.NewTestHub(t.TempDir())"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go", "rel_path": "src/hub/hub_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 40, "end_line": 126, "text": "\ttests := []struct {\n\t\tname     string\n\t\tappURL   string\n\t\tparts    []string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no parts, no trailing slash in AppURL\",\n\t\t\tappURL:   \"http://localhost:8090\",\n\t\t\tparts:    []string{},\n\t\t\texpected: \"http://localhost:8090\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no parts, with trailing slash in AppURL\",\n\t\t\tappURL:   \"http://localhost:8090/\",\n\t\t\tparts:    []string{},\n\t\t\texpected: \"http://localhost:8090\", // TrimSuffix should handle the trailing slash\n\t\t},\n\t\t{\n\t\t\tname:     \"one part\",\n\t\t\tappURL:   \"http://example.com\",\n\t\t\tparts:    []string{\"one\"},\n\t\t\texpected: \"http://example.com/one\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple parts\",\n\t\t\tappURL:   \"http://example.com\",\n\t\t\tparts:    []string{\"alpha\", \"beta\", \"gamma\"},\n\t\t\texpected: \"http://example.com/alpha/beta/gamma\",\n\t\t},\n\t\t{\n\t\t\tname:     \"parts with spaces needing escaping\",\n\t\t\tappURL:   \"http://example.com\",\n\t\t\tparts:    []string{\"path with spaces\", \"another part\"},\n\t\t\texpected: \"http://example.com/path%20with%20spaces/another%20part\",\n\t\t},\n\t\t{\n\t\t\tname:     \"parts with slashes needing escaping\",\n\t\t\tappURL:   \"http://example.com\",\n\t\t\tparts:    []string{\"a/b\", \"c\"},\n\t\t\texpected: \"http://example.com/a%2Fb/c\", // url.PathEscape escapes '/'\n\t\t},\n\t\t{\n\t\t\tname:     \"AppURL with subpath, no trailing slash\",\n\t\t\tappURL:   \"http://localhost/sub\",\n\t\t\tparts:    []string{\"resource\"},\n\t\t\texpected: \"http://localhost/sub/resource\",\n\t\t},\n\t\t{\n\t\t\tname:     \"AppURL with subpath, with trailing slash\",\n\t\t\tappURL:   \"http://localhost/sub/\",\n\t\t\tparts:    []string{\"item\"},\n\t\t\texpected: \"http://localhost/sub/item\",\n\t\t},\n\t\t{\n\t\t\tname:     \"empty parts in the middle\",\n\t\t\tappURL:   \"http://localhost\",\n\t\t\tparts:    []string{\"first\", \"\", \"third\"},\n\t\t\texpected: \"http://localhost/first/third\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing empty parts\",\n\t\t\tappURL:   \"http://localhost\",\n\t\t\tparts:    []string{\"\", \"path\", \"\"},\n\t\t\texpected: \"http://localhost/path\",\n\t\t},\n\t\t{\n\t\t\tname:     \"parts with various special characters\",\n\t\t\tappURL:   \"https://test.dev/\",\n\t\t\tparts:    []string{\"p@th?\", \"key=value&\"},\n\t\t\texpected: \"https://test.dev/p@th%3F/key=value&\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Store original app URL and restore it after the test\n\t\t\toriginalAppURL := hub.Settings().Meta.AppURL\n\t\t\thub.Settings().Meta.AppURL = tt.appURL\n\t\t\tdefer func() { hub.Settings().Meta.AppURL = originalAppURL }()\n\n\t\t\tgot := hub.MakeLink(tt.parts...)\n\t\t\tassert.Equal(t, tt.expected, got, \"MakeLink generated URL does not match expected\")\n\t\t})\n\t}\n}\n", "n_tokens": 758, "primary_symbol": "", "primary_kind": "", "primary_span": [40, 126], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "appURL", "parts", "expected", "trailing", "slash", "AppURL", "http", "localhost", "with", "TrimSuffix", "should", "handle", "the", "one", "part", "example", "com", "multiple", "alpha", "beta", "gamma", "spaces", "needing", "escaping", "path", "another", "slashes", "url", "PathEscape", "escapes", "subpath", "sub", "resource", "item", "empty", "middle", "first", "third", "leading", "and", "various", "special", "characters", "https", "test", "dev", "key", "value", "for", "range", "Run", "func", "testing", "Store", "original", "app", "URL", "restore", "after", "originalAppURL", "hub", "Settings", "Meta", "defer", "got", "MakeLink", "assert", "Equal", "generated", "does", "not", "match"], "doc_head": "\ttests := []struct {\n\t\tname     string\n\t\tappURL   string\n\t\tparts    []string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no parts, no trailing slash in AppURL\",\n\t\t\tappURL:   \"http://localhost:8090\",\n\t\t\tparts:    []string{},\n\t\t\texpected: \"http://localhost:8090\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no parts, with trailing slash in AppURL\",\n\t\t\tappURL:   \"http://localhost:8090/\",\n\t\t\tparts:    []string{},\n\t\t\texpected: \"http://localhost:8090\", // TrimSuffix should handle the trailing slash\n\t\t},\n\t\t{\n\t\t\tname:     \"one part\",\n\t\t\tappURL:   \"http://example.com\",\n\t\t\tparts:    []string{\"one\"},\n\t\t\texpected: \"http://example.com/one\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple parts\",\n\t\t\tappURL:   \"http://example.com\",\n\t\t\tparts:    []string{\"alpha\", \"beta\", \"gamma\"},\n\t\t\texpected: \"http://example.com/alpha/beta/gamma\",\n\t\t},\n\t\t{\n\t\t\tname:     \"parts with spaces needing escaping\",\n\t\t\tappURL:   \"http://example.com\",\n\t\t\tparts:    []string{\"path with spaces\", \"another part\"},\n\t\t\texpected: \"http://example.com/path%20with%20spaces/another%20part\",\n\t\t},\n\t\t{\n\t\t\tname:     \"parts with slashes needing escaping\",\n\t\t\tappURL:   \"http://example.com\",\n\t\t\tparts:    []string{\"a/b\", \"c\"},\n\t\t\texpected: \"http://example.com/a%2Fb/c\", // url.PathEsca"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go", "rel_path": "src/hub/hub_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 127, "end_line": 199, "text": "func TestGetSSHKey(t *testing.T) {\n\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\n\t// Test Case 1: Key generation (no existing key)\n\tt.Run(\"KeyGeneration\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\n\t\t// Ensure pubKey is initially empty or different to ensure GetSSHKey sets it\n\t\thub.SetPubkey(\"\")\n\n\t\tsigner, err := hub.GetSSHKey(tempDir)\n\t\tassert.NoError(t, err, \"GetSSHKey should not error when generating a new key\")\n\t\tassert.NotNil(t, signer, \"GetSSHKey should return a non-nil signer\")\n\n\t\t// Check if private key file was created\n\t\tprivateKeyPath := filepath.Join(tempDir, \"id_ed25519\")\n\t\tinfo, err := os.Stat(privateKeyPath)\n\t\tassert.NoError(t, err, \"Private key file should be created\")\n\t\tassert.False(t, info.IsDir(), \"Private key path should be a file, not a directory\")\n\n\t\t// Check if h.pubKey was set\n\t\tassert.NotEmpty(t, hub.GetPubkey(), \"h.pubKey should be set after key generation\")\n\t\tassert.True(t, strings.HasPrefix(hub.GetPubkey(), \"ssh-ed25519 \"), \"h.pubKey should start with 'ssh-ed25519 '\")\n\n\t\t// Verify the generated private key is parsable\n\t\tkeyData, err := os.ReadFile(privateKeyPath)\n\t\trequire.NoError(t, err)\n\t\t_, err = ssh.ParsePrivateKey(keyData)\n\t\tassert.NoError(t, err, \"Generated private key should be parsable by ssh.ParsePrivateKey\")\n\t})\n\n\t// Test Case 2: Existing key\n\tt.Run(\"ExistingKey\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\n\t\t// Manually create a valid key pair for the test\n\t\trawPubKey, rawPrivKey, err := ed25519.GenerateKey(nil)\n\t\trequire.NoError(t, err, \"Failed to generate raw ed25519 key pair for pre-existing key test\")\n\n\t\t// Marshal the private key into OpenSSH PEM format\n\t\tpemBlock, err := ssh.MarshalPrivateKey(rawPrivKey, \"\")\n\t\trequire.NoError(t, err, \"Failed to marshal private key to PEM block for pre-existing key test\")\n\n\t\tprivateKeyBytes := pem.EncodeToMemory(pemBlock)\n\t\trequire.NotNil(t, privateKeyBytes, \"PEM encoded private key bytes should not be nil\")\n\n\t\tprivateKeyPath := filepath.Join(tempDir, \"id_ed25519\")\n\t\terr = os.WriteFile(privateKeyPath, privateKeyBytes, 0600)\n\t\trequire.NoError(t, err, \"Failed to write pre-existing private key\")\n\n\t\t// Determine the expected public key string\n\t\tsshPubKey, err := ssh.NewPublicKey(rawPubKey)\n\t\trequire.NoError(t, err)\n\t\texpectedPubKeyStr := strings.TrimSpace(string(ssh.MarshalAuthorizedKey(sshPubKey)))\n\n\t\t// Reset h.pubKey to ensure it's set by GetSSHKey from the file\n\t\thub.SetPubkey(\"\")\n\n\t\tsigner, err := hub.GetSSHKey(tempDir)\n\t\tassert.NoError(t, err, \"GetSSHKey should not error when reading an existing key\")\n\t\tassert.NotNil(t, signer, \"GetSSHKey should return a non-nil signer for an existing key\")\n\n\t\t// Check if h.pubKey was set correctly to the public key from the file\n\t\tassert.Equal(t, expectedPubKeyStr, hub.GetPubkey(), \"h.pubKey should match the existing public key\")\n\n\t\t// Verify the signer's public key matches the original public key\n\t\tsignerPubKey := signer.PublicKey()\n\t\tmarshaledSignerPubKey := strings.TrimSpace(string(ssh.MarshalAuthorizedKey(signerPubKey)))\n\t\tassert.Equal(t, expectedPubKeyStr, marshaledSignerPubKey, \"Signer's public key should match the existing public key\")\n\t})\n\n\t// Test Case 3: Error cases\n\tt.Run(\"ErrorCases\", func(t *testing.T) {", "n_tokens": 843, "primary_symbol": "TestGetSSHKey", "primary_kind": "function", "primary_span": [127, 199], "def_symbols": ["TestGetSSHKey"], "symbols": ["TestGetSSHKey", "func", "testing", "hub", "beszelTests", "NewTestHub", "TempDir", "Test", "Case", "Key", "generation", "existing", "key", "Run", "KeyGeneration", "tempDir", "Ensure", "pubKey", "initially", "empty", "different", "ensure", "GetSSHKey", "sets", "SetPubkey", "signer", "err", "assert", "NoError", "should", "not", "error", "when", "generating", "new", "NotNil", "return", "non", "nil", "Check", "private", "file", "was", "created", "privateKeyPath", "filepath", "Join", "id_ed25519", "info", "Stat", "Private", "False", "IsDir", "path", "directory", "set", "NotEmpty", "GetPubkey", "after", "True", "strings", "HasPrefix", "ssh", "ed25519", "start", "with", "Verify", "the", "generated", "parsable", "keyData", "ReadFile", "require", "ParsePrivateKey", "Generated", "Existing", "ExistingKey", "Manually", "create", "valid", "pair", "for", "test", "rawPubKey", "rawPrivKey", "GenerateKey", "Failed", "generate", "raw", "pre", "Marshal", "into", "OpenSSH", "PEM", "format", "pemBlock", "MarshalPrivateKey", "marshal", "block", "privateKeyBytes", "pem", "EncodeToMemory", "encoded", "bytes", "WriteFile", "write", "Determine", "expected", "public", "string", "sshPubKey", "NewPublicKey", "expectedPubKeyStr", "TrimSpace", "MarshalAuthorizedKey", "Reset", "from", "reading", "correctly", "Equal", "match", "matches", "original", "signerPubKey", "PublicKey", "marshaledSignerPubKey", "Signer", "Error", "cases", "ErrorCases"], "doc_head": "func TestGetSSHKey(t *testing.T) {\n\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\t// Test Case 1: Key generation (no existing key)\n\tt.Run(\"KeyGeneration\", func(t *testing.T) {\n\t\ttempDir := t.TempDir()\n\t\t// Ensure pubKey is initially empty or different to ensure GetSSHKey sets it\n\t\thub.SetPubkey(\"\")\n\t\tsigner, err := hub.GetSSHKey(tempDir)\n\t\tassert.NoError(t, err, \"GetSSHKey should not error when generating a new key\")\n\t\tassert.NotNil(t, signer, \"GetSSHKey should return a non-nil signer\")\n\t\t// Check if private key file was created\n\t\tprivateKeyPath := filepath.Join(tempDir, \"id_ed25519\")\n\t\tinfo, err := os.Stat(privateKeyPath)\n\t\tassert.NoError(t, err, \"Private key file should be created\")\n\t\tassert.False(t, info.IsDir(), \"Private key path should be a file, not a directory\")\n\t\t// Check if h.pubKey was set\n\t\tassert.NotEmpty(t, hub.GetPubkey(), \"h.pubKey should be set after key generation\")\n\t\tassert.True(t, strings.HasPrefix(hub.GetPubkey(), \"ssh-ed25519 \"), \"h.pubKey should start with 'ssh-ed25519 '\")\n\t\t// Verify the generated private key is parsable\n\t\tkeyData, err := os.ReadFile(privateKeyPath)\n\t\trequire.NoError(t, err)\n\t\t_, err = ssh.ParsePrivateKey(keyData)\n\t\tassert.NoError(t, err, \"G"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go", "rel_path": "src/hub/hub_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 200, "end_line": 268, "text": "\t\ttests := []struct {\n\t\t\tname       string\n\t\t\tsetupFunc  func(dir string) error\n\t\t\terrorCheck func(t *testing.T, err error)\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"CorruptedKey\",\n\t\t\t\tsetupFunc: func(dir string) error {\n\t\t\t\t\treturn os.WriteFile(filepath.Join(dir, \"id_ed25519\"), []byte(\"this is not a valid SSH key\"), 0600)\n\t\t\t\t},\n\t\t\t\terrorCheck: func(t *testing.T, err error) {\n\t\t\t\t\tassert.Error(t, err)\n\t\t\t\t\tassert.Contains(t, err.Error(), \"ssh: no key found\")\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"PermissionDenied\",\n\t\t\t\tsetupFunc: func(dir string) error {\n\t\t\t\t\t// Create the key file\n\t\t\t\t\tkeyPath := filepath.Join(dir, \"id_ed25519\")\n\t\t\t\t\tif err := os.WriteFile(keyPath, []byte(\"dummy content\"), 0600); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\t// Make it read-only (can't be opened for writing in case a new key needs to be written)\n\t\t\t\t\treturn os.Chmod(keyPath, 0400)\n\t\t\t\t},\n\t\t\t\terrorCheck: func(t *testing.T, err error) {\n\t\t\t\t\t// On read-only key, the parser will attempt to parse it and fail with \"ssh: no key found\"\n\t\t\t\t\tassert.Error(t, err)\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"EmptyFile\",\n\t\t\t\tsetupFunc: func(dir string) error {\n\t\t\t\t\t// Create an empty file\n\t\t\t\t\treturn os.WriteFile(filepath.Join(dir, \"id_ed25519\"), []byte{}, 0600)\n\t\t\t\t},\n\t\t\t\terrorCheck: func(t *testing.T, err error) {\n\t\t\t\t\tassert.Error(t, err)\n\t\t\t\t\t// The error from attempting to parse an empty file\n\t\t\t\t\tassert.Contains(t, err.Error(), \"ssh: no key found\")\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range tests {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\ttempDir := t.TempDir()\n\n\t\t\t\t// Setup the test case\n\t\t\t\terr := tc.setupFunc(tempDir)\n\t\t\t\trequire.NoError(t, err, \"Setup failed\")\n\n\t\t\t\t// Reset h.pubKey before each test case\n\t\t\t\thub.SetPubkey(\"\")\n\n\t\t\t\t// Attempt to get SSH key\n\t\t\t\t_, err = hub.GetSSHKey(tempDir)\n\n\t\t\t\t// Verify the error\n\t\t\t\ttc.errorCheck(t, err)\n\n\t\t\t\t// Check that pubKey was not set in error cases\n\t\t\t\tassert.Empty(t, hub.GetPubkey(), \"h.pubKey should not be set if there was an error\")\n\t\t\t})\n\t\t}\n\t})\n}\n", "n_tokens": 567, "primary_symbol": "", "primary_kind": "", "primary_span": [200, 268], "def_symbols": [], "symbols": ["tests", "struct", "name", "string", "setupFunc", "func", "dir", "error", "errorCheck", "testing", "err", "CorruptedKey", "return", "WriteFile", "filepath", "Join", "id_ed25519", "byte", "this", "not", "valid", "SSH", "key", "assert", "Error", "Contains", "ssh", "found", "PermissionDenied", "Create", "the", "file", "keyPath", "dummy", "content", "nil", "Make", "read", "only", "can", "opened", "for", "writing", "case", "new", "needs", "written", "Chmod", "parser", "will", "attempt", "parse", "and", "fail", "with", "EmptyFile", "empty", "The", "from", "attempting", "range", "Run", "tempDir", "TempDir", "Setup", "test", "require", "NoError", "failed", "Reset", "pubKey", "before", "each", "hub", "SetPubkey", "Attempt", "get", "GetSSHKey", "Verify", "Check", "that", "was", "set", "cases", "Empty", "GetPubkey", "should", "there"], "doc_head": "\t\ttests := []struct {\n\t\t\tname       string\n\t\t\tsetupFunc  func(dir string) error\n\t\t\terrorCheck func(t *testing.T, err error)\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"CorruptedKey\",\n\t\t\t\tsetupFunc: func(dir string) error {\n\t\t\t\t\treturn os.WriteFile(filepath.Join(dir, \"id_ed25519\"), []byte(\"this is not a valid SSH key\"), 0600)\n\t\t\t\t},\n\t\t\t\terrorCheck: func(t *testing.T, err error) {\n\t\t\t\t\tassert.Error(t, err)\n\t\t\t\t\tassert.Contains(t, err.Error(), \"ssh: no key found\")\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"PermissionDenied\",\n\t\t\t\tsetupFunc: func(dir string) error {\n\t\t\t\t\t// Create the key file\n\t\t\t\t\tkeyPath := filepath.Join(dir, \"id_ed25519\")\n\t\t\t\t\tif err := os.WriteFile(keyPath, []byte(\"dummy content\"), 0600); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\t// Make it read-only (can't be opened for writing in case a new key needs to be written)\n\t\t\t\t\treturn os.Chmod(keyPath, 0400)\n\t\t\t\t},\n\t\t\t\terrorCheck: func(t *testing.T, err error) {\n\t\t\t\t\t// On read-only key, the parser will attempt to parse it and fail with \"ssh: no key found\"\n\t\t\t\t\tassert.Error(t, err)\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"EmptyFile\",\n\t\t\t\tsetupFunc: func(dir string) error {\n\t\t\t\t\t// Create an empty file\n\t\t\t\t\treturn os.WriteFile(filepath.Join(dir, \"id_ed25519\"), []byte{}, "}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go", "rel_path": "src/hub/hub_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 269, "end_line": 537, "text": "func TestApiRoutesAuthentication(t *testing.T) {\n\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\tdefer hub.Cleanup()\n\n\thub.StartHub()\n\n\t// Create test user and get auth token\n\tuser, err := beszelTests.CreateUser(hub, \"testuser@example.com\", \"password123\")\n\trequire.NoError(t, err, \"Failed to create test user\")\n\n\tadminUser, err := beszelTests.CreateRecord(hub, \"users\", map[string]any{\n\t\t\"email\":    \"admin@example.com\",\n\t\t\"password\": \"password123\",\n\t\t\"role\":     \"admin\",\n\t})\n\trequire.NoError(t, err, \"Failed to create admin user\")\n\tadminUserToken, err := adminUser.NewAuthToken()\n\n\t// superUser, err := beszelTests.CreateRecord(hub, core.CollectionNameSuperusers, map[string]any{\n\t// \t\"email\":    \"superuser@example.com\",\n\t// \t\"password\": \"password123\",\n\t// })\n\t// require.NoError(t, err, \"Failed to create superuser\")\n\n\tuserToken, err := user.NewAuthToken()\n\trequire.NoError(t, err, \"Failed to create auth token\")\n\n\t// Create test system for user-alerts endpoints\n\tsystem, err := beszelTests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":  \"test-system\",\n\t\t\"users\": []string{user.Id},\n\t\t\"host\":  \"127.0.0.1\",\n\t})\n\trequire.NoError(t, err, \"Failed to create test system\")\n\n\ttestAppFactory := func(t testing.TB) *pbTests.TestApp {\n\t\treturn hub.TestApp\n\t}\n\n\tscenarios := []beszelTests.ApiScenario{\n\t\t// Auth Protected Routes - Should require authentication\n\t\t{\n\t\t\tName:            \"POST /test-notification - no auth should fail\",\n\t\t\tMethod:          http.MethodPost,\n\t\t\tURL:             \"/api/beszel/test-notification\",\n\t\t\tExpectedStatus:  401,\n\t\t\tExpectedContent: []string{\"requires valid\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"url\": \"generic://127.0.0.1\",\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tName:           \"POST /test-notification - with auth should succeed\",\n\t\t\tMethod:         http.MethodPost,\n\t\t\tURL:            \"/api/beszel/test-notification\",\n\t\t\tTestAppFactory: testAppFactory,\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": userToken,\n\t\t\t},\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"url\": \"generic://127.0.0.1\",\n\t\t\t}),\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"sending message\"},\n\t\t},\n\t\t{\n\t\t\tName:            \"GET /config-yaml - no auth should fail\",\n\t\t\tMethod:          http.MethodGet,\n\t\t\tURL:             \"/api/beszel/config-yaml\",\n\t\t\tExpectedStatus:  401,\n\t\t\tExpectedContent: []string{\"requires valid\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:   \"GET /config-yaml - with user auth should fail\",\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/api/beszel/config-yaml\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": userToken,\n\t\t\t},\n\t\t\tExpectedStatus:  403,\n\t\t\tExpectedContent: []string{\"Requires admin\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:   \"GET /config-yaml - with admin auth should succeed\",\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/api/beszel/config-yaml\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": adminUserToken,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"test-system\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:            \"GET /universal-token - no auth should fail\",\n\t\t\tMethod:          http.MethodGet,\n\t\t\tURL:             \"/api/beszel/universal-token\",\n\t\t\tExpectedStatus:  401,\n\t\t\tExpectedContent: []string{\"requires valid\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:   \"GET /universal-token - with auth should succeed\",\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/api/beszel/universal-token\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": userToken,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"active\", \"token\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:            \"POST /user-alerts - no auth should fail\",\n\t\t\tMethod:          http.MethodPost,\n\t\t\tURL:             \"/api/beszel/user-alerts\",\n\t\t\tExpectedStatus:  401,\n\t\t\tExpectedContent: []string{\"requires valid\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":    \"CPU\",\n\t\t\t\t\"value\":   80,\n\t\t\t\t\"min\":     10,\n\t\t\t\t\"systems\": []string{system.Id},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tName:   \"POST /user-alerts - with auth should succeed\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": userToken,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"success\\\":true\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":    \"CPU\",\n\t\t\t\t\"value\":   80,\n\t\t\t\t\"min\":     10,\n\t\t\t\t\"systems\": []string{system.Id},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tName:            \"DELETE /user-alerts - no auth should fail\",\n\t\t\tMethod:          http.MethodDelete,\n\t\t\tURL:             \"/api/beszel/user-alerts\",\n\t\t\tExpectedStatus:  401,\n\t\t\tExpectedContent: []string{\"requires valid\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":    \"CPU\",\n\t\t\t\t\"systems\": []string{system.Id},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tName:   \"DELETE /user-alerts - with auth should succeed\",\n\t\t\tMethod: http.MethodDelete,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": userToken,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"success\\\":true\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":    \"CPU\",\n\t\t\t\t\"systems\": []string{system.Id},\n\t\t\t}),\n\t\t\tBeforeTestFunc: func(t testing.TB, app *pbTests.TestApp, e *core.ServeEvent) {\n\t\t\t\t// Create an alert to delete\n\t\t\t\tbeszelTests.CreateRecord(app, \"alerts\", map[string]any{\n\t\t\t\t\t\"name\":   \"CPU\",\n\t\t\t\t\t\"system\": system.Id,\n\t\t\t\t\t\"user\":   user.Id,\n\t\t\t\t\t\"value\":  80,\n\t\t\t\t\t\"min\":    10,\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\n\t\t// Auth Optional Routes - Should work without authentication\n\t\t{\n\t\t\tName:            \"GET /getkey - no auth should fail\",\n\t\t\tMethod:          http.MethodGet,\n\t\t\tURL:             \"/api/beszel/getkey\",\n\t\t\tExpectedStatus:  401,\n\t\t\tExpectedContent: []string{\"requires valid\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:   \"GET /getkey - with auth should also succeed\",\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/api/beszel/getkey\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": userToken,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"key\\\":\", \"\\\"v\\\":\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:            \"GET /first-run - no auth should succeed\",\n\t\t\tMethod:          http.MethodGet,\n\t\t\tURL:             \"/api/beszel/first-run\",\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"firstRun\\\":false\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:   \"GET /first-run - with auth should also succeed\",\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/api/beszel/first-run\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": userToken,\n\t\t\t},\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"\\\"firstRun\\\":false\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:            \"GET /agent-connect - no auth should succeed (websocket upgrade fails but route is accessible)\",\n\t\t\tMethod:          http.MethodGet,\n\t\t\tURL:             \"/api/beszel/agent-connect\",\n\t\t\tExpectedStatus:  400,\n\t\t\tExpectedContent: []string{},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:   \"POST /test-notification - invalid auth token should fail\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/test-notification\",\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"url\": \"generic://127.0.0.1\",\n\t\t\t}),\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": \"invalid-token\",\n\t\t\t},\n\t\t\tExpectedStatus:  401,\n\t\t\tExpectedContent: []string{\"requires valid\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t},\n\t\t{\n\t\t\tName:   \"POST /user-alerts - invalid auth token should fail\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/user-alerts\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Authorization\": \"invalid-token\",\n\t\t\t},\n\t\t\tExpectedStatus:  401,\n\t\t\tExpectedContent: []string{\"requires valid\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"name\":    \"CPU\",\n\t\t\t\t\"value\":   80,\n\t\t\t\t\"min\":     10,\n\t\t\t\t\"systems\": []string{system.Id},\n\t\t\t}),\n\t\t},\n\t}\n\n\tfor _, scenario := range scenarios {\n\t\tscenario.Test(t)\n\t}\n}\n", "n_tokens": 2317, "primary_symbol": "TestApiRoutesAuthentication", "primary_kind": "function", "primary_span": [269, 537], "def_symbols": ["TestApiRoutesAuthentication"], "symbols": ["TestApiRoutesAuthentication", "func", "testing", "hub", "beszelTests", "NewTestHub", "TempDir", "defer", "Cleanup", "StartHub", "Create", "test", "user", "and", "get", "auth", "token", "err", "CreateUser", "testuser", "example", "com", "password123", "require", "NoError", "Failed", "create", "adminUser", "CreateRecord", "users", "map", "string", "any", "email", "admin", "password", "role", "adminUserToken", "NewAuthToken", "superUser", "core", "CollectionNameSuperusers", "superuser", "userToken", "system", "for", "alerts", "endpoints", "systems", "name", "host", "testAppFactory", "pbTests", "TestApp", "return", "scenarios", "ApiScenario", "Auth", "Protected", "Routes", "Should", "authentication", "Name", "POST", "notification", "should", "fail", "Method", "http", "MethodPost", "URL", "api", "beszel", "ExpectedStatus", "ExpectedContent", "requires", "valid", "TestAppFactory", "Body", "jsonReader", "url", "generic", "with", "succeed", "Headers", "Authorization", "sending", "message", "GET", "config", "yaml", "MethodGet", "Requires", "universal", "active", "CPU", "value", "min", "success", "true", "DELETE", "MethodDelete", "BeforeTestFunc", "app", "ServeEvent", "alert", "delete", "Optional", "work", "without", "getkey", "also", "key", "first", "run", "firstRun", "false", "agent", "connect", "websocket", "upgrade", "fails", "but", "route", "accessible", "invalid", "scenario", "range", "Test"], "doc_head": "func TestApiRoutesAuthentication(t *testing.T) {\n\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\tdefer hub.Cleanup()\n\thub.StartHub()\n\t// Create test user and get auth token\n\tuser, err := beszelTests.CreateUser(hub, \"testuser@example.com\", \"password123\")\n\trequire.NoError(t, err, \"Failed to create test user\")\n\tadminUser, err := beszelTests.CreateRecord(hub, \"users\", map[string]any{\n\t\t\"email\":    \"admin@example.com\",\n\t\t\"password\": \"password123\",\n\t\t\"role\":     \"admin\",\n\t})\n\trequire.NoError(t, err, \"Failed to create admin user\")\n\tadminUserToken, err := adminUser.NewAuthToken()\n\t// superUser, err := beszelTests.CreateRecord(hub, core.CollectionNameSuperusers, map[string]any{\n\t// \t\"email\":    \"superuser@example.com\",\n\t// \t\"password\": \"password123\",\n\t// })\n\t// require.NoError(t, err, \"Failed to create superuser\")\n\tuserToken, err := user.NewAuthToken()\n\trequire.NoError(t, err, \"Failed to create auth token\")\n\t// Create test system for user-alerts endpoints\n\tsystem, err := beszelTests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\"name\":  \"test-system\",\n\t\t\"users\": []string{user.Id},\n\t\t\"host\":  \"127.0.0.1\",\n\t})\n\trequire.NoError(t, err, \"Failed to create test system\")\n\ttestAppFactory := func(t"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go", "rel_path": "src/hub/hub_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 538, "end_line": 646, "text": "func TestFirstUserCreation(t *testing.T) {\n\tt.Run(\"CreateUserEndpoint available when no users exist\", func(t *testing.T) {\n\t\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\t\tdefer hub.Cleanup()\n\n\t\thub.StartHub()\n\n\t\ttestAppFactoryExisting := func(t testing.TB) *pbTests.TestApp {\n\t\t\treturn hub.TestApp\n\t\t}\n\n\t\tscenarios := []beszelTests.ApiScenario{\n\t\t\t{\n\t\t\t\tName:   \"POST /create-user - should be available when no users exist\",\n\t\t\t\tMethod: http.MethodPost,\n\t\t\t\tURL:    \"/api/beszel/create-user\",\n\t\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\t\"email\":    \"firstuser@example.com\",\n\t\t\t\t\t\"password\": \"password123\",\n\t\t\t\t}),\n\t\t\t\tExpectedStatus:  200,\n\t\t\t\tExpectedContent: []string{\"User created\"},\n\t\t\t\tTestAppFactory:  testAppFactoryExisting,\n\t\t\t\tBeforeTestFunc: func(t testing.TB, app *pbTests.TestApp, e *core.ServeEvent) {\n\t\t\t\t\tuserCount, err := hub.CountRecords(\"users\")\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.Zero(t, userCount, \"Should start with no users\")\n\t\t\t\t\tsuperusers, err := hub.FindAllRecords(core.CollectionNameSuperusers)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.EqualValues(t, 1, len(superusers), \"Should start with one temporary superuser\")\n\t\t\t\t\trequire.EqualValues(t, migrations.TempAdminEmail, superusers[0].GetString(\"email\"), \"Should have created one temporary superuser\")\n\t\t\t\t},\n\t\t\t\tAfterTestFunc: func(t testing.TB, app *pbTests.TestApp, res *http.Response) {\n\t\t\t\t\tuserCount, err := hub.CountRecords(\"users\")\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.EqualValues(t, 1, userCount, \"Should have created one user\")\n\t\t\t\t\tsuperusers, err := hub.FindAllRecords(core.CollectionNameSuperusers)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.EqualValues(t, 1, len(superusers), \"Should have created one superuser\")\n\t\t\t\t\trequire.EqualValues(t, \"firstuser@example.com\", superusers[0].GetString(\"email\"), \"Should have created one superuser\")\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"POST /create-user - should not be available when users exist\",\n\t\t\t\tMethod: http.MethodPost,\n\t\t\t\tURL:    \"/api/beszel/create-user\",\n\t\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\t\"email\":    \"firstuser@example.com\",\n\t\t\t\t\t\"password\": \"password123\",\n\t\t\t\t}),\n\t\t\t\tExpectedStatus:  404,\n\t\t\t\tExpectedContent: []string{\"wasn't found\"},\n\t\t\t\tTestAppFactory:  testAppFactoryExisting,\n\t\t\t},\n\t\t}\n\n\t\tfor _, scenario := range scenarios {\n\t\t\tscenario.Test(t)\n\t\t}\n\t})\n\n\tt.Run(\"CreateUserEndpoint not available when USER_EMAIL, USER_PASSWORD are set\", func(t *testing.T) {\n\t\tos.Setenv(\"BESZEL_HUB_USER_EMAIL\", \"me@example.com\")\n\t\tos.Setenv(\"BESZEL_HUB_USER_PASSWORD\", \"password123\")\n\t\tdefer os.Unsetenv(\"BESZEL_HUB_USER_EMAIL\")\n\t\tdefer os.Unsetenv(\"BESZEL_HUB_USER_PASSWORD\")\n\n\t\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\t\tdefer hub.Cleanup()\n\n\t\thub.StartHub()\n\n\t\ttestAppFactory := func(t testing.TB) *pbTests.TestApp {\n\t\t\treturn hub.TestApp\n\t\t}\n\n\t\tscenario := beszelTests.ApiScenario{\n\t\t\tName:            \"POST /create-user - should not be available when USER_EMAIL, USER_PASSWORD are set\",\n\t\t\tMethod:          http.MethodPost,\n\t\t\tURL:             \"/api/beszel/create-user\",\n\t\t\tExpectedStatus:  404,\n\t\t\tExpectedContent: []string{\"wasn't found\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t\tBeforeTestFunc: func(t testing.TB, app *pbTests.TestApp, e *core.ServeEvent) {\n\t\t\t\tusers, err := hub.FindAllRecords(\"users\")\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.EqualValues(t, 1, len(users), \"Should start with one user\")\n\t\t\t\trequire.EqualValues(t, \"me@example.com\", users[0].GetString(\"email\"), \"Should have created one user\")\n\t\t\t\tsuperusers, err := hub.FindAllRecords(core.CollectionNameSuperusers)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.EqualValues(t, 1, len(superusers), \"Should start with one superuser\")\n\t\t\t\trequire.EqualValues(t, \"me@example.com\", superusers[0].GetString(\"email\"), \"Should have created one superuser\")\n\t\t\t},\n\t\t\tAfterTestFunc: func(t testing.TB, app *pbTests.TestApp, res *http.Response) {\n\t\t\t\tusers, err := hub.FindAllRecords(\"users\")\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.EqualValues(t, 1, len(users), \"Should still have one user\")\n\t\t\t\trequire.EqualValues(t, \"me@example.com\", users[0].GetString(\"email\"), \"Should have created one user\")\n\t\t\t\tsuperusers, err := hub.FindAllRecords(core.CollectionNameSuperusers)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.EqualValues(t, 1, len(superusers), \"Should still have one superuser\")\n\t\t\t\trequire.EqualValues(t, \"me@example.com\", superusers[0].GetString(\"email\"), \"Should have created one superuser\")\n\t\t\t},\n\t\t}\n\n\t\tscenario.Test(t)\n\t})\n}\n", "n_tokens": 1187, "primary_symbol": "TestFirstUserCreation", "primary_kind": "function", "primary_span": [538, 646], "def_symbols": ["TestFirstUserCreation"], "symbols": ["TestFirstUserCreation", "func", "testing", "Run", "CreateUserEndpoint", "available", "when", "users", "exist", "hub", "beszelTests", "NewTestHub", "TempDir", "defer", "Cleanup", "StartHub", "testAppFactoryExisting", "pbTests", "TestApp", "return", "scenarios", "ApiScenario", "Name", "POST", "create", "user", "should", "Method", "http", "MethodPost", "URL", "api", "beszel", "Body", "jsonReader", "map", "string", "any", "email", "firstuser", "example", "com", "password", "password123", "ExpectedStatus", "ExpectedContent", "User", "created", "TestAppFactory", "BeforeTestFunc", "app", "core", "ServeEvent", "userCount", "err", "CountRecords", "require", "NoError", "Zero", "Should", "start", "with", "superusers", "FindAllRecords", "CollectionNameSuperusers", "EqualValues", "len", "one", "temporary", "superuser", "migrations", "TempAdminEmail", "GetString", "have", "AfterTestFunc", "res", "Response", "not", "wasn", "found", "for", "scenario", "range", "Test", "USER_EMAIL", "USER_PASSWORD", "are", "set", "Setenv", "BESZEL_HUB_USER_EMAIL", "BESZEL_HUB_USER_PASSWORD", "Unsetenv", "testAppFactory", "still"], "doc_head": "func TestFirstUserCreation(t *testing.T) {\n\tt.Run(\"CreateUserEndpoint available when no users exist\", func(t *testing.T) {\n\t\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\t\tdefer hub.Cleanup()\n\t\thub.StartHub()\n\t\ttestAppFactoryExisting := func(t testing.TB) *pbTests.TestApp {\n\t\t\treturn hub.TestApp\n\t\t}\n\t\tscenarios := []beszelTests.ApiScenario{\n\t\t\t{\n\t\t\t\tName:   \"POST /create-user - should be available when no users exist\",\n\t\t\t\tMethod: http.MethodPost,\n\t\t\t\tURL:    \"/api/beszel/create-user\",\n\t\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\t\"email\":    \"firstuser@example.com\",\n\t\t\t\t\t\"password\": \"password123\",\n\t\t\t\t}),\n\t\t\t\tExpectedStatus:  200,\n\t\t\t\tExpectedContent: []string{\"User created\"},\n\t\t\t\tTestAppFactory:  testAppFactoryExisting,\n\t\t\t\tBeforeTestFunc: func(t testing.TB, app *pbTests.TestApp, e *core.ServeEvent) {\n\t\t\t\t\tuserCount, err := hub.CountRecords(\"users\")\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.Zero(t, userCount, \"Should start with no users\")\n\t\t\t\t\tsuperusers, err := hub.FindAllRecords(core.CollectionNameSuperusers)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.EqualValues(t, 1, len(superusers), \"Should start with one temporary superuser\")\n\t\t\t\t\trequire.EqualValues(t, migrations.TempAdminEmai"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/hub_test.go", "rel_path": "src/hub/hub_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 647, "end_line": 714, "text": "func TestCreateUserEndpointAvailability(t *testing.T) {\n\tt.Run(\"CreateUserEndpoint available when no users exist\", func(t *testing.T) {\n\t\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\t\tdefer hub.Cleanup()\n\n\t\t// Ensure no users exist\n\t\tuserCount, err := hub.CountRecords(\"users\")\n\t\trequire.NoError(t, err)\n\t\trequire.Zero(t, userCount, \"Should start with no users\")\n\n\t\thub.StartHub()\n\n\t\ttestAppFactory := func(t testing.TB) *pbTests.TestApp {\n\t\t\treturn hub.TestApp\n\t\t}\n\n\t\tscenario := beszelTests.ApiScenario{\n\t\t\tName:   \"POST /create-user - should be available when no users exist\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/create-user\",\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"email\":    \"firstuser@example.com\",\n\t\t\t\t\"password\": \"password123\",\n\t\t\t}),\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"User created\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t}\n\n\t\tscenario.Test(t)\n\n\t\t// Verify user was created\n\t\tuserCount, err = hub.CountRecords(\"users\")\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 1, userCount, \"Should have created one user\")\n\t})\n\n\tt.Run(\"CreateUserEndpoint not available when users exist\", func(t *testing.T) {\n\t\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\t\tdefer hub.Cleanup()\n\n\t\t// Create a user first\n\t\t_, err := beszelTests.CreateUser(hub, \"existing@example.com\", \"password\")\n\t\trequire.NoError(t, err)\n\n\t\thub.StartHub()\n\n\t\ttestAppFactory := func(t testing.TB) *pbTests.TestApp {\n\t\t\treturn hub.TestApp\n\t\t}\n\n\t\tscenario := beszelTests.ApiScenario{\n\t\t\tName:   \"POST /create-user - should not be available when users exist\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/create-user\",\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"email\":    \"another@example.com\",\n\t\t\t\t\"password\": \"password123\",\n\t\t\t}),\n\t\t\tExpectedStatus:  404,\n\t\t\tExpectedContent: []string{\"wasn't found\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t}\n\n\t\tscenario.Test(t)\n\t})\n}\n", "n_tokens": 530, "primary_symbol": "TestCreateUserEndpointAvailability", "primary_kind": "function", "primary_span": [647, 714], "def_symbols": ["TestCreateUserEndpointAvailability"], "symbols": ["TestCreateUserEndpointAvailability", "func", "testing", "Run", "CreateUserEndpoint", "available", "when", "users", "exist", "hub", "beszelTests", "NewTestHub", "TempDir", "defer", "Cleanup", "Ensure", "userCount", "err", "CountRecords", "require", "NoError", "Zero", "Should", "start", "with", "StartHub", "testAppFactory", "pbTests", "TestApp", "return", "scenario", "ApiScenario", "Name", "POST", "create", "user", "should", "Method", "http", "MethodPost", "URL", "api", "beszel", "Body", "jsonReader", "map", "string", "any", "email", "firstuser", "example", "com", "password", "password123", "ExpectedStatus", "ExpectedContent", "User", "created", "TestAppFactory", "Test", "Verify", "was", "EqualValues", "have", "one", "not", "Create", "first", "CreateUser", "existing", "another", "wasn", "found"], "doc_head": "func TestCreateUserEndpointAvailability(t *testing.T) {\n\tt.Run(\"CreateUserEndpoint available when no users exist\", func(t *testing.T) {\n\t\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\t\tdefer hub.Cleanup()\n\t\t// Ensure no users exist\n\t\tuserCount, err := hub.CountRecords(\"users\")\n\t\trequire.NoError(t, err)\n\t\trequire.Zero(t, userCount, \"Should start with no users\")\n\t\thub.StartHub()\n\t\ttestAppFactory := func(t testing.TB) *pbTests.TestApp {\n\t\t\treturn hub.TestApp\n\t\t}\n\t\tscenario := beszelTests.ApiScenario{\n\t\t\tName:   \"POST /create-user - should be available when no users exist\",\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/api/beszel/create-user\",\n\t\t\tBody: jsonReader(map[string]any{\n\t\t\t\t\"email\":    \"firstuser@example.com\",\n\t\t\t\t\"password\": \"password123\",\n\t\t\t}),\n\t\t\tExpectedStatus:  200,\n\t\t\tExpectedContent: []string{\"User created\"},\n\t\t\tTestAppFactory:  testAppFactory,\n\t\t}\n\t\tscenario.Test(t)\n\t\t// Verify user was created\n\t\tuserCount, err = hub.CountRecords(\"users\")\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 1, userCount, \"Should have created one user\")\n\t})\n\tt.Run(\"CreateUserEndpoint not available when users exist\", func(t *testing.T) {\n\t\thub, _ := beszelTests.NewTestHub(t.TempDir())\n\t\tdefer"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go", "rel_path": "src/hub/config/config.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 30, "text": "// Package config provides functions for syncing systems with the config.yml file\npackage config\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/spf13/cast\"\n\t\"gopkg.in/yaml.v3\"\n)\n\ntype config struct {\n\tSystems []systemConfig `yaml:\"systems\"`\n}\n\ntype systemConfig struct {\n\tName  string   `yaml:\"name\"`\n\tHost  string   `yaml:\"host\"`\n\tPort  uint16   `yaml:\"port,omitempty\"`\n\tToken string   `yaml:\"token,omitempty\"`\n\tUsers []string `yaml:\"users\"`\n}\n", "n_tokens": 162, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 30], "def_symbols": [], "symbols": ["Package", "config", "provides", "functions", "for", "syncing", "systems", "with", "the", "yml", "file", "package", "import", "fmt", "log", "path", "filepath", "github", "com", "google", "uuid", "henrygd", "beszel", "src", "entities", "system", "pocketbase", "dbx", "core", "spf13", "cast", "gopkg", "yaml", "type", "struct", "Systems", "systemConfig", "Name", "string", "name", "Host", "host", "Port", "uint16", "port", "omitempty", "Token", "token", "Users", "users"], "doc_head": "// Package config provides functions for syncing systems with the config.yml file\npackage config\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"github.com/google/uuid\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/pocketbase/dbx\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/spf13/cast\"\n\t\"gopkg.in/yaml.v3\"\n)\ntype config struct {\n\tSystems []systemConfig `yaml:\"systems\"`\n}\ntype systemConfig struct {\n\tName  string   `yaml:\"name\"`\n\tHost  string   `yaml:\"host\"`\n\tPort  uint16   `yaml:\"port,omitempty\"`\n\tToken string   `yaml:\"token,omitempty\"`\n\tUsers []string `yaml:\"users\"`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go", "rel_path": "src/hub/config/config.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 31, "end_line": 162, "text": "// Syncs systems with the config.yml file\nfunc SyncSystems(e *core.ServeEvent) error {\n\th := e.App\n\tconfigPath := filepath.Join(h.DataDir(), \"config.yml\")\n\tconfigData, err := os.ReadFile(configPath)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\tvar config config\n\terr = yaml.Unmarshal(configData, &config)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse config.yml: %v\", err)\n\t}\n\n\tif len(config.Systems) == 0 {\n\t\tlog.Println(\"No systems defined in config.yml.\")\n\t\treturn nil\n\t}\n\n\tvar firstUser *core.Record\n\n\t// Create a map of email to user ID\n\tuserEmailToID := make(map[string]string)\n\tusers, err := h.FindAllRecords(\"users\", dbx.NewExp(\"id != ''\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(users) > 0 {\n\t\tfirstUser = users[0]\n\t\tfor _, user := range users {\n\t\t\tuserEmailToID[user.GetString(\"email\")] = user.Id\n\t\t}\n\t}\n\n\t// add default settings for systems if not defined in config\n\tfor i := range config.Systems {\n\t\tsystem := &config.Systems[i]\n\t\tif system.Port == 0 {\n\t\t\tsystem.Port = 45876\n\t\t}\n\t\tif len(users) > 0 && len(system.Users) == 0 {\n\t\t\t// default to first user if none are defined\n\t\t\tsystem.Users = []string{firstUser.Id}\n\t\t} else {\n\t\t\t// Convert email addresses to user IDs\n\t\t\tuserIDs := make([]string, 0, len(system.Users))\n\t\t\tfor _, email := range system.Users {\n\t\t\t\tif id, ok := userEmailToID[email]; ok {\n\t\t\t\t\tuserIDs = append(userIDs, id)\n\t\t\t\t} else {\n\t\t\t\t\tlog.Printf(\"User %s not found\", email)\n\t\t\t\t}\n\t\t\t}\n\t\t\tsystem.Users = userIDs\n\t\t}\n\t}\n\n\t// Get existing systems\n\texistingSystems, err := h.FindAllRecords(\"systems\", dbx.NewExp(\"id != ''\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create a map of existing systems\n\texistingSystemsMap := make(map[string]*core.Record)\n\tfor _, system := range existingSystems {\n\t\tkey := system.GetString(\"name\") + system.GetString(\"host\") + system.GetString(\"port\")\n\t\texistingSystemsMap[key] = system\n\t}\n\n\t// Process systems from config\n\tfor _, sysConfig := range config.Systems {\n\t\tkey := sysConfig.Name + sysConfig.Host + cast.ToString(sysConfig.Port)\n\t\tif existingSystem, ok := existingSystemsMap[key]; ok {\n\t\t\t// Update existing system\n\t\t\texistingSystem.Set(\"name\", sysConfig.Name)\n\t\t\texistingSystem.Set(\"users\", sysConfig.Users)\n\t\t\texistingSystem.Set(\"port\", sysConfig.Port)\n\t\t\tif err := h.Save(existingSystem); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Only update token if one is specified in config, otherwise preserve existing token\n\t\t\tif sysConfig.Token != \"\" {\n\t\t\t\tif err := updateFingerprintToken(h, existingSystem.Id, sysConfig.Token); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdelete(existingSystemsMap, key)\n\t\t} else {\n\t\t\t// Create new system\n\t\t\tsystemsCollection, err := h.FindCollectionByNameOrId(\"systems\")\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to find systems collection: %v\", err)\n\t\t\t}\n\t\t\tnewSystem := core.NewRecord(systemsCollection)\n\t\t\tnewSystem.Set(\"name\", sysConfig.Name)\n\t\t\tnewSystem.Set(\"host\", sysConfig.Host)\n\t\t\tnewSystem.Set(\"port\", sysConfig.Port)\n\t\t\tnewSystem.Set(\"users\", sysConfig.Users)\n\t\t\tnewSystem.Set(\"info\", system.Info{})\n\t\t\tnewSystem.Set(\"status\", \"pending\")\n\t\t\tif err := h.Save(newSystem); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to create new system: %v\", err)\n\t\t\t}\n\n\t\t\t// For new systems, generate token if not provided\n\t\t\ttoken := sysConfig.Token\n\t\t\tif token == \"\" {\n\t\t\t\ttoken = uuid.New().String()\n\t\t\t}\n\n\t\t\t// Create fingerprint record for new system\n\t\t\tif err := createFingerprintRecord(h, newSystem.Id, token); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\t// Delete systems not in config (and their fingerprint records will cascade delete)\n\tfor _, system := range existingSystemsMap {\n\t\tif err := h.Delete(system); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlog.Println(\"Systems synced with config.yml\")\n\treturn nil\n}\n", "n_tokens": 987, "primary_symbol": "SyncSystems", "primary_kind": "function", "primary_span": [32, 162], "def_symbols": ["SyncSystems"], "symbols": ["SyncSystems", "Syncs", "systems", "with", "the", "config", "yml", "file", "func", "core", "ServeEvent", "error", "App", "configPath", "filepath", "Join", "DataDir", "configData", "err", "ReadFile", "nil", "return", "var", "yaml", "Unmarshal", "fmt", "Errorf", "failed", "parse", "len", "Systems", "log", "Println", "defined", "firstUser", "Record", "Create", "map", "email", "user", "userEmailToID", "make", "string", "users", "FindAllRecords", "dbx", "NewExp", "for", "range", "GetString", "add", "default", "settings", "not", "system", "Port", "Users", "first", "none", "are", "else", "Convert", "addresses", "IDs", "userIDs", "append", "Printf", "User", "found", "Get", "existing", "existingSystems", "existingSystemsMap", "key", "name", "host", "port", "Process", "from", "sysConfig", "Name", "Host", "cast", "ToString", "existingSystem", "Update", "Set", "Save", "Only", "update", "token", "one", "specified", "otherwise", "preserve", "Token", "updateFingerprintToken", "delete", "new", "systemsCollection", "FindCollectionByNameOrId", "find", "collection", "newSystem", "NewRecord", "info", "Info", "status", "pending", "create", "For", "generate", "provided", "uuid", "New", "String", "fingerprint", "record", "createFingerprintRecord", "Delete", "and", "their", "records", "will", "cascade", "synced"], "doc_head": "// Syncs systems with the config.yml file\nfunc SyncSystems(e *core.ServeEvent) error {\n\th := e.App\n\tconfigPath := filepath.Join(h.DataDir(), \"config.yml\")\n\tconfigData, err := os.ReadFile(configPath)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tvar config config\n\terr = yaml.Unmarshal(configData, &config)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse config.yml: %v\", err)\n\t}\n\tif len(config.Systems) == 0 {\n\t\tlog.Println(\"No systems defined in config.yml.\")\n\t\treturn nil\n\t}\n\tvar firstUser *core.Record\n\t// Create a map of email to user ID\n\tuserEmailToID := make(map[string]string)\n\tusers, err := h.FindAllRecords(\"users\", dbx.NewExp(\"id != ''\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(users) > 0 {\n\t\tfirstUser = users[0]\n\t\tfor _, user := range users {\n\t\t\tuserEmailToID[user.GetString(\"email\")] = user.Id\n\t\t}\n\t}\n\t// add default settings for systems if not defined in config\n\tfor i := range config.Systems {\n\t\tsystem := &config.Systems[i]\n\t\tif system.Port == 0 {\n\t\t\tsystem.Port = 45876\n\t\t}\n\t\tif len(users) > 0 && len(system.Users) == 0 {\n\t\t\t// default to first user if none are defined\n\t\t\tsystem.Users = []string{firstUser.Id}\n\t\t} else {\n\t\t\t// Convert email addresses to user IDs\n\t\t\tuserIDs := make([]st"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go", "rel_path": "src/hub/config/config.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 163, "end_line": 185, "text": "// Generates content for the config.yml file as a YAML string\nfunc generateYAML(h core.App) (string, error) {\n\t// Fetch all systems from the database\n\tsystems, err := h.FindRecordsByFilter(\"systems\", \"id != ''\", \"name\", -1, 0)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Create a Config struct to hold the data\n\tconfig := config{\n\t\tSystems: make([]systemConfig, 0, len(systems)),\n\t}\n\n\t// Fetch all users at once\n\tallUserIDs := make([]string, 0)\n\tfor _, system := range systems {\n\t\tallUserIDs = append(allUserIDs, system.GetStringSlice(\"users\")...)\n\t}\n\tuserEmailMap, err := getUserEmailMap(h, allUserIDs)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n", "n_tokens": 180, "primary_symbol": "generateYAML", "primary_kind": "function", "primary_span": [164, 185], "def_symbols": ["generateYAML"], "symbols": ["generateYAML", "Generates", "content", "for", "the", "config", "yml", "file", "YAML", "string", "func", "core", "App", "error", "Fetch", "all", "systems", "from", "database", "err", "FindRecordsByFilter", "name", "nil", "return", "Create", "Config", "struct", "hold", "data", "Systems", "make", "systemConfig", "len", "users", "once", "allUserIDs", "system", "range", "append", "GetStringSlice", "userEmailMap", "getUserEmailMap"], "doc_head": "// Generates content for the config.yml file as a YAML string\nfunc generateYAML(h core.App) (string, error) {\n\t// Fetch all systems from the database\n\tsystems, err := h.FindRecordsByFilter(\"systems\", \"id != ''\", \"name\", -1, 0)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// Create a Config struct to hold the data\n\tconfig := config{\n\t\tSystems: make([]systemConfig, 0, len(systems)),\n\t}\n\t// Fetch all users at once\n\tallUserIDs := make([]string, 0)\n\tfor _, system := range systems {\n\t\tallUserIDs = append(allUserIDs, system.GetStringSlice(\"users\")...)\n\t}\n\tuserEmailMap, err := getUserEmailMap(h, allUserIDs)\n\tif err != nil {\n\t\treturn \"\", err\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go", "rel_path": "src/hub/config/config.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 186, "end_line": 235, "text": "\t// Fetch all fingerprint records to get tokens\n\ttype fingerprintData struct {\n\t\tID     string `db:\"id\"`\n\t\tSystem string `db:\"system\"`\n\t\tToken  string `db:\"token\"`\n\t}\n\tvar fingerprints []fingerprintData\n\terr = h.DB().NewQuery(\"SELECT id, system, token FROM fingerprints\").All(&fingerprints)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Create a map of system ID to token\n\tsystemTokenMap := make(map[string]string)\n\tfor _, fingerprint := range fingerprints {\n\t\tsystemTokenMap[fingerprint.System] = fingerprint.Token\n\t}\n\n\t// Populate the Config struct with system data\n\tfor _, system := range systems {\n\t\tuserIDs := system.GetStringSlice(\"users\")\n\t\tuserEmails := make([]string, 0, len(userIDs))\n\t\tfor _, userID := range userIDs {\n\t\t\tif email, ok := userEmailMap[userID]; ok {\n\t\t\t\tuserEmails = append(userEmails, email)\n\t\t\t}\n\t\t}\n\n\t\tsysConfig := systemConfig{\n\t\t\tName:  system.GetString(\"name\"),\n\t\t\tHost:  system.GetString(\"host\"),\n\t\t\tPort:  cast.ToUint16(system.Get(\"port\")),\n\t\t\tUsers: userEmails,\n\t\t\tToken: systemTokenMap[system.Id],\n\t\t}\n\t\tconfig.Systems = append(config.Systems, sysConfig)\n\t}\n\n\t// Marshal the Config struct to YAML\n\tyamlData, err := yaml.Marshal(&config)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Add a header to the YAML\n\tyamlData = append([]byte(\"# Values for port, users, and token are optional.\\n# Defaults are port 45876, the first created user, and a generated UUID token.\\n\\n\"), yamlData...)\n\n\treturn string(yamlData), nil\n}\n", "n_tokens": 377, "primary_symbol": "", "primary_kind": "", "primary_span": [186, 235], "def_symbols": [], "symbols": ["Fetch", "all", "fingerprint", "records", "get", "tokens", "type", "fingerprintData", "struct", "string", "System", "system", "Token", "token", "var", "fingerprints", "err", "NewQuery", "SELECT", "FROM", "All", "nil", "return", "Create", "map", "systemTokenMap", "make", "for", "range", "Populate", "the", "Config", "with", "data", "systems", "userIDs", "GetStringSlice", "users", "userEmails", "len", "userID", "email", "userEmailMap", "append", "sysConfig", "systemConfig", "Name", "GetString", "name", "Host", "host", "Port", "cast", "ToUint16", "Get", "port", "Users", "config", "Systems", "Marshal", "YAML", "yamlData", "yaml", "Add", "header", "byte", "Values", "and", "are", "optional", "Defaults", "first", "created", "user", "generated", "UUID"], "doc_head": "\t// Fetch all fingerprint records to get tokens\n\ttype fingerprintData struct {\n\t\tID     string `db:\"id\"`\n\t\tSystem string `db:\"system\"`\n\t\tToken  string `db:\"token\"`\n\t}\n\tvar fingerprints []fingerprintData\n\terr = h.DB().NewQuery(\"SELECT id, system, token FROM fingerprints\").All(&fingerprints)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// Create a map of system ID to token\n\tsystemTokenMap := make(map[string]string)\n\tfor _, fingerprint := range fingerprints {\n\t\tsystemTokenMap[fingerprint.System] = fingerprint.Token\n\t}\n\t// Populate the Config struct with system data\n\tfor _, system := range systems {\n\t\tuserIDs := system.GetStringSlice(\"users\")\n\t\tuserEmails := make([]string, 0, len(userIDs))\n\t\tfor _, userID := range userIDs {\n\t\t\tif email, ok := userEmailMap[userID]; ok {\n\t\t\t\tuserEmails = append(userEmails, email)\n\t\t\t}\n\t\t}\n\t\tsysConfig := systemConfig{\n\t\t\tName:  system.GetString(\"name\"),\n\t\t\tHost:  system.GetString(\"host\"),\n\t\t\tPort:  cast.ToUint16(system.Get(\"port\")),\n\t\t\tUsers: userEmails,\n\t\t\tToken: systemTokenMap[system.Id],\n\t\t}\n\t\tconfig.Systems = append(config.Systems, sysConfig)\n\t}\n\t// Marshal the Config struct to YAML\n\tyamlData, err := yaml.Marshal(&config)\n\tif err != nil {\n\t\treturn \"\", err\n\t}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go", "rel_path": "src/hub/config/config.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 236, "end_line": 250, "text": "// New helper function to get a map of user IDs to emails\nfunc getUserEmailMap(h core.App, userIDs []string) (map[string]string, error) {\n\tusers, err := h.FindRecordsByIds(\"users\", userIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuserEmailMap := make(map[string]string, len(users))\n\tfor _, user := range users {\n\t\tuserEmailMap[user.Id] = user.GetString(\"email\")\n\t}\n\n\treturn userEmailMap, nil\n}\n", "n_tokens": 104, "primary_symbol": "getUserEmailMap", "primary_kind": "function", "primary_span": [237, 250], "def_symbols": ["getUserEmailMap"], "symbols": ["getUserEmailMap", "New", "helper", "function", "get", "map", "user", "IDs", "emails", "func", "core", "App", "userIDs", "string", "error", "users", "err", "FindRecordsByIds", "nil", "return", "userEmailMap", "make", "len", "for", "range", "GetString", "email"], "doc_head": "// New helper function to get a map of user IDs to emails\nfunc getUserEmailMap(h core.App, userIDs []string) (map[string]string, error) {\n\tusers, err := h.FindRecordsByIds(\"users\", userIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserEmailMap := make(map[string]string, len(users))\n\tfor _, user := range users {\n\t\tuserEmailMap[user.Id] = user.GetString(\"email\")\n\t}\n\treturn userEmailMap, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go", "rel_path": "src/hub/config/config.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 251, "end_line": 264, "text": "// Helper function to update or create fingerprint token for an existing system\nfunc updateFingerprintToken(app core.App, systemID, token string) error {\n\t// Try to find existing fingerprint record\n\tfingerprint, err := app.FindFirstRecordByFilter(\"fingerprints\", \"system = {:system}\", dbx.Params{\"system\": systemID})\n\tif err != nil {\n\t\t// If no fingerprint record exists, create one\n\t\treturn createFingerprintRecord(app, systemID, token)\n\t}\n\n\t// Update existing fingerprint record with new token (keep existing fingerprint)\n\tfingerprint.Set(\"token\", token)\n\treturn app.Save(fingerprint)\n}\n", "n_tokens": 131, "primary_symbol": "updateFingerprintToken", "primary_kind": "function", "primary_span": [252, 264], "def_symbols": ["updateFingerprintToken"], "symbols": ["updateFingerprintToken", "Helper", "function", "update", "create", "fingerprint", "token", "for", "existing", "system", "func", "app", "core", "App", "systemID", "string", "error", "Try", "find", "record", "err", "FindFirstRecordByFilter", "fingerprints", "dbx", "Params", "nil", "exists", "one", "return", "createFingerprintRecord", "Update", "with", "new", "keep", "Set", "Save"], "doc_head": "// Helper function to update or create fingerprint token for an existing system\nfunc updateFingerprintToken(app core.App, systemID, token string) error {\n\t// Try to find existing fingerprint record\n\tfingerprint, err := app.FindFirstRecordByFilter(\"fingerprints\", \"system = {:system}\", dbx.Params{\"system\": systemID})\n\tif err != nil {\n\t\t// If no fingerprint record exists, create one\n\t\treturn createFingerprintRecord(app, systemID, token)\n\t}\n\t// Update existing fingerprint record with new token (keep existing fingerprint)\n\tfingerprint.Set(\"token\", token)\n\treturn app.Save(fingerprint)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go", "rel_path": "src/hub/config/config.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 265, "end_line": 279, "text": "// Helper function to create a new fingerprint record for a system\nfunc createFingerprintRecord(app core.App, systemID, token string) error {\n\tfingerprintsCollection, err := app.FindCollectionByNameOrId(\"fingerprints\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to find fingerprints collection: %v\", err)\n\t}\n\n\tnewFingerprint := core.NewRecord(fingerprintsCollection)\n\tnewFingerprint.Set(\"system\", systemID)\n\tnewFingerprint.Set(\"token\", token)\n\tnewFingerprint.Set(\"fingerprint\", \"\") // Empty fingerprint, will be set on first connection\n\n\treturn app.Save(newFingerprint)\n}\n", "n_tokens": 129, "primary_symbol": "createFingerprintRecord", "primary_kind": "function", "primary_span": [266, 279], "def_symbols": ["createFingerprintRecord"], "symbols": ["createFingerprintRecord", "Helper", "function", "create", "new", "fingerprint", "record", "for", "system", "func", "app", "core", "App", "systemID", "token", "string", "error", "fingerprintsCollection", "err", "FindCollectionByNameOrId", "fingerprints", "nil", "return", "fmt", "Errorf", "failed", "find", "collection", "newFingerprint", "NewRecord", "Set", "Empty", "will", "set", "first", "connection", "Save"], "doc_head": "// Helper function to create a new fingerprint record for a system\nfunc createFingerprintRecord(app core.App, systemID, token string) error {\n\tfingerprintsCollection, err := app.FindCollectionByNameOrId(\"fingerprints\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to find fingerprints collection: %v\", err)\n\t}\n\tnewFingerprint := core.NewRecord(fingerprintsCollection)\n\tnewFingerprint.Set(\"system\", systemID)\n\tnewFingerprint.Set(\"token\", token)\n\tnewFingerprint.Set(\"fingerprint\", \"\") // Empty fingerprint, will be set on first connection\n\treturn app.Save(newFingerprint)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config.go", "rel_path": "src/hub/config/config.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 280, "end_line": 291, "text": "// Returns the current config.yml file as a JSON object\nfunc GetYamlConfig(e *core.RequestEvent) error {\n\tif e.Auth.GetString(\"role\") != \"admin\" {\n\t\treturn e.ForbiddenError(\"Requires admin role\", nil)\n\t}\n\tconfigContent, err := generateYAML(e.App)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn e.JSON(200, map[string]string{\"config\": configContent})\n}\n", "n_tokens": 90, "primary_symbol": "GetYamlConfig", "primary_kind": "function", "primary_span": [281, 291], "def_symbols": ["GetYamlConfig"], "symbols": ["GetYamlConfig", "Returns", "the", "current", "config", "yml", "file", "JSON", "object", "func", "core", "RequestEvent", "error", "Auth", "GetString", "role", "admin", "return", "ForbiddenError", "Requires", "nil", "configContent", "err", "generateYAML", "App", "map", "string"], "doc_head": "// Returns the current config.yml file as a JSON object\nfunc GetYamlConfig(e *core.RequestEvent) error {\n\tif e.Auth.GetString(\"role\") != \"admin\" {\n\t\treturn e.ForbiddenError(\"Requires admin role\", nil)\n\t}\n\tconfigContent, err := generateYAML(e.App)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn e.JSON(200, map[string]string{\"config\": configContent})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config_test.go", "rel_path": "src/hub/config/config_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 25, "text": "//go:build testing\n// +build testing\n\npackage config_test\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/henrygd/beszel/src/tests\"\n\n\t\"github.com/henrygd/beszel/src/hub/config\"\n\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"gopkg.in/yaml.v3\"\n)\n\n// Config struct for testing (copied from config package since it's not exported)\ntype testConfig struct {\n\tSystems []testSystemConfig `yaml:\"systems\"`\n}\n", "n_tokens": 126, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 25], "def_symbols": [], "symbols": ["build", "testing", "package", "config_test", "import", "path", "filepath", "github", "com", "henrygd", "beszel", "src", "tests", "hub", "config", "pocketbase", "core", "stretchr", "testify", "assert", "require", "gopkg", "yaml", "Config", "struct", "for", "copied", "from", "since", "not", "exported", "type", "testConfig", "Systems", "testSystemConfig", "systems"], "doc_head": "//go:build testing\n// +build testing\npackage config_test\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"github.com/henrygd/beszel/src/tests\"\n\t\"github.com/henrygd/beszel/src/hub/config\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"gopkg.in/yaml.v3\"\n)\n// Config struct for testing (copied from config package since it's not exported)\ntype testConfig struct {\n\tSystems []testSystemConfig `yaml:\"systems\"`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config_test.go", "rel_path": "src/hub/config/config_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 26, "end_line": 50, "text": "type testSystemConfig struct {\n\tName  string   `yaml:\"name\"`\n\tHost  string   `yaml:\"host\"`\n\tPort  uint16   `yaml:\"port,omitempty\"`\n\tUsers []string `yaml:\"users\"`\n\tToken string   `yaml:\"token,omitempty\"`\n}\n\n// Helper function to create a test system for config tests\n// func createConfigTestSystem(app core.App, name, host string, port uint16, userIDs []string) (*core.Record, error) {\n// \tsystemCollection, err := app.FindCollectionByNameOrId(\"systems\")\n// \tif err != nil {\n// \t\treturn nil, err\n// \t}\n\n// \tsystem := core.NewRecord(systemCollection)\n// \tsystem.Set(\"name\", name)\n// \tsystem.Set(\"host\", host)\n// \tsystem.Set(\"port\", port)\n// \tsystem.Set(\"users\", userIDs)\n// \tsystem.Set(\"status\", \"pending\")\n\n// \treturn system, app.Save(system)\n// }\n", "n_tokens": 200, "primary_symbol": "", "primary_kind": "", "primary_span": [26, 50], "def_symbols": [], "symbols": ["type", "testSystemConfig", "struct", "Name", "string", "yaml", "name", "Host", "host", "Port", "uint16", "port", "omitempty", "Users", "users", "Token", "token", "Helper", "function", "create", "test", "system", "for", "config", "tests", "func", "createConfigTestSystem", "app", "core", "App", "userIDs", "Record", "error", "systemCollection", "err", "FindCollectionByNameOrId", "systems", "nil", "return", "NewRecord", "Set", "status", "pending", "Save"], "doc_head": "type testSystemConfig struct {\n\tName  string   `yaml:\"name\"`\n\tHost  string   `yaml:\"host\"`\n\tPort  uint16   `yaml:\"port,omitempty\"`\n\tUsers []string `yaml:\"users\"`\n\tToken string   `yaml:\"token,omitempty\"`\n}\n// Helper function to create a test system for config tests\n// func createConfigTestSystem(app core.App, name, host string, port uint16, userIDs []string) (*core.Record, error) {\n// \tsystemCollection, err := app.FindCollectionByNameOrId(\"systems\")\n// \tif err != nil {\n// \t\treturn nil, err\n// \t}\n// \tsystem := core.NewRecord(systemCollection)\n// \tsystem.Set(\"name\", name)\n// \tsystem.Set(\"host\", host)\n// \tsystem.Set(\"port\", port)\n// \tsystem.Set(\"users\", userIDs)\n// \tsystem.Set(\"status\", \"pending\")\n// \treturn system, app.Save(system)\n// }"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config_test.go", "rel_path": "src/hub/config/config_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 51, "end_line": 75, "text": "// Helper function to create a fingerprint record\nfunc createConfigTestFingerprint(app core.App, systemID, token, fingerprint string) (*core.Record, error) {\n\tfingerprintCollection, err := app.FindCollectionByNameOrId(\"fingerprints\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfp := core.NewRecord(fingerprintCollection)\n\tfp.Set(\"system\", systemID)\n\tfp.Set(\"token\", token)\n\tfp.Set(\"fingerprint\", fingerprint)\n\n\treturn fp, app.Save(fp)\n}\n\n// TestConfigSyncWithTokens tests the config.SyncSystems function with various token scenarios\nfunc TestConfigSyncWithTokens(t *testing.T) {\n\ttestHub, err := tests.NewTestHub()\n\trequire.NoError(t, err)\n\tdefer testHub.Cleanup()\n\n\t// Create test user\n\tuser, err := tests.CreateUser(testHub.App, \"admin@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n", "n_tokens": 187, "primary_symbol": "createConfigTestFingerprint", "primary_kind": "function", "primary_span": [52, 75], "def_symbols": ["createConfigTestFingerprint", "TestConfigSyncWithTokens"], "symbols": ["createConfigTestFingerprint", "TestConfigSyncWithTokens", "Helper", "function", "create", "fingerprint", "record", "func", "app", "core", "App", "systemID", "token", "string", "Record", "error", "fingerprintCollection", "err", "FindCollectionByNameOrId", "fingerprints", "nil", "return", "NewRecord", "Set", "system", "Save", "tests", "the", "config", "SyncSystems", "with", "various", "scenarios", "testing", "testHub", "NewTestHub", "require", "NoError", "defer", "Cleanup", "Create", "test", "user", "CreateUser", "admin", "example", "com", "testtesttest"], "doc_head": "// Helper function to create a fingerprint record\nfunc createConfigTestFingerprint(app core.App, systemID, token, fingerprint string) (*core.Record, error) {\n\tfingerprintCollection, err := app.FindCollectionByNameOrId(\"fingerprints\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfp := core.NewRecord(fingerprintCollection)\n\tfp.Set(\"system\", systemID)\n\tfp.Set(\"token\", token)\n\tfp.Set(\"fingerprint\", fingerprint)\n\treturn fp, app.Save(fp)\n}\n// TestConfigSyncWithTokens tests the config.SyncSystems function with various token scenarios\nfunc TestConfigSyncWithTokens(t *testing.T) {\n\ttestHub, err := tests.NewTestHub()\n\trequire.NoError(t, err)\n\tdefer testHub.Cleanup()\n\t// Create test user\n\tuser, err := tests.CreateUser(testHub.App, \"admin@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config_test.go", "rel_path": "src/hub/config/config_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 76, "end_line": 190, "text": "\ttestCases := []struct {\n\t\tname        string\n\t\tsetupFunc   func() (string, *core.Record, *core.Record) // Returns: existing token, system record, fingerprint record\n\t\tconfigYAML  string\n\t\texpectToken string // Expected token after sync\n\t\tdescription string\n\t}{\n\t\t{\n\t\t\tname: \"new system with token in config\",\n\t\t\tsetupFunc: func() (string, *core.Record, *core.Record) {\n\t\t\t\treturn \"\", nil, nil // No existing system\n\t\t\t},\n\t\t\tconfigYAML: `systems:\n  - name: \"new-server\"\n    host: \"new.example.com\"\n    port: 45876\n    users:\n      - \"admin@example.com\"\n    token: \"explicit-token-123\"`,\n\t\t\texpectToken: \"explicit-token-123\",\n\t\t\tdescription: \"New system should use token from config\",\n\t\t},\n\t\t{\n\t\t\tname: \"existing system without token in config (preserve existing)\",\n\t\t\tsetupFunc: func() (string, *core.Record, *core.Record) {\n\t\t\t\t// Create existing system and fingerprint\n\t\t\t\tsystem, err := tests.CreateRecord(testHub.App, \"systems\", map[string]any{\n\t\t\t\t\t\"name\":  \"preserve-server\",\n\t\t\t\t\t\"host\":  \"preserve.example.com\",\n\t\t\t\t\t\"port\":  45876,\n\t\t\t\t\t\"users\": []string{user.Id},\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tfingerprint, err := createConfigTestFingerprint(testHub.App, system.Id, \"preserve-token-999\", \"preserve-fingerprint\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\treturn \"preserve-token-999\", system, fingerprint\n\t\t\t},\n\t\t\tconfigYAML: `systems:\n  - name: \"preserve-server\"\n    host: \"preserve.example.com\"\n    port: 45876\n    users:\n      - \"admin@example.com\"`,\n\t\t\texpectToken: \"preserve-token-999\",\n\t\t\tdescription: \"Existing system should preserve original token when config doesn't specify one\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Setup test data\n\t\t\t_, existingSystem, existingFingerprint := tc.setupFunc()\n\n\t\t\t// Write config file\n\t\t\tconfigPath := filepath.Join(testHub.DataDir(), \"config.yml\")\n\t\t\terr := os.WriteFile(configPath, []byte(tc.configYAML), 0644)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Create serve event and sync\n\t\t\tevent := &core.ServeEvent{App: testHub.App}\n\t\t\terr = config.SyncSystems(event)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Parse the config to get the system name for verification\n\t\t\tvar configData testConfig\n\t\t\terr = yaml.Unmarshal([]byte(tc.configYAML), &configData)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, configData.Systems, 1)\n\t\t\tsystemName := configData.Systems[0].Name\n\n\t\t\t// Find the system after sync\n\t\t\tsystems, err := testHub.FindRecordsByFilter(\"systems\", \"name = {:name}\", \"\", -1, 0, map[string]any{\"name\": systemName})\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, systems, 1)\n\t\t\tsystem := systems[0]\n\n\t\t\t// Find the fingerprint record\n\t\t\tfingerprints, err := testHub.FindRecordsByFilter(\"fingerprints\", \"system = {:system}\", \"\", -1, 0, map[string]any{\"system\": system.Id})\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, fingerprints, 1)\n\t\t\tfingerprint := fingerprints[0]\n\n\t\t\t// Verify token\n\t\t\tactualToken := fingerprint.GetString(\"token\")\n\t\t\tif tc.expectToken == \"\" {\n\t\t\t\t// For generated tokens, just verify it's not empty and is a valid UUID format\n\t\t\t\tassert.NotEmpty(t, actualToken, tc.description)\n\t\t\t\tassert.Len(t, actualToken, 36, \"Generated token should be UUID format\") // UUID length\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, tc.expectToken, actualToken, tc.description)\n\t\t\t}\n\n\t\t\t// For existing systems, verify fingerprint is preserved\n\t\t\tif existingFingerprint != nil {\n\t\t\t\tactualFingerprint := fingerprint.GetString(\"fingerprint\")\n\t\t\t\texpectedFingerprint := existingFingerprint.GetString(\"fingerprint\")\n\t\t\t\tassert.Equal(t, expectedFingerprint, actualFingerprint, \"Fingerprint should be preserved\")\n\t\t\t}\n\n\t\t\t// Cleanup for next test\n\t\t\tif existingSystem != nil {\n\t\t\t\ttestHub.Delete(existingSystem)\n\t\t\t}\n\t\t\tif existingFingerprint != nil {\n\t\t\t\ttestHub.Delete(existingFingerprint)\n\t\t\t}\n\t\t\t// Clean up the new records\n\t\t\ttestHub.Delete(system)\n\t\t\ttestHub.Delete(fingerprint)\n\t\t})\n\t}\n}\n", "n_tokens": 1008, "primary_symbol": "", "primary_kind": "", "primary_span": [76, 190], "def_symbols": [], "symbols": ["testCases", "struct", "name", "string", "setupFunc", "func", "core", "Record", "Returns", "existing", "token", "system", "record", "fingerprint", "configYAML", "expectToken", "Expected", "after", "sync", "description", "new", "with", "config", "return", "nil", "systems", "server", "host", "example", "com", "port", "users", "admin", "explicit", "New", "should", "use", "from", "without", "preserve", "Create", "and", "err", "tests", "CreateRecord", "testHub", "App", "map", "any", "user", "require", "NoError", "createConfigTestFingerprint", "Existing", "original", "when", "doesn", "specify", "one", "for", "range", "Run", "testing", "Setup", "test", "data", "existingSystem", "existingFingerprint", "Write", "file", "configPath", "filepath", "Join", "DataDir", "yml", "WriteFile", "byte", "serve", "event", "ServeEvent", "SyncSystems", "Parse", "the", "get", "verification", "var", "configData", "testConfig", "yaml", "Unmarshal", "Len", "Systems", "systemName", "Name", "Find", "FindRecordsByFilter", "fingerprints", "Verify", "actualToken", "GetString", "For", "generated", "tokens", "just", "verify", "not", "empty", "valid", "UUID", "format", "assert", "NotEmpty", "Generated", "length", "else", "Equal", "preserved", "actualFingerprint", "expectedFingerprint", "Fingerprint", "Cleanup", "next", "Delete", "Clean", "records"], "doc_head": "\ttestCases := []struct {\n\t\tname        string\n\t\tsetupFunc   func() (string, *core.Record, *core.Record) // Returns: existing token, system record, fingerprint record\n\t\tconfigYAML  string\n\t\texpectToken string // Expected token after sync\n\t\tdescription string\n\t}{\n\t\t{\n\t\t\tname: \"new system with token in config\",\n\t\t\tsetupFunc: func() (string, *core.Record, *core.Record) {\n\t\t\t\treturn \"\", nil, nil // No existing system\n\t\t\t},\n\t\t\tconfigYAML: `systems:\n  - name: \"new-server\"\n    host: \"new.example.com\"\n    port: 45876\n    users:\n      - \"admin@example.com\"\n    token: \"explicit-token-123\"`,\n\t\t\texpectToken: \"explicit-token-123\",\n\t\t\tdescription: \"New system should use token from config\",\n\t\t},\n\t\t{\n\t\t\tname: \"existing system without token in config (preserve existing)\",\n\t\t\tsetupFunc: func() (string, *core.Record, *core.Record) {\n\t\t\t\t// Create existing system and fingerprint\n\t\t\t\tsystem, err := tests.CreateRecord(testHub.App, \"systems\", map[string]any{\n\t\t\t\t\t\"name\":  \"preserve-server\",\n\t\t\t\t\t\"host\":  \"preserve.example.com\",\n\t\t\t\t\t\"port\":  45876,\n\t\t\t\t\t\"users\": []string{user.Id},\n\t\t\t\t})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tfingerprint, err := createConfigTestFingerprint(testHub.App, system.Id, \"preserve-token"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/config/config_test.go", "rel_path": "src/hub/config/config_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 191, "end_line": 248, "text": "// TestConfigMigrationScenario tests the specific migration scenario mentioned in the discussion\nfunc TestConfigMigrationScenario(t *testing.T) {\n\ttestHub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer testHub.Cleanup()\n\n\t// Create test user\n\tuser, err := tests.CreateUser(testHub.App, \"admin@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\n\t// Simulate migration scenario: system exists with token from migration\n\texistingSystem, err := tests.CreateRecord(testHub.App, \"systems\", map[string]any{\n\t\t\"name\":  \"migrated-server\",\n\t\t\"host\":  \"migrated.example.com\",\n\t\t\"port\":  45876,\n\t\t\"users\": []string{user.Id},\n\t})\n\trequire.NoError(t, err)\n\n\tmigrationToken := \"migration-generated-token-123\"\n\texistingFingerprint, err := createConfigTestFingerprint(testHub.App, existingSystem.Id, migrationToken, \"existing-fingerprint-from-agent\")\n\trequire.NoError(t, err)\n\n\t// User exports config BEFORE this update (so no token field in YAML)\n\toldConfigYAML := `systems:\n  - name: \"migrated-server\"\n    host: \"migrated.example.com\"\n    port: 45876\n    users:\n      - \"admin@example.com\"`\n\n\t// Write old config file and import\n\tconfigPath := filepath.Join(testHub.DataDir(), \"config.yml\")\n\terr = os.WriteFile(configPath, []byte(oldConfigYAML), 0644)\n\trequire.NoError(t, err)\n\n\tevent := &core.ServeEvent{App: testHub.App}\n\terr = config.SyncSystems(event)\n\trequire.NoError(t, err)\n\n\t// Verify the original token is preserved\n\tupdatedFingerprint, err := testHub.FindRecordById(\"fingerprints\", existingFingerprint.Id)\n\trequire.NoError(t, err)\n\n\tactualToken := updatedFingerprint.GetString(\"token\")\n\tassert.Equal(t, migrationToken, actualToken, \"Migration token should be preserved when config doesn't specify a token\")\n\n\t// Verify fingerprint is also preserved\n\tactualFingerprint := updatedFingerprint.GetString(\"fingerprint\")\n\tassert.Equal(t, \"existing-fingerprint-from-agent\", actualFingerprint, \"Existing fingerprint should be preserved\")\n\n\t// Verify system still exists and is updated correctly\n\tupdatedSystem, err := testHub.FindRecordById(\"systems\", existingSystem.Id)\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"migrated-server\", updatedSystem.GetString(\"name\"))\n\tassert.Equal(t, \"migrated.example.com\", updatedSystem.GetString(\"host\"))\n}\n", "n_tokens": 529, "primary_symbol": "TestConfigMigrationScenario", "primary_kind": "function", "primary_span": [192, 248], "def_symbols": ["TestConfigMigrationScenario"], "symbols": ["TestConfigMigrationScenario", "tests", "the", "specific", "migration", "scenario", "mentioned", "discussion", "func", "testing", "testHub", "err", "NewTestHub", "TempDir", "require", "NoError", "defer", "Cleanup", "Create", "test", "user", "CreateUser", "App", "admin", "example", "com", "testtesttest", "Simulate", "system", "exists", "with", "token", "from", "existingSystem", "CreateRecord", "systems", "map", "string", "any", "name", "migrated", "server", "host", "port", "users", "migrationToken", "generated", "existingFingerprint", "createConfigTestFingerprint", "existing", "fingerprint", "agent", "User", "exports", "config", "BEFORE", "this", "update", "field", "YAML", "oldConfigYAML", "Write", "old", "file", "and", "import", "configPath", "filepath", "Join", "DataDir", "yml", "WriteFile", "byte", "event", "core", "ServeEvent", "SyncSystems", "Verify", "original", "preserved", "updatedFingerprint", "FindRecordById", "fingerprints", "actualToken", "GetString", "assert", "Equal", "Migration", "should", "when", "doesn", "specify", "also", "actualFingerprint", "Existing", "still", "updated", "correctly", "updatedSystem"], "doc_head": "// TestConfigMigrationScenario tests the specific migration scenario mentioned in the discussion\nfunc TestConfigMigrationScenario(t *testing.T) {\n\ttestHub, err := tests.NewTestHub(t.TempDir())\n\trequire.NoError(t, err)\n\tdefer testHub.Cleanup()\n\t// Create test user\n\tuser, err := tests.CreateUser(testHub.App, \"admin@example.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\t// Simulate migration scenario: system exists with token from migration\n\texistingSystem, err := tests.CreateRecord(testHub.App, \"systems\", map[string]any{\n\t\t\"name\":  \"migrated-server\",\n\t\t\"host\":  \"migrated.example.com\",\n\t\t\"port\":  45876,\n\t\t\"users\": []string{user.Id},\n\t})\n\trequire.NoError(t, err)\n\tmigrationToken := \"migration-generated-token-123\"\n\texistingFingerprint, err := createConfigTestFingerprint(testHub.App, existingSystem.Id, migrationToken, \"existing-fingerprint-from-agent\")\n\trequire.NoError(t, err)\n\t// User exports config BEFORE this update (so no token field in YAML)\n\toldConfigYAML := `systems:\n  - name: \"migrated-server\"\n    host: \"migrated.example.com\"\n    port: 45876\n    users:\n      - \"admin@example.com\"`\n\t// Write old config file and import\n\tconfigPath := filepath.Join(testHub.DataDir(), \"config.yml\")\n\t"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 39, "text": "//go:build testing\n// +build testing\n\npackage expirymap\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// Not using the following methods but are useful for testing\n\n// TESTING: Has checks if a key exists and hasn't expired\nfunc (m *ExpiryMap[T]) Has(key string) bool {\n\t_, ok := m.GetOk(key)\n\treturn ok\n}\n\n// TESTING: Get retrieves a value, returns zero value if not found or expired\nfunc (m *ExpiryMap[T]) Get(key string) T {\n\tvalue, _ := m.GetOk(key)\n\treturn value\n}\n\n// TESTING: Len returns the number of non-expired entries\nfunc (m *ExpiryMap[T]) Len() int {\n\tcount := 0\n\tnow := time.Now()\n\tfor _, val := range m.store.Values() {\n\t\tif val.expires.After(now) {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n", "n_tokens": 206, "primary_symbol": "Has", "primary_kind": "function", "primary_span": [17, 39], "def_symbols": ["Has", "Get", "Len"], "symbols": ["Has", "Get", "Len", "build", "testing", "package", "expirymap", "import", "time", "github", "com", "stretchr", "testify", "assert", "require", "Not", "using", "the", "following", "methods", "but", "are", "useful", "for", "TESTING", "checks", "key", "exists", "and", "hasn", "expired", "func", "ExpiryMap", "string", "bool", "GetOk", "return", "retrieves", "value", "returns", "zero", "not", "found", "number", "non", "entries", "int", "count", "now", "Now", "val", "range", "store", "Values", "expires", "After"], "doc_head": "//go:build testing\n// +build testing\npackage expirymap\nimport (\n\t\"testing\"\n\t\"time\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n// Not using the following methods but are useful for testing\n// TESTING: Has checks if a key exists and hasn't expired\nfunc (m *ExpiryMap[T]) Has(key string) bool {\n\t_, ok := m.GetOk(key)\n\treturn ok\n}\n// TESTING: Get retrieves a value, returns zero value if not found or expired\nfunc (m *ExpiryMap[T]) Get(key string) T {\n\tvalue, _ := m.GetOk(key)\n\treturn value\n}\n// TESTING: Len returns the number of non-expired entries\nfunc (m *ExpiryMap[T]) Len() int {\n\tcount := 0\n\tnow := time.Now()\n\tfor _, val := range m.store.Values() {\n\t\tif val.expires.After(now) {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 40, "end_line": 61, "text": "func TestExpiryMap_BasicOperations(t *testing.T) {\n\tem := New[string](time.Hour)\n\n\t// Test Set and GetOk\n\tem.Set(\"key1\", \"value1\", time.Hour)\n\tvalue, ok := em.GetOk(\"key1\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"value1\", value)\n\n\t// Test Get\n\tvalue = em.Get(\"key1\")\n\tassert.Equal(t, \"value1\", value)\n\n\t// Test Has\n\tassert.True(t, em.Has(\"key1\"))\n\tassert.False(t, em.Has(\"nonexistent\"))\n\n\t// Test Remove\n\tem.Remove(\"key1\")\n\tassert.False(t, em.Has(\"key1\"))\n}\n", "n_tokens": 140, "primary_symbol": "TestExpiryMap_BasicOperations", "primary_kind": "function", "primary_span": [40, 61], "def_symbols": ["TestExpiryMap_BasicOperations"], "symbols": ["TestExpiryMap_BasicOperations", "func", "testing", "New", "string", "time", "Hour", "Test", "Set", "and", "GetOk", "key1", "value1", "value", "assert", "True", "Equal", "Get", "Has", "False", "nonexistent", "Remove"], "doc_head": "func TestExpiryMap_BasicOperations(t *testing.T) {\n\tem := New[string](time.Hour)\n\t// Test Set and GetOk\n\tem.Set(\"key1\", \"value1\", time.Hour)\n\tvalue, ok := em.GetOk(\"key1\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"value1\", value)\n\t// Test Get\n\tvalue = em.Get(\"key1\")\n\tassert.Equal(t, \"value1\", value)\n\t// Test Has\n\tassert.True(t, em.Has(\"key1\"))\n\tassert.False(t, em.Has(\"nonexistent\"))\n\t// Test Remove\n\tem.Remove(\"key1\")\n\tassert.False(t, em.Has(\"key1\"))\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 62, "end_line": 80, "text": "func TestExpiryMap_Expiration(t *testing.T) {\n\tem := New[string](time.Hour)\n\n\t// Set a value with very short TTL\n\tem.Set(\"shortlived\", \"value\", time.Millisecond*10)\n\n\t// Should exist immediately\n\tassert.True(t, em.Has(\"shortlived\"))\n\n\t// Wait for expiration\n\ttime.Sleep(time.Millisecond * 20)\n\n\t// Should be expired and automatically cleaned up on access\n\tassert.False(t, em.Has(\"shortlived\"))\n\tvalue, ok := em.GetOk(\"shortlived\")\n\tassert.False(t, ok)\n\tassert.Equal(t, \"\", value) // zero value for string\n}\n", "n_tokens": 132, "primary_symbol": "TestExpiryMap_Expiration", "primary_kind": "function", "primary_span": [62, 80], "def_symbols": ["TestExpiryMap_Expiration"], "symbols": ["TestExpiryMap_Expiration", "func", "testing", "New", "string", "time", "Hour", "Set", "value", "with", "very", "short", "TTL", "shortlived", "Millisecond", "Should", "exist", "immediately", "assert", "True", "Has", "Wait", "for", "expiration", "Sleep", "expired", "and", "automatically", "cleaned", "access", "False", "GetOk", "Equal", "zero"], "doc_head": "func TestExpiryMap_Expiration(t *testing.T) {\n\tem := New[string](time.Hour)\n\t// Set a value with very short TTL\n\tem.Set(\"shortlived\", \"value\", time.Millisecond*10)\n\t// Should exist immediately\n\tassert.True(t, em.Has(\"shortlived\"))\n\t// Wait for expiration\n\ttime.Sleep(time.Millisecond * 20)\n\t// Should be expired and automatically cleaned up on access\n\tassert.False(t, em.Has(\"shortlived\"))\n\tvalue, ok := em.GetOk(\"shortlived\")\n\tassert.False(t, ok)\n\tassert.Equal(t, \"\", value) // zero value for string\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 81, "end_line": 101, "text": "func TestExpiryMap_LazyCleanup(t *testing.T) {\n\tem := New[int](time.Hour)\n\n\t// Set multiple values with short TTL\n\tem.Set(\"key1\", 1, time.Millisecond*10)\n\tem.Set(\"key2\", 2, time.Millisecond*10)\n\tem.Set(\"key3\", 3, time.Hour) // This one won't expire\n\n\t// Wait for expiration\n\ttime.Sleep(time.Millisecond * 20)\n\n\t// Access expired keys should trigger lazy cleanup\n\t_, ok := em.GetOk(\"key1\")\n\tassert.False(t, ok)\n\n\t// Non-expired key should still exist\n\tvalue, ok := em.GetOk(\"key3\")\n\tassert.True(t, ok)\n\tassert.Equal(t, 3, value)\n}\n", "n_tokens": 156, "primary_symbol": "TestExpiryMap_LazyCleanup", "primary_kind": "function", "primary_span": [81, 101], "def_symbols": ["TestExpiryMap_LazyCleanup"], "symbols": ["TestExpiryMap_LazyCleanup", "func", "testing", "New", "int", "time", "Hour", "Set", "multiple", "values", "with", "short", "TTL", "key1", "Millisecond", "key2", "key3", "This", "one", "won", "expire", "Wait", "for", "expiration", "Sleep", "Access", "expired", "keys", "should", "trigger", "lazy", "cleanup", "GetOk", "assert", "False", "Non", "key", "still", "exist", "value", "True", "Equal"], "doc_head": "func TestExpiryMap_LazyCleanup(t *testing.T) {\n\tem := New[int](time.Hour)\n\t// Set multiple values with short TTL\n\tem.Set(\"key1\", 1, time.Millisecond*10)\n\tem.Set(\"key2\", 2, time.Millisecond*10)\n\tem.Set(\"key3\", 3, time.Hour) // This one won't expire\n\t// Wait for expiration\n\ttime.Sleep(time.Millisecond * 20)\n\t// Access expired keys should trigger lazy cleanup\n\t_, ok := em.GetOk(\"key1\")\n\tassert.False(t, ok)\n\t// Non-expired key should still exist\n\tvalue, ok := em.GetOk(\"key3\")\n\tassert.True(t, ok)\n\tassert.Equal(t, 3, value)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 102, "end_line": 122, "text": "func TestExpiryMap_Len(t *testing.T) {\n\tem := New[string](time.Hour)\n\n\t// Initially empty\n\tassert.Equal(t, 0, em.Len())\n\n\t// Add some values\n\tem.Set(\"key1\", \"value1\", time.Hour)\n\tem.Set(\"key2\", \"value2\", time.Hour)\n\tem.Set(\"key3\", \"value3\", time.Millisecond*10) // Will expire soon\n\n\t// Should count all initially\n\tassert.Equal(t, 3, em.Len())\n\n\t// Wait for one to expire\n\ttime.Sleep(time.Millisecond * 20)\n\n\t// Len should reflect only non-expired entries\n\tassert.Equal(t, 2, em.Len())\n}\n", "n_tokens": 143, "primary_symbol": "TestExpiryMap_Len", "primary_kind": "function", "primary_span": [102, 122], "def_symbols": ["TestExpiryMap_Len"], "symbols": ["TestExpiryMap_Len", "func", "testing", "New", "string", "time", "Hour", "Initially", "empty", "assert", "Equal", "Len", "Add", "some", "values", "Set", "key1", "value1", "key2", "value2", "key3", "value3", "Millisecond", "Will", "expire", "soon", "Should", "count", "all", "initially", "Wait", "for", "one", "Sleep", "should", "reflect", "only", "non", "expired", "entries"], "doc_head": "func TestExpiryMap_Len(t *testing.T) {\n\tem := New[string](time.Hour)\n\t// Initially empty\n\tassert.Equal(t, 0, em.Len())\n\t// Add some values\n\tem.Set(\"key1\", \"value1\", time.Hour)\n\tem.Set(\"key2\", \"value2\", time.Hour)\n\tem.Set(\"key3\", \"value3\", time.Millisecond*10) // Will expire soon\n\t// Should count all initially\n\tassert.Equal(t, 3, em.Len())\n\t// Wait for one to expire\n\ttime.Sleep(time.Millisecond * 20)\n\t// Len should reflect only non-expired entries\n\tassert.Equal(t, 2, em.Len())\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 123, "end_line": 140, "text": "func TestExpiryMap_CustomInterval(t *testing.T) {\n\t// Create with very short cleanup interval for testing\n\tem := New[string](time.Millisecond * 50)\n\n\t// Set a value that expires quickly\n\tem.Set(\"test\", \"value\", time.Millisecond*10)\n\n\t// Should exist initially\n\tassert.True(t, em.Has(\"test\"))\n\n\t// Wait for expiration + cleanup cycle\n\ttime.Sleep(time.Millisecond * 100)\n\n\t// Should be cleaned up by background process\n\t// Note: This test might be flaky due to timing, but demonstrates the concept\n\tassert.False(t, em.Has(\"test\"))\n}\n", "n_tokens": 128, "primary_symbol": "TestExpiryMap_CustomInterval", "primary_kind": "function", "primary_span": [123, 140], "def_symbols": ["TestExpiryMap_CustomInterval"], "symbols": ["TestExpiryMap_CustomInterval", "func", "testing", "Create", "with", "very", "short", "cleanup", "interval", "for", "New", "string", "time", "Millisecond", "Set", "value", "that", "expires", "quickly", "test", "Should", "exist", "initially", "assert", "True", "Has", "Wait", "expiration", "cycle", "Sleep", "cleaned", "background", "process", "Note", "This", "might", "flaky", "due", "timing", "but", "demonstrates", "the", "concept", "False"], "doc_head": "func TestExpiryMap_CustomInterval(t *testing.T) {\n\t// Create with very short cleanup interval for testing\n\tem := New[string](time.Millisecond * 50)\n\t// Set a value that expires quickly\n\tem.Set(\"test\", \"value\", time.Millisecond*10)\n\t// Should exist initially\n\tassert.True(t, em.Has(\"test\"))\n\t// Wait for expiration + cleanup cycle\n\ttime.Sleep(time.Millisecond * 100)\n\t// Should be cleaned up by background process\n\t// Note: This test might be flaky due to timing, but demonstrates the concept\n\tassert.False(t, em.Has(\"test\"))\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 141, "end_line": 152, "text": "func TestExpiryMap_GenericTypes(t *testing.T) {\n\t// Test with different types\n\tt.Run(\"Int\", func(t *testing.T) {\n\t\tem := New[int](time.Hour)\n\n\t\tem.Set(\"num\", 42, time.Hour)\n\t\tvalue, ok := em.GetOk(\"num\")\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, 42, value)\n\t})\n\n\tt.Run(\"Struct\", func(t *testing.T) {", "n_tokens": 95, "primary_symbol": "TestExpiryMap_GenericTypes", "primary_kind": "function", "primary_span": [141, 152], "def_symbols": ["TestExpiryMap_GenericTypes"], "symbols": ["TestExpiryMap_GenericTypes", "func", "testing", "Test", "with", "different", "types", "Run", "Int", "New", "int", "time", "Hour", "Set", "num", "value", "GetOk", "assert", "True", "Equal", "Struct"], "doc_head": "func TestExpiryMap_GenericTypes(t *testing.T) {\n\t// Test with different types\n\tt.Run(\"Int\", func(t *testing.T) {\n\t\tem := New[int](time.Hour)\n\t\tem.Set(\"num\", 42, time.Hour)\n\t\tvalue, ok := em.GetOk(\"num\")\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, 42, value)\n\t})\n\tt.Run(\"Struct\", func(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 153, "end_line": 180, "text": "\t\ttype TestStruct struct {\n\t\t\tName string\n\t\t\tAge  int\n\t\t}\n\n\t\tem := New[TestStruct](time.Hour)\n\n\t\texpected := TestStruct{Name: \"John\", Age: 30}\n\t\tem.Set(\"person\", expected, time.Hour)\n\n\t\tvalue, ok := em.GetOk(\"person\")\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, expected, value)\n\t})\n\n\tt.Run(\"Pointer\", func(t *testing.T) {\n\t\tem := New[*string](time.Hour)\n\n\t\tstr := \"hello\"\n\t\tem.Set(\"ptr\", &str, time.Hour)\n\n\t\tvalue, ok := em.GetOk(\"ptr\")\n\t\tassert.True(t, ok)\n\t\trequire.NotNil(t, value)\n\t\tassert.Equal(t, \"hello\", *value)\n\t})\n}\n", "n_tokens": 163, "primary_symbol": "", "primary_kind": "", "primary_span": [153, 180], "def_symbols": [], "symbols": ["type", "TestStruct", "struct", "Name", "string", "Age", "int", "New", "time", "Hour", "expected", "John", "Set", "person", "value", "GetOk", "assert", "True", "Equal", "Run", "Pointer", "func", "testing", "str", "hello", "ptr", "require", "NotNil"], "doc_head": "\t\ttype TestStruct struct {\n\t\t\tName string\n\t\t\tAge  int\n\t\t}\n\t\tem := New[TestStruct](time.Hour)\n\t\texpected := TestStruct{Name: \"John\", Age: 30}\n\t\tem.Set(\"person\", expected, time.Hour)\n\t\tvalue, ok := em.GetOk(\"person\")\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, expected, value)\n\t})\n\tt.Run(\"Pointer\", func(t *testing.T) {\n\t\tem := New[*string](time.Hour)\n\t\tstr := \"hello\"\n\t\tem.Set(\"ptr\", &str, time.Hour)\n\t\tvalue, ok := em.GetOk(\"ptr\")\n\t\tassert.True(t, ok)\n\t\trequire.NotNil(t, value)\n\t\tassert.Equal(t, \"hello\", *value)\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 181, "end_line": 195, "text": "func TestExpiryMap_ZeroValues(t *testing.T) {\n\tem := New[string](time.Hour)\n\n\t// Test getting non-existent key returns zero value\n\tvalue := em.Get(\"nonexistent\")\n\tassert.Equal(t, \"\", value)\n\n\t// Test getting expired key returns zero value\n\tem.Set(\"expired\", \"value\", time.Millisecond*10)\n\ttime.Sleep(time.Millisecond * 20)\n\n\tvalue = em.Get(\"expired\")\n\tassert.Equal(t, \"\", value)\n}\n", "n_tokens": 93, "primary_symbol": "TestExpiryMap_ZeroValues", "primary_kind": "function", "primary_span": [181, 195], "def_symbols": ["TestExpiryMap_ZeroValues"], "symbols": ["TestExpiryMap_ZeroValues", "func", "testing", "New", "string", "time", "Hour", "Test", "getting", "non", "existent", "key", "returns", "zero", "value", "Get", "nonexistent", "assert", "Equal", "expired", "Set", "Millisecond", "Sleep"], "doc_head": "func TestExpiryMap_ZeroValues(t *testing.T) {\n\tem := New[string](time.Hour)\n\t// Test getting non-existent key returns zero value\n\tvalue := em.Get(\"nonexistent\")\n\tassert.Equal(t, \"\", value)\n\t// Test getting expired key returns zero value\n\tem.Set(\"expired\", \"value\", time.Millisecond*10)\n\ttime.Sleep(time.Millisecond * 20)\n\tvalue = em.Get(\"expired\")\n\tassert.Equal(t, \"\", value)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 196, "end_line": 227, "text": "func TestExpiryMap_Concurrent(t *testing.T) {\n\tem := New[int](time.Hour)\n\n\t// Simple concurrent access test\n\tdone := make(chan bool, 2)\n\n\t// Writer goroutine\n\tgo func() {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tem.Set(\"key\", i, time.Hour)\n\t\t\ttime.Sleep(time.Microsecond)\n\t\t}\n\t\tdone <- true\n\t}()\n\n\t// Reader goroutine\n\tgo func() {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\t_ = em.Get(\"key\")\n\t\t\ttime.Sleep(time.Microsecond)\n\t\t}\n\t\tdone <- true\n\t}()\n\n\t// Wait for both to complete\n\t<-done\n\t<-done\n\n\t// Should not panic and should have some value\n\tassert.True(t, em.Has(\"key\"))\n}\n", "n_tokens": 180, "primary_symbol": "TestExpiryMap_Concurrent", "primary_kind": "function", "primary_span": [196, 227], "def_symbols": ["TestExpiryMap_Concurrent"], "symbols": ["TestExpiryMap_Concurrent", "func", "testing", "New", "int", "time", "Hour", "Simple", "concurrent", "access", "test", "done", "make", "chan", "bool", "Writer", "goroutine", "for", "Set", "key", "Sleep", "Microsecond", "true", "Reader", "Get", "Wait", "both", "complete", "Should", "not", "panic", "and", "should", "have", "some", "value", "assert", "True", "Has"], "doc_head": "func TestExpiryMap_Concurrent(t *testing.T) {\n\tem := New[int](time.Hour)\n\t// Simple concurrent access test\n\tdone := make(chan bool, 2)\n\t// Writer goroutine\n\tgo func() {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tem.Set(\"key\", i, time.Hour)\n\t\t\ttime.Sleep(time.Microsecond)\n\t\t}\n\t\tdone <- true\n\t}()\n\t// Reader goroutine\n\tgo func() {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\t_ = em.Get(\"key\")\n\t\t\ttime.Sleep(time.Microsecond)\n\t\t}\n\t\tdone <- true\n\t}()\n\t// Wait for both to complete\n\t<-done\n\t<-done\n\t// Should not panic and should have some value\n\tassert.True(t, em.Has(\"key\"))\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 228, "end_line": 254, "text": "func TestExpiryMap_GetByValue(t *testing.T) {\n\tem := New[string](time.Hour)\n\n\t// Test getting by value when value exists\n\tem.Set(\"key1\", \"value1\", time.Hour)\n\tem.Set(\"key2\", \"value2\", time.Hour)\n\tem.Set(\"key3\", \"value1\", time.Hour) // Duplicate value - should return first match\n\n\t// Test successful retrieval\n\tkey, value, ok := em.GetByValue(\"value1\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"value1\", value)\n\tassert.Contains(t, []string{\"key1\", \"key3\"}, key) // Should be one of the keys with this value\n\n\t// Test retrieval of unique value\n\tkey, value, ok = em.GetByValue(\"value2\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"value2\", value)\n\tassert.Equal(t, \"key2\", key)\n\n\t// Test getting non-existent value\n\tkey, value, ok = em.GetByValue(\"nonexistent\")\n\tassert.False(t, ok)\n\tassert.Equal(t, \"\", value) // zero value for string\n\tassert.Equal(t, \"\", key)   // zero value for string\n}\n", "n_tokens": 247, "primary_symbol": "TestExpiryMap_GetByValue", "primary_kind": "function", "primary_span": [228, 254], "def_symbols": ["TestExpiryMap_GetByValue"], "symbols": ["TestExpiryMap_GetByValue", "func", "testing", "New", "string", "time", "Hour", "Test", "getting", "value", "when", "exists", "Set", "key1", "value1", "key2", "value2", "key3", "Duplicate", "should", "return", "first", "match", "successful", "retrieval", "key", "GetByValue", "assert", "True", "Equal", "Contains", "Should", "one", "the", "keys", "with", "this", "unique", "non", "existent", "nonexistent", "False", "zero", "for"], "doc_head": "func TestExpiryMap_GetByValue(t *testing.T) {\n\tem := New[string](time.Hour)\n\t// Test getting by value when value exists\n\tem.Set(\"key1\", \"value1\", time.Hour)\n\tem.Set(\"key2\", \"value2\", time.Hour)\n\tem.Set(\"key3\", \"value1\", time.Hour) // Duplicate value - should return first match\n\t// Test successful retrieval\n\tkey, value, ok := em.GetByValue(\"value1\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"value1\", value)\n\tassert.Contains(t, []string{\"key1\", \"key3\"}, key) // Should be one of the keys with this value\n\t// Test retrieval of unique value\n\tkey, value, ok = em.GetByValue(\"value2\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"value2\", value)\n\tassert.Equal(t, \"key2\", key)\n\t// Test getting non-existent value\n\tkey, value, ok = em.GetByValue(\"nonexistent\")\n\tassert.False(t, ok)\n\tassert.Equal(t, \"\", value) // zero value for string\n\tassert.Equal(t, \"\", key)   // zero value for string\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 255, "end_line": 283, "text": "func TestExpiryMap_GetByValue_Expiration(t *testing.T) {\n\tem := New[string](time.Hour)\n\n\t// Set a value with short TTL\n\tem.Set(\"shortkey\", \"shortvalue\", time.Millisecond*10)\n\tem.Set(\"longkey\", \"longvalue\", time.Hour)\n\n\t// Should find the short-lived value initially\n\tkey, value, ok := em.GetByValue(\"shortvalue\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"shortvalue\", value)\n\tassert.Equal(t, \"shortkey\", key)\n\n\t// Wait for expiration\n\ttime.Sleep(time.Millisecond * 20)\n\n\t// Should not find expired value and should trigger lazy cleanup\n\tkey, value, ok = em.GetByValue(\"shortvalue\")\n\tassert.False(t, ok)\n\tassert.Equal(t, \"\", value)\n\tassert.Equal(t, \"\", key)\n\n\t// Should still find non-expired value\n\tkey, value, ok = em.GetByValue(\"longvalue\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"longvalue\", value)\n\tassert.Equal(t, \"longkey\", key)\n}\n", "n_tokens": 223, "primary_symbol": "TestExpiryMap_GetByValue_Expiration", "primary_kind": "function", "primary_span": [255, 283], "def_symbols": ["TestExpiryMap_GetByValue_Expiration"], "symbols": ["TestExpiryMap_GetByValue_Expiration", "func", "testing", "New", "string", "time", "Hour", "Set", "value", "with", "short", "TTL", "shortkey", "shortvalue", "Millisecond", "longkey", "longvalue", "Should", "find", "the", "lived", "initially", "key", "GetByValue", "assert", "True", "Equal", "Wait", "for", "expiration", "Sleep", "not", "expired", "and", "should", "trigger", "lazy", "cleanup", "False", "still", "non"], "doc_head": "func TestExpiryMap_GetByValue_Expiration(t *testing.T) {\n\tem := New[string](time.Hour)\n\t// Set a value with short TTL\n\tem.Set(\"shortkey\", \"shortvalue\", time.Millisecond*10)\n\tem.Set(\"longkey\", \"longvalue\", time.Hour)\n\t// Should find the short-lived value initially\n\tkey, value, ok := em.GetByValue(\"shortvalue\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"shortvalue\", value)\n\tassert.Equal(t, \"shortkey\", key)\n\t// Wait for expiration\n\ttime.Sleep(time.Millisecond * 20)\n\t// Should not find expired value and should trigger lazy cleanup\n\tkey, value, ok = em.GetByValue(\"shortvalue\")\n\tassert.False(t, ok)\n\tassert.Equal(t, \"\", value)\n\tassert.Equal(t, \"\", key)\n\t// Should still find non-expired value\n\tkey, value, ok = em.GetByValue(\"longvalue\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"longvalue\", value)\n\tassert.Equal(t, \"longkey\", key)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 13, "start_line": 284, "end_line": 302, "text": "func TestExpiryMap_GetByValue_GenericTypes(t *testing.T) {\n\tt.Run(\"Int\", func(t *testing.T) {\n\t\tem := New[int](time.Hour)\n\n\t\tem.Set(\"num1\", 42, time.Hour)\n\t\tem.Set(\"num2\", 84, time.Hour)\n\n\t\tkey, value, ok := em.GetByValue(42)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, 42, value)\n\t\tassert.Equal(t, \"num1\", key)\n\n\t\tkey, value, ok = em.GetByValue(99)\n\t\tassert.False(t, ok)\n\t\tassert.Equal(t, 0, value)\n\t\tassert.Equal(t, \"\", key)\n\t})\n\n\tt.Run(\"Struct\", func(t *testing.T) {", "n_tokens": 158, "primary_symbol": "TestExpiryMap_GetByValue_GenericTypes", "primary_kind": "function", "primary_span": [284, 302], "def_symbols": ["TestExpiryMap_GetByValue_GenericTypes"], "symbols": ["TestExpiryMap_GetByValue_GenericTypes", "func", "testing", "Run", "Int", "New", "int", "time", "Hour", "Set", "num1", "num2", "key", "value", "GetByValue", "assert", "True", "Equal", "False", "Struct"], "doc_head": "func TestExpiryMap_GetByValue_GenericTypes(t *testing.T) {\n\tt.Run(\"Int\", func(t *testing.T) {\n\t\tem := New[int](time.Hour)\n\t\tem.Set(\"num1\", 42, time.Hour)\n\t\tem.Set(\"num2\", 84, time.Hour)\n\t\tkey, value, ok := em.GetByValue(42)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, 42, value)\n\t\tassert.Equal(t, \"num1\", key)\n\t\tkey, value, ok = em.GetByValue(99)\n\t\tassert.False(t, ok)\n\t\tassert.Equal(t, 0, value)\n\t\tassert.Equal(t, \"\", key)\n\t})\n\tt.Run(\"Struct\", func(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 14, "start_line": 303, "end_line": 328, "text": "\t\ttype TestStruct struct {\n\t\t\tName string\n\t\t\tAge  int\n\t\t}\n\n\t\tem := New[TestStruct](time.Hour)\n\n\t\tperson1 := TestStruct{Name: \"John\", Age: 30}\n\t\tperson2 := TestStruct{Name: \"Jane\", Age: 25}\n\n\t\tem.Set(\"person1\", person1, time.Hour)\n\t\tem.Set(\"person2\", person2, time.Hour)\n\n\t\tkey, value, ok := em.GetByValue(person1)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, person1, value)\n\t\tassert.Equal(t, \"person1\", key)\n\n\t\tnonexistent := TestStruct{Name: \"Bob\", Age: 40}\n\t\tkey, value, ok = em.GetByValue(nonexistent)\n\t\tassert.False(t, ok)\n\t\tassert.Equal(t, TestStruct{}, value)\n\t\tassert.Equal(t, \"\", key)\n\t})\n}\n", "n_tokens": 188, "primary_symbol": "", "primary_kind": "", "primary_span": [303, 328], "def_symbols": [], "symbols": ["type", "TestStruct", "struct", "Name", "string", "Age", "int", "New", "time", "Hour", "person1", "John", "person2", "Jane", "Set", "key", "value", "GetByValue", "assert", "True", "Equal", "nonexistent", "Bob", "False"], "doc_head": "\t\ttype TestStruct struct {\n\t\t\tName string\n\t\t\tAge  int\n\t\t}\n\t\tem := New[TestStruct](time.Hour)\n\t\tperson1 := TestStruct{Name: \"John\", Age: 30}\n\t\tperson2 := TestStruct{Name: \"Jane\", Age: 25}\n\t\tem.Set(\"person1\", person1, time.Hour)\n\t\tem.Set(\"person2\", person2, time.Hour)\n\t\tkey, value, ok := em.GetByValue(person1)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, person1, value)\n\t\tassert.Equal(t, \"person1\", key)\n\t\tnonexistent := TestStruct{Name: \"Bob\", Age: 40}\n\t\tkey, value, ok = em.GetByValue(nonexistent)\n\t\tassert.False(t, ok)\n\t\tassert.Equal(t, TestStruct{}, value)\n\t\tassert.Equal(t, \"\", key)\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 15, "start_line": 329, "end_line": 357, "text": "func TestExpiryMap_RemoveValue(t *testing.T) {\n\tem := New[string](time.Hour)\n\n\t// Test removing existing value\n\tem.Set(\"key1\", \"value1\", time.Hour)\n\tem.Set(\"key2\", \"value2\", time.Hour)\n\tem.Set(\"key3\", \"value1\", time.Hour) // Duplicate value\n\n\t// Remove by value should remove one instance\n\tremovedValue, ok := em.RemovebyValue(\"value1\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"value1\", removedValue)\n\n\t// Should still have the other instance or value2\n\tassert.True(t, em.Has(\"key2\")) // value2 should still exist\n\n\t// Check if one of the duplicate values was removed\n\t// At least one key with \"value1\" should be gone\n\tkey1Exists := em.Has(\"key1\")\n\tkey3Exists := em.Has(\"key3\")\n\tassert.False(t, key1Exists && key3Exists) // Both shouldn't exist\n\tassert.True(t, key1Exists || key3Exists)  // At least one should be gone\n\n\t// Test removing non-existent value\n\tremovedValue, ok = em.RemovebyValue(\"nonexistent\")\n\tassert.False(t, ok)\n\tassert.Equal(t, \"\", removedValue) // zero value for string\n}\n", "n_tokens": 270, "primary_symbol": "TestExpiryMap_RemoveValue", "primary_kind": "function", "primary_span": [329, 357], "def_symbols": ["TestExpiryMap_RemoveValue"], "symbols": ["TestExpiryMap_RemoveValue", "func", "testing", "New", "string", "time", "Hour", "Test", "removing", "existing", "value", "Set", "key1", "value1", "key2", "value2", "key3", "Duplicate", "Remove", "should", "remove", "one", "instance", "removedValue", "RemovebyValue", "assert", "True", "Equal", "Should", "still", "have", "the", "other", "Has", "exist", "Check", "duplicate", "values", "was", "removed", "least", "key", "with", "gone", "key1Exists", "key3Exists", "False", "Both", "shouldn", "non", "existent", "nonexistent", "zero", "for"], "doc_head": "func TestExpiryMap_RemoveValue(t *testing.T) {\n\tem := New[string](time.Hour)\n\t// Test removing existing value\n\tem.Set(\"key1\", \"value1\", time.Hour)\n\tem.Set(\"key2\", \"value2\", time.Hour)\n\tem.Set(\"key3\", \"value1\", time.Hour) // Duplicate value\n\t// Remove by value should remove one instance\n\tremovedValue, ok := em.RemovebyValue(\"value1\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"value1\", removedValue)\n\t// Should still have the other instance or value2\n\tassert.True(t, em.Has(\"key2\")) // value2 should still exist\n\t// Check if one of the duplicate values was removed\n\t// At least one key with \"value1\" should be gone\n\tkey1Exists := em.Has(\"key1\")\n\tkey3Exists := em.Has(\"key3\")\n\tassert.False(t, key1Exists && key3Exists) // Both shouldn't exist\n\tassert.True(t, key1Exists || key3Exists)  // At least one should be gone\n\t// Test removing non-existent value\n\tremovedValue, ok = em.RemovebyValue(\"nonexistent\")\n\tassert.False(t, ok)\n\tassert.Equal(t, \"\", removedValue) // zero value for string\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#16", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 16, "start_line": 358, "end_line": 378, "text": "func TestExpiryMap_RemoveValue_GenericTypes(t *testing.T) {\n\tt.Run(\"Int\", func(t *testing.T) {\n\t\tem := New[int](time.Hour)\n\n\t\tem.Set(\"num1\", 42, time.Hour)\n\t\tem.Set(\"num2\", 84, time.Hour)\n\n\t\t// Remove existing value\n\t\tremovedValue, ok := em.RemovebyValue(42)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, 42, removedValue)\n\t\tassert.False(t, em.Has(\"num1\"))\n\t\tassert.True(t, em.Has(\"num2\"))\n\n\t\t// Remove non-existent value\n\t\tremovedValue, ok = em.RemovebyValue(99)\n\t\tassert.False(t, ok)\n\t\tassert.Equal(t, 0, removedValue)\n\t})\n\n\tt.Run(\"Struct\", func(t *testing.T) {", "n_tokens": 177, "primary_symbol": "TestExpiryMap_RemoveValue_GenericTypes", "primary_kind": "function", "primary_span": [358, 378], "def_symbols": ["TestExpiryMap_RemoveValue_GenericTypes"], "symbols": ["TestExpiryMap_RemoveValue_GenericTypes", "func", "testing", "Run", "Int", "New", "int", "time", "Hour", "Set", "num1", "num2", "Remove", "existing", "value", "removedValue", "RemovebyValue", "assert", "True", "Equal", "False", "Has", "non", "existent", "Struct"], "doc_head": "func TestExpiryMap_RemoveValue_GenericTypes(t *testing.T) {\n\tt.Run(\"Int\", func(t *testing.T) {\n\t\tem := New[int](time.Hour)\n\t\tem.Set(\"num1\", 42, time.Hour)\n\t\tem.Set(\"num2\", 84, time.Hour)\n\t\t// Remove existing value\n\t\tremovedValue, ok := em.RemovebyValue(42)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, 42, removedValue)\n\t\tassert.False(t, em.Has(\"num1\"))\n\t\tassert.True(t, em.Has(\"num2\"))\n\t\t// Remove non-existent value\n\t\tremovedValue, ok = em.RemovebyValue(99)\n\t\tassert.False(t, ok)\n\t\tassert.Equal(t, 0, removedValue)\n\t})\n\tt.Run(\"Struct\", func(t *testing.T) {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#17", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 17, "start_line": 379, "end_line": 406, "text": "\t\ttype TestStruct struct {\n\t\t\tName string\n\t\t\tAge  int\n\t\t}\n\n\t\tem := New[TestStruct](time.Hour)\n\n\t\tperson1 := TestStruct{Name: \"John\", Age: 30}\n\t\tperson2 := TestStruct{Name: \"Jane\", Age: 25}\n\n\t\tem.Set(\"person1\", person1, time.Hour)\n\t\tem.Set(\"person2\", person2, time.Hour)\n\n\t\t// Remove existing struct\n\t\tremovedValue, ok := em.RemovebyValue(person1)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, person1, removedValue)\n\t\tassert.False(t, em.Has(\"person1\"))\n\t\tassert.True(t, em.Has(\"person2\"))\n\n\t\t// Remove non-existent struct\n\t\tnonexistent := TestStruct{Name: \"Bob\", Age: 40}\n\t\tremovedValue, ok = em.RemovebyValue(nonexistent)\n\t\tassert.False(t, ok)\n\t\tassert.Equal(t, TestStruct{}, removedValue)\n\t})\n}\n", "n_tokens": 208, "primary_symbol": "", "primary_kind": "", "primary_span": [379, 406], "def_symbols": [], "symbols": ["type", "TestStruct", "struct", "Name", "string", "Age", "int", "New", "time", "Hour", "person1", "John", "person2", "Jane", "Set", "Remove", "existing", "removedValue", "RemovebyValue", "assert", "True", "Equal", "False", "Has", "non", "existent", "nonexistent", "Bob"], "doc_head": "\t\ttype TestStruct struct {\n\t\t\tName string\n\t\t\tAge  int\n\t\t}\n\t\tem := New[TestStruct](time.Hour)\n\t\tperson1 := TestStruct{Name: \"John\", Age: 30}\n\t\tperson2 := TestStruct{Name: \"Jane\", Age: 25}\n\t\tem.Set(\"person1\", person1, time.Hour)\n\t\tem.Set(\"person2\", person2, time.Hour)\n\t\t// Remove existing struct\n\t\tremovedValue, ok := em.RemovebyValue(person1)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, person1, removedValue)\n\t\tassert.False(t, em.Has(\"person1\"))\n\t\tassert.True(t, em.Has(\"person2\"))\n\t\t// Remove non-existent struct\n\t\tnonexistent := TestStruct{Name: \"Bob\", Age: 40}\n\t\tremovedValue, ok = em.RemovebyValue(nonexistent)\n\t\tassert.False(t, ok)\n\t\tassert.Equal(t, TestStruct{}, removedValue)\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#18", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 18, "start_line": 407, "end_line": 435, "text": "func TestExpiryMap_RemoveValue_WithExpiration(t *testing.T) {\n\tem := New[string](time.Hour)\n\n\t// Set values with different TTLs\n\tem.Set(\"key1\", \"value1\", time.Millisecond*10) // Will expire\n\tem.Set(\"key2\", \"value2\", time.Hour)           // Won't expire\n\tem.Set(\"key3\", \"value1\", time.Hour)           // Won't expire, duplicate value\n\n\t// Wait for first value to expire\n\ttime.Sleep(time.Millisecond * 20)\n\n\t// Try to remove the expired value - should remove one of the \"value1\" entries\n\tremovedValue, ok := em.RemovebyValue(\"value1\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"value1\", removedValue)\n\n\t// Should still have key2 (different value)\n\tassert.True(t, em.Has(\"key2\"))\n\n\t// Should have removed one of the \"value1\" entries (either key1 or key3)\n\t// But we can't predict which one due to map iteration order\n\tkey1Exists := em.Has(\"key1\")\n\tkey3Exists := em.Has(\"key3\")\n\n\t// Exactly one of key1 or key3 should be gone\n\tassert.False(t, key1Exists && key3Exists) // Both shouldn't exist\n\tassert.True(t, key1Exists || key3Exists)  // At least one should still exist\n}\n", "n_tokens": 292, "primary_symbol": "TestExpiryMap_RemoveValue_WithExpiration", "primary_kind": "function", "primary_span": [407, 435], "def_symbols": ["TestExpiryMap_RemoveValue_WithExpiration"], "symbols": ["TestExpiryMap_RemoveValue_WithExpiration", "func", "testing", "New", "string", "time", "Hour", "Set", "values", "with", "different", "TTLs", "key1", "value1", "Millisecond", "Will", "expire", "key2", "value2", "Won", "key3", "duplicate", "value", "Wait", "for", "first", "Sleep", "Try", "remove", "the", "expired", "should", "one", "entries", "removedValue", "RemovebyValue", "assert", "True", "Equal", "Should", "still", "have", "Has", "removed", "either", "But", "can", "predict", "which", "due", "map", "iteration", "order", "key1Exists", "key3Exists", "Exactly", "gone", "False", "Both", "shouldn", "exist", "least"], "doc_head": "func TestExpiryMap_RemoveValue_WithExpiration(t *testing.T) {\n\tem := New[string](time.Hour)\n\t// Set values with different TTLs\n\tem.Set(\"key1\", \"value1\", time.Millisecond*10) // Will expire\n\tem.Set(\"key2\", \"value2\", time.Hour)           // Won't expire\n\tem.Set(\"key3\", \"value1\", time.Hour)           // Won't expire, duplicate value\n\t// Wait for first value to expire\n\ttime.Sleep(time.Millisecond * 20)\n\t// Try to remove the expired value - should remove one of the \"value1\" entries\n\tremovedValue, ok := em.RemovebyValue(\"value1\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"value1\", removedValue)\n\t// Should still have key2 (different value)\n\tassert.True(t, em.Has(\"key2\"))\n\t// Should have removed one of the \"value1\" entries (either key1 or key3)\n\t// But we can't predict which one due to map iteration order\n\tkey1Exists := em.Has(\"key1\")\n\tkey3Exists := em.Has(\"key3\")\n\t// Exactly one of key1 or key3 should be gone\n\tassert.False(t, key1Exists && key3Exists) // Both shouldn't exist\n\tassert.True(t, key1Exists || key3Exists)  // At least one should still exist\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go#19", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap_test.go", "rel_path": "src/hub/expirymap/expirymap_test.go", "ext": "go", "language": "go", "chunk_number": 19, "start_line": 436, "end_line": 478, "text": "func TestExpiryMap_ValueOperations_Integration(t *testing.T) {\n\tem := New[string](time.Hour)\n\n\t// Test integration of GetByValue and RemoveValue\n\tem.Set(\"key1\", \"shared\", time.Hour)\n\tem.Set(\"key2\", \"unique\", time.Hour)\n\tem.Set(\"key3\", \"shared\", time.Hour)\n\n\t// Find shared value\n\tkey, value, ok := em.GetByValue(\"shared\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"shared\", value)\n\tassert.Contains(t, []string{\"key1\", \"key3\"}, key)\n\n\t// Remove shared value\n\tremovedValue, ok := em.RemovebyValue(\"shared\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"shared\", removedValue)\n\n\t// Should still be able to find the other shared value\n\tkey, value, ok = em.GetByValue(\"shared\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"shared\", value)\n\tassert.Contains(t, []string{\"key1\", \"key3\"}, key)\n\n\t// Remove the other shared value\n\tremovedValue, ok = em.RemovebyValue(\"shared\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"shared\", removedValue)\n\n\t// Should not find shared value anymore\n\tkey, value, ok = em.GetByValue(\"shared\")\n\tassert.False(t, ok)\n\tassert.Equal(t, \"\", value)\n\tassert.Equal(t, \"\", key)\n\n\t// Unique value should still exist\n\tkey, value, ok = em.GetByValue(\"unique\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"unique\", value)\n\tassert.Equal(t, \"key2\", key)\n}\n", "n_tokens": 339, "primary_symbol": "TestExpiryMap_ValueOperations_Integration", "primary_kind": "function", "primary_span": [436, 478], "def_symbols": ["TestExpiryMap_ValueOperations_Integration"], "symbols": ["TestExpiryMap_ValueOperations_Integration", "func", "testing", "New", "string", "time", "Hour", "Test", "integration", "GetByValue", "and", "RemoveValue", "Set", "key1", "shared", "key2", "unique", "key3", "Find", "value", "key", "assert", "True", "Equal", "Contains", "Remove", "removedValue", "RemovebyValue", "Should", "still", "able", "find", "the", "other", "not", "anymore", "False", "Unique", "should", "exist"], "doc_head": "func TestExpiryMap_ValueOperations_Integration(t *testing.T) {\n\tem := New[string](time.Hour)\n\t// Test integration of GetByValue and RemoveValue\n\tem.Set(\"key1\", \"shared\", time.Hour)\n\tem.Set(\"key2\", \"unique\", time.Hour)\n\tem.Set(\"key3\", \"shared\", time.Hour)\n\t// Find shared value\n\tkey, value, ok := em.GetByValue(\"shared\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"shared\", value)\n\tassert.Contains(t, []string{\"key1\", \"key3\"}, key)\n\t// Remove shared value\n\tremovedValue, ok := em.RemovebyValue(\"shared\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"shared\", removedValue)\n\t// Should still be able to find the other shared value\n\tkey, value, ok = em.GetByValue(\"shared\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"shared\", value)\n\tassert.Contains(t, []string{\"key1\", \"key3\"}, key)\n\t// Remove the other shared value\n\tremovedValue, ok = em.RemovebyValue(\"shared\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"shared\", removedValue)\n\t// Should not find shared value anymore\n\tkey, value, ok = em.GetByValue(\"shared\")\n\tassert.False(t, ok)\n\tassert.Equal(t, \"\", value)\n\tassert.Equal(t, \"\", key)\n\t// Unique value should still exist\n\tkey, value, ok = em.GetByValue(\"unique\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"unique\", value)\n\tassert"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap.go", "rel_path": "src/hub/expirymap/expirymap.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 37, "text": "package expirymap\n\nimport (\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/pocketbase/pocketbase/tools/store\"\n)\n\ntype val[T any] struct {\n\tvalue   T\n\texpires time.Time\n}\n\ntype ExpiryMap[T any] struct {\n\tstore           *store.Store[string, *val[T]]\n\tcleanupInterval time.Duration\n}\n\n// New creates a new expiry map with custom cleanup interval\nfunc New[T any](cleanupInterval time.Duration) *ExpiryMap[T] {\n\tm := &ExpiryMap[T]{\n\t\tstore:           store.New(map[string]*val[T]{}),\n\t\tcleanupInterval: cleanupInterval,\n\t}\n\tm.startCleaner()\n\treturn m\n}\n\n// Set stores a value with the given TTL\nfunc (m *ExpiryMap[T]) Set(key string, value T, ttl time.Duration) {\n\tm.store.Set(key, &val[T]{\n\t\tvalue:   value,\n\t\texpires: time.Now().Add(ttl),\n\t})\n}\n", "n_tokens": 204, "primary_symbol": "Set", "primary_kind": "function", "primary_span": [31, 37], "def_symbols": ["Set"], "symbols": ["Set", "package", "expirymap", "import", "reflect", "time", "github", "com", "pocketbase", "tools", "store", "type", "val", "any", "struct", "value", "expires", "Time", "ExpiryMap", "Store", "string", "cleanupInterval", "Duration", "New", "creates", "new", "expiry", "map", "with", "custom", "cleanup", "interval", "func", "startCleaner", "return", "stores", "the", "given", "TTL", "key", "ttl", "Now", "Add"], "doc_head": "package expirymap\nimport (\n\t\"reflect\"\n\t\"time\"\n\t\"github.com/pocketbase/pocketbase/tools/store\"\n)\ntype val[T any] struct {\n\tvalue   T\n\texpires time.Time\n}\ntype ExpiryMap[T any] struct {\n\tstore           *store.Store[string, *val[T]]\n\tcleanupInterval time.Duration\n}\n// New creates a new expiry map with custom cleanup interval\nfunc New[T any](cleanupInterval time.Duration) *ExpiryMap[T] {\n\tm := &ExpiryMap[T]{\n\t\tstore:           store.New(map[string]*val[T]{}),\n\t\tcleanupInterval: cleanupInterval,\n\t}\n\tm.startCleaner()\n\treturn m\n}\n// Set stores a value with the given TTL\nfunc (m *ExpiryMap[T]) Set(key string, value T, ttl time.Duration) {\n\tm.store.Set(key, &val[T]{\n\t\tvalue:   value,\n\t\texpires: time.Now().Add(ttl),\n\t})\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap.go", "rel_path": "src/hub/expirymap/expirymap.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 38, "end_line": 54, "text": "// GetOk retrieves a value and checks if it exists and hasn't expired\n// Performs lazy cleanup of expired entries on access\nfunc (m *ExpiryMap[T]) GetOk(key string) (T, bool) {\n\tvalue, ok := m.store.GetOk(key)\n\tif !ok {\n\t\treturn *new(T), false\n\t}\n\n\t// Check if expired and perform lazy cleanup\n\tif value.expires.Before(time.Now()) {\n\t\tm.store.Remove(key)\n\t\treturn *new(T), false\n\t}\n\n\treturn value.value, true\n}\n", "n_tokens": 111, "primary_symbol": "GetOk", "primary_kind": "function", "primary_span": [40, 54], "def_symbols": ["GetOk"], "symbols": ["GetOk", "retrieves", "value", "and", "checks", "exists", "hasn", "expired", "Performs", "lazy", "cleanup", "entries", "access", "func", "ExpiryMap", "key", "string", "bool", "store", "return", "new", "false", "Check", "perform", "expires", "Before", "time", "Now", "Remove", "true"], "doc_head": "// GetOk retrieves a value and checks if it exists and hasn't expired\n// Performs lazy cleanup of expired entries on access\nfunc (m *ExpiryMap[T]) GetOk(key string) (T, bool) {\n\tvalue, ok := m.store.GetOk(key)\n\tif !ok {\n\t\treturn *new(T), false\n\t}\n\t// Check if expired and perform lazy cleanup\n\tif value.expires.Before(time.Now()) {\n\t\tm.store.Remove(key)\n\t\treturn *new(T), false\n\t}\n\treturn value.value, true\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap.go", "rel_path": "src/hub/expirymap/expirymap.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 55, "end_line": 74, "text": "// GetByValue retrieves a value by value\nfunc (m *ExpiryMap[T]) GetByValue(val T) (key string, value T, ok bool) {\n\tfor key, v := range m.store.GetAll() {\n\t\tif reflect.DeepEqual(v.value, val) {\n\t\t\t// check if expired\n\t\t\tif v.expires.Before(time.Now()) {\n\t\t\t\tm.store.Remove(key)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn key, v.value, true\n\t\t}\n\t}\n\treturn \"\", *new(T), false\n}\n\n// Remove explicitly removes a key\nfunc (m *ExpiryMap[T]) Remove(key string) {\n\tm.store.Remove(key)\n}\n", "n_tokens": 135, "primary_symbol": "GetByValue", "primary_kind": "function", "primary_span": [56, 74], "def_symbols": ["GetByValue", "Remove"], "symbols": ["GetByValue", "Remove", "retrieves", "value", "func", "ExpiryMap", "val", "key", "string", "bool", "for", "range", "store", "GetAll", "reflect", "DeepEqual", "check", "expired", "expires", "Before", "time", "Now", "break", "return", "true", "new", "false", "explicitly", "removes"], "doc_head": "// GetByValue retrieves a value by value\nfunc (m *ExpiryMap[T]) GetByValue(val T) (key string, value T, ok bool) {\n\tfor key, v := range m.store.GetAll() {\n\t\tif reflect.DeepEqual(v.value, val) {\n\t\t\t// check if expired\n\t\t\tif v.expires.Before(time.Now()) {\n\t\t\t\tm.store.Remove(key)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn key, v.value, true\n\t\t}\n\t}\n\treturn \"\", *new(T), false\n}\n// Remove explicitly removes a key\nfunc (m *ExpiryMap[T]) Remove(key string) {\n\tm.store.Remove(key)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/expirymap/expirymap.go", "rel_path": "src/hub/expirymap/expirymap.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 75, "end_line": 105, "text": "// RemovebyValue removes a value by value\nfunc (m *ExpiryMap[T]) RemovebyValue(value T) (T, bool) {\n\tfor key, val := range m.store.GetAll() {\n\t\tif reflect.DeepEqual(val.value, value) {\n\t\t\tm.store.Remove(key)\n\t\t\treturn val.value, true\n\t\t}\n\t}\n\treturn *new(T), false\n}\n\n// startCleaner runs the background cleanup process\nfunc (m *ExpiryMap[T]) startCleaner() {\n\tgo func() {\n\t\ttick := time.Tick(m.cleanupInterval)\n\t\tfor range tick {\n\t\t\tm.cleanup()\n\t\t}\n\t}()\n}\n\n// cleanup removes all expired entries\nfunc (m *ExpiryMap[T]) cleanup() {\n\tnow := time.Now()\n\tfor key, val := range m.store.GetAll() {\n\t\tif val.expires.Before(now) {\n\t\t\tm.store.Remove(key)\n\t\t}\n\t}\n}\n", "n_tokens": 186, "primary_symbol": "RemovebyValue", "primary_kind": "function", "primary_span": [76, 105], "def_symbols": ["RemovebyValue", "startCleaner", "cleanup"], "symbols": ["RemovebyValue", "startCleaner", "cleanup", "removes", "value", "func", "ExpiryMap", "bool", "for", "key", "val", "range", "store", "GetAll", "reflect", "DeepEqual", "Remove", "return", "true", "new", "false", "runs", "the", "background", "process", "tick", "time", "Tick", "cleanupInterval", "all", "expired", "entries", "now", "Now", "expires", "Before"], "doc_head": "// RemovebyValue removes a value by value\nfunc (m *ExpiryMap[T]) RemovebyValue(value T) (T, bool) {\n\tfor key, val := range m.store.GetAll() {\n\t\tif reflect.DeepEqual(val.value, value) {\n\t\t\tm.store.Remove(key)\n\t\t\treturn val.value, true\n\t\t}\n\t}\n\treturn *new(T), false\n}\n// startCleaner runs the background cleanup process\nfunc (m *ExpiryMap[T]) startCleaner() {\n\tgo func() {\n\t\ttick := time.Tick(m.cleanupInterval)\n\t\tfor range tick {\n\t\t\tm.cleanup()\n\t\t}\n\t}()\n}\n// cleanup removes all expired entries\nfunc (m *ExpiryMap[T]) cleanup() {\n\tnow := time.Now()\n\tfor key, val := range m.store.GetAll() {\n\t\tif val.expires.Before(now) {\n\t\t\tm.store.Remove(key)\n\t\t}\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 24, "text": "package systems\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/hub/ws\"\n\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/henrygd/beszel\"\n\n\t\"github.com/blang/semver\"\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"golang.org/x/crypto/ssh\"\n)\n", "n_tokens": 113, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 24], "def_symbols": [], "symbols": ["package", "systems", "import", "context", "encoding", "json", "errors", "fmt", "math", "rand", "net", "strings", "time", "github", "com", "henrygd", "beszel", "src", "hub", "entities", "system", "blang", "semver", "fxamacker", "cbor", "pocketbase", "core", "golang", "org", "crypto", "ssh"], "doc_head": "package systems\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/hub/ws\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/blang/semver\"\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"golang.org/x/crypto/ssh\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 25, "end_line": 48, "text": "type System struct {\n\tId           string               `db:\"id\"`\n\tHost         string               `db:\"host\"`\n\tPort         string               `db:\"port\"`\n\tStatus       string               `db:\"status\"`\n\tmanager      *SystemManager       // Manager that this system belongs to\n\tclient       *ssh.Client          // SSH client for fetching data\n\tdata         *system.CombinedData // system data from agent\n\tctx          context.Context      // Context for stopping the updater\n\tcancel       context.CancelFunc   // Stops and removes system from updater\n\tWsConn       *ws.WsConn           // Handler for agent WebSocket connection\n\tagentVersion semver.Version       // Agent version\n\tupdateTicker *time.Ticker         // Ticker for updating the system\n}\n\nfunc (sm *SystemManager) NewSystem(systemId string) *System {\n\tsystem := &System{\n\t\tId:   systemId,\n\t\tdata: &system.CombinedData{},\n\t}\n\tsystem.ctx, system.cancel = system.getContext()\n\treturn system\n}\n", "n_tokens": 205, "primary_symbol": "NewSystem", "primary_kind": "function", "primary_span": [40, 48], "def_symbols": ["NewSystem"], "symbols": ["NewSystem", "type", "System", "struct", "string", "Host", "host", "Port", "port", "Status", "status", "manager", "SystemManager", "Manager", "that", "this", "system", "belongs", "client", "ssh", "Client", "SSH", "for", "fetching", "data", "CombinedData", "from", "agent", "ctx", "context", "Context", "stopping", "the", "updater", "cancel", "CancelFunc", "Stops", "and", "removes", "WsConn", "Handler", "WebSocket", "connection", "agentVersion", "semver", "Version", "Agent", "version", "updateTicker", "time", "Ticker", "updating", "func", "systemId", "getContext", "return"], "doc_head": "type System struct {\n\tId           string               `db:\"id\"`\n\tHost         string               `db:\"host\"`\n\tPort         string               `db:\"port\"`\n\tStatus       string               `db:\"status\"`\n\tmanager      *SystemManager       // Manager that this system belongs to\n\tclient       *ssh.Client          // SSH client for fetching data\n\tdata         *system.CombinedData // system data from agent\n\tctx          context.Context      // Context for stopping the updater\n\tcancel       context.CancelFunc   // Stops and removes system from updater\n\tWsConn       *ws.WsConn           // Handler for agent WebSocket connection\n\tagentVersion semver.Version       // Agent version\n\tupdateTicker *time.Ticker         // Ticker for updating the system\n}\nfunc (sm *SystemManager) NewSystem(systemId string) *System {\n\tsystem := &System{\n\t\tId:   systemId,\n\t\tdata: &system.CombinedData{},\n\t}\n\tsystem.ctx, system.cancel = system.getContext()\n\treturn system\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 49, "end_line": 52, "text": "// StartUpdater starts the system updater.\n// It first fetches the data from the agent then updates the records.\n// If the data is not found or the system is down, it sets the system down.\nfunc (sys *System) StartUpdater() {", "n_tokens": 52, "primary_symbol": "StartUpdater", "primary_kind": "function", "primary_span": [52, 52], "def_symbols": ["StartUpdater"], "symbols": ["StartUpdater", "starts", "the", "system", "updater", "first", "fetches", "data", "from", "agent", "then", "updates", "records", "not", "found", "down", "sets", "func", "sys", "System"], "doc_head": "// StartUpdater starts the system updater.\n// It first fetches the data from the agent then updates the records.\n// If the data is not found or the system is down, it sets the system down.\nfunc (sys *System) StartUpdater() {"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 53, "end_line": 103, "text": "\t// Channel that can be used to set the system down. Currently only used to\n\t// allow a short delay for reconnection after websocket connection is closed.\n\tvar downChan chan struct{}\n\n\t// Add random jitter to first WebSocket connection to prevent\n\t// clustering if all agents are started at the same time.\n\t// SSH connections during hub startup are already staggered.\n\tvar jitter <-chan time.Time\n\tif sys.WsConn != nil {\n\t\tjitter = getJitter()\n\t\t// use the websocket connection's down channel to set the system down\n\t\tdownChan = sys.WsConn.DownChan\n\t} else {\n\t\t// if the system does not have a websocket connection, wait before updating\n\t\t// to allow the agent to connect via websocket (makes sure fingerprint is set).\n\t\ttime.Sleep(11 * time.Second)\n\t}\n\n\t// update immediately if system is not paused (only for ws connections)\n\t// we'll wait a minute before connecting via SSH to prioritize ws connections\n\tif sys.Status != paused && sys.ctx.Err() == nil {\n\t\tif err := sys.update(); err != nil {\n\t\t\t_ = sys.setDown(err)\n\t\t}\n\t}\n\n\tsys.updateTicker = time.NewTicker(time.Duration(interval) * time.Millisecond)\n\t// Go 1.23+ will automatically stop the ticker when the system is garbage collected, however we seem to need this or testing/synctest will block even if calling runtime.GC()\n\tdefer sys.updateTicker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-sys.ctx.Done():\n\t\t\treturn\n\t\tcase <-sys.updateTicker.C:\n\t\t\tif err := sys.update(); err != nil {\n\t\t\t\t_ = sys.setDown(err)\n\t\t\t}\n\t\tcase <-downChan:\n\t\t\tsys.WsConn = nil\n\t\t\tdownChan = nil\n\t\t\t_ = sys.setDown(nil)\n\t\tcase <-jitter:\n\t\t\tsys.updateTicker.Reset(time.Duration(interval) * time.Millisecond)\n\t\t\tif err := sys.update(); err != nil {\n\t\t\t\t_ = sys.setDown(err)\n\t\t\t}\n\t\t}\n\t}\n}\n", "n_tokens": 431, "primary_symbol": "", "primary_kind": "", "primary_span": [53, 103], "def_symbols": [], "symbols": ["Channel", "that", "can", "used", "set", "the", "system", "down", "Currently", "only", "allow", "short", "delay", "for", "reconnection", "after", "websocket", "connection", "closed", "var", "downChan", "chan", "struct", "Add", "random", "jitter", "first", "WebSocket", "prevent", "clustering", "all", "agents", "are", "started", "same", "time", "SSH", "connections", "during", "hub", "startup", "already", "staggered", "Time", "sys", "WsConn", "nil", "getJitter", "use", "channel", "DownChan", "else", "does", "not", "have", "wait", "before", "updating", "agent", "connect", "via", "makes", "sure", "fingerprint", "Sleep", "Second", "update", "immediately", "paused", "minute", "connecting", "prioritize", "Status", "ctx", "Err", "err", "setDown", "updateTicker", "NewTicker", "Duration", "interval", "Millisecond", "will", "automatically", "stop", "ticker", "when", "garbage", "collected", "however", "seem", "need", "this", "testing", "synctest", "block", "even", "calling", "runtime", "defer", "Stop", "select", "case", "Done", "return", "Reset"], "doc_head": "\t// Channel that can be used to set the system down. Currently only used to\n\t// allow a short delay for reconnection after websocket connection is closed.\n\tvar downChan chan struct{}\n\t// Add random jitter to first WebSocket connection to prevent\n\t// clustering if all agents are started at the same time.\n\t// SSH connections during hub startup are already staggered.\n\tvar jitter <-chan time.Time\n\tif sys.WsConn != nil {\n\t\tjitter = getJitter()\n\t\t// use the websocket connection's down channel to set the system down\n\t\tdownChan = sys.WsConn.DownChan\n\t} else {\n\t\t// if the system does not have a websocket connection, wait before updating\n\t\t// to allow the agent to connect via websocket (makes sure fingerprint is set).\n\t\ttime.Sleep(11 * time.Second)\n\t}\n\t// update immediately if system is not paused (only for ws connections)\n\t// we'll wait a minute before connecting via SSH to prioritize ws connections\n\tif sys.Status != paused && sys.ctx.Err() == nil {\n\t\tif err := sys.update(); err != nil {\n\t\t\t_ = sys.setDown(err)\n\t\t}\n\t}\n\tsys.updateTicker = time.NewTicker(time.Duration(interval) * time.Millisecond)\n\t// Go 1.23+ will automatically stop the ticker when the system is garbage collected, however we"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 104, "end_line": 129, "text": "// update updates the system data and records.\nfunc (sys *System) update() error {\n\tif sys.Status == paused {\n\t\tsys.handlePaused()\n\t\treturn nil\n\t}\n\tdata, err := sys.fetchDataFromAgent()\n\tif err == nil {\n\t\t_, err = sys.createRecords(data)\n\t}\n\treturn err\n}\n\nfunc (sys *System) handlePaused() {\n\tif sys.WsConn == nil {\n\t\t// if the system is paused and there's no websocket connection, remove the system\n\t\t_ = sys.manager.RemoveSystem(sys.Id)\n\t} else {\n\t\t// Send a ping to the agent to keep the connection alive if the system is paused\n\t\tif err := sys.WsConn.Ping(); err != nil {\n\t\t\tsys.manager.hub.Logger().Warn(\"Failed to ping agent\", \"system\", sys.Id, \"err\", err)\n\t\t\t_ = sys.manager.RemoveSystem(sys.Id)\n\t\t}\n\t}\n}\n", "n_tokens": 196, "primary_symbol": "update", "primary_kind": "function", "primary_span": [105, 129], "def_symbols": ["update", "handlePaused"], "symbols": ["update", "handlePaused", "updates", "the", "system", "data", "and", "records", "func", "sys", "System", "error", "Status", "paused", "return", "nil", "err", "fetchDataFromAgent", "createRecords", "WsConn", "there", "websocket", "connection", "remove", "manager", "RemoveSystem", "else", "Send", "ping", "agent", "keep", "alive", "Ping", "hub", "Logger", "Warn", "Failed"], "doc_head": "// update updates the system data and records.\nfunc (sys *System) update() error {\n\tif sys.Status == paused {\n\t\tsys.handlePaused()\n\t\treturn nil\n\t}\n\tdata, err := sys.fetchDataFromAgent()\n\tif err == nil {\n\t\t_, err = sys.createRecords(data)\n\t}\n\treturn err\n}\nfunc (sys *System) handlePaused() {\n\tif sys.WsConn == nil {\n\t\t// if the system is paused and there's no websocket connection, remove the system\n\t\t_ = sys.manager.RemoveSystem(sys.Id)\n\t} else {\n\t\t// Send a ping to the agent to keep the connection alive if the system is paused\n\t\tif err := sys.WsConn.Ping(); err != nil {\n\t\t\tsys.manager.hub.Logger().Warn(\"Failed to ping agent\", \"system\", sys.Id, \"err\", err)\n\t\t\t_ = sys.manager.RemoveSystem(sys.Id)\n\t\t}\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 130, "end_line": 173, "text": "// createRecords updates the system record and adds system_stats and container_stats records\nfunc (sys *System) createRecords(data *system.CombinedData) (*core.Record, error) {\n\tsystemRecord, err := sys.getRecord()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thub := sys.manager.hub\n\t// add system_stats and container_stats records\n\tsystemStatsCollection, err := hub.FindCachedCollectionByNameOrId(\"system_stats\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsystemStatsRecord := core.NewRecord(systemStatsCollection)\n\tsystemStatsRecord.Set(\"system\", systemRecord.Id)\n\tsystemStatsRecord.Set(\"stats\", data.Stats)\n\tsystemStatsRecord.Set(\"type\", \"1m\")\n\tif err := hub.SaveNoValidate(systemStatsRecord); err != nil {\n\t\treturn nil, err\n\t}\n\t// add new container_stats record\n\tif len(data.Containers) > 0 {\n\t\tcontainerStatsCollection, err := hub.FindCachedCollectionByNameOrId(\"container_stats\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcontainerStatsRecord := core.NewRecord(containerStatsCollection)\n\t\tcontainerStatsRecord.Set(\"system\", systemRecord.Id)\n\t\tcontainerStatsRecord.Set(\"stats\", data.Containers)\n\t\tcontainerStatsRecord.Set(\"type\", \"1m\")\n\t\tif err := hub.SaveNoValidate(containerStatsRecord); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// update system record (do this last because it triggers alerts and we need above records to be inserted first)\n\tsystemRecord.Set(\"status\", up)\n\n\tsystemRecord.Set(\"info\", data.Info)\n\tif err := hub.SaveNoValidate(systemRecord); err != nil {\n\t\treturn nil, err\n\t}\n\treturn systemRecord, nil\n}\n", "n_tokens": 371, "primary_symbol": "createRecords", "primary_kind": "function", "primary_span": [131, 173], "def_symbols": ["createRecords"], "symbols": ["createRecords", "updates", "the", "system", "record", "and", "adds", "system_stats", "container_stats", "records", "func", "sys", "System", "data", "CombinedData", "core", "Record", "error", "systemRecord", "err", "getRecord", "nil", "return", "hub", "manager", "add", "systemStatsCollection", "FindCachedCollectionByNameOrId", "systemStatsRecord", "NewRecord", "Set", "stats", "Stats", "type", "SaveNoValidate", "new", "len", "Containers", "containerStatsCollection", "containerStatsRecord", "update", "this", "last", "because", "triggers", "alerts", "need", "above", "inserted", "first", "status", "info", "Info"], "doc_head": "// createRecords updates the system record and adds system_stats and container_stats records\nfunc (sys *System) createRecords(data *system.CombinedData) (*core.Record, error) {\n\tsystemRecord, err := sys.getRecord()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thub := sys.manager.hub\n\t// add system_stats and container_stats records\n\tsystemStatsCollection, err := hub.FindCachedCollectionByNameOrId(\"system_stats\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsystemStatsRecord := core.NewRecord(systemStatsCollection)\n\tsystemStatsRecord.Set(\"system\", systemRecord.Id)\n\tsystemStatsRecord.Set(\"stats\", data.Stats)\n\tsystemStatsRecord.Set(\"type\", \"1m\")\n\tif err := hub.SaveNoValidate(systemStatsRecord); err != nil {\n\t\treturn nil, err\n\t}\n\t// add new container_stats record\n\tif len(data.Containers) > 0 {\n\t\tcontainerStatsCollection, err := hub.FindCachedCollectionByNameOrId(\"container_stats\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcontainerStatsRecord := core.NewRecord(containerStatsCollection)\n\t\tcontainerStatsRecord.Set(\"system\", systemRecord.Id)\n\t\tcontainerStatsRecord.Set(\"stats\", data.Containers)\n\t\tcontainerStatsRecord.Set(\"type\", \"1m\")\n\t\tif err := hub.SaveNoValidate(containerStatsRecord); err != nil {\n\t"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 174, "end_line": 184, "text": "// getRecord retrieves the system record from the database.\n// If the record is not found, it removes the system from the manager.\nfunc (sys *System) getRecord() (*core.Record, error) {\n\trecord, err := sys.manager.hub.FindRecordById(\"systems\", sys.Id)\n\tif err != nil || record == nil {\n\t\t_ = sys.manager.RemoveSystem(sys.Id)\n\t\treturn nil, err\n\t}\n\treturn record, nil\n}\n", "n_tokens": 94, "primary_symbol": "getRecord", "primary_kind": "function", "primary_span": [176, 184], "def_symbols": ["getRecord"], "symbols": ["getRecord", "retrieves", "the", "system", "record", "from", "database", "not", "found", "removes", "manager", "func", "sys", "System", "core", "Record", "error", "err", "hub", "FindRecordById", "systems", "nil", "RemoveSystem", "return"], "doc_head": "// getRecord retrieves the system record from the database.\n// If the record is not found, it removes the system from the manager.\nfunc (sys *System) getRecord() (*core.Record, error) {\n\trecord, err := sys.manager.hub.FindRecordById(\"systems\", sys.Id)\n\tif err != nil || record == nil {\n\t\t_ = sys.manager.RemoveSystem(sys.Id)\n\t\treturn nil, err\n\t}\n\treturn record, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 185, "end_line": 209, "text": "// setDown marks a system as down in the database.\n// It takes the original error that caused the system to go down and returns any error\n// encountered during the process of updating the system status.\nfunc (sys *System) setDown(originalError error) error {\n\tif sys.Status == down || sys.Status == paused {\n\t\treturn nil\n\t}\n\trecord, err := sys.getRecord()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif originalError != nil {\n\t\tsys.manager.hub.Logger().Error(\"System down\", \"system\", record.GetString(\"name\"), \"err\", originalError)\n\t}\n\trecord.Set(\"status\", down)\n\treturn sys.manager.hub.SaveNoValidate(record)\n}\n\nfunc (sys *System) getContext() (context.Context, context.CancelFunc) {\n\tif sys.ctx == nil {\n\t\tsys.ctx, sys.cancel = context.WithCancel(context.Background())\n\t}\n\treturn sys.ctx, sys.cancel\n}\n", "n_tokens": 189, "primary_symbol": "setDown", "primary_kind": "function", "primary_span": [188, 209], "def_symbols": ["setDown", "getContext"], "symbols": ["setDown", "getContext", "marks", "system", "down", "the", "database", "takes", "original", "error", "that", "caused", "and", "returns", "any", "encountered", "during", "process", "updating", "status", "func", "sys", "System", "originalError", "Status", "paused", "return", "nil", "record", "err", "getRecord", "manager", "hub", "Logger", "Error", "GetString", "name", "Set", "SaveNoValidate", "context", "Context", "CancelFunc", "ctx", "cancel", "WithCancel", "Background"], "doc_head": "// setDown marks a system as down in the database.\n// It takes the original error that caused the system to go down and returns any error\n// encountered during the process of updating the system status.\nfunc (sys *System) setDown(originalError error) error {\n\tif sys.Status == down || sys.Status == paused {\n\t\treturn nil\n\t}\n\trecord, err := sys.getRecord()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif originalError != nil {\n\t\tsys.manager.hub.Logger().Error(\"System down\", \"system\", record.GetString(\"name\"), \"err\", originalError)\n\t}\n\trecord.Set(\"status\", down)\n\treturn sys.manager.hub.SaveNoValidate(record)\n}\nfunc (sys *System) getContext() (context.Context, context.CancelFunc) {\n\tif sys.ctx == nil {\n\t\tsys.ctx, sys.cancel = context.WithCancel(context.Background())\n\t}\n\treturn sys.ctx, sys.cancel\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 210, "end_line": 232, "text": "// fetchDataFromAgent attempts to fetch data from the agent,\n// prioritizing WebSocket if available.\nfunc (sys *System) fetchDataFromAgent() (*system.CombinedData, error) {\n\tif sys.data == nil {\n\t\tsys.data = &system.CombinedData{}\n\t}\n\n\tif sys.WsConn != nil && sys.WsConn.IsConnected() {\n\t\twsData, err := sys.fetchDataViaWebSocket()\n\t\tif err == nil {\n\t\t\treturn wsData, nil\n\t\t}\n\t\t// close the WebSocket connection if error and try SSH\n\t\tsys.closeWebSocketConnection()\n\t}\n\n\tsshData, err := sys.fetchDataViaSSH()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn sshData, nil\n}\n", "n_tokens": 156, "primary_symbol": "fetchDataFromAgent", "primary_kind": "function", "primary_span": [212, 232], "def_symbols": ["fetchDataFromAgent"], "symbols": ["fetchDataFromAgent", "attempts", "fetch", "data", "from", "the", "agent", "prioritizing", "WebSocket", "available", "func", "sys", "System", "system", "CombinedData", "error", "nil", "WsConn", "IsConnected", "wsData", "err", "fetchDataViaWebSocket", "return", "close", "connection", "and", "try", "SSH", "closeWebSocketConnection", "sshData", "fetchDataViaSSH"], "doc_head": "// fetchDataFromAgent attempts to fetch data from the agent,\n// prioritizing WebSocket if available.\nfunc (sys *System) fetchDataFromAgent() (*system.CombinedData, error) {\n\tif sys.data == nil {\n\t\tsys.data = &system.CombinedData{}\n\t}\n\tif sys.WsConn != nil && sys.WsConn.IsConnected() {\n\t\twsData, err := sys.fetchDataViaWebSocket()\n\t\tif err == nil {\n\t\t\treturn wsData, nil\n\t\t}\n\t\t// close the WebSocket connection if error and try SSH\n\t\tsys.closeWebSocketConnection()\n\t}\n\tsshData, err := sys.fetchDataViaSSH()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn sshData, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 233, "end_line": 243, "text": "func (sys *System) fetchDataViaWebSocket() (*system.CombinedData, error) {\n\tif sys.WsConn == nil || !sys.WsConn.IsConnected() {\n\t\treturn nil, errors.New(\"no websocket connection\")\n\t}\n\terr := sys.WsConn.RequestSystemData(sys.data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn sys.data, nil\n}\n", "n_tokens": 82, "primary_symbol": "fetchDataViaWebSocket", "primary_kind": "function", "primary_span": [233, 243], "def_symbols": ["fetchDataViaWebSocket"], "symbols": ["fetchDataViaWebSocket", "func", "sys", "System", "system", "CombinedData", "error", "WsConn", "nil", "IsConnected", "return", "errors", "New", "websocket", "connection", "err", "RequestSystemData", "data"], "doc_head": "func (sys *System) fetchDataViaWebSocket() (*system.CombinedData, error) {\n\tif sys.WsConn == nil || !sys.WsConn.IsConnected() {\n\t\treturn nil, errors.New(\"no websocket connection\")\n\t}\n\terr := sys.WsConn.RequestSystemData(sys.data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn sys.data, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 244, "end_line": 303, "text": "// fetchDataViaSSH handles fetching data using SSH.\n// This function encapsulates the original SSH logic.\n// It updates sys.data directly upon successful fetch.\nfunc (sys *System) fetchDataViaSSH() (*system.CombinedData, error) {\n\tmaxRetries := 1\n\tfor attempt := 0; attempt <= maxRetries; attempt++ {\n\t\tif sys.client == nil || sys.Status == down {\n\t\t\tif err := sys.createSSHClient(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tsession, err := sys.createSessionWithTimeout(4 * time.Second)\n\t\tif err != nil {\n\t\t\tif attempt >= maxRetries {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tsys.manager.hub.Logger().Warn(\"Session closed. Retrying...\", \"host\", sys.Host, \"port\", sys.Port, \"err\", err)\n\t\t\tsys.closeSSHConnection()\n\t\t\t// Reset format detection on connection failure - agent might have been upgraded\n\t\t\tcontinue\n\t\t}\n\t\tdefer session.Close()\n\n\t\tstdout, err := session.StdoutPipe()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := session.Shell(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t*sys.data = system.CombinedData{}\n\n\t\tif sys.agentVersion.GTE(beszel.MinVersionCbor) {\n\t\t\terr = cbor.NewDecoder(stdout).Decode(sys.data)\n\t\t} else {\n\t\t\terr = json.NewDecoder(stdout).Decode(sys.data)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tsys.closeSSHConnection()\n\t\t\tif attempt < maxRetries {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// wait for the session to complete\n\t\tif err := session.Wait(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn sys.data, nil\n\t}\n\n\t// this should never be reached due to the return in the loop\n\treturn nil, fmt.Errorf(\"failed to fetch data\")\n}\n", "n_tokens": 421, "primary_symbol": "fetchDataViaSSH", "primary_kind": "function", "primary_span": [247, 303], "def_symbols": ["fetchDataViaSSH"], "symbols": ["fetchDataViaSSH", "handles", "fetching", "data", "using", "SSH", "This", "function", "encapsulates", "the", "original", "logic", "updates", "sys", "directly", "upon", "successful", "fetch", "func", "System", "system", "CombinedData", "error", "maxRetries", "for", "attempt", "client", "nil", "Status", "down", "err", "createSSHClient", "return", "session", "createSessionWithTimeout", "time", "Second", "manager", "hub", "Logger", "Warn", "Session", "closed", "Retrying", "host", "Host", "port", "Port", "closeSSHConnection", "Reset", "format", "detection", "connection", "failure", "agent", "might", "have", "been", "upgraded", "continue", "defer", "Close", "stdout", "StdoutPipe", "Shell", "agentVersion", "GTE", "beszel", "MinVersionCbor", "cbor", "NewDecoder", "Decode", "else", "json", "wait", "complete", "Wait", "this", "should", "never", "reached", "due", "loop", "fmt", "Errorf", "failed"], "doc_head": "// fetchDataViaSSH handles fetching data using SSH.\n// This function encapsulates the original SSH logic.\n// It updates sys.data directly upon successful fetch.\nfunc (sys *System) fetchDataViaSSH() (*system.CombinedData, error) {\n\tmaxRetries := 1\n\tfor attempt := 0; attempt <= maxRetries; attempt++ {\n\t\tif sys.client == nil || sys.Status == down {\n\t\t\tif err := sys.createSSHClient(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tsession, err := sys.createSessionWithTimeout(4 * time.Second)\n\t\tif err != nil {\n\t\t\tif attempt >= maxRetries {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tsys.manager.hub.Logger().Warn(\"Session closed. Retrying...\", \"host\", sys.Host, \"port\", sys.Port, \"err\", err)\n\t\t\tsys.closeSSHConnection()\n\t\t\t// Reset format detection on connection failure - agent might have been upgraded\n\t\t\tcontinue\n\t\t}\n\t\tdefer session.Close()\n\t\tstdout, err := session.StdoutPipe()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := session.Shell(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t*sys.data = system.CombinedData{}\n\t\tif sys.agentVersion.GTE(beszel.MinVersionCbor) {\n\t\t\terr = cbor.NewDecoder(stdout).Decode(sys.data)\n\t\t} else {\n\t\t\terr = json.NewDecoder(stdout).Decode(sys.data)\n\t\t}\n\t\tif err != nil {\n\t\t\tsys.cl"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 304, "end_line": 326, "text": "// createSSHClient creates a new SSH client for the system\nfunc (s *System) createSSHClient() error {\n\tif s.manager.sshConfig == nil {\n\t\tif err := s.manager.createSSHClientConfig(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tnetwork := \"tcp\"\n\thost := s.Host\n\tif strings.HasPrefix(host, \"/\") {\n\t\tnetwork = \"unix\"\n\t} else {\n\t\thost = net.JoinHostPort(host, s.Port)\n\t}\n\tvar err error\n\ts.client, err = ssh.Dial(network, host, s.manager.sshConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.agentVersion, _ = extractAgentVersion(string(s.client.Conn.ServerVersion()))\n\treturn nil\n}\n", "n_tokens": 154, "primary_symbol": "createSSHClient", "primary_kind": "function", "primary_span": [305, 326], "def_symbols": ["createSSHClient"], "symbols": ["createSSHClient", "creates", "new", "SSH", "client", "for", "the", "system", "func", "System", "error", "manager", "sshConfig", "nil", "err", "createSSHClientConfig", "return", "network", "tcp", "host", "Host", "strings", "HasPrefix", "unix", "else", "net", "JoinHostPort", "Port", "var", "ssh", "Dial", "agentVersion", "extractAgentVersion", "string", "Conn", "ServerVersion"], "doc_head": "// createSSHClient creates a new SSH client for the system\nfunc (s *System) createSSHClient() error {\n\tif s.manager.sshConfig == nil {\n\t\tif err := s.manager.createSSHClientConfig(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tnetwork := \"tcp\"\n\thost := s.Host\n\tif strings.HasPrefix(host, \"/\") {\n\t\tnetwork = \"unix\"\n\t} else {\n\t\thost = net.JoinHostPort(host, s.Port)\n\t}\n\tvar err error\n\ts.client, err = ssh.Dial(network, host, s.manager.sshConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.agentVersion, _ = extractAgentVersion(string(s.client.Conn.ServerVersion()))\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 13, "start_line": 327, "end_line": 357, "text": "// createSessionWithTimeout creates a new SSH session with a timeout to avoid hanging\n// in case of network issues\nfunc (sys *System) createSessionWithTimeout(timeout time.Duration) (*ssh.Session, error) {\n\tif sys.client == nil {\n\t\treturn nil, fmt.Errorf(\"client not initialized\")\n\t}\n\n\tctx, cancel := context.WithTimeout(sys.ctx, timeout)\n\tdefer cancel()\n\n\tsessionChan := make(chan *ssh.Session, 1)\n\terrChan := make(chan error, 1)\n\n\tgo func() {\n\t\tif session, err := sys.client.NewSession(); err != nil {\n\t\t\terrChan <- err\n\t\t} else {\n\t\t\tsessionChan <- session\n\t\t}\n\t}()\n\n\tselect {\n\tcase session := <-sessionChan:\n\t\treturn session, nil\n\tcase err := <-errChan:\n\t\treturn nil, err\n\tcase <-ctx.Done():\n\t\treturn nil, fmt.Errorf(\"timeout\")\n\t}\n}\n", "n_tokens": 187, "primary_symbol": "createSessionWithTimeout", "primary_kind": "function", "primary_span": [329, 357], "def_symbols": ["createSessionWithTimeout"], "symbols": ["createSessionWithTimeout", "creates", "new", "SSH", "session", "with", "timeout", "avoid", "hanging", "case", "network", "issues", "func", "sys", "System", "time", "Duration", "ssh", "Session", "error", "client", "nil", "return", "fmt", "Errorf", "not", "initialized", "ctx", "cancel", "context", "WithTimeout", "defer", "sessionChan", "make", "chan", "errChan", "err", "NewSession", "else", "select", "Done"], "doc_head": "// createSessionWithTimeout creates a new SSH session with a timeout to avoid hanging\n// in case of network issues\nfunc (sys *System) createSessionWithTimeout(timeout time.Duration) (*ssh.Session, error) {\n\tif sys.client == nil {\n\t\treturn nil, fmt.Errorf(\"client not initialized\")\n\t}\n\tctx, cancel := context.WithTimeout(sys.ctx, timeout)\n\tdefer cancel()\n\tsessionChan := make(chan *ssh.Session, 1)\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\tif session, err := sys.client.NewSession(); err != nil {\n\t\t\terrChan <- err\n\t\t} else {\n\t\t\tsessionChan <- session\n\t\t}\n\t}()\n\tselect {\n\tcase session := <-sessionChan:\n\t\treturn session, nil\n\tcase err := <-errChan:\n\t\treturn nil, err\n\tcase <-ctx.Done():\n\t\treturn nil, fmt.Errorf(\"timeout\")\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 14, "start_line": 358, "end_line": 380, "text": "// closeSSHConnection closes the SSH connection but keeps the system in the manager\nfunc (sys *System) closeSSHConnection() {\n\tif sys.client != nil {\n\t\tsys.client.Close()\n\t\tsys.client = nil\n\t}\n}\n\n// closeWebSocketConnection closes the WebSocket connection but keeps the system in the manager\n// to allow updating via SSH. It will be removed if the WS connection is re-established.\n// The system will be set as down a few seconds later if the connection is not re-established.\nfunc (sys *System) closeWebSocketConnection() {\n\tif sys.WsConn != nil {\n\t\tsys.WsConn.Close(nil)\n\t}\n}\n\n// extractAgentVersion extracts the beszel version from SSH server version string\nfunc extractAgentVersion(versionString string) (semver.Version, error) {\n\t_, after, _ := strings.Cut(versionString, \"_\")\n\treturn semver.Parse(after)\n}\n", "n_tokens": 184, "primary_symbol": "closeSSHConnection", "primary_kind": "function", "primary_span": [359, 380], "def_symbols": ["closeSSHConnection", "closeWebSocketConnection", "extractAgentVersion"], "symbols": ["closeSSHConnection", "closeWebSocketConnection", "extractAgentVersion", "closes", "the", "SSH", "connection", "but", "keeps", "system", "manager", "func", "sys", "System", "client", "nil", "Close", "WebSocket", "allow", "updating", "via", "will", "removed", "established", "The", "set", "down", "few", "seconds", "later", "not", "WsConn", "extracts", "beszel", "version", "from", "server", "string", "versionString", "semver", "Version", "error", "after", "strings", "Cut", "return", "Parse"], "doc_head": "// closeSSHConnection closes the SSH connection but keeps the system in the manager\nfunc (sys *System) closeSSHConnection() {\n\tif sys.client != nil {\n\t\tsys.client.Close()\n\t\tsys.client = nil\n\t}\n}\n// closeWebSocketConnection closes the WebSocket connection but keeps the system in the manager\n// to allow updating via SSH. It will be removed if the WS connection is re-established.\n// The system will be set as down a few seconds later if the connection is not re-established.\nfunc (sys *System) closeWebSocketConnection() {\n\tif sys.WsConn != nil {\n\t\tsys.WsConn.Close(nil)\n\t}\n}\n// extractAgentVersion extracts the beszel version from SSH server version string\nfunc extractAgentVersion(versionString string) (semver.Version, error) {\n\t_, after, _ := strings.Cut(versionString, \"_\")\n\treturn semver.Parse(after)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system.go", "rel_path": "src/hub/systems/system.go", "ext": "go", "language": "go", "chunk_number": 15, "start_line": 381, "end_line": 391, "text": "// getJitter returns a channel that will be triggered after a random delay\n// between 40% and 90% of the interval.\n// This is used to stagger the initial WebSocket connections to prevent clustering.\nfunc getJitter() <-chan time.Time {\n\tminPercent := 40\n\tmaxPercent := 90\n\tjitterRange := maxPercent - minPercent\n\tmsDelay := (interval * minPercent / 100) + rand.Intn(interval*jitterRange/100)\n\treturn time.After(time.Duration(msDelay) * time.Millisecond)\n}\n", "n_tokens": 111, "primary_symbol": "getJitter", "primary_kind": "function", "primary_span": [384, 391], "def_symbols": ["getJitter"], "symbols": ["getJitter", "returns", "channel", "that", "will", "triggered", "after", "random", "delay", "between", "and", "the", "interval", "This", "used", "stagger", "initial", "WebSocket", "connections", "prevent", "clustering", "func", "chan", "time", "Time", "minPercent", "maxPercent", "jitterRange", "msDelay", "rand", "Intn", "return", "After", "Duration", "Millisecond"], "doc_head": "// getJitter returns a channel that will be triggered after a random delay\n// between 40% and 90% of the interval.\n// This is used to stagger the initial WebSocket connections to prevent clustering.\nfunc getJitter() <-chan time.Time {\n\tminPercent := 40\n\tmaxPercent := 90\n\tjitterRange := maxPercent - minPercent\n\tmsDelay := (interval * minPercent / 100) + rand.Intn(interval*jitterRange/100)\n\treturn time.After(time.Duration(msDelay) * time.Millisecond)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test_helpers.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test_helpers.go", "rel_path": "src/hub/systems/systems_test_helpers.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 32, "text": "//go:build testing\n// +build testing\n\npackage systems\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\tentities \"github.com/henrygd/beszel/src/entities/system\"\n)\n\n// TESTING ONLY: GetSystemCount returns the number of systems in the store\nfunc (sm *SystemManager) GetSystemCount() int {\n\treturn sm.systems.Length()\n}\n\n// TESTING ONLY: HasSystem checks if a system with the given ID exists in the store\nfunc (sm *SystemManager) HasSystem(systemID string) bool {\n\treturn sm.systems.Has(systemID)\n}\n\n// TESTING ONLY: GetSystemStatusFromStore returns the status of a system with the given ID\n// Returns an empty string if the system doesn't exist\nfunc (sm *SystemManager) GetSystemStatusFromStore(systemID string) string {\n\tsys, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn sys.Status\n}\n", "n_tokens": 194, "primary_symbol": "GetSystemCount", "primary_kind": "function", "primary_span": [14, 32], "def_symbols": ["GetSystemCount", "HasSystem", "GetSystemStatusFromStore"], "symbols": ["GetSystemCount", "HasSystem", "GetSystemStatusFromStore", "build", "testing", "package", "systems", "import", "context", "fmt", "entities", "github", "com", "henrygd", "beszel", "src", "system", "TESTING", "ONLY", "returns", "the", "number", "store", "func", "SystemManager", "int", "return", "Length", "checks", "with", "given", "exists", "systemID", "string", "bool", "Has", "status", "Returns", "empty", "doesn", "exist", "sys", "GetOk", "Status"], "doc_head": "//go:build testing\n// +build testing\npackage systems\nimport (\n\t\"context\"\n\t\"fmt\"\n\tentities \"github.com/henrygd/beszel/src/entities/system\"\n)\n// TESTING ONLY: GetSystemCount returns the number of systems in the store\nfunc (sm *SystemManager) GetSystemCount() int {\n\treturn sm.systems.Length()\n}\n// TESTING ONLY: HasSystem checks if a system with the given ID exists in the store\nfunc (sm *SystemManager) HasSystem(systemID string) bool {\n\treturn sm.systems.Has(systemID)\n}\n// TESTING ONLY: GetSystemStatusFromStore returns the status of a system with the given ID\n// Returns an empty string if the system doesn't exist\nfunc (sm *SystemManager) GetSystemStatusFromStore(systemID string) string {\n\tsys, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn sys.Status\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test_helpers.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test_helpers.go", "rel_path": "src/hub/systems/systems_test_helpers.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 33, "end_line": 50, "text": "// TESTING ONLY: GetSystemContextFromStore returns the context and cancel function for a system\nfunc (sm *SystemManager) GetSystemContextFromStore(systemID string) (context.Context, context.CancelFunc, error) {\n\tsys, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn nil, nil, fmt.Errorf(\"no system\")\n\t}\n\treturn sys.ctx, sys.cancel, nil\n}\n\n// TESTING ONLY: GetSystemFromStore returns a store from the system\nfunc (sm *SystemManager) GetSystemFromStore(systemID string) (*System, error) {\n\tsys, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no system\")\n\t}\n\treturn sys, nil\n}\n", "n_tokens": 156, "primary_symbol": "GetSystemContextFromStore", "primary_kind": "function", "primary_span": [33, 50], "def_symbols": ["GetSystemContextFromStore", "GetSystemFromStore"], "symbols": ["GetSystemContextFromStore", "GetSystemFromStore", "TESTING", "ONLY", "returns", "the", "context", "and", "cancel", "function", "for", "system", "func", "SystemManager", "systemID", "string", "Context", "CancelFunc", "error", "sys", "systems", "GetOk", "return", "nil", "fmt", "Errorf", "ctx", "store", "from", "System"], "doc_head": "// TESTING ONLY: GetSystemContextFromStore returns the context and cancel function for a system\nfunc (sm *SystemManager) GetSystemContextFromStore(systemID string) (context.Context, context.CancelFunc, error) {\n\tsys, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn nil, nil, fmt.Errorf(\"no system\")\n\t}\n\treturn sys.ctx, sys.cancel, nil\n}\n// TESTING ONLY: GetSystemFromStore returns a store from the system\nfunc (sm *SystemManager) GetSystemFromStore(systemID string) (*System, error) {\n\tsys, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no system\")\n\t}\n\treturn sys, nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test_helpers.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test_helpers.go", "rel_path": "src/hub/systems/systems_test_helpers.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 51, "end_line": 71, "text": "// TESTING ONLY: GetAllSystemIDs returns a slice of all system IDs in the store\nfunc (sm *SystemManager) GetAllSystemIDs() []string {\n\tdata := sm.systems.GetAll()\n\tids := make([]string, 0, len(data))\n\tfor id := range data {\n\t\tids = append(ids, id)\n\t}\n\treturn ids\n}\n\n// TESTING ONLY: GetSystemData returns the combined data for a system with the given ID\n// Returns nil if the system doesn't exist\n// This method is intended for testing\nfunc (sm *SystemManager) GetSystemData(systemID string) *entities.CombinedData {\n\tsys, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn sys.data\n}\n", "n_tokens": 158, "primary_symbol": "GetAllSystemIDs", "primary_kind": "function", "primary_span": [52, 71], "def_symbols": ["GetAllSystemIDs", "GetSystemData"], "symbols": ["GetAllSystemIDs", "GetSystemData", "TESTING", "ONLY", "returns", "slice", "all", "system", "IDs", "the", "store", "func", "SystemManager", "string", "data", "systems", "GetAll", "ids", "make", "len", "for", "range", "append", "return", "combined", "with", "given", "Returns", "nil", "doesn", "exist", "This", "method", "intended", "testing", "systemID", "entities", "CombinedData", "sys", "GetOk"], "doc_head": "// TESTING ONLY: GetAllSystemIDs returns a slice of all system IDs in the store\nfunc (sm *SystemManager) GetAllSystemIDs() []string {\n\tdata := sm.systems.GetAll()\n\tids := make([]string, 0, len(data))\n\tfor id := range data {\n\t\tids = append(ids, id)\n\t}\n\treturn ids\n}\n// TESTING ONLY: GetSystemData returns the combined data for a system with the given ID\n// Returns nil if the system doesn't exist\n// This method is intended for testing\nfunc (sm *SystemManager) GetSystemData(systemID string) *entities.CombinedData {\n\tsys, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn sys.data\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test_helpers.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test_helpers.go", "rel_path": "src/hub/systems/systems_test_helpers.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 72, "end_line": 81, "text": "// TESTING ONLY: GetSystemHostPort returns the host and port for a system with the given ID\n// Returns empty strings if the system doesn't exist\nfunc (sm *SystemManager) GetSystemHostPort(systemID string) (string, string) {\n\tsys, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn \"\", \"\"\n\t}\n\treturn sys.Host, sys.Port\n}\n", "n_tokens": 83, "primary_symbol": "GetSystemHostPort", "primary_kind": "function", "primary_span": [74, 81], "def_symbols": ["GetSystemHostPort"], "symbols": ["GetSystemHostPort", "TESTING", "ONLY", "returns", "the", "host", "and", "port", "for", "system", "with", "given", "Returns", "empty", "strings", "doesn", "exist", "func", "SystemManager", "systemID", "string", "sys", "systems", "GetOk", "return", "Host", "Port"], "doc_head": "// TESTING ONLY: GetSystemHostPort returns the host and port for a system with the given ID\n// Returns empty strings if the system doesn't exist\nfunc (sm *SystemManager) GetSystemHostPort(systemID string) (string, string) {\n\tsys, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn \"\", \"\"\n\t}\n\treturn sys.Host, sys.Port\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test_helpers.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test_helpers.go", "rel_path": "src/hub/systems/systems_test_helpers.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 82, "end_line": 111, "text": "// TESTING ONLY: SetSystemStatusInDB sets the status of a system directly and updates the database record\n// This is intended for testing\n// Returns false if the system doesn't exist\nfunc (sm *SystemManager) SetSystemStatusInDB(systemID string, status string) bool {\n\tif !sm.HasSystem(systemID) {\n\t\treturn false\n\t}\n\n\t// Update the database record\n\trecord, err := sm.hub.FindRecordById(\"systems\", systemID)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\trecord.Set(\"status\", status)\n\terr = sm.hub.Save(record)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// TESTING ONLY: RemoveAllSystems removes all systems from the store\nfunc (sm *SystemManager) RemoveAllSystems() {\n\tfor _, system := range sm.systems.GetAll() {\n\t\tsm.RemoveSystem(system.Id)\n\t}\n}\n", "n_tokens": 186, "primary_symbol": "SetSystemStatusInDB", "primary_kind": "function", "primary_span": [85, 111], "def_symbols": ["SetSystemStatusInDB", "RemoveAllSystems"], "symbols": ["SetSystemStatusInDB", "RemoveAllSystems", "TESTING", "ONLY", "sets", "the", "status", "system", "directly", "and", "updates", "database", "record", "This", "intended", "for", "testing", "Returns", "false", "doesn", "exist", "func", "SystemManager", "systemID", "string", "bool", "HasSystem", "return", "Update", "err", "hub", "FindRecordById", "systems", "nil", "Set", "Save", "true", "removes", "all", "from", "store", "range", "GetAll", "RemoveSystem"], "doc_head": "// TESTING ONLY: SetSystemStatusInDB sets the status of a system directly and updates the database record\n// This is intended for testing\n// Returns false if the system doesn't exist\nfunc (sm *SystemManager) SetSystemStatusInDB(systemID string, status string) bool {\n\tif !sm.HasSystem(systemID) {\n\t\treturn false\n\t}\n\t// Update the database record\n\trecord, err := sm.hub.FindRecordById(\"systems\", systemID)\n\tif err != nil {\n\t\treturn false\n\t}\n\trecord.Set(\"status\", status)\n\terr = sm.hub.Save(record)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn true\n}\n// TESTING ONLY: RemoveAllSystems removes all systems from the store\nfunc (sm *SystemManager) RemoveAllSystems() {\n\tfor _, system := range sm.systems.GetAll() {\n\t\tsm.RemoveSystem(system.Id)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test.go", "rel_path": "src/hub/systems/systems_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 21, "text": "//go:build testing\n// +build testing\n\npackage systems_test\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\t\"testing/synctest\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/entities/container\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/henrygd/beszel/src/hub/systems\"\n\t\"github.com/henrygd/beszel/src/tests\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n", "n_tokens": 108, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 21], "def_symbols": [], "symbols": ["build", "testing", "package", "systems_test", "import", "fmt", "sync", "synctest", "time", "github", "com", "henrygd", "beszel", "src", "entities", "container", "system", "hub", "systems", "tests", "stretchr", "testify", "assert", "require"], "doc_head": "//go:build testing\n// +build testing\npackage systems_test\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\t\"testing/synctest\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/entities/container\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/henrygd/beszel/src/hub/systems\"\n\t\"github.com/henrygd/beszel/src/tests\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test.go", "rel_path": "src/hub/systems/systems_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 22, "end_line": 133, "text": "func TestSystemManagerNew(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer hub.Cleanup()\n\tsm := hub.GetSystemManager()\n\n\tuser, err := tests.CreateUser(hub, \"test@test.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\n\tsynctest.Test(t, func(t *testing.T) {\n\t\tsm.Initialize()\n\n\t\trecord, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":  \"it-was-coney-island\",\n\t\t\t\"host\":  \"the-playground-of-the-world\",\n\t\t\t\"port\":  \"33914\",\n\t\t\t\"users\": []string{user.Id},\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, \"pending\", record.GetString(\"status\"), \"System status should be 'pending'\")\n\t\tassert.Equal(t, \"pending\", sm.GetSystemStatusFromStore(record.Id), \"System status should be 'pending'\")\n\n\t\t// Verify the system host and port\n\t\thost, port := sm.GetSystemHostPort(record.Id)\n\t\tassert.Equal(t, record.GetString(\"host\"), host, \"System host should match\")\n\t\tassert.Equal(t, record.GetString(\"port\"), port, \"System port should match\")\n\n\t\ttime.Sleep(13 * time.Second)\n\t\tsynctest.Wait()\n\n\t\tassert.Equal(t, \"pending\", record.Fresh().GetString(\"status\"), \"System status should be 'pending'\")\n\t\t// Verify the system was added by checking if it exists\n\t\tassert.True(t, sm.HasSystem(record.Id), \"System should exist in the store\")\n\n\t\ttime.Sleep(10 * time.Second)\n\t\tsynctest.Wait()\n\n\t\t// system should be set to down after 15 seconds (no websocket connection)\n\t\tassert.Equal(t, \"down\", sm.GetSystemStatusFromStore(record.Id), \"System status should be 'down'\")\n\t\t// make sure the system is down in the db\n\t\trecord, err = hub.FindRecordById(\"systems\", record.Id)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, \"down\", record.GetString(\"status\"), \"System status should be 'down'\")\n\n\t\tassert.Equal(t, 1, sm.GetSystemCount(), \"System count should be 1\")\n\n\t\terr = sm.RemoveSystem(record.Id)\n\t\tassert.NoError(t, err)\n\n\t\tassert.Equal(t, 0, sm.GetSystemCount(), \"System count should be 0\")\n\t\tassert.False(t, sm.HasSystem(record.Id), \"System should not exist in the store after removal\")\n\n\t\t// let's also make sure a system is removed from the store when the record is deleted\n\t\trecord, err = tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":  \"there-was-no-place-like-it\",\n\t\t\t\"host\":  \"in-the-whole-world\",\n\t\t\t\"port\":  \"33914\",\n\t\t\t\"users\": []string{user.Id},\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\tassert.True(t, sm.HasSystem(record.Id), \"System should exist in the store after creation\")\n\n\t\ttime.Sleep(8 * time.Second)\n\t\tsynctest.Wait()\n\t\tassert.Equal(t, \"pending\", sm.GetSystemStatusFromStore(record.Id), \"System status should be 'pending'\")\n\n\t\tsm.SetSystemStatusInDB(record.Id, \"up\")\n\t\ttime.Sleep(time.Second)\n\t\tsynctest.Wait()\n\t\tassert.Equal(t, \"up\", sm.GetSystemStatusFromStore(record.Id), \"System status should be 'up'\")\n\n\t\t// make sure the system switches to down after 11 seconds\n\t\tsm.RemoveSystem(record.Id)\n\t\tsm.AddRecord(record, nil)\n\t\tassert.Equal(t, \"pending\", sm.GetSystemStatusFromStore(record.Id), \"System status should be 'pending'\")\n\t\ttime.Sleep(12 * time.Second)\n\t\tsynctest.Wait()\n\t\tassert.Equal(t, \"down\", sm.GetSystemStatusFromStore(record.Id), \"System status should be 'down'\")\n\n\t\t// sm.SetSystemStatusInDB(record.Id, \"paused\")\n\t\t// time.Sleep(time.Second)\n\t\t// synctest.Wait()\n\t\t// assert.Equal(t, \"paused\", sm.GetSystemStatusFromStore(record.Id), \"System status should be 'paused'\")\n\n\t\t// delete the record\n\t\terr = hub.Delete(record)\n\t\trequire.NoError(t, err)\n\t\tassert.False(t, sm.HasSystem(record.Id), \"System should not exist in the store after deletion\")\n\t})\n\n\ttestOld(t, hub)\n\n\tsynctest.Test(t, func(t *testing.T) {\n\t\ttime.Sleep(time.Second)\n\t\tsynctest.Wait()\n\n\t\tfor _, systemId := range sm.GetAllSystemIDs() {\n\t\t\terr = sm.RemoveSystem(systemId)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.False(t, sm.HasSystem(systemId), \"System should not exist in the store after deletion\")\n\t\t}\n\n\t\tassert.Equal(t, 0, sm.GetSystemCount(), \"System count should be 0\")\n\n\t\t// TODO: test with websocket client\n\t})\n}\n", "n_tokens": 1071, "primary_symbol": "TestSystemManagerNew", "primary_kind": "function", "primary_span": [22, 133], "def_symbols": ["TestSystemManagerNew"], "symbols": ["TestSystemManagerNew", "func", "testing", "hub", "err", "tests", "NewTestHub", "TempDir", "nil", "Fatal", "defer", "Cleanup", "GetSystemManager", "user", "CreateUser", "test", "com", "testtesttest", "require", "NoError", "synctest", "Test", "Initialize", "record", "CreateRecord", "systems", "map", "string", "any", "name", "was", "coney", "island", "host", "the", "playground", "world", "port", "users", "assert", "Equal", "pending", "GetString", "status", "System", "should", "GetSystemStatusFromStore", "Verify", "system", "and", "GetSystemHostPort", "match", "time", "Sleep", "Second", "Wait", "Fresh", "added", "checking", "exists", "True", "HasSystem", "exist", "store", "set", "down", "after", "seconds", "websocket", "connection", "make", "sure", "FindRecordById", "GetSystemCount", "count", "RemoveSystem", "False", "not", "removal", "let", "also", "removed", "from", "when", "deleted", "there", "place", "like", "whole", "creation", "SetSystemStatusInDB", "switches", "AddRecord", "paused", "delete", "Delete", "deletion", "testOld", "for", "systemId", "range", "GetAllSystemIDs", "TODO", "with", "client"], "doc_head": "func TestSystemManagerNew(t *testing.T) {\n\thub, err := tests.NewTestHub(t.TempDir())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer hub.Cleanup()\n\tsm := hub.GetSystemManager()\n\tuser, err := tests.CreateUser(hub, \"test@test.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\tsynctest.Test(t, func(t *testing.T) {\n\t\tsm.Initialize()\n\t\trecord, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":  \"it-was-coney-island\",\n\t\t\t\"host\":  \"the-playground-of-the-world\",\n\t\t\t\"port\":  \"33914\",\n\t\t\t\"users\": []string{user.Id},\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, \"pending\", record.GetString(\"status\"), \"System status should be 'pending'\")\n\t\tassert.Equal(t, \"pending\", sm.GetSystemStatusFromStore(record.Id), \"System status should be 'pending'\")\n\t\t// Verify the system host and port\n\t\thost, port := sm.GetSystemHostPort(record.Id)\n\t\tassert.Equal(t, record.GetString(\"host\"), host, \"System host should match\")\n\t\tassert.Equal(t, record.GetString(\"port\"), port, \"System port should match\")\n\t\ttime.Sleep(13 * time.Second)\n\t\tsynctest.Wait()\n\t\tassert.Equal(t, \"pending\", record.Fresh().GetString(\"status\"), \"System status should be 'pending'\")\n\t\t// Verify the system was added by checking if it exists"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/systems_test.go", "rel_path": "src/hub/systems/systems_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 134, "end_line": 423, "text": "func testOld(t *testing.T, hub *tests.TestHub) {\n\tuser, err := tests.CreateUser(hub, \"test@testy.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\n\tsm := hub.GetSystemManager()\n\tassert.NotNil(t, sm)\n\n\t// error expected when creating a user with a duplicate email\n\t_, err = tests.CreateUser(hub, \"test@test.com\", \"testtesttest\")\n\trequire.Error(t, err)\n\n\t// Test collection existence. todo: move to hub package tests\n\tt.Run(\"CollectionExistence\", func(t *testing.T) {\n\t\t// Verify that required collections exist\n\t\tsystems, err := hub.FindCachedCollectionByNameOrId(\"systems\")\n\t\trequire.NoError(t, err)\n\t\tassert.NotNil(t, systems)\n\n\t\tsystemStats, err := hub.FindCachedCollectionByNameOrId(\"system_stats\")\n\t\trequire.NoError(t, err)\n\t\tassert.NotNil(t, systemStats)\n\n\t\tcontainerStats, err := hub.FindCachedCollectionByNameOrId(\"container_stats\")\n\t\trequire.NoError(t, err)\n\t\tassert.NotNil(t, containerStats)\n\t})\n\n\tt.Run(\"RemoveSystem\", func(t *testing.T) {\n\t\t// Get the count before adding the system\n\t\tcountBefore := sm.GetSystemCount()\n\n\t\t// Create a test system record\n\t\trecord, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":  \"i-even-got-lost-at-coney-island\",\n\t\t\t\"host\":  \"but-they-found-me\",\n\t\t\t\"port\":  \"33914\",\n\t\t\t\"users\": []string{user.Id},\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\t// Verify the system count increased\n\t\tcountAfterAdd := sm.GetSystemCount()\n\t\tassert.Equal(t, countBefore+1, countAfterAdd, \"System count should increase after adding a system via event hook\")\n\n\t\t// Verify the system exists\n\t\tassert.True(t, sm.HasSystem(record.Id), \"System should exist in the store\")\n\n\t\t// Remove the system\n\t\terr = sm.RemoveSystem(record.Id)\n\t\tassert.NoError(t, err)\n\n\t\t// Check that the system count decreased\n\t\tcountAfterRemove := sm.GetSystemCount()\n\t\tassert.Equal(t, countAfterAdd-1, countAfterRemove, \"System count should decrease after removing a system\")\n\n\t\t// Verify the system no longer exists\n\t\tassert.False(t, sm.HasSystem(record.Id), \"System should not exist in the store after removal\")\n\n\t\t// Verify the system is not in the list of all system IDs\n\t\tids := sm.GetAllSystemIDs()\n\t\tassert.NotContains(t, ids, record.Id, \"System ID should not be in the list of all system IDs after removal\")\n\n\t\t// Verify the system status is empty\n\t\tstatus := sm.GetSystemStatusFromStore(record.Id)\n\t\tassert.Equal(t, \"\", status, \"System status should be empty after removal\")\n\n\t\t// Try to remove it again - should return an error since it's already removed\n\t\terr = sm.RemoveSystem(record.Id)\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"NewRecordPending\", func(t *testing.T) {\n\t\t// Create a test system\n\t\trecord, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":  \"and-you-know\",\n\t\t\t\"host\":  \"i-feel-very-bad\",\n\t\t\t\"port\":  \"33914\",\n\t\t\t\"users\": []string{user.Id},\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\t// Add the record to the system manager\n\t\terr = sm.AddRecord(record, nil)\n\t\trequire.NoError(t, err)\n\n\t\t// Test filtering records by status - should be \"pending\" now\n\t\tfilter := \"status = 'pending'\"\n\t\tpendingSystems, err := hub.FindRecordsByFilter(\"systems\", filter, \"-created\", 0, 0, nil)\n\t\trequire.NoError(t, err)\n\t\tassert.GreaterOrEqual(t, len(pendingSystems), 1)\n\t})\n\n\tt.Run(\"SystemStatusUpdate\", func(t *testing.T) {\n\t\t// Create a test system record\n\t\trecord, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":  \"we-used-to-sleep-on-the-beach\",\n\t\t\t\"host\":  \"sleep-overnight-here\",\n\t\t\t\"port\":  \"33914\",\n\t\t\t\"users\": []string{user.Id},\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\t// Add the record to the system manager\n\t\terr = sm.AddRecord(record, nil)\n\t\trequire.NoError(t, err)\n\n\t\t// Test status changes\n\t\tinitialStatus := sm.GetSystemStatusFromStore(record.Id)\n\n\t\t// Set a new status\n\t\tsm.SetSystemStatusInDB(record.Id, \"up\")\n\n\t\t// Verify status was updated\n\t\tnewStatus := sm.GetSystemStatusFromStore(record.Id)\n\t\tassert.Equal(t, \"up\", newStatus, \"System status should be updated to 'up'\")\n\t\tassert.NotEqual(t, initialStatus, newStatus, \"Status should have changed\")\n\n\t\t// Verify the database was updated\n\t\tupdatedRecord, err := hub.FindRecordById(\"systems\", record.Id)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, \"up\", updatedRecord.Get(\"status\"), \"Database status should match\")\n\t})\n\n\tt.Run(\"HandleSystemData\", func(t *testing.T) {\n\t\t// Create a test system record\n\t\trecord, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":  \"things-changed-you-know\",\n\t\t\t\"host\":  \"they-dont-sleep-anymore-on-the-beach\",\n\t\t\t\"port\":  \"33914\",\n\t\t\t\"users\": []string{user.Id},\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\t// Create test system data\n\t\ttestData := &system.CombinedData{\n\t\t\tInfo: system.Info{\n\t\t\t\tHostname:      \"data-test.example.com\",\n\t\t\t\tKernelVersion: \"5.15.0-generic\",\n\t\t\t\tCores:         4,\n\t\t\t\tThreads:       8,\n\t\t\t\tCpuModel:      \"Test CPU\",\n\t\t\t\tUptime:        3600,\n\t\t\t\tCpu:           25.5,\n\t\t\t\tMemPct:        40.2,\n\t\t\t\tDiskPct:       60.0,\n\t\t\t\tBandwidth:     100.0,\n\t\t\t\tAgentVersion:  \"1.0.0\",\n\t\t\t},\n\t\t\tStats: system.Stats{\n\t\t\t\tCpu:         25.5,\n\t\t\t\tMem:         16384.0,\n\t\t\t\tMemUsed:     6553.6,\n\t\t\t\tMemPct:      40.0,\n\t\t\t\tDiskTotal:   1024000.0,\n\t\t\t\tDiskUsed:    614400.0,\n\t\t\t\tDiskPct:     60.0,\n\t\t\t\tNetworkSent: 1024.0,\n\t\t\t\tNetworkRecv: 2048.0,\n\t\t\t},\n\t\t\tContainers: []*container.Stats{},\n\t\t}\n\n\t\t// Test handling system data. todo: move to hub/alerts package tests\n\t\terr = hub.HandleSystemAlerts(record, testData)\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"ErrorHandling\", func(t *testing.T) {\n\t\t// Try to add a non-existent record\n\t\tnonExistentId := \"non_existent_id\"\n\t\terr := sm.RemoveSystem(nonExistentId)\n\t\tassert.Error(t, err)\n\n\t\t// Try to add a system with invalid host\n\t\tsystem := &systems.System{\n\t\t\tHost: \"\",\n\t\t}\n\t\terr = sm.AddSystem(system)\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"ConcurrentOperations\", func(t *testing.T) {\n\t\t// Create a test system\n\t\trecord, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":  \"jfkjahkfajs\",\n\t\t\t\"host\":  \"localhost\",\n\t\t\t\"port\":  \"33914\",\n\t\t\t\"users\": []string{user.Id},\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\t// Run concurrent operations\n\t\tconst goroutines = 5\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(goroutines)\n\n\t\tfor i := range goroutines {\n\t\t\tgo func(i int) {\n\t\t\t\tdefer wg.Done()\n\n\t\t\t\t// Alternate between different operations\n\t\t\t\tswitch i % 3 {\n\t\t\t\tcase 0:\n\t\t\t\t\tstatus := fmt.Sprintf(\"status-%d\", i)\n\t\t\t\t\tsm.SetSystemStatusInDB(record.Id, status)\n\t\t\t\tcase 1:\n\t\t\t\t\t_ = sm.GetSystemStatusFromStore(record.Id)\n\t\t\t\tcase 2:\n\t\t\t\t\t_, _ = sm.GetSystemHostPort(record.Id)\n\t\t\t\t}\n\t\t\t}(i)\n\t\t}\n\n\t\twg.Wait()\n\n\t\t// Verify system still exists and is in a valid state\n\t\tassert.True(t, sm.HasSystem(record.Id), \"System should still exist after concurrent operations\")\n\t\tstatus := sm.GetSystemStatusFromStore(record.Id)\n\t\tassert.NotEmpty(t, status, \"System should have a status after concurrent operations\")\n\t})\n\n\tt.Run(\"ContextCancellation\", func(t *testing.T) {\n\t\t// Create a test system record\n\t\trecord, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":  \"lkhsdfsjf\",\n\t\t\t\"host\":  \"localhost\",\n\t\t\t\"port\":  \"33914\",\n\t\t\t\"users\": []string{user.Id},\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\t// Verify the system exists in the store\n\t\tassert.True(t, sm.HasSystem(record.Id), \"System should exist in the store\")\n\n\t\t// Store the original context and cancel function\n\t\toriginalCtx, originalCancel, err := sm.GetSystemContextFromStore(record.Id)\n\t\tassert.NoError(t, err)\n\n\t\t// Ensure the context is not nil\n\t\tassert.NotNil(t, originalCtx, \"System context should not be nil\")\n\t\tassert.NotNil(t, originalCancel, \"System cancel function should not be nil\")\n\n\t\t// Cancel the context\n\t\toriginalCancel()\n\n\t\t// Wait a short time for cancellation to propagate\n\t\ttime.Sleep(10 * time.Millisecond)\n\n\t\t// Verify the context is done\n\t\tselect {\n\t\tcase <-originalCtx.Done():\n\t\t\t// Context was properly cancelled\n\t\tdefault:\n\t\t\tt.Fatal(\"Context was not cancelled\")\n\t\t}\n\n\t\t// Verify the system is still in the store (cancellation shouldn't remove it)\n\t\tassert.True(t, sm.HasSystem(record.Id), \"System should still exist after context cancellation\")\n\n\t\t// Explicitly remove the system\n\t\terr = sm.RemoveSystem(record.Id)\n\t\tassert.NoError(t, err, \"RemoveSystem should succeed\")\n\n\t\t// Verify the system is removed\n\t\tassert.False(t, sm.HasSystem(record.Id), \"System should be removed after RemoveSystem\")\n\n\t\t// Try to remove it again - should return an error\n\t\terr = sm.RemoveSystem(record.Id)\n\t\tassert.Error(t, err, \"RemoveSystem should fail for non-existent system\")\n\n\t\t// Add the system back\n\t\terr = sm.AddRecord(record, nil)\n\t\trequire.NoError(t, err, \"AddRecord should succeed\")\n\n\t\t// Verify the system is back in the store\n\t\tassert.True(t, sm.HasSystem(record.Id), \"System should exist after re-adding\")\n\n\t\t// Verify a new context was created\n\t\tnewCtx, newCancel, err := sm.GetSystemContextFromStore(record.Id)\n\t\tassert.NoError(t, err)\n\t\tassert.NotNil(t, newCtx, \"New system context should not be nil\")\n\t\tassert.NotNil(t, newCancel, \"New system cancel function should not be nil\")\n\t\tassert.NotEqual(t, originalCtx, newCtx, \"New context should be different from original\")\n\n\t\t// Clean up\n\t\terr = sm.RemoveSystem(record.Id)\n\t\tassert.NoError(t, err)\n\t})\n}\n", "n_tokens": 2556, "primary_symbol": "testOld", "primary_kind": "function", "primary_span": [134, 423], "def_symbols": ["testOld"], "symbols": ["testOld", "func", "testing", "hub", "tests", "TestHub", "user", "err", "CreateUser", "test", "testy", "com", "testtesttest", "require", "NoError", "GetSystemManager", "assert", "NotNil", "error", "expected", "when", "creating", "with", "duplicate", "email", "Error", "Test", "collection", "existence", "todo", "move", "package", "Run", "CollectionExistence", "Verify", "that", "required", "collections", "exist", "systems", "FindCachedCollectionByNameOrId", "systemStats", "system_stats", "containerStats", "container_stats", "RemoveSystem", "Get", "the", "count", "before", "adding", "system", "countBefore", "GetSystemCount", "Create", "record", "CreateRecord", "map", "string", "any", "name", "even", "got", "lost", "coney", "island", "host", "but", "they", "found", "port", "users", "increased", "countAfterAdd", "Equal", "System", "should", "increase", "after", "via", "event", "hook", "exists", "True", "HasSystem", "store", "Remove", "Check", "decreased", "countAfterRemove", "decrease", "removing", "longer", "False", "not", "removal", "list", "all", "IDs", "ids", "GetAllSystemIDs", "NotContains", "status", "empty", "GetSystemStatusFromStore", "Try", "remove", "again", "return", "since", "already", "removed", "NewRecordPending", "and", "you", "know", "feel", "very", "bad", "Add", "manager", "AddRecord", "nil", "filtering", "records", "pending", "now", "filter", "pendingSystems", "FindRecordsByFilter", "created", "GreaterOrEqual", "len", "SystemStatusUpdate", "used", "sleep", "beach", "overnight", "here", "changes", "initialStatus", "Set", "new", "SetSystemStatusInDB", "was", "updated", "newStatus", "NotEqual", "Status", "have", "changed", "database", "updatedRecord", "FindRecordById", "Database", "match", "HandleSystemData", "things", "dont", "anymore", "data", "testData", "CombinedData", "Info", "Hostname", "example", "KernelVersion", "generic", "Cores", "Threads", "CpuModel", "CPU", "Uptime", "Cpu", "MemPct", "DiskPct", "Bandwidth", "AgentVersion", "Stats", "Mem", "MemUsed", "DiskTotal", "DiskUsed", "NetworkSent", "NetworkRecv", "Containers", "container", "handling", "alerts", "HandleSystemAlerts", "ErrorHandling", "add", "non", "existent", "nonExistentId", "non_existent_id", "invalid", "Host", "AddSystem", "ConcurrentOperations", "jfkjahkfajs", "localhost", "concurrent", "operations", "const", "goroutines", "var", "sync", "WaitGroup", "for", "range", "int", "defer", "Done", "Alternate", "between", "different", "switch", "case", "fmt", "Sprintf", "GetSystemHostPort", "Wait", "still", "valid", "state", "NotEmpty", "ContextCancellation", "lkhsdfsjf", "Store", "original", "context", "cancel", "function", "originalCtx", "originalCancel", "GetSystemContextFromStore", "Ensure", "Cancel", "short", "time", "cancellation", "propagate", "Sleep", "Millisecond", "done", "select", "Context", "properly", "cancelled", "default", "Fatal", "shouldn", "Explicitly", "succeed", "fail"], "doc_head": "func testOld(t *testing.T, hub *tests.TestHub) {\n\tuser, err := tests.CreateUser(hub, \"test@testy.com\", \"testtesttest\")\n\trequire.NoError(t, err)\n\tsm := hub.GetSystemManager()\n\tassert.NotNil(t, sm)\n\t// error expected when creating a user with a duplicate email\n\t_, err = tests.CreateUser(hub, \"test@test.com\", \"testtesttest\")\n\trequire.Error(t, err)\n\t// Test collection existence. todo: move to hub package tests\n\tt.Run(\"CollectionExistence\", func(t *testing.T) {\n\t\t// Verify that required collections exist\n\t\tsystems, err := hub.FindCachedCollectionByNameOrId(\"systems\")\n\t\trequire.NoError(t, err)\n\t\tassert.NotNil(t, systems)\n\t\tsystemStats, err := hub.FindCachedCollectionByNameOrId(\"system_stats\")\n\t\trequire.NoError(t, err)\n\t\tassert.NotNil(t, systemStats)\n\t\tcontainerStats, err := hub.FindCachedCollectionByNameOrId(\"container_stats\")\n\t\trequire.NoError(t, err)\n\t\tassert.NotNil(t, containerStats)\n\t})\n\tt.Run(\"RemoveSystem\", func(t *testing.T) {\n\t\t// Get the count before adding the system\n\t\tcountBefore := sm.GetSystemCount()\n\t\t// Create a test system record\n\t\trecord, err := tests.CreateRecord(hub, \"systems\", map[string]any{\n\t\t\t\"name\":  \"i-even-got-lost-at-coney-island\",\n\t\t\t\"host\":  \"but-they-found-m"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 2, "text": "package systems\n", "n_tokens": 3, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 2], "def_symbols": [], "symbols": ["package", "systems"], "doc_head": "package systems"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 3, "end_line": 39, "text": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/hub/ws\"\n\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/henrygd/beszel/src/common\"\n\n\t\"github.com/henrygd/beszel\"\n\n\t\"github.com/blang/semver\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tools/store\"\n\t\"golang.org/x/crypto/ssh\"\n)\n\n// System status constants\nconst (\n\tup      string = \"up\"      // System is online and responding\n\tdown    string = \"down\"    // System is offline or not responding\n\tpaused  string = \"paused\"  // System monitoring is paused\n\tpending string = \"pending\" // System is waiting on initial connection result\n\n\t// interval is the default update interval in milliseconds (60 seconds)\n\tinterval int = 60_000\n\t// interval int = 10_000 // Debug interval for faster updates\n\n\t// sessionTimeout is the maximum time to wait for SSH connections\n\tsessionTimeout = 4 * time.Second\n)\n\n// errSystemExists is returned when attempting to add a system that already exists\nvar errSystemExists = errors.New(\"system exists\")\n", "n_tokens": 267, "primary_symbol": "", "primary_kind": "", "primary_span": [3, 39], "def_symbols": [], "symbols": ["import", "errors", "fmt", "time", "github", "com", "henrygd", "beszel", "src", "hub", "entities", "system", "common", "blang", "semver", "pocketbase", "core", "tools", "store", "golang", "org", "crypto", "ssh", "System", "status", "constants", "const", "string", "online", "and", "responding", "down", "offline", "not", "paused", "monitoring", "pending", "waiting", "initial", "connection", "result", "interval", "the", "default", "update", "milliseconds", "seconds", "int", "Debug", "for", "faster", "updates", "sessionTimeout", "maximum", "wait", "SSH", "connections", "Second", "errSystemExists", "returned", "when", "attempting", "add", "that", "already", "exists", "var", "New"], "doc_head": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/hub/ws\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/henrygd/beszel/src/common\"\n\t\"github.com/henrygd/beszel\"\n\t\"github.com/blang/semver\"\n\t\"github.com/pocketbase/pocketbase/core\"\n\t\"github.com/pocketbase/pocketbase/tools/store\"\n\t\"golang.org/x/crypto/ssh\"\n)\n// System status constants\nconst (\n\tup      string = \"up\"      // System is online and responding\n\tdown    string = \"down\"    // System is offline or not responding\n\tpaused  string = \"paused\"  // System monitoring is paused\n\tpending string = \"pending\" // System is waiting on initial connection result\n\t// interval is the default update interval in milliseconds (60 seconds)\n\tinterval int = 60_000\n\t// interval int = 10_000 // Debug interval for faster updates\n\t// sessionTimeout is the maximum time to wait for SSH connections\n\tsessionTimeout = 4 * time.Second\n)\n// errSystemExists is returned when attempting to add a system that already exists\nvar errSystemExists = errors.New(\"system exists\")"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 40, "end_line": 56, "text": "// SystemManager manages a collection of monitored systems and their connections.\n// It handles system lifecycle, status updates, and maintains both SSH and WebSocket connections.\ntype SystemManager struct {\n\thub       hubLike                       // Hub interface for database and alert operations\n\tsystems   *store.Store[string, *System] // Thread-safe store of active systems\n\tsshConfig *ssh.ClientConfig             // SSH client configuration for system connections\n}\n\n// hubLike defines the interface requirements for the hub dependency.\n// It extends core.App with system-specific functionality.\ntype hubLike interface {\n\tcore.App\n\tGetSSHKey(dataDir string) (ssh.Signer, error)\n\tHandleSystemAlerts(systemRecord *core.Record, data *system.CombinedData) error\n\tHandleStatusAlerts(status string, systemRecord *core.Record) error\n}\n", "n_tokens": 168, "primary_symbol": "", "primary_kind": "", "primary_span": [40, 56], "def_symbols": [], "symbols": ["SystemManager", "manages", "collection", "monitored", "systems", "and", "their", "connections", "handles", "system", "lifecycle", "status", "updates", "maintains", "both", "SSH", "WebSocket", "type", "struct", "hub", "hubLike", "Hub", "interface", "for", "database", "alert", "operations", "store", "Store", "string", "System", "Thread", "safe", "active", "sshConfig", "ssh", "ClientConfig", "client", "configuration", "defines", "the", "requirements", "dependency", "extends", "core", "App", "with", "specific", "functionality", "GetSSHKey", "dataDir", "Signer", "error", "HandleSystemAlerts", "systemRecord", "Record", "data", "CombinedData", "HandleStatusAlerts"], "doc_head": "// SystemManager manages a collection of monitored systems and their connections.\n// It handles system lifecycle, status updates, and maintains both SSH and WebSocket connections.\ntype SystemManager struct {\n\thub       hubLike                       // Hub interface for database and alert operations\n\tsystems   *store.Store[string, *System] // Thread-safe store of active systems\n\tsshConfig *ssh.ClientConfig             // SSH client configuration for system connections\n}\n// hubLike defines the interface requirements for the hub dependency.\n// It extends core.App with system-specific functionality.\ntype hubLike interface {\n\tcore.App\n\tGetSSHKey(dataDir string) (ssh.Signer, error)\n\tHandleSystemAlerts(systemRecord *core.Record, data *system.CombinedData) error\n\tHandleStatusAlerts(status string, systemRecord *core.Record) error\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 57, "end_line": 65, "text": "// NewSystemManager creates a new SystemManager instance with the provided hub.\n// The hub must implement the hubLike interface to provide database and alert functionality.\nfunc NewSystemManager(hub hubLike) *SystemManager {\n\treturn &SystemManager{\n\t\tsystems: store.New(map[string]*System{}),\n\t\thub:     hub,\n\t}\n}\n", "n_tokens": 71, "primary_symbol": "NewSystemManager", "primary_kind": "function", "primary_span": [59, 65], "def_symbols": ["NewSystemManager"], "symbols": ["NewSystemManager", "creates", "new", "SystemManager", "instance", "with", "the", "provided", "hub", "The", "must", "implement", "hubLike", "interface", "provide", "database", "and", "alert", "functionality", "func", "return", "systems", "store", "New", "map", "string", "System"], "doc_head": "// NewSystemManager creates a new SystemManager instance with the provided hub.\n// The hub must implement the hubLike interface to provide database and alert functionality.\nfunc NewSystemManager(hub hubLike) *SystemManager {\n\treturn &SystemManager{\n\t\tsystems: store.New(map[string]*System{}),\n\t\thub:     hub,\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 66, "end_line": 99, "text": "// Initialize sets up the system manager by binding event hooks and starting existing systems.\n// It configures SSH client settings and begins monitoring all non-paused systems from the database.\n// Systems are started with staggered delays to prevent overwhelming the hub during startup.\nfunc (sm *SystemManager) Initialize() error {\n\tsm.bindEventHooks()\n\n\t// Initialize SSH client configuration\n\terr := sm.createSSHClientConfig()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Load existing systems from database (excluding paused ones)\n\tvar systems []*System\n\terr = sm.hub.DB().NewQuery(\"SELECT id, host, port, status FROM systems WHERE status != 'paused'\").All(&systems)\n\tif err != nil || len(systems) == 0 {\n\t\treturn err\n\t}\n\n\t// Start systems in background with staggered timing\n\tgo func() {\n\t\t// Calculate staggered delay between system starts (max 2 seconds per system)\n\t\tdelta := interval / max(1, len(systems))\n\t\tdelta = min(delta, 2_000)\n\t\tsleepTime := time.Duration(delta) * time.Millisecond\n\n\t\tfor _, system := range systems {\n\t\t\ttime.Sleep(sleepTime)\n\t\t\t_ = sm.AddSystem(system)\n\t\t}\n\t}()\n\treturn nil\n}\n", "n_tokens": 263, "primary_symbol": "Initialize", "primary_kind": "function", "primary_span": [69, 99], "def_symbols": ["Initialize"], "symbols": ["Initialize", "sets", "the", "system", "manager", "binding", "event", "hooks", "and", "starting", "existing", "systems", "configures", "SSH", "client", "settings", "begins", "monitoring", "all", "non", "paused", "from", "database", "Systems", "are", "started", "with", "staggered", "delays", "prevent", "overwhelming", "hub", "during", "startup", "func", "SystemManager", "error", "bindEventHooks", "configuration", "err", "createSSHClientConfig", "nil", "return", "Load", "excluding", "ones", "var", "System", "NewQuery", "SELECT", "host", "port", "status", "FROM", "WHERE", "All", "len", "Start", "background", "timing", "Calculate", "delay", "between", "starts", "max", "seconds", "per", "delta", "interval", "min", "sleepTime", "time", "Duration", "Millisecond", "for", "range", "Sleep", "AddSystem"], "doc_head": "// Initialize sets up the system manager by binding event hooks and starting existing systems.\n// It configures SSH client settings and begins monitoring all non-paused systems from the database.\n// Systems are started with staggered delays to prevent overwhelming the hub during startup.\nfunc (sm *SystemManager) Initialize() error {\n\tsm.bindEventHooks()\n\t// Initialize SSH client configuration\n\terr := sm.createSSHClientConfig()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Load existing systems from database (excluding paused ones)\n\tvar systems []*System\n\terr = sm.hub.DB().NewQuery(\"SELECT id, host, port, status FROM systems WHERE status != 'paused'\").All(&systems)\n\tif err != nil || len(systems) == 0 {\n\t\treturn err\n\t}\n\t// Start systems in background with staggered timing\n\tgo func() {\n\t\t// Calculate staggered delay between system starts (max 2 seconds per system)\n\t\tdelta := interval / max(1, len(systems))\n\t\tdelta = min(delta, 2_000)\n\t\tsleepTime := time.Duration(delta) * time.Millisecond\n\t\tfor _, system := range systems {\n\t\t\ttime.Sleep(sleepTime)\n\t\t\t_ = sm.AddSystem(system)\n\t\t}\n\t}()\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 100, "end_line": 110, "text": "// bindEventHooks registers event handlers for system and fingerprint record changes.\n// These hooks ensure the system manager stays synchronized with database changes.\nfunc (sm *SystemManager) bindEventHooks() {\n\tsm.hub.OnRecordCreate(\"systems\").BindFunc(sm.onRecordCreate)\n\tsm.hub.OnRecordAfterCreateSuccess(\"systems\").BindFunc(sm.onRecordAfterCreateSuccess)\n\tsm.hub.OnRecordUpdate(\"systems\").BindFunc(sm.onRecordUpdate)\n\tsm.hub.OnRecordAfterUpdateSuccess(\"systems\").BindFunc(sm.onRecordAfterUpdateSuccess)\n\tsm.hub.OnRecordAfterDeleteSuccess(\"systems\").BindFunc(sm.onRecordAfterDeleteSuccess)\n\tsm.hub.OnRecordAfterUpdateSuccess(\"fingerprints\").BindFunc(sm.onTokenRotated)\n}\n", "n_tokens": 152, "primary_symbol": "bindEventHooks", "primary_kind": "function", "primary_span": [102, 110], "def_symbols": ["bindEventHooks"], "symbols": ["bindEventHooks", "registers", "event", "handlers", "for", "system", "and", "fingerprint", "record", "changes", "These", "hooks", "ensure", "the", "manager", "stays", "synchronized", "with", "database", "func", "SystemManager", "hub", "OnRecordCreate", "systems", "BindFunc", "onRecordCreate", "OnRecordAfterCreateSuccess", "onRecordAfterCreateSuccess", "OnRecordUpdate", "onRecordUpdate", "OnRecordAfterUpdateSuccess", "onRecordAfterUpdateSuccess", "OnRecordAfterDeleteSuccess", "onRecordAfterDeleteSuccess", "fingerprints", "onTokenRotated"], "doc_head": "// bindEventHooks registers event handlers for system and fingerprint record changes.\n// These hooks ensure the system manager stays synchronized with database changes.\nfunc (sm *SystemManager) bindEventHooks() {\n\tsm.hub.OnRecordCreate(\"systems\").BindFunc(sm.onRecordCreate)\n\tsm.hub.OnRecordAfterCreateSuccess(\"systems\").BindFunc(sm.onRecordAfterCreateSuccess)\n\tsm.hub.OnRecordUpdate(\"systems\").BindFunc(sm.onRecordUpdate)\n\tsm.hub.OnRecordAfterUpdateSuccess(\"systems\").BindFunc(sm.onRecordAfterUpdateSuccess)\n\tsm.hub.OnRecordAfterDeleteSuccess(\"systems\").BindFunc(sm.onRecordAfterDeleteSuccess)\n\tsm.hub.OnRecordAfterUpdateSuccess(\"fingerprints\").BindFunc(sm.onTokenRotated)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 111, "end_line": 128, "text": "// onTokenRotated handles fingerprint token rotation events.\n// When a system's authentication token is rotated, any existing WebSocket connection\n// must be closed to force re-authentication with the new token.\nfunc (sm *SystemManager) onTokenRotated(e *core.RecordEvent) error {\n\tsystemID := e.Record.GetString(\"system\")\n\tsystem, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn e.Next()\n\t}\n\t// No need to close connection if not connected via websocket\n\tif system.WsConn == nil {\n\t\treturn e.Next()\n\t}\n\tsystem.setDown(nil)\n\tsm.RemoveSystem(systemID)\n\treturn e.Next()\n}\n", "n_tokens": 135, "primary_symbol": "onTokenRotated", "primary_kind": "function", "primary_span": [114, 128], "def_symbols": ["onTokenRotated"], "symbols": ["onTokenRotated", "handles", "fingerprint", "token", "rotation", "events", "When", "system", "authentication", "rotated", "any", "existing", "WebSocket", "connection", "must", "closed", "force", "with", "the", "new", "func", "SystemManager", "core", "RecordEvent", "error", "systemID", "Record", "GetString", "systems", "GetOk", "return", "Next", "need", "close", "not", "connected", "via", "websocket", "WsConn", "nil", "setDown", "RemoveSystem"], "doc_head": "// onTokenRotated handles fingerprint token rotation events.\n// When a system's authentication token is rotated, any existing WebSocket connection\n// must be closed to force re-authentication with the new token.\nfunc (sm *SystemManager) onTokenRotated(e *core.RecordEvent) error {\n\tsystemID := e.Record.GetString(\"system\")\n\tsystem, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn e.Next()\n\t}\n\t// No need to close connection if not connected via websocket\n\tif system.WsConn == nil {\n\t\treturn e.Next()\n\t}\n\tsystem.setDown(nil)\n\tsm.RemoveSystem(systemID)\n\treturn e.Next()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 129, "end_line": 145, "text": "// onRecordCreate is called before a new system record is committed to the database.\n// It initializes the record with default values: empty info and pending status.\nfunc (sm *SystemManager) onRecordCreate(e *core.RecordEvent) error {\n\te.Record.Set(\"info\", system.Info{})\n\te.Record.Set(\"status\", pending)\n\treturn e.Next()\n}\n\n// onRecordAfterCreateSuccess is called after a new system record is successfully created.\n// It adds the new system to the manager to begin monitoring.\nfunc (sm *SystemManager) onRecordAfterCreateSuccess(e *core.RecordEvent) error {\n\tif err := sm.AddRecord(e.Record, nil); err != nil {\n\t\te.App.Logger().Error(\"Error adding record\", \"err\", err)\n\t}\n\treturn e.Next()\n}\n", "n_tokens": 160, "primary_symbol": "onRecordCreate", "primary_kind": "function", "primary_span": [131, 145], "def_symbols": ["onRecordCreate", "onRecordAfterCreateSuccess"], "symbols": ["onRecordCreate", "onRecordAfterCreateSuccess", "called", "before", "new", "system", "record", "committed", "the", "database", "initializes", "with", "default", "values", "empty", "info", "and", "pending", "status", "func", "SystemManager", "core", "RecordEvent", "error", "Record", "Set", "Info", "return", "Next", "after", "successfully", "created", "adds", "manager", "begin", "monitoring", "err", "AddRecord", "nil", "App", "Logger", "Error", "adding"], "doc_head": "// onRecordCreate is called before a new system record is committed to the database.\n// It initializes the record with default values: empty info and pending status.\nfunc (sm *SystemManager) onRecordCreate(e *core.RecordEvent) error {\n\te.Record.Set(\"info\", system.Info{})\n\te.Record.Set(\"status\", pending)\n\treturn e.Next()\n}\n// onRecordAfterCreateSuccess is called after a new system record is successfully created.\n// It adds the new system to the manager to begin monitoring.\nfunc (sm *SystemManager) onRecordAfterCreateSuccess(e *core.RecordEvent) error {\n\tif err := sm.AddRecord(e.Record, nil); err != nil {\n\t\te.App.Logger().Error(\"Error adding record\", \"err\", err)\n\t}\n\treturn e.Next()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 146, "end_line": 154, "text": "// onRecordUpdate is called before a system record is updated in the database.\n// It clears system info when the status is changed to paused.\nfunc (sm *SystemManager) onRecordUpdate(e *core.RecordEvent) error {\n\tif e.Record.GetString(\"status\") == paused {\n\t\te.Record.Set(\"info\", system.Info{})\n\t}\n\treturn e.Next()\n}\n", "n_tokens": 74, "primary_symbol": "onRecordUpdate", "primary_kind": "function", "primary_span": [148, 154], "def_symbols": ["onRecordUpdate"], "symbols": ["onRecordUpdate", "called", "before", "system", "record", "updated", "the", "database", "clears", "info", "when", "status", "changed", "paused", "func", "SystemManager", "core", "RecordEvent", "error", "Record", "GetString", "Set", "Info", "return", "Next"], "doc_head": "// onRecordUpdate is called before a system record is updated in the database.\n// It clears system info when the status is changed to paused.\nfunc (sm *SystemManager) onRecordUpdate(e *core.RecordEvent) error {\n\tif e.Record.GetString(\"status\") == paused {\n\t\te.Record.Set(\"info\", system.Info{})\n\t}\n\treturn e.Next()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 155, "end_line": 213, "text": "// onRecordAfterUpdateSuccess handles system record updates after they're committed to the database.\n// It manages system lifecycle based on status changes and triggers appropriate alerts.\n// Status transitions are handled as follows:\n// - paused: Closes SSH connection and deactivates alerts\n// - pending: Starts monitoring (reuses WebSocket if available)\n// - up: Triggers system alerts\n// - down: Triggers status change alerts\nfunc (sm *SystemManager) onRecordAfterUpdateSuccess(e *core.RecordEvent) error {\n\tnewStatus := e.Record.GetString(\"status\")\n\tprevStatus := pending\n\tsystem, ok := sm.systems.GetOk(e.Record.Id)\n\tif ok {\n\t\tprevStatus = system.Status\n\t\tsystem.Status = newStatus\n\t}\n\n\tswitch newStatus {\n\tcase paused:\n\t\tif ok {\n\t\t\t// Pause monitoring but keep system in manager for potential resume\n\t\t\tsystem.closeSSHConnection()\n\t\t}\n\t\t_ = deactivateAlerts(e.App, e.Record.Id)\n\t\treturn e.Next()\n\tcase pending:\n\t\t// Resume monitoring, preferring existing WebSocket connection\n\t\tif ok && system.WsConn != nil {\n\t\t\tgo system.update()\n\t\t\treturn e.Next()\n\t\t}\n\t\t// Start new monitoring session\n\t\tif err := sm.AddRecord(e.Record, nil); err != nil {\n\t\t\te.App.Logger().Error(\"Error adding record\", \"err\", err)\n\t\t}\n\t\t_ = deactivateAlerts(e.App, e.Record.Id)\n\t\treturn e.Next()\n\t}\n\n\t// Handle systems not in manager\n\tif !ok {\n\t\treturn sm.AddRecord(e.Record, nil)\n\t}\n\n\t// Trigger system alerts when system comes online\n\tif newStatus == up {\n\t\tif err := sm.hub.HandleSystemAlerts(e.Record, system.data); err != nil {\n\t\t\te.App.Logger().Error(\"Error handling system alerts\", \"err\", err)\n\t\t}\n\t}\n\n\t// Trigger status change alerts for up/down transitions\n\tif (newStatus == down && prevStatus == up) || (newStatus == up && prevStatus == down) {\n\t\tif err := sm.hub.HandleStatusAlerts(newStatus, e.Record); err != nil {\n\t\t\te.App.Logger().Error(\"Error handling status alerts\", \"err\", err)\n\t\t}\n\t}\n\treturn e.Next()\n}\n", "n_tokens": 474, "primary_symbol": "onRecordAfterUpdateSuccess", "primary_kind": "function", "primary_span": [162, 213], "def_symbols": ["onRecordAfterUpdateSuccess"], "symbols": ["onRecordAfterUpdateSuccess", "handles", "system", "record", "updates", "after", "they", "committed", "the", "database", "manages", "lifecycle", "based", "status", "changes", "and", "triggers", "appropriate", "alerts", "Status", "transitions", "are", "handled", "follows", "paused", "Closes", "SSH", "connection", "deactivates", "pending", "Starts", "monitoring", "reuses", "WebSocket", "available", "Triggers", "down", "change", "func", "SystemManager", "core", "RecordEvent", "error", "newStatus", "Record", "GetString", "prevStatus", "systems", "GetOk", "switch", "case", "Pause", "but", "keep", "manager", "for", "potential", "resume", "closeSSHConnection", "deactivateAlerts", "App", "return", "Next", "Resume", "preferring", "existing", "WsConn", "nil", "update", "Start", "new", "session", "err", "AddRecord", "Logger", "Error", "adding", "Handle", "not", "Trigger", "when", "comes", "online", "hub", "HandleSystemAlerts", "data", "handling", "HandleStatusAlerts"], "doc_head": "// onRecordAfterUpdateSuccess handles system record updates after they're committed to the database.\n// It manages system lifecycle based on status changes and triggers appropriate alerts.\n// Status transitions are handled as follows:\n// - paused: Closes SSH connection and deactivates alerts\n// - pending: Starts monitoring (reuses WebSocket if available)\n// - up: Triggers system alerts\n// - down: Triggers status change alerts\nfunc (sm *SystemManager) onRecordAfterUpdateSuccess(e *core.RecordEvent) error {\n\tnewStatus := e.Record.GetString(\"status\")\n\tprevStatus := pending\n\tsystem, ok := sm.systems.GetOk(e.Record.Id)\n\tif ok {\n\t\tprevStatus = system.Status\n\t\tsystem.Status = newStatus\n\t}\n\tswitch newStatus {\n\tcase paused:\n\t\tif ok {\n\t\t\t// Pause monitoring but keep system in manager for potential resume\n\t\t\tsystem.closeSSHConnection()\n\t\t}\n\t\t_ = deactivateAlerts(e.App, e.Record.Id)\n\t\treturn e.Next()\n\tcase pending:\n\t\t// Resume monitoring, preferring existing WebSocket connection\n\t\tif ok && system.WsConn != nil {\n\t\t\tgo system.update()\n\t\t\treturn e.Next()\n\t\t}\n\t\t// Start new monitoring session\n\t\tif err := sm.AddRecord(e.Record, nil); err != nil {\n\t\t\te.App.Logger().Error(\"Error adding record\", \"err"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#11", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 11, "start_line": 214, "end_line": 220, "text": "// onRecordAfterDeleteSuccess is called after a system record is successfully deleted.\n// It removes the system from the manager and cleans up all associated resources.\nfunc (sm *SystemManager) onRecordAfterDeleteSuccess(e *core.RecordEvent) error {\n\tsm.RemoveSystem(e.Record.Id)\n\treturn e.Next()\n}\n", "n_tokens": 63, "primary_symbol": "onRecordAfterDeleteSuccess", "primary_kind": "function", "primary_span": [216, 220], "def_symbols": ["onRecordAfterDeleteSuccess"], "symbols": ["onRecordAfterDeleteSuccess", "called", "after", "system", "record", "successfully", "deleted", "removes", "the", "from", "manager", "and", "cleans", "all", "associated", "resources", "func", "SystemManager", "core", "RecordEvent", "error", "RemoveSystem", "Record", "return", "Next"], "doc_head": "// onRecordAfterDeleteSuccess is called after a system record is successfully deleted.\n// It removes the system from the manager and cleans up all associated resources.\nfunc (sm *SystemManager) onRecordAfterDeleteSuccess(e *core.RecordEvent) error {\n\tsm.RemoveSystem(e.Record.Id)\n\treturn e.Next()\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#12", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 12, "start_line": 221, "end_line": 242, "text": "// AddSystem adds a system to the manager and starts monitoring it.\n// It validates required fields, initializes the system context, and starts the update goroutine.\n// Returns error if a system with the same ID already exists.\nfunc (sm *SystemManager) AddSystem(sys *System) error {\n\tif sm.systems.Has(sys.Id) {\n\t\treturn errSystemExists\n\t}\n\tif sys.Id == \"\" || sys.Host == \"\" {\n\t\treturn errors.New(\"system missing required fields\")\n\t}\n\n\t// Initialize system for monitoring\n\tsys.manager = sm\n\tsys.ctx, sys.cancel = sys.getContext()\n\tsys.data = &system.CombinedData{}\n\tsm.systems.Set(sys.Id, sys)\n\n\t// Start monitoring in background\n\tgo sys.StartUpdater()\n\treturn nil\n}\n", "n_tokens": 156, "primary_symbol": "AddSystem", "primary_kind": "function", "primary_span": [224, 242], "def_symbols": ["AddSystem"], "symbols": ["AddSystem", "adds", "system", "the", "manager", "and", "starts", "monitoring", "validates", "required", "fields", "initializes", "context", "update", "goroutine", "Returns", "error", "with", "same", "already", "exists", "func", "SystemManager", "sys", "System", "systems", "Has", "return", "errSystemExists", "Host", "errors", "New", "missing", "Initialize", "for", "ctx", "cancel", "getContext", "data", "CombinedData", "Set", "Start", "background", "StartUpdater", "nil"], "doc_head": "// AddSystem adds a system to the manager and starts monitoring it.\n// It validates required fields, initializes the system context, and starts the update goroutine.\n// Returns error if a system with the same ID already exists.\nfunc (sm *SystemManager) AddSystem(sys *System) error {\n\tif sm.systems.Has(sys.Id) {\n\t\treturn errSystemExists\n\t}\n\tif sys.Id == \"\" || sys.Host == \"\" {\n\t\treturn errors.New(\"system missing required fields\")\n\t}\n\t// Initialize system for monitoring\n\tsys.manager = sm\n\tsys.ctx, sys.cancel = sys.getContext()\n\tsys.data = &system.CombinedData{}\n\tsm.systems.Set(sys.Id, sys)\n\t// Start monitoring in background\n\tgo sys.StartUpdater()\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#13", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 13, "start_line": 243, "end_line": 263, "text": "// RemoveSystem removes a system from the manager and cleans up all associated resources.\n// It cancels the system's context, closes all connections, and removes it from the store.\n// Returns an error if the system is not found.\nfunc (sm *SystemManager) RemoveSystem(systemID string) error {\n\tsystem, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn errors.New(\"system not found\")\n\t}\n\n\t// Stop the update goroutine\n\tif system.cancel != nil {\n\t\tsystem.cancel()\n\t}\n\n\t// Clean up all connections\n\tsystem.closeSSHConnection()\n\tsystem.closeWebSocketConnection()\n\tsm.systems.Remove(systemID)\n\treturn nil\n}\n", "n_tokens": 137, "primary_symbol": "RemoveSystem", "primary_kind": "function", "primary_span": [246, 263], "def_symbols": ["RemoveSystem"], "symbols": ["RemoveSystem", "removes", "system", "from", "the", "manager", "and", "cleans", "all", "associated", "resources", "cancels", "context", "closes", "connections", "store", "Returns", "error", "not", "found", "func", "SystemManager", "systemID", "string", "systems", "GetOk", "return", "errors", "New", "Stop", "update", "goroutine", "cancel", "nil", "Clean", "closeSSHConnection", "closeWebSocketConnection", "Remove"], "doc_head": "// RemoveSystem removes a system from the manager and cleans up all associated resources.\n// It cancels the system's context, closes all connections, and removes it from the store.\n// Returns an error if the system is not found.\nfunc (sm *SystemManager) RemoveSystem(systemID string) error {\n\tsystem, ok := sm.systems.GetOk(systemID)\n\tif !ok {\n\t\treturn errors.New(\"system not found\")\n\t}\n\t// Stop the update goroutine\n\tif system.cancel != nil {\n\t\tsystem.cancel()\n\t}\n\t// Clean up all connections\n\tsystem.closeSSHConnection()\n\tsystem.closeWebSocketConnection()\n\tsm.systems.Remove(systemID)\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#14", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 14, "start_line": 264, "end_line": 286, "text": "// AddRecord creates a System instance from a database record and adds it to the manager.\n// If a system with the same ID already exists, it's removed first to ensure clean state.\n// If no system instance is provided, a new one is created.\n// This method is typically called when systems are created or their status changes to pending.\nfunc (sm *SystemManager) AddRecord(record *core.Record, system *System) (err error) {\n\t// Remove existing system to ensure clean state\n\tif sm.systems.Has(record.Id) {\n\t\t_ = sm.RemoveSystem(record.Id)\n\t}\n\n\t// Create new system if none provided\n\tif system == nil {\n\t\tsystem = sm.NewSystem(record.Id)\n\t}\n\n\t// Populate system from record\n\tsystem.Status = record.GetString(\"status\")\n\tsystem.Host = record.GetString(\"host\")\n\tsystem.Port = record.GetString(\"port\")\n\n\treturn sm.AddSystem(system)\n}\n", "n_tokens": 186, "primary_symbol": "AddRecord", "primary_kind": "function", "primary_span": [268, 286], "def_symbols": ["AddRecord"], "symbols": ["AddRecord", "creates", "System", "instance", "from", "database", "record", "and", "adds", "the", "manager", "system", "with", "same", "already", "exists", "removed", "first", "ensure", "clean", "state", "provided", "new", "one", "created", "This", "method", "typically", "called", "when", "systems", "are", "their", "status", "changes", "pending", "func", "SystemManager", "core", "Record", "err", "error", "Remove", "existing", "Has", "RemoveSystem", "Create", "none", "nil", "NewSystem", "Populate", "Status", "GetString", "Host", "host", "Port", "port", "return", "AddSystem"], "doc_head": "// AddRecord creates a System instance from a database record and adds it to the manager.\n// If a system with the same ID already exists, it's removed first to ensure clean state.\n// If no system instance is provided, a new one is created.\n// This method is typically called when systems are created or their status changes to pending.\nfunc (sm *SystemManager) AddRecord(record *core.Record, system *System) (err error) {\n\t// Remove existing system to ensure clean state\n\tif sm.systems.Has(record.Id) {\n\t\t_ = sm.RemoveSystem(record.Id)\n\t}\n\t// Create new system if none provided\n\tif system == nil {\n\t\tsystem = sm.NewSystem(record.Id)\n\t}\n\t// Populate system from record\n\tsystem.Status = record.GetString(\"status\")\n\tsystem.Host = record.GetString(\"host\")\n\tsystem.Port = record.GetString(\"port\")\n\treturn sm.AddSystem(system)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#15", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 15, "start_line": 287, "end_line": 305, "text": "// AddWebSocketSystem creates and adds a system with an established WebSocket connection.\n// This method is called when an agent connects via WebSocket with valid authentication.\n// The system is immediately added to monitoring with the provided connection and version info.\nfunc (sm *SystemManager) AddWebSocketSystem(systemId string, agentVersion semver.Version, wsConn *ws.WsConn) error {\n\tsystemRecord, err := sm.hub.FindRecordById(\"systems\", systemId)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsystem := sm.NewSystem(systemId)\n\tsystem.WsConn = wsConn\n\tsystem.agentVersion = agentVersion\n\n\tif err := sm.AddRecord(systemRecord, system); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "n_tokens": 152, "primary_symbol": "AddWebSocketSystem", "primary_kind": "function", "primary_span": [290, 305], "def_symbols": ["AddWebSocketSystem"], "symbols": ["AddWebSocketSystem", "creates", "and", "adds", "system", "with", "established", "WebSocket", "connection", "This", "method", "called", "when", "agent", "connects", "via", "valid", "authentication", "The", "immediately", "added", "monitoring", "the", "provided", "version", "info", "func", "SystemManager", "systemId", "string", "agentVersion", "semver", "Version", "wsConn", "WsConn", "error", "systemRecord", "err", "hub", "FindRecordById", "systems", "nil", "return", "NewSystem", "AddRecord"], "doc_head": "// AddWebSocketSystem creates and adds a system with an established WebSocket connection.\n// This method is called when an agent connects via WebSocket with valid authentication.\n// The system is immediately added to monitoring with the provided connection and version info.\nfunc (sm *SystemManager) AddWebSocketSystem(systemId string, agentVersion semver.Version, wsConn *ws.WsConn) error {\n\tsystemRecord, err := sm.hub.FindRecordById(\"systems\", systemId)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsystem := sm.NewSystem(systemId)\n\tsystem.WsConn = wsConn\n\tsystem.agentVersion = agentVersion\n\tif err := sm.AddRecord(systemRecord, system); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#16", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 16, "start_line": 306, "end_line": 329, "text": "// createSSHClientConfig initializes the SSH client configuration for connecting to an agent's server\nfunc (sm *SystemManager) createSSHClientConfig() error {\n\tprivateKey, err := sm.hub.GetSSHKey(\"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsm.sshConfig = &ssh.ClientConfig{\n\t\tUser: \"u\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.PublicKeys(privateKey),\n\t\t},\n\t\tConfig: ssh.Config{\n\t\t\tCiphers:      common.DefaultCiphers,\n\t\t\tKeyExchanges: common.DefaultKeyExchanges,\n\t\t\tMACs:         common.DefaultMACs,\n\t\t},\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t\tClientVersion:   fmt.Sprintf(\"SSH-2.0-%s_%s\", beszel.AppName, beszel.Version),\n\t\tTimeout:         sessionTimeout,\n\t}\n\treturn nil\n}\n", "n_tokens": 186, "primary_symbol": "createSSHClientConfig", "primary_kind": "function", "primary_span": [307, 329], "def_symbols": ["createSSHClientConfig"], "symbols": ["createSSHClientConfig", "initializes", "the", "SSH", "client", "configuration", "for", "connecting", "agent", "server", "func", "SystemManager", "error", "privateKey", "err", "hub", "GetSSHKey", "nil", "return", "sshConfig", "ssh", "ClientConfig", "User", "Auth", "AuthMethod", "PublicKeys", "Config", "Ciphers", "common", "DefaultCiphers", "KeyExchanges", "DefaultKeyExchanges", "MACs", "DefaultMACs", "HostKeyCallback", "InsecureIgnoreHostKey", "ClientVersion", "fmt", "Sprintf", "beszel", "AppName", "Version", "Timeout", "sessionTimeout"], "doc_head": "// createSSHClientConfig initializes the SSH client configuration for connecting to an agent's server\nfunc (sm *SystemManager) createSSHClientConfig() error {\n\tprivateKey, err := sm.hub.GetSSHKey(\"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tsm.sshConfig = &ssh.ClientConfig{\n\t\tUser: \"u\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.PublicKeys(privateKey),\n\t\t},\n\t\tConfig: ssh.Config{\n\t\t\tCiphers:      common.DefaultCiphers,\n\t\t\tKeyExchanges: common.DefaultKeyExchanges,\n\t\t\tMACs:         common.DefaultMACs,\n\t\t},\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t\tClientVersion:   fmt.Sprintf(\"SSH-2.0-%s_%s\", beszel.AppName, beszel.Version),\n\t\tTimeout:         sessionTimeout,\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go#17", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/systems/system_manager.go", "rel_path": "src/hub/systems/system_manager.go", "ext": "go", "language": "go", "chunk_number": 17, "start_line": 330, "end_line": 349, "text": "// deactivateAlerts finds all triggered alerts for a system and sets them to inactive.\n// This is called when a system is paused or goes offline to prevent continued alerts.\nfunc deactivateAlerts(app core.App, systemID string) error {\n\t// Note: Direct SQL updates don't trigger SSE, so we use the PocketBase API\n\t// _, err := app.DB().NewQuery(fmt.Sprintf(\"UPDATE alerts SET triggered = false WHERE system = '%s'\", systemID)).Execute()\n\n\talerts, err := app.FindRecordsByFilter(\"alerts\", fmt.Sprintf(\"system = '%s' && triggered = 1\", systemID), \"\", -1, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, alert := range alerts {\n\t\talert.Set(\"triggered\", false)\n\t\tif err := app.SaveNoValidate(alert); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n", "n_tokens": 189, "primary_symbol": "deactivateAlerts", "primary_kind": "function", "primary_span": [332, 349], "def_symbols": ["deactivateAlerts"], "symbols": ["deactivateAlerts", "finds", "all", "triggered", "alerts", "for", "system", "and", "sets", "them", "inactive", "This", "called", "when", "paused", "goes", "offline", "prevent", "continued", "func", "app", "core", "App", "systemID", "string", "error", "Note", "Direct", "SQL", "updates", "don", "trigger", "SSE", "use", "the", "PocketBase", "API", "err", "NewQuery", "fmt", "Sprintf", "UPDATE", "SET", "false", "WHERE", "Execute", "FindRecordsByFilter", "nil", "return", "alert", "range", "Set", "SaveNoValidate"], "doc_head": "// deactivateAlerts finds all triggered alerts for a system and sets them to inactive.\n// This is called when a system is paused or goes offline to prevent continued alerts.\nfunc deactivateAlerts(app core.App, systemID string) error {\n\t// Note: Direct SQL updates don't trigger SSE, so we use the PocketBase API\n\t// _, err := app.DB().NewQuery(fmt.Sprintf(\"UPDATE alerts SET triggered = false WHERE system = '%s'\", systemID)).Execute()\n\talerts, err := app.FindRecordsByFilter(\"alerts\", fmt.Sprintf(\"system = '%s' && triggered = 1\", systemID), \"\", -1, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, alert := range alerts {\n\t\talert.Set(\"triggered\", false)\n\t\tif err := app.SaveNoValidate(alert); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go", "rel_path": "src/hub/ws/ws.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 32, "text": "package ws\n\nimport (\n\t\"errors\"\n\t\"time\"\n\t\"weak\"\n\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\n\t\"github.com/henrygd/beszel/src/common\"\n\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/lxzan/gws\"\n\t\"golang.org/x/crypto/ssh\"\n)\n\nconst (\n\tdeadline = 70 * time.Second\n)\n\n// Handler implements the WebSocket event handler for agent connections.\ntype Handler struct {\n\tgws.BuiltinEventHandler\n}\n\n// WsConn represents a WebSocket connection to an agent.\ntype WsConn struct {\n\tconn         *gws.Conn\n\tresponseChan chan *gws.Message\n\tDownChan     chan struct{}\n}\n", "n_tokens": 148, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 32], "def_symbols": [], "symbols": ["package", "import", "errors", "time", "weak", "github", "com", "henrygd", "beszel", "src", "entities", "system", "common", "fxamacker", "cbor", "lxzan", "gws", "golang", "org", "crypto", "ssh", "const", "deadline", "Second", "Handler", "implements", "the", "WebSocket", "event", "handler", "for", "agent", "connections", "type", "struct", "BuiltinEventHandler", "WsConn", "represents", "connection", "conn", "Conn", "responseChan", "chan", "Message", "DownChan"], "doc_head": "package ws\nimport (\n\t\"errors\"\n\t\"time\"\n\t\"weak\"\n\t\"github.com/henrygd/beszel/src/entities/system\"\n\t\"github.com/henrygd/beszel/src/common\"\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/lxzan/gws\"\n\t\"golang.org/x/crypto/ssh\"\n)\nconst (\n\tdeadline = 70 * time.Second\n)\n// Handler implements the WebSocket event handler for agent connections.\ntype Handler struct {\n\tgws.BuiltinEventHandler\n}\n// WsConn represents a WebSocket connection to an agent.\ntype WsConn struct {\n\tconn         *gws.Conn\n\tresponseChan chan *gws.Message\n\tDownChan     chan struct{}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go", "rel_path": "src/hub/ws/ws.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 33, "end_line": 61, "text": "// FingerprintRecord is fingerprints collection record data in the hub\ntype FingerprintRecord struct {\n\tId          string `db:\"id\"`\n\tSystemId    string `db:\"system\"`\n\tFingerprint string `db:\"fingerprint\"`\n\tToken       string `db:\"token\"`\n}\n\nvar upgrader *gws.Upgrader\n\n// GetUpgrader returns a singleton WebSocket upgrader instance.\nfunc GetUpgrader() *gws.Upgrader {\n\tif upgrader != nil {\n\t\treturn upgrader\n\t}\n\thandler := &Handler{}\n\tupgrader = gws.NewUpgrader(handler, &gws.ServerOption{})\n\treturn upgrader\n}\n\n// NewWsConnection creates a new WebSocket connection wrapper.\nfunc NewWsConnection(conn *gws.Conn) *WsConn {\n\treturn &WsConn{\n\t\tconn:         conn,\n\t\tresponseChan: make(chan *gws.Message, 1),\n\t\tDownChan:     make(chan struct{}, 1),\n\t}\n}\n", "n_tokens": 202, "primary_symbol": "GetUpgrader", "primary_kind": "function", "primary_span": [44, 61], "def_symbols": ["GetUpgrader", "NewWsConnection"], "symbols": ["GetUpgrader", "NewWsConnection", "FingerprintRecord", "fingerprints", "collection", "record", "data", "the", "hub", "type", "struct", "string", "SystemId", "system", "Fingerprint", "fingerprint", "Token", "token", "var", "upgrader", "gws", "Upgrader", "returns", "singleton", "WebSocket", "instance", "func", "nil", "return", "handler", "Handler", "NewUpgrader", "ServerOption", "creates", "new", "connection", "wrapper", "conn", "Conn", "WsConn", "responseChan", "make", "chan", "Message", "DownChan"], "doc_head": "// FingerprintRecord is fingerprints collection record data in the hub\ntype FingerprintRecord struct {\n\tId          string `db:\"id\"`\n\tSystemId    string `db:\"system\"`\n\tFingerprint string `db:\"fingerprint\"`\n\tToken       string `db:\"token\"`\n}\nvar upgrader *gws.Upgrader\n// GetUpgrader returns a singleton WebSocket upgrader instance.\nfunc GetUpgrader() *gws.Upgrader {\n\tif upgrader != nil {\n\t\treturn upgrader\n\t}\n\thandler := &Handler{}\n\tupgrader = gws.NewUpgrader(handler, &gws.ServerOption{})\n\treturn upgrader\n}\n// NewWsConnection creates a new WebSocket connection wrapper.\nfunc NewWsConnection(conn *gws.Conn) *WsConn {\n\treturn &WsConn{\n\t\tconn:         conn,\n\t\tresponseChan: make(chan *gws.Message, 1),\n\t\tDownChan:     make(chan struct{}, 1),\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go", "rel_path": "src/hub/ws/ws.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 62, "end_line": 85, "text": "// OnOpen sets a deadline for the WebSocket connection.\nfunc (h *Handler) OnOpen(conn *gws.Conn) {\n\tconn.SetDeadline(time.Now().Add(deadline))\n}\n\n// OnMessage routes incoming WebSocket messages to the response channel.\nfunc (h *Handler) OnMessage(conn *gws.Conn, message *gws.Message) {\n\tconn.SetDeadline(time.Now().Add(deadline))\n\tif message.Opcode != gws.OpcodeBinary || message.Data.Len() == 0 {\n\t\treturn\n\t}\n\twsConn, ok := conn.Session().Load(\"wsConn\")\n\tif !ok {\n\t\t_ = conn.WriteClose(1000, nil)\n\t\treturn\n\t}\n\tselect {\n\tcase wsConn.(*WsConn).responseChan <- message:\n\tdefault:\n\t\t// close if the connection is not expecting a response\n\t\twsConn.(*WsConn).Close(nil)\n\t}\n}\n", "n_tokens": 183, "primary_symbol": "OnOpen", "primary_kind": "function", "primary_span": [63, 85], "def_symbols": ["OnOpen", "OnMessage"], "symbols": ["OnOpen", "OnMessage", "sets", "deadline", "for", "the", "WebSocket", "connection", "func", "Handler", "conn", "gws", "Conn", "SetDeadline", "time", "Now", "Add", "routes", "incoming", "messages", "response", "channel", "message", "Message", "Opcode", "OpcodeBinary", "Data", "Len", "return", "wsConn", "Session", "Load", "WriteClose", "nil", "select", "case", "WsConn", "responseChan", "default", "close", "not", "expecting", "Close"], "doc_head": "// OnOpen sets a deadline for the WebSocket connection.\nfunc (h *Handler) OnOpen(conn *gws.Conn) {\n\tconn.SetDeadline(time.Now().Add(deadline))\n}\n// OnMessage routes incoming WebSocket messages to the response channel.\nfunc (h *Handler) OnMessage(conn *gws.Conn, message *gws.Message) {\n\tconn.SetDeadline(time.Now().Add(deadline))\n\tif message.Opcode != gws.OpcodeBinary || message.Data.Len() == 0 {\n\t\treturn\n\t}\n\twsConn, ok := conn.Session().Load(\"wsConn\")\n\tif !ok {\n\t\t_ = conn.WriteClose(1000, nil)\n\t\treturn\n\t}\n\tselect {\n\tcase wsConn.(*WsConn).responseChan <- message:\n\tdefault:\n\t\t// close if the connection is not expecting a response\n\t\twsConn.(*WsConn).Close(nil)\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go", "rel_path": "src/hub/ws/ws.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 86, "end_line": 103, "text": "// OnClose handles WebSocket connection closures and triggers system down status after delay.\nfunc (h *Handler) OnClose(conn *gws.Conn, err error) {\n\twsConn, ok := conn.Session().Load(\"wsConn\")\n\tif !ok {\n\t\treturn\n\t}\n\twsConn.(*WsConn).conn = nil\n\t// wait 5 seconds to allow reconnection before setting system down\n\t// use a weak pointer to avoid keeping references if the system is removed\n\tgo func(downChan weak.Pointer[chan struct{}]) {\n\t\ttime.Sleep(5 * time.Second)\n\t\tdownChanValue := downChan.Value()\n\t\tif downChanValue != nil {\n\t\t\t*downChanValue <- struct{}{}\n\t\t}\n\t}(weak.Make(&wsConn.(*WsConn).DownChan))\n}\n", "n_tokens": 165, "primary_symbol": "OnClose", "primary_kind": "function", "primary_span": [87, 103], "def_symbols": ["OnClose"], "symbols": ["OnClose", "handles", "WebSocket", "connection", "closures", "and", "triggers", "system", "down", "status", "after", "delay", "func", "Handler", "conn", "gws", "Conn", "err", "error", "wsConn", "Session", "Load", "return", "WsConn", "nil", "wait", "seconds", "allow", "reconnection", "before", "setting", "use", "weak", "pointer", "avoid", "keeping", "references", "the", "removed", "downChan", "Pointer", "chan", "struct", "time", "Sleep", "Second", "downChanValue", "Value", "Make", "DownChan"], "doc_head": "// OnClose handles WebSocket connection closures and triggers system down status after delay.\nfunc (h *Handler) OnClose(conn *gws.Conn, err error) {\n\twsConn, ok := conn.Session().Load(\"wsConn\")\n\tif !ok {\n\t\treturn\n\t}\n\twsConn.(*WsConn).conn = nil\n\t// wait 5 seconds to allow reconnection before setting system down\n\t// use a weak pointer to avoid keeping references if the system is removed\n\tgo func(downChan weak.Pointer[chan struct{}]) {\n\t\ttime.Sleep(5 * time.Second)\n\t\tdownChanValue := downChan.Value()\n\t\tif downChanValue != nil {\n\t\t\t*downChanValue <- struct{}{}\n\t\t}\n\t}(weak.Make(&wsConn.(*WsConn).DownChan))\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go", "rel_path": "src/hub/ws/ws.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 104, "end_line": 128, "text": "// Close terminates the WebSocket connection gracefully.\nfunc (ws *WsConn) Close(msg []byte) {\n\tif ws.IsConnected() {\n\t\tws.conn.WriteClose(1000, msg)\n\t}\n}\n\n// Ping sends a ping frame to keep the connection alive.\nfunc (ws *WsConn) Ping() error {\n\tws.conn.SetDeadline(time.Now().Add(deadline))\n\treturn ws.conn.WritePing(nil)\n}\n\n// sendMessage encodes data to CBOR and sends it as a binary message to the agent.\nfunc (ws *WsConn) sendMessage(data common.HubRequest[any]) error {\n\tif ws.conn == nil {\n\t\treturn gws.ErrConnClosed\n\t}\n\tbytes, err := cbor.Marshal(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ws.conn.WriteMessage(gws.OpcodeBinary, bytes)\n}\n", "n_tokens": 172, "primary_symbol": "Close", "primary_kind": "function", "primary_span": [105, 128], "def_symbols": ["Close", "Ping", "sendMessage"], "symbols": ["Close", "Ping", "sendMessage", "terminates", "the", "WebSocket", "connection", "gracefully", "func", "WsConn", "msg", "byte", "IsConnected", "conn", "WriteClose", "sends", "ping", "frame", "keep", "alive", "error", "SetDeadline", "time", "Now", "Add", "deadline", "return", "WritePing", "nil", "encodes", "data", "CBOR", "and", "binary", "message", "agent", "common", "HubRequest", "any", "gws", "ErrConnClosed", "bytes", "err", "cbor", "Marshal", "WriteMessage", "OpcodeBinary"], "doc_head": "// Close terminates the WebSocket connection gracefully.\nfunc (ws *WsConn) Close(msg []byte) {\n\tif ws.IsConnected() {\n\t\tws.conn.WriteClose(1000, msg)\n\t}\n}\n// Ping sends a ping frame to keep the connection alive.\nfunc (ws *WsConn) Ping() error {\n\tws.conn.SetDeadline(time.Now().Add(deadline))\n\treturn ws.conn.WritePing(nil)\n}\n// sendMessage encodes data to CBOR and sends it as a binary message to the agent.\nfunc (ws *WsConn) sendMessage(data common.HubRequest[any]) error {\n\tif ws.conn == nil {\n\t\treturn gws.ErrConnClosed\n\t}\n\tbytes, err := cbor.Marshal(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ws.conn.WriteMessage(gws.OpcodeBinary, bytes)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go", "rel_path": "src/hub/ws/ws.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 129, "end_line": 145, "text": "// RequestSystemData requests system metrics from the agent and unmarshals the response.\nfunc (ws *WsConn) RequestSystemData(data *system.CombinedData) error {\n\tvar message *gws.Message\n\n\tws.sendMessage(common.HubRequest[any]{\n\t\tAction: common.GetData,\n\t})\n\tselect {\n\tcase <-time.After(10 * time.Second):\n\t\tws.Close(nil)\n\t\treturn gws.ErrConnClosed\n\tcase message = <-ws.responseChan:\n\t}\n\tdefer message.Close()\n\treturn cbor.Unmarshal(message.Data.Bytes(), data)\n}\n", "n_tokens": 114, "primary_symbol": "RequestSystemData", "primary_kind": "function", "primary_span": [130, 145], "def_symbols": ["RequestSystemData"], "symbols": ["RequestSystemData", "requests", "system", "metrics", "from", "the", "agent", "and", "unmarshals", "response", "func", "WsConn", "data", "CombinedData", "error", "var", "message", "gws", "Message", "sendMessage", "common", "HubRequest", "any", "Action", "GetData", "select", "case", "time", "After", "Second", "Close", "nil", "return", "ErrConnClosed", "responseChan", "defer", "cbor", "Unmarshal", "Data", "Bytes"], "doc_head": "// RequestSystemData requests system metrics from the agent and unmarshals the response.\nfunc (ws *WsConn) RequestSystemData(data *system.CombinedData) error {\n\tvar message *gws.Message\n\tws.sendMessage(common.HubRequest[any]{\n\t\tAction: common.GetData,\n\t})\n\tselect {\n\tcase <-time.After(10 * time.Second):\n\t\tws.Close(nil)\n\t\treturn gws.ErrConnClosed\n\tcase message = <-ws.responseChan:\n\t}\n\tdefer message.Close()\n\treturn cbor.Unmarshal(message.Data.Bytes(), data)\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go", "rel_path": "src/hub/ws/ws.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 146, "end_line": 178, "text": "// GetFingerprint authenticates with the agent using SSH signature and returns the agent's fingerprint.\nfunc (ws *WsConn) GetFingerprint(token string, signer ssh.Signer, needSysInfo bool) (common.FingerprintResponse, error) {\n\tvar clientFingerprint common.FingerprintResponse\n\tchallenge := []byte(token)\n\n\tsignature, err := signer.Sign(nil, challenge)\n\tif err != nil {\n\t\treturn clientFingerprint, err\n\t}\n\n\terr = ws.sendMessage(common.HubRequest[any]{\n\t\tAction: common.CheckFingerprint,\n\t\tData: common.FingerprintRequest{\n\t\t\tSignature:   signature.Blob,\n\t\t\tNeedSysInfo: needSysInfo,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn clientFingerprint, err\n\t}\n\n\tvar message *gws.Message\n\tselect {\n\tcase message = <-ws.responseChan:\n\tcase <-time.After(10 * time.Second):\n\t\treturn clientFingerprint, errors.New(\"request expired\")\n\t}\n\tdefer message.Close()\n\n\terr = cbor.Unmarshal(message.Data.Bytes(), &clientFingerprint)\n\treturn clientFingerprint, err\n}\n", "n_tokens": 227, "primary_symbol": "GetFingerprint", "primary_kind": "function", "primary_span": [147, 178], "def_symbols": ["GetFingerprint"], "symbols": ["GetFingerprint", "authenticates", "with", "the", "agent", "using", "SSH", "signature", "and", "returns", "fingerprint", "func", "WsConn", "token", "string", "signer", "ssh", "Signer", "needSysInfo", "bool", "common", "FingerprintResponse", "error", "var", "clientFingerprint", "challenge", "byte", "err", "Sign", "nil", "return", "sendMessage", "HubRequest", "any", "Action", "CheckFingerprint", "Data", "FingerprintRequest", "Signature", "Blob", "NeedSysInfo", "message", "gws", "Message", "select", "case", "responseChan", "time", "After", "Second", "errors", "New", "request", "expired", "defer", "Close", "cbor", "Unmarshal", "Bytes"], "doc_head": "// GetFingerprint authenticates with the agent using SSH signature and returns the agent's fingerprint.\nfunc (ws *WsConn) GetFingerprint(token string, signer ssh.Signer, needSysInfo bool) (common.FingerprintResponse, error) {\n\tvar clientFingerprint common.FingerprintResponse\n\tchallenge := []byte(token)\n\tsignature, err := signer.Sign(nil, challenge)\n\tif err != nil {\n\t\treturn clientFingerprint, err\n\t}\n\terr = ws.sendMessage(common.HubRequest[any]{\n\t\tAction: common.CheckFingerprint,\n\t\tData: common.FingerprintRequest{\n\t\t\tSignature:   signature.Blob,\n\t\t\tNeedSysInfo: needSysInfo,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn clientFingerprint, err\n\t}\n\tvar message *gws.Message\n\tselect {\n\tcase message = <-ws.responseChan:\n\tcase <-time.After(10 * time.Second):\n\t\treturn clientFingerprint, errors.New(\"request expired\")\n\t}\n\tdefer message.Close()\n\terr = cbor.Unmarshal(message.Data.Bytes(), &clientFingerprint)\n\treturn clientFingerprint, err\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws.go", "rel_path": "src/hub/ws/ws.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 179, "end_line": 183, "text": "// IsConnected returns true if the WebSocket connection is active.\nfunc (ws *WsConn) IsConnected() bool {\n\treturn ws.conn != nil\n}\n", "n_tokens": 31, "primary_symbol": "IsConnected", "primary_kind": "function", "primary_span": [180, 183], "def_symbols": ["IsConnected"], "symbols": ["IsConnected", "returns", "true", "the", "WebSocket", "connection", "active", "func", "WsConn", "bool", "return", "conn", "nil"], "doc_head": "// IsConnected returns true if the WebSocket connection is active.\nfunc (ws *WsConn) IsConnected() bool {\n\treturn ws.conn != nil\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go", "rel_path": "src/hub/ws/ws_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 18, "text": "//go:build testing\n// +build testing\n\npackage ws\n\nimport (\n\t\"crypto/ed25519\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/common\"\n\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)\n", "n_tokens": 79, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 18], "def_symbols": [], "symbols": ["build", "testing", "package", "import", "crypto", "ed25519", "time", "github", "com", "henrygd", "beszel", "src", "common", "fxamacker", "cbor", "stretchr", "testify", "assert", "require", "golang", "org", "ssh"], "doc_head": "//go:build testing\n// +build testing\npackage ws\nimport (\n\t\"crypto/ed25519\"\n\t\"testing\"\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/common\"\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/crypto/ssh\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go", "rel_path": "src/hub/ws/ws_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 19, "end_line": 35, "text": "// TestGetUpgrader tests the singleton upgrader\nfunc TestGetUpgrader(t *testing.T) {\n\t// Reset the global upgrader to test singleton behavior\n\tupgrader = nil\n\n\t// First call should create the upgrader\n\tupgrader1 := GetUpgrader()\n\tassert.NotNil(t, upgrader1, \"Upgrader should not be nil\")\n\n\t// Second call should return the same instance\n\tupgrader2 := GetUpgrader()\n\tassert.Same(t, upgrader1, upgrader2, \"Should return the same upgrader instance\")\n\n\t// Verify it's properly configured\n\tassert.NotNil(t, upgrader1, \"Upgrader should be configured\")\n}\n", "n_tokens": 154, "primary_symbol": "TestGetUpgrader", "primary_kind": "function", "primary_span": [20, 35], "def_symbols": ["TestGetUpgrader"], "symbols": ["TestGetUpgrader", "tests", "the", "singleton", "upgrader", "func", "testing", "Reset", "global", "test", "behavior", "nil", "First", "call", "should", "create", "upgrader1", "GetUpgrader", "assert", "NotNil", "Upgrader", "not", "Second", "return", "same", "instance", "upgrader2", "Same", "Should", "Verify", "properly", "configured"], "doc_head": "// TestGetUpgrader tests the singleton upgrader\nfunc TestGetUpgrader(t *testing.T) {\n\t// Reset the global upgrader to test singleton behavior\n\tupgrader = nil\n\t// First call should create the upgrader\n\tupgrader1 := GetUpgrader()\n\tassert.NotNil(t, upgrader1, \"Upgrader should not be nil\")\n\t// Second call should return the same instance\n\tupgrader2 := GetUpgrader()\n\tassert.Same(t, upgrader1, upgrader2, \"Should return the same upgrader instance\")\n\t// Verify it's properly configured\n\tassert.NotNil(t, upgrader1, \"Upgrader should be configured\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go", "rel_path": "src/hub/ws/ws_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 36, "end_line": 48, "text": "// TestNewWsConnection tests WebSocket connection creation\nfunc TestNewWsConnection(t *testing.T) {\n\t// We can't easily mock gws.Conn, so we'll pass nil and test the structure\n\twsConn := NewWsConnection(nil)\n\n\tassert.NotNil(t, wsConn, \"WebSocket connection should not be nil\")\n\tassert.Nil(t, wsConn.conn, \"Connection should be nil as passed\")\n\tassert.NotNil(t, wsConn.responseChan, \"Response channel should be initialized\")\n\tassert.NotNil(t, wsConn.DownChan, \"Down channel should be initialized\")\n\tassert.Equal(t, 1, cap(wsConn.responseChan), \"Response channel should have capacity of 1\")\n\tassert.Equal(t, 1, cap(wsConn.DownChan), \"Down channel should have capacity of 1\")\n}\n", "n_tokens": 161, "primary_symbol": "TestNewWsConnection", "primary_kind": "function", "primary_span": [37, 48], "def_symbols": ["TestNewWsConnection"], "symbols": ["TestNewWsConnection", "tests", "WebSocket", "connection", "creation", "func", "testing", "can", "easily", "mock", "gws", "Conn", "pass", "nil", "and", "test", "the", "structure", "wsConn", "NewWsConnection", "assert", "NotNil", "should", "not", "Nil", "conn", "Connection", "passed", "responseChan", "Response", "channel", "initialized", "DownChan", "Down", "Equal", "cap", "have", "capacity"], "doc_head": "// TestNewWsConnection tests WebSocket connection creation\nfunc TestNewWsConnection(t *testing.T) {\n\t// We can't easily mock gws.Conn, so we'll pass nil and test the structure\n\twsConn := NewWsConnection(nil)\n\tassert.NotNil(t, wsConn, \"WebSocket connection should not be nil\")\n\tassert.Nil(t, wsConn.conn, \"Connection should be nil as passed\")\n\tassert.NotNil(t, wsConn.responseChan, \"Response channel should be initialized\")\n\tassert.NotNil(t, wsConn.DownChan, \"Down channel should be initialized\")\n\tassert.Equal(t, 1, cap(wsConn.responseChan), \"Response channel should have capacity of 1\")\n\tassert.Equal(t, 1, cap(wsConn.DownChan), \"Down channel should have capacity of 1\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go", "rel_path": "src/hub/ws/ws_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 49, "end_line": 65, "text": "// TestWsConn_IsConnected tests the connection status check\nfunc TestWsConn_IsConnected(t *testing.T) {\n\t// Test with nil connection\n\twsConn := NewWsConnection(nil)\n\tassert.False(t, wsConn.IsConnected(), \"Should not be connected when conn is nil\")\n}\n\n// TestWsConn_Close tests the connection closing with nil connection\nfunc TestWsConn_Close(t *testing.T) {\n\twsConn := NewWsConnection(nil)\n\n\t// Should handle nil connection gracefully\n\tassert.NotPanics(t, func() {\n\t\twsConn.Close([]byte(\"test message\"))\n\t}, \"Should not panic when closing nil connection\")\n}\n", "n_tokens": 133, "primary_symbol": "TestWsConn_IsConnected", "primary_kind": "function", "primary_span": [50, 65], "def_symbols": ["TestWsConn_IsConnected", "TestWsConn_Close"], "symbols": ["TestWsConn_IsConnected", "TestWsConn_Close", "tests", "the", "connection", "status", "check", "func", "testing", "Test", "with", "nil", "wsConn", "NewWsConnection", "assert", "False", "IsConnected", "Should", "not", "connected", "when", "conn", "closing", "handle", "gracefully", "NotPanics", "Close", "byte", "test", "message", "panic"], "doc_head": "// TestWsConn_IsConnected tests the connection status check\nfunc TestWsConn_IsConnected(t *testing.T) {\n\t// Test with nil connection\n\twsConn := NewWsConnection(nil)\n\tassert.False(t, wsConn.IsConnected(), \"Should not be connected when conn is nil\")\n}\n// TestWsConn_Close tests the connection closing with nil connection\nfunc TestWsConn_Close(t *testing.T) {\n\twsConn := NewWsConnection(nil)\n\t// Should handle nil connection gracefully\n\tassert.NotPanics(t, func() {\n\t\twsConn.Close([]byte(\"test message\"))\n\t}, \"Should not panic when closing nil connection\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go", "rel_path": "src/hub/ws/ws_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 66, "end_line": 90, "text": "// TestWsConn_SendMessage_CBOR tests CBOR encoding in sendMessage\nfunc TestWsConn_SendMessage_CBOR(t *testing.T) {\n\twsConn := NewWsConnection(nil)\n\n\ttestData := common.HubRequest[any]{\n\t\tAction: common.GetData,\n\t\tData:   \"test data\",\n\t}\n\n\t// This will fail because conn is nil, but we can test the CBOR encoding logic\n\t// by checking that the function properly encodes to CBOR before failing\n\terr := wsConn.sendMessage(testData)\n\tassert.Error(t, err, \"Should error with nil connection\")\n\n\t// Test CBOR encoding separately\n\tbytes, err := cbor.Marshal(testData)\n\tassert.NoError(t, err, \"Should encode to CBOR successfully\")\n\n\t// Verify we can decode it back\n\tvar decodedData common.HubRequest[any]\n\terr = cbor.Unmarshal(bytes, &decodedData)\n\tassert.NoError(t, err, \"Should decode from CBOR successfully\")\n\tassert.Equal(t, testData.Action, decodedData.Action, \"Action should match\")\n}\n", "n_tokens": 215, "primary_symbol": "TestWsConn_SendMessage_CBOR", "primary_kind": "function", "primary_span": [67, 90], "def_symbols": ["TestWsConn_SendMessage_CBOR"], "symbols": ["TestWsConn_SendMessage_CBOR", "tests", "CBOR", "encoding", "sendMessage", "func", "testing", "wsConn", "NewWsConnection", "nil", "testData", "common", "HubRequest", "any", "Action", "GetData", "Data", "test", "data", "This", "will", "fail", "because", "conn", "but", "can", "the", "logic", "checking", "that", "function", "properly", "encodes", "before", "failing", "err", "assert", "Error", "Should", "error", "with", "connection", "Test", "separately", "bytes", "cbor", "Marshal", "NoError", "encode", "successfully", "Verify", "decode", "back", "var", "decodedData", "Unmarshal", "from", "Equal", "should", "match"], "doc_head": "// TestWsConn_SendMessage_CBOR tests CBOR encoding in sendMessage\nfunc TestWsConn_SendMessage_CBOR(t *testing.T) {\n\twsConn := NewWsConnection(nil)\n\ttestData := common.HubRequest[any]{\n\t\tAction: common.GetData,\n\t\tData:   \"test data\",\n\t}\n\t// This will fail because conn is nil, but we can test the CBOR encoding logic\n\t// by checking that the function properly encodes to CBOR before failing\n\terr := wsConn.sendMessage(testData)\n\tassert.Error(t, err, \"Should error with nil connection\")\n\t// Test CBOR encoding separately\n\tbytes, err := cbor.Marshal(testData)\n\tassert.NoError(t, err, \"Should encode to CBOR successfully\")\n\t// Verify we can decode it back\n\tvar decodedData common.HubRequest[any]\n\terr = cbor.Unmarshal(bytes, &decodedData)\n\tassert.NoError(t, err, \"Should decode from CBOR successfully\")\n\tassert.Equal(t, testData.Action, decodedData.Action, \"Action should match\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go", "rel_path": "src/hub/ws/ws_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 91, "end_line": 140, "text": "// TestWsConn_GetFingerprint_SignatureGeneration tests signature creation logic\nfunc TestWsConn_GetFingerprint_SignatureGeneration(t *testing.T) {\n\t// Generate test key pair\n\t_, privKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\n\tsigner, err := ssh.NewSignerFromKey(privKey)\n\trequire.NoError(t, err)\n\n\ttoken := \"test-token\"\n\n\t// This will timeout since conn is nil, but we can verify the signature logic\n\t// We can't test the full flow, but we can test that the signature is created properly\n\tchallenge := []byte(token)\n\tsignature, err := signer.Sign(nil, challenge)\n\tassert.NoError(t, err, \"Should create signature successfully\")\n\tassert.NotEmpty(t, signature.Blob, \"Signature blob should not be empty\")\n\tassert.Equal(t, signer.PublicKey().Type(), signature.Format, \"Signature format should match key type\")\n\n\t// Test the fingerprint request structure\n\tfpRequest := common.FingerprintRequest{\n\t\tSignature:   signature.Blob,\n\t\tNeedSysInfo: true,\n\t}\n\n\t// Test CBOR encoding of fingerprint request\n\tfpData, err := cbor.Marshal(fpRequest)\n\tassert.NoError(t, err, \"Should encode fingerprint request to CBOR\")\n\n\tvar decodedFpRequest common.FingerprintRequest\n\terr = cbor.Unmarshal(fpData, &decodedFpRequest)\n\tassert.NoError(t, err, \"Should decode fingerprint request from CBOR\")\n\tassert.Equal(t, fpRequest.Signature, decodedFpRequest.Signature, \"Signature should match\")\n\tassert.Equal(t, fpRequest.NeedSysInfo, decodedFpRequest.NeedSysInfo, \"NeedSysInfo should match\")\n\n\t// Test the full hub request structure\n\thubRequest := common.HubRequest[any]{\n\t\tAction: common.CheckFingerprint,\n\t\tData:   fpRequest,\n\t}\n\n\thubData, err := cbor.Marshal(hubRequest)\n\tassert.NoError(t, err, \"Should encode hub request to CBOR\")\n\n\tvar decodedHubRequest common.HubRequest[cbor.RawMessage]\n\terr = cbor.Unmarshal(hubData, &decodedHubRequest)\n\tassert.NoError(t, err, \"Should decode hub request from CBOR\")\n\tassert.Equal(t, common.CheckFingerprint, decodedHubRequest.Action, \"Action should be CheckFingerprint\")\n}\n", "n_tokens": 483, "primary_symbol": "TestWsConn_GetFingerprint_SignatureGeneration", "primary_kind": "function", "primary_span": [92, 140], "def_symbols": ["TestWsConn_GetFingerprint_SignatureGeneration"], "symbols": ["TestWsConn_GetFingerprint_SignatureGeneration", "tests", "signature", "creation", "logic", "func", "testing", "Generate", "test", "key", "pair", "privKey", "err", "ed25519", "GenerateKey", "nil", "require", "NoError", "signer", "ssh", "NewSignerFromKey", "token", "This", "will", "timeout", "since", "conn", "but", "can", "verify", "the", "full", "flow", "that", "created", "properly", "challenge", "byte", "Sign", "assert", "Should", "create", "successfully", "NotEmpty", "Blob", "Signature", "blob", "should", "not", "empty", "Equal", "PublicKey", "Type", "Format", "format", "match", "type", "Test", "fingerprint", "request", "structure", "fpRequest", "common", "FingerprintRequest", "NeedSysInfo", "true", "CBOR", "encoding", "fpData", "cbor", "Marshal", "encode", "var", "decodedFpRequest", "Unmarshal", "decode", "from", "hub", "hubRequest", "HubRequest", "any", "Action", "CheckFingerprint", "Data", "hubData", "decodedHubRequest", "RawMessage"], "doc_head": "// TestWsConn_GetFingerprint_SignatureGeneration tests signature creation logic\nfunc TestWsConn_GetFingerprint_SignatureGeneration(t *testing.T) {\n\t// Generate test key pair\n\t_, privKey, err := ed25519.GenerateKey(nil)\n\trequire.NoError(t, err)\n\tsigner, err := ssh.NewSignerFromKey(privKey)\n\trequire.NoError(t, err)\n\ttoken := \"test-token\"\n\t// This will timeout since conn is nil, but we can verify the signature logic\n\t// We can't test the full flow, but we can test that the signature is created properly\n\tchallenge := []byte(token)\n\tsignature, err := signer.Sign(nil, challenge)\n\tassert.NoError(t, err, \"Should create signature successfully\")\n\tassert.NotEmpty(t, signature.Blob, \"Signature blob should not be empty\")\n\tassert.Equal(t, signer.PublicKey().Type(), signature.Format, \"Signature format should match key type\")\n\t// Test the fingerprint request structure\n\tfpRequest := common.FingerprintRequest{\n\t\tSignature:   signature.Blob,\n\t\tNeedSysInfo: true,\n\t}\n\t// Test CBOR encoding of fingerprint request\n\tfpData, err := cbor.Marshal(fpRequest)\n\tassert.NoError(t, err, \"Should encode fingerprint request to CBOR\")\n\tvar decodedFpRequest common.FingerprintRequest\n\terr = cbor.Unmarshal(fpData, &decod"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go", "rel_path": "src/hub/ws/ws_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 141, "end_line": 158, "text": "// TestWsConn_RequestSystemData_RequestFormat tests system data request format\nfunc TestWsConn_RequestSystemData_RequestFormat(t *testing.T) {\n\t// Test the request format that would be sent\n\trequest := common.HubRequest[any]{\n\t\tAction: common.GetData,\n\t}\n\n\t// Test CBOR encoding\n\tdata, err := cbor.Marshal(request)\n\tassert.NoError(t, err, \"Should encode request to CBOR\")\n\n\t// Test decoding\n\tvar decodedRequest common.HubRequest[any]\n\terr = cbor.Unmarshal(data, &decodedRequest)\n\tassert.NoError(t, err, \"Should decode request from CBOR\")\n\tassert.Equal(t, common.GetData, decodedRequest.Action, \"Should have GetData action\")\n}\n", "n_tokens": 147, "primary_symbol": "TestWsConn_RequestSystemData_RequestFormat", "primary_kind": "function", "primary_span": [142, 158], "def_symbols": ["TestWsConn_RequestSystemData_RequestFormat"], "symbols": ["TestWsConn_RequestSystemData_RequestFormat", "tests", "system", "data", "request", "format", "func", "testing", "Test", "the", "that", "would", "sent", "common", "HubRequest", "any", "Action", "GetData", "CBOR", "encoding", "err", "cbor", "Marshal", "assert", "NoError", "Should", "encode", "decoding", "var", "decodedRequest", "Unmarshal", "decode", "from", "Equal", "have", "action"], "doc_head": "// TestWsConn_RequestSystemData_RequestFormat tests system data request format\nfunc TestWsConn_RequestSystemData_RequestFormat(t *testing.T) {\n\t// Test the request format that would be sent\n\trequest := common.HubRequest[any]{\n\t\tAction: common.GetData,\n\t}\n\t// Test CBOR encoding\n\tdata, err := cbor.Marshal(request)\n\tassert.NoError(t, err, \"Should encode request to CBOR\")\n\t// Test decoding\n\tvar decodedRequest common.HubRequest[any]\n\terr = cbor.Unmarshal(data, &decodedRequest)\n\tassert.NoError(t, err, \"Should decode request from CBOR\")\n\tassert.Equal(t, common.GetData, decodedRequest.Action, \"Should have GetData action\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go#8", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go", "rel_path": "src/hub/ws/ws_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 159, "end_line": 178, "text": "// TestFingerprintRecord tests the FingerprintRecord struct\nfunc TestFingerprintRecord(t *testing.T) {\n\trecord := FingerprintRecord{\n\t\tId:          \"test-id\",\n\t\tSystemId:    \"system-123\",\n\t\tFingerprint: \"test-fingerprint\",\n\t\tToken:       \"test-token\",\n\t}\n\n\tassert.Equal(t, \"test-id\", record.Id)\n\tassert.Equal(t, \"system-123\", record.SystemId)\n\tassert.Equal(t, \"test-fingerprint\", record.Fingerprint)\n\tassert.Equal(t, \"test-token\", record.Token)\n}\n\n// TestDeadlineConstant tests that the deadline constant is reasonable\nfunc TestDeadlineConstant(t *testing.T) {\n\tassert.Equal(t, 70*time.Second, deadline, \"Deadline should be 70 seconds\")\n}\n", "n_tokens": 157, "primary_symbol": "TestFingerprintRecord", "primary_kind": "function", "primary_span": [160, 178], "def_symbols": ["TestFingerprintRecord", "TestDeadlineConstant"], "symbols": ["TestFingerprintRecord", "TestDeadlineConstant", "tests", "the", "FingerprintRecord", "struct", "func", "testing", "record", "test", "SystemId", "system", "Fingerprint", "fingerprint", "Token", "token", "assert", "Equal", "that", "deadline", "constant", "reasonable", "time", "Second", "Deadline", "should", "seconds"], "doc_head": "// TestFingerprintRecord tests the FingerprintRecord struct\nfunc TestFingerprintRecord(t *testing.T) {\n\trecord := FingerprintRecord{\n\t\tId:          \"test-id\",\n\t\tSystemId:    \"system-123\",\n\t\tFingerprint: \"test-fingerprint\",\n\t\tToken:       \"test-token\",\n\t}\n\tassert.Equal(t, \"test-id\", record.Id)\n\tassert.Equal(t, \"system-123\", record.SystemId)\n\tassert.Equal(t, \"test-fingerprint\", record.Fingerprint)\n\tassert.Equal(t, \"test-token\", record.Token)\n}\n// TestDeadlineConstant tests that the deadline constant is reasonable\nfunc TestDeadlineConstant(t *testing.T) {\n\tassert.Equal(t, 70*time.Second, deadline, \"Deadline should be 70 seconds\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go#9", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go", "rel_path": "src/hub/ws/ws_test.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 179, "end_line": 194, "text": "// TestCommonActions tests that the common actions are properly defined\nfunc TestCommonActions(t *testing.T) {\n\t// Test that the actions we use exist and have expected values\n\tassert.Equal(t, common.WebSocketAction(0), common.GetData, \"GetData should be action 0\")\n\tassert.Equal(t, common.WebSocketAction(1), common.CheckFingerprint, \"CheckFingerprint should be action 1\")\n}\n\n// TestHandler tests that we can create a Handler\nfunc TestHandler(t *testing.T) {\n\thandler := &Handler{}\n\tassert.NotNil(t, handler, \"Handler should be created successfully\")\n\n\t// The Handler embeds gws.BuiltinEventHandler, so it should have the embedded type\n\tassert.NotNil(t, handler.BuiltinEventHandler, \"Should have embedded BuiltinEventHandler\")\n}\n", "n_tokens": 162, "primary_symbol": "TestCommonActions", "primary_kind": "function", "primary_span": [180, 194], "def_symbols": ["TestCommonActions", "TestHandler"], "symbols": ["TestCommonActions", "TestHandler", "tests", "that", "the", "common", "actions", "are", "properly", "defined", "func", "testing", "Test", "use", "exist", "and", "have", "expected", "values", "assert", "Equal", "WebSocketAction", "GetData", "should", "action", "CheckFingerprint", "can", "create", "Handler", "handler", "NotNil", "created", "successfully", "The", "embeds", "gws", "BuiltinEventHandler", "embedded", "type", "Should"], "doc_head": "// TestCommonActions tests that the common actions are properly defined\nfunc TestCommonActions(t *testing.T) {\n\t// Test that the actions we use exist and have expected values\n\tassert.Equal(t, common.WebSocketAction(0), common.GetData, \"GetData should be action 0\")\n\tassert.Equal(t, common.WebSocketAction(1), common.CheckFingerprint, \"CheckFingerprint should be action 1\")\n}\n// TestHandler tests that we can create a Handler\nfunc TestHandler(t *testing.T) {\n\thandler := &Handler{}\n\tassert.NotNil(t, handler, \"Handler should be created successfully\")\n\t// The Handler embeds gws.BuiltinEventHandler, so it should have the embedded type\n\tassert.NotNil(t, handler.BuiltinEventHandler, \"Should have embedded BuiltinEventHandler\")\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go#10", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/hub/ws/ws_test.go", "rel_path": "src/hub/ws/ws_test.go", "ext": "go", "language": "go", "chunk_number": 10, "start_line": 195, "end_line": 223, "text": "// TestWsConnChannelBehavior tests channel behavior without WebSocket connections\nfunc TestWsConnChannelBehavior(t *testing.T) {\n\twsConn := NewWsConnection(nil)\n\n\t// Test that channels are properly initialized and can be used\n\tselect {\n\tcase wsConn.DownChan <- struct{}{}:\n\t\t// Should be able to write to channel\n\tdefault:\n\t\tt.Error(\"Should be able to write to DownChan\")\n\t}\n\n\t// Test reading from DownChan\n\tselect {\n\tcase <-wsConn.DownChan:\n\t\t// Should be able to read from channel\n\tcase <-time.After(10 * time.Millisecond):\n\t\tt.Error(\"Should be able to read from DownChan\")\n\t}\n\n\t// Response channel should be empty initially\n\tselect {\n\tcase <-wsConn.responseChan:\n\t\tt.Error(\"Response channel should be empty initially\")\n\tdefault:\n\t\t// Expected - channel should be empty\n\t}\n}\n", "n_tokens": 184, "primary_symbol": "TestWsConnChannelBehavior", "primary_kind": "function", "primary_span": [196, 223], "def_symbols": ["TestWsConnChannelBehavior"], "symbols": ["TestWsConnChannelBehavior", "tests", "channel", "behavior", "without", "WebSocket", "connections", "func", "testing", "wsConn", "NewWsConnection", "nil", "Test", "that", "channels", "are", "properly", "initialized", "and", "can", "used", "select", "case", "DownChan", "struct", "Should", "able", "write", "default", "Error", "reading", "from", "read", "time", "After", "Millisecond", "Response", "should", "empty", "initially", "responseChan", "Expected"], "doc_head": "// TestWsConnChannelBehavior tests channel behavior without WebSocket connections\nfunc TestWsConnChannelBehavior(t *testing.T) {\n\twsConn := NewWsConnection(nil)\n\t// Test that channels are properly initialized and can be used\n\tselect {\n\tcase wsConn.DownChan <- struct{}{}:\n\t\t// Should be able to write to channel\n\tdefault:\n\t\tt.Error(\"Should be able to write to DownChan\")\n\t}\n\t// Test reading from DownChan\n\tselect {\n\tcase <-wsConn.DownChan:\n\t\t// Should be able to read from channel\n\tcase <-time.After(10 * time.Millisecond):\n\t\tt.Error(\"Should be able to read from DownChan\")\n\t}\n\t// Response channel should be empty initially\n\tselect {\n\tcase <-wsConn.responseChan:\n\t\tt.Error(\"Response channel should be empty initially\")\n\tdefault:\n\t\t// Expected - channel should be empty\n\t}\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go", "rel_path": "src/entities/container/container.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 27, "text": "package container\n\nimport \"time\"\n\n// Docker container info from /containers/json\ntype ApiInfo struct {\n\tId      string\n\tIdShort string\n\tNames   []string\n\tStatus  string\n\t// Image   string\n\t// ImageID string\n\t// Command string\n\t// Created int64\n\t// Ports      []Port\n\t// SizeRw     int64 `json:\",omitempty\"`\n\t// SizeRootFs int64 `json:\",omitempty\"`\n\t// Labels     map[string]string\n\t// State      string\n\t// HostConfig struct {\n\t// \tNetworkMode string            `json:\",omitempty\"`\n\t// \tAnnotations map[string]string `json:\",omitempty\"`\n\t// }\n\t// NetworkSettings *SummaryNetworkSettings\n\t// Mounts          []MountPoint\n}\n", "n_tokens": 162, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 27], "def_symbols": [], "symbols": ["package", "container", "import", "time", "Docker", "info", "from", "containers", "json", "type", "ApiInfo", "struct", "string", "IdShort", "Names", "Status", "Image", "ImageID", "Command", "Created", "int64", "Ports", "Port", "SizeRw", "omitempty", "SizeRootFs", "Labels", "map", "State", "HostConfig", "NetworkMode", "Annotations", "NetworkSettings", "SummaryNetworkSettings", "Mounts", "MountPoint"], "doc_head": "package container\nimport \"time\"\n// Docker container info from /containers/json\ntype ApiInfo struct {\n\tId      string\n\tIdShort string\n\tNames   []string\n\tStatus  string\n\t// Image   string\n\t// ImageID string\n\t// Command string\n\t// Created int64\n\t// Ports      []Port\n\t// SizeRw     int64 `json:\",omitempty\"`\n\t// SizeRootFs int64 `json:\",omitempty\"`\n\t// Labels     map[string]string\n\t// State      string\n\t// HostConfig struct {\n\t// \tNetworkMode string            `json:\",omitempty\"`\n\t// \tAnnotations map[string]string `json:\",omitempty\"`\n\t// }\n\t// NetworkSettings *SummaryNetworkSettings\n\t// Mounts          []MountPoint\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go", "rel_path": "src/entities/container/container.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 28, "end_line": 36, "text": "// Docker container resources from /containers/{id}/stats\ntype ApiStats struct {\n\tRead        time.Time `json:\"read\"`               // Time of stats generation\n\tNumProcs    uint32    `json:\"num_procs,omitzero\"` // Windows specific, not populated on Linux.\n\tNetworks    map[string]NetworkStats\n\tCPUStats    CPUStats    `json:\"cpu_stats\"`\n\tMemoryStats MemoryStats `json:\"memory_stats\"`\n}\n", "n_tokens": 95, "primary_symbol": "", "primary_kind": "", "primary_span": [28, 36], "def_symbols": [], "symbols": ["Docker", "container", "resources", "from", "containers", "stats", "type", "ApiStats", "struct", "Read", "time", "Time", "json", "read", "generation", "NumProcs", "uint32", "num_procs", "omitzero", "Windows", "specific", "not", "populated", "Linux", "Networks", "map", "string", "NetworkStats", "CPUStats", "cpu_stats", "MemoryStats", "memory_stats"], "doc_head": "// Docker container resources from /containers/{id}/stats\ntype ApiStats struct {\n\tRead        time.Time `json:\"read\"`               // Time of stats generation\n\tNumProcs    uint32    `json:\"num_procs,omitzero\"` // Windows specific, not populated on Linux.\n\tNetworks    map[string]NetworkStats\n\tCPUStats    CPUStats    `json:\"cpu_stats\"`\n\tMemoryStats MemoryStats `json:\"memory_stats\"`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go", "rel_path": "src/entities/container/container.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 37, "end_line": 48, "text": "func (s *ApiStats) CalculateCpuPercentLinux(prevCpuContainer uint64, prevCpuSystem uint64) float64 {\n\tcpuDelta := s.CPUStats.CPUUsage.TotalUsage - prevCpuContainer\n\tsystemDelta := s.CPUStats.SystemUsage - prevCpuSystem\n\n\t// Avoid division by zero and handle first run case\n\tif systemDelta == 0 || prevCpuContainer == 0 {\n\t\treturn 0.0\n\t}\n\n\treturn float64(cpuDelta) / float64(systemDelta) * 100.0\n}\n", "n_tokens": 117, "primary_symbol": "CalculateCpuPercentLinux", "primary_kind": "function", "primary_span": [37, 48], "def_symbols": ["CalculateCpuPercentLinux"], "symbols": ["CalculateCpuPercentLinux", "func", "ApiStats", "prevCpuContainer", "uint64", "prevCpuSystem", "float64", "cpuDelta", "CPUStats", "CPUUsage", "TotalUsage", "systemDelta", "SystemUsage", "Avoid", "division", "zero", "and", "handle", "first", "run", "case", "return"], "doc_head": "func (s *ApiStats) CalculateCpuPercentLinux(prevCpuContainer uint64, prevCpuSystem uint64) float64 {\n\tcpuDelta := s.CPUStats.CPUUsage.TotalUsage - prevCpuContainer\n\tsystemDelta := s.CPUStats.SystemUsage - prevCpuSystem\n\t// Avoid division by zero and handle first run case\n\tif systemDelta == 0 || prevCpuContainer == 0 {\n\t\treturn 0.0\n\t}\n\treturn float64(cpuDelta) / float64(systemDelta) * 100.0\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go", "rel_path": "src/entities/container/container.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 49, "end_line": 65, "text": "// from: https://github.com/docker/cli/blob/master/cli/command/container/stats_helpers.go#L185\nfunc (s *ApiStats) CalculateCpuPercentWindows(prevCpuUsage uint64, prevRead time.Time) float64 {\n\t// Max number of 100ns intervals between the previous time read and now\n\tpossIntervals := uint64(s.Read.Sub(prevRead).Nanoseconds())\n\tpossIntervals /= 100                // Convert to number of 100ns intervals\n\tpossIntervals *= uint64(s.NumProcs) // Multiple by the number of processors\n\n\t// Intervals used\n\tintervalsUsed := s.CPUStats.CPUUsage.TotalUsage - prevCpuUsage\n\n\t// Percentage avoiding divide-by-zero\n\tif possIntervals > 0 {\n\t\treturn float64(intervalsUsed) / float64(possIntervals) * 100.0\n\t}\n\treturn 0.00\n}\n", "n_tokens": 192, "primary_symbol": "CalculateCpuPercentWindows", "primary_kind": "function", "primary_span": [50, 65], "def_symbols": ["CalculateCpuPercentWindows"], "symbols": ["CalculateCpuPercentWindows", "from", "https", "github", "com", "docker", "cli", "blob", "master", "command", "container", "stats_helpers", "L185", "func", "ApiStats", "prevCpuUsage", "uint64", "prevRead", "time", "Time", "float64", "Max", "number", "intervals", "between", "the", "previous", "read", "and", "now", "possIntervals", "Read", "Sub", "Nanoseconds", "Convert", "NumProcs", "Multiple", "processors", "Intervals", "used", "intervalsUsed", "CPUStats", "CPUUsage", "TotalUsage", "Percentage", "avoiding", "divide", "zero", "return"], "doc_head": "// from: https://github.com/docker/cli/blob/master/cli/command/container/stats_helpers.go#L185\nfunc (s *ApiStats) CalculateCpuPercentWindows(prevCpuUsage uint64, prevRead time.Time) float64 {\n\t// Max number of 100ns intervals between the previous time read and now\n\tpossIntervals := uint64(s.Read.Sub(prevRead).Nanoseconds())\n\tpossIntervals /= 100                // Convert to number of 100ns intervals\n\tpossIntervals *= uint64(s.NumProcs) // Multiple by the number of processors\n\t// Intervals used\n\tintervalsUsed := s.CPUStats.CPUUsage.TotalUsage - prevCpuUsage\n\t// Percentage avoiding divide-by-zero\n\tif possIntervals > 0 {\n\t\treturn float64(intervalsUsed) / float64(possIntervals) * 100.0\n\t}\n\treturn 0.00\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go", "rel_path": "src/entities/container/container.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 66, "end_line": 93, "text": "type CPUStats struct {\n\t// CPU Usage. Linux and Windows.\n\tCPUUsage CPUUsage `json:\"cpu_usage\"`\n\t// System Usage. Linux only.\n\tSystemUsage uint64 `json:\"system_cpu_usage,omitempty\"`\n}\n\ntype CPUUsage struct {\n\t// Total CPU time consumed.\n\t// Units: nanoseconds (Linux)\n\t// Units: 100's of nanoseconds (Windows)\n\tTotalUsage uint64 `json:\"total_usage\"`\n}\n\ntype MemoryStats struct {\n\t// current res_counter usage for memory\n\tUsage uint64 `json:\"usage,omitempty\"`\n\t// all the stats exported via memory.stat.\n\tStats MemoryStatsStats `json:\"stats\"`\n\t// private working set (Windows only)\n\tPrivateWorkingSet uint64 `json:\"privateworkingset,omitempty\"`\n}\n\ntype MemoryStatsStats struct {\n\tCache        uint64 `json:\"cache,omitempty\"`\n\tInactiveFile uint64 `json:\"inactive_file,omitempty\"`\n}\n", "n_tokens": 190, "primary_symbol": "", "primary_kind": "", "primary_span": [66, 93], "def_symbols": [], "symbols": ["type", "CPUStats", "struct", "CPU", "Usage", "Linux", "and", "Windows", "CPUUsage", "json", "cpu_usage", "System", "only", "SystemUsage", "uint64", "system_cpu_usage", "omitempty", "Total", "time", "consumed", "Units", "nanoseconds", "TotalUsage", "total_usage", "MemoryStats", "current", "res_counter", "usage", "for", "memory", "all", "the", "stats", "exported", "via", "stat", "Stats", "MemoryStatsStats", "private", "working", "set", "PrivateWorkingSet", "privateworkingset", "Cache", "cache", "InactiveFile", "inactive_file"], "doc_head": "type CPUStats struct {\n\t// CPU Usage. Linux and Windows.\n\tCPUUsage CPUUsage `json:\"cpu_usage\"`\n\t// System Usage. Linux only.\n\tSystemUsage uint64 `json:\"system_cpu_usage,omitempty\"`\n}\ntype CPUUsage struct {\n\t// Total CPU time consumed.\n\t// Units: nanoseconds (Linux)\n\t// Units: 100's of nanoseconds (Windows)\n\tTotalUsage uint64 `json:\"total_usage\"`\n}\ntype MemoryStats struct {\n\t// current res_counter usage for memory\n\tUsage uint64 `json:\"usage,omitempty\"`\n\t// all the stats exported via memory.stat.\n\tStats MemoryStatsStats `json:\"stats\"`\n\t// private working set (Windows only)\n\tPrivateWorkingSet uint64 `json:\"privateworkingset,omitempty\"`\n}\ntype MemoryStatsStats struct {\n\tCache        uint64 `json:\"cache,omitempty\"`\n\tInactiveFile uint64 `json:\"inactive_file,omitempty\"`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go", "rel_path": "src/entities/container/container.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 94, "end_line": 105, "text": "type NetworkStats struct {\n\t// Bytes received. Windows and Linux.\n\tRxBytes uint64 `json:\"rx_bytes\"`\n\t// Bytes sent. Windows and Linux.\n\tTxBytes uint64 `json:\"tx_bytes\"`\n}\n\ntype prevNetStats struct {\n\tSent uint64\n\tRecv uint64\n}\n", "n_tokens": 63, "primary_symbol": "", "primary_kind": "", "primary_span": [94, 105], "def_symbols": [], "symbols": ["type", "NetworkStats", "struct", "Bytes", "received", "Windows", "and", "Linux", "RxBytes", "uint64", "json", "rx_bytes", "sent", "TxBytes", "tx_bytes", "prevNetStats", "Sent", "Recv"], "doc_head": "type NetworkStats struct {\n\t// Bytes received. Windows and Linux.\n\tRxBytes uint64 `json:\"rx_bytes\"`\n\t// Bytes sent. Windows and Linux.\n\tTxBytes uint64 `json:\"tx_bytes\"`\n}\ntype prevNetStats struct {\n\tSent uint64\n\tRecv uint64\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/container/container.go", "rel_path": "src/entities/container/container.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 106, "end_line": 119, "text": "// Docker container stats\ntype Stats struct {\n\tName        string  `json:\"n\" cbor:\"0,keyasint\"`\n\tCpu         float64 `json:\"c\" cbor:\"1,keyasint\"`\n\tMem         float64 `json:\"m\" cbor:\"2,keyasint\"`\n\tNetworkSent float64 `json:\"ns\" cbor:\"3,keyasint\"`\n\tNetworkRecv float64 `json:\"nr\" cbor:\"4,keyasint\"`\n\t// PrevCpu     [2]uint64    `json:\"-\"`\n\tCpuSystem    uint64       `json:\"-\"`\n\tCpuContainer uint64       `json:\"-\"`\n\tPrevNet      prevNetStats `json:\"-\"`\n\tPrevReadTime time.Time    `json:\"-\"`\n}\n", "n_tokens": 153, "primary_symbol": "", "primary_kind": "", "primary_span": [106, 119], "def_symbols": [], "symbols": ["Docker", "container", "stats", "type", "Stats", "struct", "Name", "string", "json", "cbor", "keyasint", "Cpu", "float64", "Mem", "NetworkSent", "NetworkRecv", "PrevCpu", "uint64", "CpuSystem", "CpuContainer", "PrevNet", "prevNetStats", "PrevReadTime", "time", "Time"], "doc_head": "// Docker container stats\ntype Stats struct {\n\tName        string  `json:\"n\" cbor:\"0,keyasint\"`\n\tCpu         float64 `json:\"c\" cbor:\"1,keyasint\"`\n\tMem         float64 `json:\"m\" cbor:\"2,keyasint\"`\n\tNetworkSent float64 `json:\"ns\" cbor:\"3,keyasint\"`\n\tNetworkRecv float64 `json:\"nr\" cbor:\"4,keyasint\"`\n\t// PrevCpu     [2]uint64    `json:\"-\"`\n\tCpuSystem    uint64       `json:\"-\"`\n\tCpuContainer uint64       `json:\"-\"`\n\tPrevNet      prevNetStats `json:\"-\"`\n\tPrevReadTime time.Time    `json:\"-\"`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go#1", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go", "rel_path": "src/entities/system/system.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 10, "text": "package system\n\n// TODO: this is confusing, make common package with common/types common/helpers etc\n\nimport (\n\t\"time\"\n\n\t\"github.com/henrygd/beszel/src/entities/container\"\n)\n", "n_tokens": 40, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 10], "def_symbols": [], "symbols": ["package", "system", "TODO", "this", "confusing", "make", "common", "with", "types", "helpers", "etc", "import", "time", "github", "com", "henrygd", "beszel", "src", "entities", "container"], "doc_head": "package system\n// TODO: this is confusing, make common package with common/types common/helpers etc\nimport (\n\t\"time\"\n\t\"github.com/henrygd/beszel/src/entities/container\"\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go#2", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go", "rel_path": "src/entities/system/system.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 11, "end_line": 45, "text": "type Stats struct {\n\tCpu            float64             `json:\"cpu\" cbor:\"0,keyasint\"`\n\tMaxCpu         float64             `json:\"cpum,omitempty\" cbor:\"1,keyasint,omitempty\"`\n\tMem            float64             `json:\"m\" cbor:\"2,keyasint\"`\n\tMemUsed        float64             `json:\"mu\" cbor:\"3,keyasint\"`\n\tMemPct         float64             `json:\"mp\" cbor:\"4,keyasint\"`\n\tMemBuffCache   float64             `json:\"mb\" cbor:\"5,keyasint\"`\n\tMemZfsArc      float64             `json:\"mz,omitempty\" cbor:\"6,keyasint,omitempty\"` // ZFS ARC memory\n\tSwap           float64             `json:\"s,omitempty\" cbor:\"7,keyasint,omitempty\"`\n\tSwapUsed       float64             `json:\"su,omitempty\" cbor:\"8,keyasint,omitempty\"`\n\tDiskTotal      float64             `json:\"d\" cbor:\"9,keyasint\"`\n\tDiskUsed       float64             `json:\"du\" cbor:\"10,keyasint\"`\n\tDiskPct        float64             `json:\"dp\" cbor:\"11,keyasint\"`\n\tDiskReadPs     float64             `json:\"dr\" cbor:\"12,keyasint\"`\n\tDiskWritePs    float64             `json:\"dw\" cbor:\"13,keyasint\"`\n\tMaxDiskReadPs  float64             `json:\"drm,omitempty\" cbor:\"14,keyasint,omitempty\"`\n\tMaxDiskWritePs float64             `json:\"dwm,omitempty\" cbor:\"15,keyasint,omitempty\"`\n\tNetworkSent    float64             `json:\"ns\" cbor:\"16,keyasint\"`\n\tNetworkRecv    float64             `json:\"nr\" cbor:\"17,keyasint\"`\n\tMaxNetworkSent float64             `json:\"nsm,omitempty\" cbor:\"18,keyasint,omitempty\"`\n\tMaxNetworkRecv float64             `json:\"nrm,omitempty\" cbor:\"19,keyasint,omitempty\"`\n\tTemperatures   map[string]float64  `json:\"t,omitempty\" cbor:\"20,keyasint,omitempty\"`\n\tExtraFs        map[string]*FsStats `json:\"efs,omitempty\" cbor:\"21,keyasint,omitempty\"`\n\tGPUData        map[string]GPUData  `json:\"g,omitempty\" cbor:\"22,keyasint,omitempty\"`\n\tLoadAvg1       float64             `json:\"l1,omitempty\" cbor:\"23,keyasint,omitempty\"`\n\tLoadAvg5       float64             `json:\"l5,omitempty\" cbor:\"24,keyasint,omitempty\"`\n\tLoadAvg15      float64             `json:\"l15,omitempty\" cbor:\"25,keyasint,omitempty\"`\n\tBandwidth      [2]uint64           `json:\"b,omitzero\" cbor:\"26,keyasint,omitzero\"`  // [sent bytes, recv bytes]\n\tMaxBandwidth   [2]uint64           `json:\"bm,omitzero\" cbor:\"27,keyasint,omitzero\"` // [sent bytes, recv bytes]\n\t// TODO: remove other load fields in future release in favor of load avg array\n\tLoadAvg [3]float64 `json:\"la,omitempty\" cbor:\"28,keyasint\"`\n\tBattery [2]uint8   `json:\"bat,omitzero\" cbor:\"29,keyasint,omitzero\"` // [percent, charge state, current]\n\tMaxMem  float64    `json:\"mm,omitempty\" cbor:\"30,keyasint,omitempty\"`\n}\n", "n_tokens": 767, "primary_symbol": "", "primary_kind": "", "primary_span": [11, 45], "def_symbols": [], "symbols": ["type", "Stats", "struct", "Cpu", "float64", "json", "cpu", "cbor", "keyasint", "MaxCpu", "cpum", "omitempty", "Mem", "MemUsed", "MemPct", "MemBuffCache", "MemZfsArc", "ZFS", "ARC", "memory", "Swap", "SwapUsed", "DiskTotal", "DiskUsed", "DiskPct", "DiskReadPs", "DiskWritePs", "MaxDiskReadPs", "drm", "MaxDiskWritePs", "dwm", "NetworkSent", "NetworkRecv", "MaxNetworkSent", "nsm", "MaxNetworkRecv", "nrm", "Temperatures", "map", "string", "ExtraFs", "FsStats", "efs", "GPUData", "LoadAvg1", "LoadAvg5", "LoadAvg15", "l15", "Bandwidth", "uint64", "omitzero", "sent", "bytes", "recv", "MaxBandwidth", "TODO", "remove", "other", "load", "fields", "future", "release", "favor", "avg", "array", "LoadAvg", "Battery", "uint8", "bat", "percent", "charge", "state", "current", "MaxMem"], "doc_head": "type Stats struct {\n\tCpu            float64             `json:\"cpu\" cbor:\"0,keyasint\"`\n\tMaxCpu         float64             `json:\"cpum,omitempty\" cbor:\"1,keyasint,omitempty\"`\n\tMem            float64             `json:\"m\" cbor:\"2,keyasint\"`\n\tMemUsed        float64             `json:\"mu\" cbor:\"3,keyasint\"`\n\tMemPct         float64             `json:\"mp\" cbor:\"4,keyasint\"`\n\tMemBuffCache   float64             `json:\"mb\" cbor:\"5,keyasint\"`\n\tMemZfsArc      float64             `json:\"mz,omitempty\" cbor:\"6,keyasint,omitempty\"` // ZFS ARC memory\n\tSwap           float64             `json:\"s,omitempty\" cbor:\"7,keyasint,omitempty\"`\n\tSwapUsed       float64             `json:\"su,omitempty\" cbor:\"8,keyasint,omitempty\"`\n\tDiskTotal      float64             `json:\"d\" cbor:\"9,keyasint\"`\n\tDiskUsed       float64             `json:\"du\" cbor:\"10,keyasint\"`\n\tDiskPct        float64             `json:\"dp\" cbor:\"11,keyasint\"`\n\tDiskReadPs     float64             `json:\"dr\" cbor:\"12,keyasint\"`\n\tDiskWritePs    float64             `json:\"dw\" cbor:\"13,keyasint\"`\n\tMaxDiskReadPs  float64             `json:\"drm,omitempty\" cbor:\"14,keyasint,omitempty\"`\n\tMaxDiskWritePs float64             `json:\"dwm,omitempty\" cbor:\"15"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go#3", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go", "rel_path": "src/entities/system/system.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 46, "end_line": 55, "text": "type GPUData struct {\n\tName        string  `json:\"n\" cbor:\"0,keyasint\"`\n\tTemperature float64 `json:\"-\"`\n\tMemoryUsed  float64 `json:\"mu,omitempty\" cbor:\"1,keyasint,omitempty\"`\n\tMemoryTotal float64 `json:\"mt,omitempty\" cbor:\"2,keyasint,omitempty\"`\n\tUsage       float64 `json:\"u\" cbor:\"3,keyasint\"`\n\tPower       float64 `json:\"p,omitempty\" cbor:\"4,keyasint,omitempty\"`\n\tCount       float64 `json:\"-\"`\n}\n", "n_tokens": 117, "primary_symbol": "", "primary_kind": "", "primary_span": [46, 55], "def_symbols": [], "symbols": ["type", "GPUData", "struct", "Name", "string", "json", "cbor", "keyasint", "Temperature", "float64", "MemoryUsed", "omitempty", "MemoryTotal", "Usage", "Power", "Count"], "doc_head": "type GPUData struct {\n\tName        string  `json:\"n\" cbor:\"0,keyasint\"`\n\tTemperature float64 `json:\"-\"`\n\tMemoryUsed  float64 `json:\"mu,omitempty\" cbor:\"1,keyasint,omitempty\"`\n\tMemoryTotal float64 `json:\"mt,omitempty\" cbor:\"2,keyasint,omitempty\"`\n\tUsage       float64 `json:\"u\" cbor:\"3,keyasint\"`\n\tPower       float64 `json:\"p,omitempty\" cbor:\"4,keyasint,omitempty\"`\n\tCount       float64 `json:\"-\"`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go#4", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go", "rel_path": "src/entities/system/system.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 56, "end_line": 69, "text": "type FsStats struct {\n\tTime           time.Time `json:\"-\"`\n\tRoot           bool      `json:\"-\"`\n\tMountpoint     string    `json:\"-\"`\n\tDiskTotal      float64   `json:\"d\" cbor:\"0,keyasint\"`\n\tDiskUsed       float64   `json:\"du\" cbor:\"1,keyasint\"`\n\tTotalRead      uint64    `json:\"-\"`\n\tTotalWrite     uint64    `json:\"-\"`\n\tDiskReadPs     float64   `json:\"r\" cbor:\"2,keyasint\"`\n\tDiskWritePs    float64   `json:\"w\" cbor:\"3,keyasint\"`\n\tMaxDiskReadPS  float64   `json:\"rm,omitempty\" cbor:\"4,keyasint,omitempty\"`\n\tMaxDiskWritePS float64   `json:\"wm,omitempty\" cbor:\"5,keyasint,omitempty\"`\n}\n", "n_tokens": 179, "primary_symbol": "", "primary_kind": "", "primary_span": [56, 69], "def_symbols": [], "symbols": ["type", "FsStats", "struct", "Time", "time", "json", "Root", "bool", "Mountpoint", "string", "DiskTotal", "float64", "cbor", "keyasint", "DiskUsed", "TotalRead", "uint64", "TotalWrite", "DiskReadPs", "DiskWritePs", "MaxDiskReadPS", "omitempty", "MaxDiskWritePS"], "doc_head": "type FsStats struct {\n\tTime           time.Time `json:\"-\"`\n\tRoot           bool      `json:\"-\"`\n\tMountpoint     string    `json:\"-\"`\n\tDiskTotal      float64   `json:\"d\" cbor:\"0,keyasint\"`\n\tDiskUsed       float64   `json:\"du\" cbor:\"1,keyasint\"`\n\tTotalRead      uint64    `json:\"-\"`\n\tTotalWrite     uint64    `json:\"-\"`\n\tDiskReadPs     float64   `json:\"r\" cbor:\"2,keyasint\"`\n\tDiskWritePs    float64   `json:\"w\" cbor:\"3,keyasint\"`\n\tMaxDiskReadPS  float64   `json:\"rm,omitempty\" cbor:\"4,keyasint,omitempty\"`\n\tMaxDiskWritePS float64   `json:\"wm,omitempty\" cbor:\"5,keyasint,omitempty\"`\n}"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go#5", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go", "rel_path": "src/entities/system/system.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 70, "end_line": 85, "text": "type NetIoStats struct {\n\tBytesRecv uint64\n\tBytesSent uint64\n\tTime      time.Time\n\tName      string\n}\n\ntype Os = uint8\n\nconst (\n\tLinux Os = iota\n\tDarwin\n\tWindows\n\tFreebsd\n)\n", "n_tokens": 54, "primary_symbol": "", "primary_kind": "", "primary_span": [70, 85], "def_symbols": [], "symbols": ["type", "NetIoStats", "struct", "BytesRecv", "uint64", "BytesSent", "Time", "time", "Name", "string", "uint8", "const", "Linux", "iota", "Darwin", "Windows", "Freebsd"], "doc_head": "type NetIoStats struct {\n\tBytesRecv uint64\n\tBytesSent uint64\n\tTime      time.Time\n\tName      string\n}\ntype Os = uint8\nconst (\n\tLinux Os = iota\n\tDarwin\n\tWindows\n\tFreebsd\n)"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go#6", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go", "rel_path": "src/entities/system/system.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 86, "end_line": 109, "text": "type Info struct {\n\tHostname       string  `json:\"h\" cbor:\"0,keyasint\"`\n\tKernelVersion  string  `json:\"k,omitempty\" cbor:\"1,keyasint,omitempty\"`\n\tCores          int     `json:\"c\" cbor:\"2,keyasint\"`\n\tThreads        int     `json:\"t,omitempty\" cbor:\"3,keyasint,omitempty\"`\n\tCpuModel       string  `json:\"m\" cbor:\"4,keyasint\"`\n\tUptime         uint64  `json:\"u\" cbor:\"5,keyasint\"`\n\tCpu            float64 `json:\"cpu\" cbor:\"6,keyasint\"`\n\tMemPct         float64 `json:\"mp\" cbor:\"7,keyasint\"`\n\tDiskPct        float64 `json:\"dp\" cbor:\"8,keyasint\"`\n\tBandwidth      float64 `json:\"b\" cbor:\"9,keyasint\"`\n\tAgentVersion   string  `json:\"v\" cbor:\"10,keyasint\"`\n\tPodman         bool    `json:\"p,omitempty\" cbor:\"11,keyasint,omitempty\"`\n\tGpuPct         float64 `json:\"g,omitempty\" cbor:\"12,keyasint,omitempty\"`\n\tDashboardTemp  float64 `json:\"dt,omitempty\" cbor:\"13,keyasint,omitempty\"`\n\tOs             Os      `json:\"os\" cbor:\"14,keyasint\"`\n\tLoadAvg1       float64 `json:\"l1,omitempty\" cbor:\"15,keyasint,omitempty\"`\n\tLoadAvg5       float64 `json:\"l5,omitempty\" cbor:\"16,keyasint,omitempty\"`\n\tLoadAvg15      float64 `json:\"l15,omitempty\" cbor:\"17,keyasint,omitempty\"`\n\tBandwidthBytes uint64  `json:\"bb\" cbor:\"18,keyasint\"`\n\t// TODO: remove load fields in future release in favor of load avg array\n\tLoadAvg [3]float64 `json:\"la,omitempty\" cbor:\"19,keyasint\"`\n}\n", "n_tokens": 426, "primary_symbol": "", "primary_kind": "", "primary_span": [86, 109], "def_symbols": [], "symbols": ["type", "Info", "struct", "Hostname", "string", "json", "cbor", "keyasint", "KernelVersion", "omitempty", "Cores", "int", "Threads", "CpuModel", "Uptime", "uint64", "Cpu", "float64", "cpu", "MemPct", "DiskPct", "Bandwidth", "AgentVersion", "Podman", "bool", "GpuPct", "DashboardTemp", "LoadAvg1", "LoadAvg5", "LoadAvg15", "l15", "BandwidthBytes", "TODO", "remove", "load", "fields", "future", "release", "favor", "avg", "array", "LoadAvg"], "doc_head": "type Info struct {\n\tHostname       string  `json:\"h\" cbor:\"0,keyasint\"`\n\tKernelVersion  string  `json:\"k,omitempty\" cbor:\"1,keyasint,omitempty\"`\n\tCores          int     `json:\"c\" cbor:\"2,keyasint\"`\n\tThreads        int     `json:\"t,omitempty\" cbor:\"3,keyasint,omitempty\"`\n\tCpuModel       string  `json:\"m\" cbor:\"4,keyasint\"`\n\tUptime         uint64  `json:\"u\" cbor:\"5,keyasint\"`\n\tCpu            float64 `json:\"cpu\" cbor:\"6,keyasint\"`\n\tMemPct         float64 `json:\"mp\" cbor:\"7,keyasint\"`\n\tDiskPct        float64 `json:\"dp\" cbor:\"8,keyasint\"`\n\tBandwidth      float64 `json:\"b\" cbor:\"9,keyasint\"`\n\tAgentVersion   string  `json:\"v\" cbor:\"10,keyasint\"`\n\tPodman         bool    `json:\"p,omitempty\" cbor:\"11,keyasint,omitempty\"`\n\tGpuPct         float64 `json:\"g,omitempty\" cbor:\"12,keyasint,omitempty\"`\n\tDashboardTemp  float64 `json:\"dt,omitempty\" cbor:\"13,keyasint,omitempty\"`\n\tOs             Os      `json:\"os\" cbor:\"14,keyasint\"`\n\tLoadAvg1       float64 `json:\"l1,omitempty\" cbor:\"15,keyasint,omitempty\"`\n\tLoadAvg5       float64 `json:\"l5,omitempty\" cbor:\"16,keyasint,omitempty\"`\n\tLoadAvg15      float64 `json:\"l15,omitempty\" cbor:\"17,keyasint,omitempty\"`\n\tBandwidthBytes uint64  `json:\"bb\" cbor:\"18,keyas"}
{"id": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go#7", "repo_id": "beszel-main", "path": "/Users/zack.alatrash/Downloads/beszel-main/src/entities/system/system.go", "rel_path": "src/entities/system/system.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 110, "end_line": 116, "text": "// Final data structure to return to the hub\ntype CombinedData struct {\n\tStats      Stats              `json:\"stats\" cbor:\"0,keyasint\"`\n\tInfo       Info               `json:\"info\" cbor:\"1,keyasint\"`\n\tContainers []*container.Stats `json:\"container\" cbor:\"2,keyasint\"`\n}\n", "n_tokens": 71, "primary_symbol": "", "primary_kind": "", "primary_span": [110, 116], "def_symbols": [], "symbols": ["Final", "data", "structure", "return", "the", "hub", "type", "CombinedData", "struct", "Stats", "json", "stats", "cbor", "keyasint", "Info", "info", "Containers", "container"], "doc_head": "// Final data structure to return to the hub\ntype CombinedData struct {\n\tStats      Stats              `json:\"stats\" cbor:\"0,keyasint\"`\n\tInfo       Info               `json:\"info\" cbor:\"1,keyasint\"`\n\tContainers []*container.Stats `json:\"container\" cbor:\"2,keyasint\"`\n}"}
