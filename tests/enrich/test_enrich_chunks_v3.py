"""
Unit tests for the enrichment tool.

This module tests the enrichment functionality including generated file detection,
Dutch summary generation, caching, and golden file validation.
"""

import json
import os
import tempfile
import unittest
from unittest.mock import Mock, patch, MagicMock
from pathlib import Path

# Add the project root to the path
import sys
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from enrich.llm_enricher import LLMEnricher
from enrich.cache import EnrichmentCache
from enrich.prompts import get_file_synopsis_prompt, get_per_chunk_prompt


class TestLLMEnricher(unittest.TestCase):
    """Test the LLM enricher functionality."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.enricher = LLMEnricher()
        
        # Sample chunk data
        self.sample_chunk = {
            "id": "test.go#1",
            "path": "test.go",
            "text": "func GetData() string { return \"test\" }",
            "ast_path": "go:function:GetData",
            "node_kind": "function",
            "type_name": "",
            "function_name": "GetData",
            "method_name": "",
            "is_generated": False
        }
        
        self.generated_chunk = {
            "id": "test.pb.go#1",
            "path": "test.pb.go",
            "text": "// Code generated by protoc-gen-go. DO NOT EDIT.",
            "ast_path": "go:type:TestMessage (struct)",
            "node_kind": "type",
            "type_name": "TestMessage",
            "function_name": "",
            "method_name": "",
            "is_generated": True
        }
    
    def test_is_generated_file(self):
        """Test generated file detection."""
        # Test explicit flag
        self.assertTrue(self.enricher._is_generated_file("test.go", self.generated_chunk))
        
        # Test file path patterns
        self.assertTrue(self.enricher._is_generated_file("test.pb.go", self.sample_chunk))
        self.assertTrue(self.enricher._is_generated_file("test.gen.go", self.sample_chunk))
        self.assertTrue(self.enricher._is_generated_file("test_generated.go", self.sample_chunk))
        self.assertTrue(self.enricher._is_generated_file("test.g.dart", self.sample_chunk))
        
        # Test non-generated files
        self.assertFalse(self.enricher._is_generated_file("test.go", self.sample_chunk))
        self.assertFalse(self.enricher._is_generated_file("service.go", self.sample_chunk))
    
    def test_truncate_text(self):
        """Test text truncation."""
        short_text = "short"
        long_text = "a" * 1000
        
        self.assertEqual(self.enricher._truncate_text(short_text, 100), short_text)
        self.assertEqual(len(self.enricher._truncate_text(long_text, 100)), 100)
        self.assertTrue(self.enricher._truncate_text(long_text, 100).endswith("..."))
    
    def test_hash_content(self):
        """Test content hashing."""
        text1 = "test content"
        text2 = "test content"
        text3 = "different content"
        
        hash1 = self.enricher._hash_content(text1)
        hash2 = self.enricher._hash_content(text2)
        hash3 = self.enricher._hash_content(text3)
        
        self.assertEqual(hash1, hash2)
        self.assertNotEqual(hash1, hash3)
        self.assertEqual(len(hash1), 64)  # SHA256 hex length
    
    @patch('enrich.llm_enricher.requests.post')
    def test_call_ollama_success(self, mock_post):
        """Test successful Ollama API call."""
        mock_response = Mock()
        mock_response.json.return_value = {"response": "test response"}
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response
        
        result = self.enricher._call_ollama("system", "user")
        
        self.assertEqual(result, "test response")
        mock_post.assert_called_once()
    
    @patch('enrich.llm_enricher.requests.post')
    def test_call_ollama_retry(self, mock_post):
        """Test Ollama API call with retry logic."""
        # First call fails, second succeeds
        mock_response = Mock()
        mock_response.json.return_value = {"response": "success"}
        mock_response.raise_for_status.return_value = None
        
        mock_post.side_effect = [Exception("Network error"), mock_response]
        
        result = self.enricher._call_ollama("system", "user")
        
        self.assertEqual(result, "success")
        self.assertEqual(mock_post.call_count, 2)
    
    def test_parse_json_response(self):
        """Test JSON response parsing."""
        # Test normal JSON
        json_response = '{"summary_nl": "test", "keywords_nl": ["a", "b"]}'
        result = self.enricher._parse_json_response(json_response)
        self.assertEqual(result["summary_nl"], "test")
        self.assertEqual(result["keywords_nl"], ["a", "b"])
        
        # Test JSON with markdown fences
        markdown_response = '```json\n{"summary_nl": "test", "keywords_nl": ["a", "b"]}\n```'
        result = self.enricher._parse_json_response(markdown_response)
        self.assertEqual(result["summary_nl"], "test")
        
        # Test invalid JSON
        with self.assertRaises(ValueError):
            self.enricher._parse_json_response("invalid json")
    
    def test_generate_template_enrichment(self):
        """Test template enrichment for generated files."""
        result = self.enricher._generate_template_enrichment(
            self.generated_chunk, "test_hash"
        )
        
        self.assertIn("summary_nl", result)
        self.assertIn("keywords_nl", result)
        self.assertIn("enrich_provenance", result)
        self.assertEqual(result["enrich_provenance"]["skipped_reason"], "generated")
        self.assertIn("protobuf", result["keywords_nl"])
    
    @patch.object(LLMEnricher, '_call_ollama')
    def test_enrich_chunk_generated(self, mock_call):
        """Test enrichment of generated chunks (should use template)."""
        result = self.enricher.enrich_chunk(
            self.generated_chunk, "file synopsis", "synopsis_hash"
        )
        
        # Should not call LLM for generated files
        mock_call.assert_not_called()
        
        self.assertEqual(result["enrich_provenance"]["skipped_reason"], "generated")
        self.assertIn("Gegenereerde", result["summary_nl"])
    
    @patch.object(LLMEnricher, '_call_ollama')
    def test_enrich_chunk_llm_success(self, mock_call):
        """Test successful LLM enrichment."""
        mock_call.return_value = '{"summary_nl": "Haalt data op", "keywords_nl": ["data", "ophalen", "functie"]}'
        
        result = self.enricher.enrich_chunk(
            self.sample_chunk, "file synopsis", "synopsis_hash"
        )
        
        mock_call.assert_called_once()
        self.assertEqual(result["summary_nl"], "Haalt data op")
        self.assertEqual(result["keywords_nl"], ["data", "ophalen", "functie"])
        self.assertIsNone(result["enrich_provenance"]["skipped_reason"])
    
    @patch.object(LLMEnricher, '_call_ollama')
    def test_enrich_chunk_llm_retry(self, mock_call):
        """Test LLM enrichment with retry on JSON parse error."""
        # First call returns invalid JSON, second returns valid JSON
        mock_call.side_effect = [
            'invalid json response',
            '{"summary_nl": "Haalt data op", "keywords_nl": ["data", "ophalen"]}'
        ]
        
        result = self.enricher.enrich_chunk(
            self.sample_chunk, "file synopsis", "synopsis_hash"
        )
        
        self.assertEqual(mock_call.call_count, 2)
        self.assertEqual(result["summary_nl"], "Haalt data op")
    
    @patch.object(LLMEnricher, '_call_ollama')
    def test_enrich_chunk_llm_failure(self, mock_call):
        """Test LLM enrichment failure handling."""
        mock_call.side_effect = Exception("LLM service unavailable")
        
        result = self.enricher.enrich_chunk(
            self.sample_chunk, "file synopsis", "synopsis_hash"
        )
        
        self.assertEqual(result["enrich_provenance"]["skipped_reason"], "llm_error")
        self.assertIn("mislukt", result["summary_nl"])


class TestEnrichmentCache(unittest.TestCase):
    """Test the enrichment cache functionality."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.temp_dir = tempfile.mkdtemp()
        self.cache_path = os.path.join(self.temp_dir, "test_cache.sqlite")
        self.cache = EnrichmentCache(self.cache_path)
    
    def tearDown(self):
        """Clean up test fixtures."""
        if os.path.exists(self.cache_path):
            os.remove(self.cache_path)
        os.rmdir(self.temp_dir)
    
    def test_cache_set_get(self):
        """Test basic cache set and get operations."""
        chunk_id = "test.go#1"
        file_sha = "abc123"
        chunk_text = "func test() {}"
        file_synopsis_hash = "def456"
        summary_nl = "Test functie"
        keywords_nl = ["test", "functie"]
        model = "qwen2.5-coder:7b-instruct"
        
        # Set cache
        self.cache.set(chunk_id, file_sha, chunk_text, file_synopsis_hash, 
                      summary_nl, keywords_nl, model)
        
        # Get from cache
        result = self.cache.get(chunk_id, file_sha, chunk_text)
        
        self.assertIsNotNone(result)
        self.assertEqual(result["summary_nl"], summary_nl)
        self.assertEqual(result["keywords_nl"], keywords_nl)
        self.assertEqual(result["enrich_provenance"]["model"], model)
    
    def test_cache_miss(self):
        """Test cache miss scenarios."""
        # Different chunk text
        result = self.cache.get("test.go#1", "abc123", "different text")
        self.assertIsNone(result)
        
        # Different file SHA
        result = self.cache.get("test.go#1", "different_sha", "func test() {}")
        self.assertIsNone(result)
    
    def test_cache_stats(self):
        """Test cache statistics."""
        # Empty cache
        stats = self.cache.stats()
        self.assertEqual(stats["total_entries"], 0)
        self.assertEqual(stats["unique_files"], 0)
        
        # Add some entries
        self.cache.set("test1.go#1", "sha1", "text1", "syn1", "sum1", ["kw1"], "model")
        self.cache.set("test1.go#2", "sha1", "text2", "syn1", "sum2", ["kw2"], "model")
        self.cache.set("test2.go#1", "sha2", "text3", "syn2", "sum3", ["kw3"], "model")
        
        stats = self.cache.stats()
        self.assertEqual(stats["total_entries"], 3)
        self.assertEqual(stats["unique_files"], 2)


class TestPrompts(unittest.TestCase):
    """Test prompt template functionality."""
    
    def test_file_synopsis_prompt(self):
        """Test file synopsis prompt generation."""
        system, user = get_file_synopsis_prompt(
            "test.go", "go", "package main\nfunc main() {}"
        )
        
        self.assertIn("behulpzame code-analist", system)
        self.assertIn("test.go", user)
        self.assertIn("go", user)
        self.assertIn("package main", user)
    
    def test_per_chunk_prompt(self):
        """Test per-chunk prompt generation."""
        system, user = get_per_chunk_prompt(
            "File synopsis", "go:function:Test", "function", "Test", "Test", "func Test() {}"
        )
        
        self.assertIn("korte, feitelijke samenvattingen", system)
        self.assertIn("File synopsis", user)
        self.assertIn("go:function:Test", user)
        self.assertIn("func Test() {}", user)
    
    def test_per_chunk_retry_prompt(self):
        """Test per-chunk retry prompt generation."""
        system, user = get_per_chunk_prompt(
            "File synopsis", "go:function:Test", "function", "Test", "Test", "func Test() {}",
            is_retry=True
        )
        
        self.assertIn("Return JSON only", user)


class TestGoldenFiles(unittest.TestCase):
    """Test against golden files."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.fixtures_dir = Path(__file__).parent / "fixtures"
        self.golden_dir = Path(__file__).parent / "golden"
    
    def test_input_fixture_exists(self):
        """Test that input fixture exists and is valid JSONL."""
        input_file = self.fixtures_dir / "chunks_input.jsonl"
        self.assertTrue(input_file.exists())
        
        with open(input_file, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if line:
                    try:
                        json.loads(line)
                    except json.JSONDecodeError as e:
                        self.fail(f"Invalid JSON in input fixture line {line_num}: {e}")
    
    def test_golden_file_exists(self):
        """Test that golden file exists and is valid JSONL."""
        golden_file = self.golden_dir / "chunks_enriched.jsonl"
        self.assertTrue(golden_file.exists())
        
        with open(golden_file, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if line:
                    try:
                        chunk = json.loads(line)
                        # Check required enrichment fields
                        self.assertIn("summary_nl", chunk)
                        self.assertIn("keywords_nl", chunk)
                        self.assertIn("enrich_provenance", chunk)
                        
                        # Check summary is Dutch and reasonable length
                        summary = chunk["summary_nl"]
                        self.assertLessEqual(len(summary), 160)
                        self.assertGreater(len(summary), 10)
                        
                        # Check keywords are reasonable
                        keywords = chunk["keywords_nl"]
                        self.assertIsInstance(keywords, list)
                        self.assertGreaterEqual(len(keywords), 5)
                        self.assertLessEqual(len(keywords), 10)
                        
                    except json.JSONDecodeError as e:
                        self.fail(f"Invalid JSON in golden file line {line_num}: {e}")
    
    def test_generated_file_template(self):
        """Test that generated files get templated summaries."""
        golden_file = self.golden_dir / "chunks_enriched.jsonl"
        
        with open(golden_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line:
                    chunk = json.loads(line)
                    if chunk.get("path", "").endswith(".pb.go"):
                        # Should be templated
                        self.assertEqual(chunk["enrich_provenance"]["skipped_reason"], "generated")
                        self.assertIn("Gegenereerde", chunk["summary_nl"])
                        self.assertIn("protobuf", chunk["keywords_nl"])
    
    def test_handwritten_file_llm(self):
        """Test that handwritten files get LLM summaries."""
        golden_file = self.golden_dir / "chunks_enriched.jsonl"
        
        with open(golden_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line:
                    chunk = json.loads(line)
                    if not chunk.get("path", "").endswith(".pb.go"):
                        # Should be LLM-generated
                        self.assertIsNone(chunk["enrich_provenance"]["skipped_reason"])
                        # Should contain Dutch words
                        summary = chunk["summary_nl"]
                        dutch_words = ["haalt", "op", "genereert", "definieert", "berekent", "bouwt"]
                        self.assertTrue(any(word in summary.lower() for word in dutch_words))


if __name__ == "__main__":
    unittest.main()
