{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/main.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/main.go", "rel_path": "main.go", "module": "main", "ext": "go", "chunk_number": 1, "symbols": ["main", "package", "impalastudios", "forecasts", "panic", "run", "root", "weather", "func", "import"], "ast_kind": "function_or_method", "text": "package main\n\nimport (\n\t\"go.impalastudios.com/weather/forecasts/cmd\"\n)\n\nfunc main() {\n\tif err := cmd.RunRootCmd(); err != nil {\n\t\tpanic(err)\n\t}\n}\n", "n_tokens": 42, "byte_len": 146, "file_sha1": "687b939e13cce6c9493d077f6cb0342384e9e0a8", "start_line": 1, "end_line": 12}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/cmd/root.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/cmd/root.go", "rel_path": "cmd/root.go", "module": "cmd.root", "ext": "go", "chunk_number": 1, "symbols": ["RunRootCmd", "short", "add", "command", "application", "string", "foreca", "strings", "viper", "persistent", "flags", "false", "stringp", "root", "run", "error", "json", "logs", "level", "forecasts", "package", "weather", "execute", "emit", "whether", "set", "env", "services", "github", "func", "endpoint", "import", "strategy", "new", "replacer", "encoding", "automatic", "bool", "logging", "return", "cobra", "proxy", "spf", "spf13", "bind", "impalastudios", "serve", "microservice", "name", "version"], "ast_kind": "function_or_method", "text": "package cmd\n\nimport (\n\t\"go.impalastudios.com/weather/forecasts/cmd/serve\"\n\t\"strings\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n)\n\n// RunRootCmd entrypoint of the root command\nfunc RunRootCmd() error {\n\tviper.AutomaticEnv()\n\tviper.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\", \"-\", \"_\"))\n\n\tcmd := &cobra.Command{\n\t\tUse:     \"weather-forecasts\",\n\t\tShort:   \"[Weather] Forecast microservice\",\n\t\tVersion: \"0.0.1\",\n\t}\n\n\tcmd.AddCommand(serve.New())\n\n\tcmd.PersistentFlags().Bool(\"logging.debug\", false, \"Whether to emit debug level logs or not.\")\n\tcmd.PersistentFlags().String(\"logging.encoding\", \"json\", \"The log encoding strategy.\")\n\tcmd.PersistentFlags().StringP(\"app.name\", \"n\", \"weather-forecasts\", \"The application name.\")\n\n\tcmd.PersistentFlags().String(\"services.foreca-proxy-endpoint\", \"\", \"The endpoint of the Foreca Proxy microservice.\")\n\tcmd.PersistentFlags().String(\"services.locations-endpoint\", \"\", \"The endpoint of the Locations microservice.\")\n\n\t_ = viper.BindPFlags(cmd.PersistentFlags())\n\n\treturn cmd.Execute()\n}\n", "n_tokens": 256, "byte_len": 1037, "file_sha1": "96d633dc4f42c83aad8982dc9e1b07525a8a2276", "start_line": 1, "end_line": 35}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/cmd/serve/http.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/cmd/serve/http.go", "rel_path": "cmd/serve/http.go", "module": "cmd.serve.http", "ext": "go", "chunk_number": 1, "symbols": ["newServeHttpCommand", "short", "zapcore", "customrules", "foreca", "function", "string", "viper", "persistent", "flags", "start", "httpresponses", "signal", "error", "new", "serve", "cockroachdb", "server", "run", "rune", "http", "package", "forecasts", "adapters", "requestid", "port", "time", "that", "opentelemetry", "weather", "runServeHttp", "logger", "config", "handler", "handlerv0", "set", "addr", "case", "chan", "failed", "path", "info", "legacy", "request", "endpoint", "defer", "grpc", "pbv", "context", "wrap"], "ast_kind": "function_or_method", "text": "package serve\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tginzap \"github.com/gin-contrib/zap\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-gonic/gin/binding\"\n\t\"github.com/go-playground/validator/v10\"\n\t\"go.impalastudios.com/grpc/dnssrvresolver\"\n\t\"go.impalastudios.com/log\"\n\trequestid \"go.impalastudios.com/requestid/gin\"\n\t\"go.impalastudios.com/weather/forecasts/internal/forecasts\"\n\t\"go.impalastudios.com/weather/forecasts/internal/forecasts/adapters\"\n\tforecaPbv0 \"go.impalastudios.com/weather/forecasts/internal/forecasts/adapters/clients/foreca/v0\"\n\tlocationsPbv0 \"go.impalastudios.com/weather/forecasts/internal/forecasts/adapters/clients/locations/v0\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/xotel\"\n\t\"go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/propagation\"\n\t\"go.uber.org/zap/zapcore\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"go.impalastudios.com/validation/customrules\"\n\thttphandlers \"go.impalastudios.com/weather/forecasts/internal/forecasts/adapters/handlers/http\"\n\t\"go.impalastudios.com/weather/forecasts/internal/forecasts/adapters/handlers/http/v0\"\n\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n\t\"go.uber.org/zap\"\n\t\"google.golang.org/grpc/resolver\"\n)\n\n// Serve is a function that starts the httpresponses server\nfunc newServeHttpCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"http\",\n\t\tShort: \"Start HTTP REST server\",\n\t\tPreRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\treturn viper.BindPFlags(cmd.Flags())\n\t\t},\n\t\tRunE: runServeHttp,\n\t\tArgs: cobra.ExactArgs(0),\n\t}\n\n\tcmd.PersistentFlags().String(\"app.http.port\", \"8080\", \"HTTP service port\")\n\n\treturn cmd\n}\n", "n_tokens": 492, "byte_len": 1707, "file_sha1": "d3ec9f89485a8a837c4cdf7522ca82a5b2cff33f", "start_line": 1, "end_line": 54}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/cmd/serve/http.go#2", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/cmd/serve/http.go", "rel_path": "cmd/serve/http.go", "module": "cmd.serve.http", "ext": "go", "chunk_number": 2, "symbols": ["runServeHttp", "logger", "config", "handler", "handlerv0", "customrules", "set", "signal", "addr", "case", "string", "adapters", "chan", "failed", "requestid", "error", "path", "info", "legacy", "request", "endpoint", "defer", "foreca", "grpc", "pbv", "wrap", "context", "proxy", "dnssrvresolver", "resolver", "newServeHttpCommand", "short", "httpresponses", "weather", "serve", "spf", "spf13", "bind", "flags", "engine", "binding", "locations", "gracefully", "tracer", "new", "health", "get", "debug", "function", "skip"], "ast_kind": "function_or_method", "text": "func runServeHttp(cmd *cobra.Command, _ []string) error {\n\tquit := make(chan os.Signal, 1)\n\tdefer close(quit)\n\n\tsignal.Notify(quit, os.Interrupt)\n\n\tlogger := log.New(\n\t\tlog.WithService(viper.GetString(\"app.name\")),\n\t\tlog.WithEncoding(viper.GetString(\"logging.encoding\")),\n\t\tlog.WithDebugEnabled(viper.GetBool(\"logging.debug\")),\n\t)\n\tlog.SetLogger(logger)\n\n\ttp, err := xotel.NewTracerProvider(cmd.Context(), xotel.TracerProviderConfig{\n\t\tEndpoint: viper.GetString(\"otel.tracer.endpoint\"),\n\t})\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to create tracer provider\")\n\t}\n\n\totel.SetTracerProvider(tp)\n\totel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{}))\n\txotel.SetGlobalTracer(tp.Tracer(viper.GetString(\"app.name\")))\n\n\tresolver.Register(dnssrvresolver.New())\n\n\tforecaGrpcClient := forecaPbv0.NewForecaProxyClient(getGrpcConnection(viper.GetString(\"services.foreca-proxy-endpoint\")))\n\tlocationsGrpcClient := locationsPbv0.NewLocationsServiceClient(getGrpcConnection(viper.GetString(\"services.locations-endpoint\")))\n\n\tforecaService := adapters.NewForecaService(forecaGrpcClient)\n\tlocationsService := adapters.NewLocationsService(locationsGrpcClient)\n\n\tforecastService := forecasts.NewService(forecaService, locationsService)\n\n\trouter := gin.New()\n\trouter.Use(requestid.New()...)\n\trouter.Use(\n\t\tginzap.GinzapWithConfig(logger, &ginzap.Config{\n\t\t\tTimeFormat: time.RFC3339,\n\t\t\tUTC:        true,\n\t\t\tSkipPaths:  []string{\"/__gw/forecasts/health\", \"/__gw/health\"},\n\t\t\tContext: func(c *gin.Context) []zapcore.Field {\n\t\t\t\treturn []zapcore.Field{\n\t\t\t\t\tlog.RequestIDExtractor(c),\n\t\t\t\t\tzap.Bool(\"is_legacy_request\", c.GetHeader(\"X-Legacy-Endpoint\") == \"true\"),\n\t\t\t\t}\n\t\t\t},\n\t\t}),\n\t\tginzap.RecoveryWithZap(logger, true),\n\t)\n\trouter.Use(otelgin.Middleware(\n\t\tviper.GetString(\"app.name\"),\n\t\totelgin.WithTracerProvider(tp),\n\t\totelgin.WithFilter(func(req *http.Request) bool {\n\t\t\tif req.URL.Path == \"/__gw/health\" {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\treturn true\n\t\t}),\n\t))\n\tlegacyGw := router.Group(\"/__gw/forecasts\")\n\tgw := router.Group(\"/__gw\")\n\n\thandlerV0 := v0.New(forecastService)\n\thandlerV0.Register(gw)\n\thandlerV0.Register(legacyGw)\n\n\thealthHandler := httphandlers.NewHealthHandler(logger)\n\thealthHandler.Register(gw)\n\thealthHandler.Register(legacyGw)\n\n\tif v, ok := binding.Validator.Engine().(*validator.Validate); ok {\n\t\tcustomrules.Register(v)\n\t}\n\n\tsrv := http.Server{\n\t\tAddr:    fmt.Sprintf(\":%d\", viper.GetInt(\"app.http.port\")),\n\t\tHandler: router,\n\t}\n\n\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\tlogger.Error(\"Error occurred while listening.\", zap.Error(err))\n\t}\n\n\t<-quit\n\n\tlogger.Info(\"Shutting down the REST server...\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tif err := srv.Shutdown(ctx); err != nil {\n\t\tlogger.Error(\"Error occurred while shutting down.\", zap.Error(err))\n\t}\n\n\tif err := tp.Shutdown(ctx); err != nil {\n\t\tlog.Error(context.TODO(), \"Error occurred while shutting down the tracer.\", zap.Error(err))\n\t}\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tlogger.Info(\"REST server shutdown timed out.\")\n\tdefault:\n\t\tlogger.Info(\"REST server shutdown gracefully.\")\n\t}\n\n\treturn nil\n}\n", "n_tokens": 823, "byte_len": 3215, "file_sha1": "d3ec9f89485a8a837c4cdf7522ca82a5b2cff33f", "start_line": 55, "end_line": 164}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/cmd/serve/root.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/cmd/serve/root.go", "rel_path": "cmd/serve/root.go", "module": "cmd.serve.root", "ext": "go", "chunk_number": 1, "symbols": ["New", "getGrpcConnection", "short", "localhost", "add", "command", "string", "conn", "persistent", "flags", "new", "serve", "interval", "client", "target", "package", "time", "with", "transport", "stats", "opentelemetry", "github", "func", "endpoint", "which", "tracer", "import", "credentials", "duration", "google", "collector", "panic", "will", "instrumentation", "golang", "return", "round", "robin", "otelgrpc", "cobra", "meter", "spf", "spf13", "tracing", "load", "balancing", "contrib", "second", "grpc", "otel"], "ast_kind": "function_or_method", "text": "package serve\n\nimport (\n\t\"github.com/spf13/cobra\"\n\t\"go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"time\"\n)\n\nfunc New() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"serve\",\n\t\tShort: \"Serve\",\n\t}\n\n\tcmd.AddCommand(newServeHttpCommand())\n\n\tcmd.PersistentFlags().String(\"otel.tracer.endpoint\", \"localhost:4317\", \"The URL of the tracing collector.\")\n\tcmd.PersistentFlags().String(\"otel.meter.endpoint\", \"localhost:4317\", \"The URL of the tracing collector.\")\n\tcmd.PersistentFlags().Duration(\"otel.meter.interval\", 60*time.Second, \"The interval which the metrics will be reported to the collector.\")\n\n\treturn cmd\n}\n\nfunc getGrpcConnection(target string) *grpc.ClientConn {\n\tconn, err := grpc.NewClient(\n\t\ttarget,\n\t\tgrpc.WithDefaultServiceConfig(`{\"loadBalancingConfig\": [{\"round_robin\":{}}]}`),\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t\tgrpc.WithStatsHandler(otelgrpc.NewClientHandler()),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn conn\n}\n", "n_tokens": 267, "byte_len": 1063, "file_sha1": "9080fdffceca3bac9d547a5ea05a93915e65e1e4", "start_line": 1, "end_line": 39}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/models.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/models.go", "rel_path": "internal/forecasts/models.go", "module": "internal.forecasts.models", "ext": "go", "chunk_number": 1, "symbols": ["Forecast", "WeatherCondition", "WindDirection", "Wind", "WindGust", "Pressure", "CurrentCondition", "DailyCondition", "HourlyCondition", "Location", "Coordinate", "dew", "point", "temperature", "feels", "float", "float32", "division", "name", "humidity", "percentage", "speed", "next", "hour", "daily", "condition", "struct", "type", "night", "isnight", "wind", "gust", "millibar", "precipitation", "probability", "subdivision", "code", "hourly", "string", "epoch", "forecasts", "package", "weather", "forecast", "time", "sunset", "heat", "index", "pressure", "abbreviation"], "ast_kind": "class_or_type", "text": "package forecasts\n\nimport \"time\"\n\ntype Forecast struct {\n\tCurrentCondition *CurrentCondition\n\tDailyConditions  []*DailyCondition\n\tHourlyConditions []*HourlyCondition\n}\n\ntype WeatherCondition struct {\n\tCode string\n}\n\ntype WindDirection struct {\n\tAbbreviation string\n\tDegrees      float32\n}\n\ntype Wind struct {\n\tDirection *WindDirection\n\tSpeed     float32\n}\n\ntype WindGust struct {\n\tWind *Wind\n\tGust float32\n}\n\ntype Pressure struct {\n\tMillibar float32\n\tTrend    int\n}\n\ntype CurrentCondition struct {\n\tEpoch            *time.Time\n\tVisibility       float32\n\tWeatherCondition *WeatherCondition\n\tPrecipitation    float32\n\tNextHour         struct {\n\t\tWeatherCondition *WeatherCondition\n\t\tPrecipitation    float32\n\t}\n\tTemperature          float32\n\tTemperatureFeelsLike float32\n\tWindGust             *WindGust\n\tDewPoint             float32\n\tHeatIndex            float32\n\tPressure             *Pressure\n\tUvIndex              float32\n\tHumidityPercentage   int\n\tIsNight              bool\n}\n\ntype DailyCondition struct {\n\tEpoch                     *time.Time\n\tTemperatureMin            float32\n\tTemperatureMax            float32\n\tPrecipitation             float32\n\tPrecipitationDay          float32\n\tPrecipitationNight        float32\n\tSnow                      float32\n\tSnowDay                   float32\n\tSnowNight                 float32\n\tPrecipitationProbability  int\n\tWind                      *Wind\n\tAverageHumidityPercentage int\n\tWeatherCondition          *WeatherCondition\n\tWeatherConditionNight     *WeatherCondition\n\tUvIndex                   float32\n\tSunrise                   *time.Time\n\tSunset                    *time.Time\n}\n\ntype HourlyCondition struct {\n\tEpoch                    *time.Time\n\tTemperature              float32\n\tTemperatureFeelsLike     float32\n\tWeatherCondition         *WeatherCondition\n\tPrecipitation            float32\n\tSnow                     float32\n\tPrecipitationProbability int\n\tWind                     *Wind\n\tPressure                 *Pressure\n\tHumidityPercentage       int\n\tUvIndex                  float32\n}\n\ntype Location struct {\n\tID              int32\n\tLat             float32\n\tLon             float32\n\tTimezone        string\n\tName            string\n\tCountryCode     *string\n\tCountryName     *string\n\tDivisionCode    *string\n\tDivisionName    *string\n\tSubdivisionCode *string\n\tSubdivisionName *string\n}\n\ntype Coordinate struct {\n\tLat float64\n\tLon float64\n}\n", "n_tokens": 541, "byte_len": 2387, "file_sha1": "48aa815472d3c6c2e37f82df319bf039a48345fc", "start_line": 1, "end_line": 107}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/service.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/service.go", "rel_path": "internal/forecasts/service.go", "module": "internal.forecasts.service", "ext": "go", "chunk_number": 1, "symbols": ["NewService", "GetForecastsForLocation", "GetForecastsForLocations", "GetForecastForClosestLocation", "GetForecastForClosestLocations", "Service", "foreca", "interface", "context", "start", "struct", "type", "error", "locale", "get", "forecasts", "text", "batch", "location", "package", "nearest", "service", "make", "coordinate", "opentelemetry", "weather", "language", "func", "new", "with", "span", "import", "xotel", "kind", "defer", "locations", "golang", "trace", "return", "impalastudios", "forecast", "otel", "range", "tracer", "coordinates"], "ast_kind": "class_or_type", "text": "package forecasts\n\nimport (\n\t\"context\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/xotel\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"golang.org/x/text/language\"\n)\n\ntype forecaService interface {\n\tGetForecastForLocation(ctx context.Context, id int) (*Forecast, error)\n\tGetForecastForLocations(ctx context.Context, ids []int) ([]*Forecast, error)\n}\n\ntype locationsService interface {\n\tGet(ctx context.Context, id int, locale language.Tag) (*Location, error)\n\tGetBatch(ctx context.Context, ids []int, locale language.Tag) ([]*Location, error)\n\tNearest(ctx context.Context, coordinate Coordinate, locale language.Tag) (*Location, error)\n\tBatchNearest(ctx context.Context, coordinates []Coordinate, locale language.Tag) ([]*Location, error)\n}\n\ntype Service struct {\n\tforeca    forecaService\n\tlocations locationsService\n}\n\nfunc NewService(foreca forecaService, locations locationsService) *Service {\n\treturn &Service{\n\t\tforeca:    foreca,\n\t\tlocations: locations,\n\t}\n}\n\nfunc (s *Service) GetForecastsForLocation(ctx context.Context, id int, locale language.Tag) (*Forecast, *Location, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"service:forecasts-location\", trace.WithSpanKind(trace.SpanKindInternal))\n\tdefer span.End()\n\n\tlocation, err := s.locations.Get(ctx, id, locale)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tforecast, err := s.foreca.GetForecastForLocation(ctx, id)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn forecast, location, nil\n}\n\nfunc (s *Service) GetForecastsForLocations(ctx context.Context, ids []int, locale language.Tag) ([]*Forecast, []*Location, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"service:forecasts-locations\", trace.WithSpanKind(trace.SpanKindInternal))\n\tdefer span.End()\n\n\tlocations, err := s.locations.GetBatch(ctx, ids, locale)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tfcs, err := s.foreca.GetForecastForLocations(ctx, ids)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn fcs, locations, nil\n}\n\nfunc (s *Service) GetForecastForClosestLocation(ctx context.Context, coordinate Coordinate, locale language.Tag) (*Forecast, *Location, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"service:forecasts-nearest-location\", trace.WithSpanKind(trace.SpanKindInternal))\n\tdefer span.End()\n\n\tlocation, err := s.locations.Nearest(ctx, coordinate, locale)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tforecast, err := s.foreca.GetForecastForLocation(ctx, int(location.ID))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn forecast, location, nil\n}\n\nfunc (s *Service) GetForecastForClosestLocations(ctx context.Context, coordinates []Coordinate, locale language.Tag) ([]*Forecast, []*Location, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"service:forecasts-nearest-locations\", trace.WithSpanKind(trace.SpanKindInternal))\n\tdefer span.End()\n\n\tlocations, err := s.locations.BatchNearest(ctx, coordinates, locale)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tids := make([]int, len(locations))\n\tfor i, l := range locations {\n\t\tids[i] = int(l.ID)\n\t}\n\n\tfcs, err := s.foreca.GetForecastForLocations(ctx, ids)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn fcs, locations, nil\n}\n", "n_tokens": 796, "byte_len": 3114, "file_sha1": "bbd6d59f95f946a194d327c4b62e3bb4041d1894", "start_line": 1, "end_line": 106}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/errrors.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/errrors.go", "rel_path": "internal/forecasts/errrors.go", "module": "internal.forecasts.errrors", "ext": "go", "chunk_number": 1, "symbols": ["forecasts", "package", "forecast", "err", "generic", "location", "errors", "found", "cannot", "import", "service"], "ast_kind": "imports", "text": "package forecasts\n\nimport \"errors\"\n\nvar (\n\tErrGeneric          = errors.New(\"forecast service: cannot get forecast for location\")\n\tErrLocationNotFound = errors.New(\"forecast service: location not found\")\n)\n", "n_tokens": 42, "byte_len": 206, "file_sha1": "5aed7419ec62407c6510da2524dd49260d4d72a9", "start_line": 1, "end_line": 9}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/foreca_service.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/foreca_service.go", "rel_path": "internal/forecasts/adapters/foreca_service.go", "module": "internal.forecasts.adapters.foreca_service", "ext": "go", "chunk_number": 1, "symbols": ["NewForecaService", "GetForecastForLocation", "GetForecastForLocations", "toDomain", "toCurrentConditionDomain", "ForecaService", "append", "outgoing", "set", "status", "foreca", "service", "daily", "condition", "adapters", "requestid", "error", "sunset", "weather", "batch", "with", "span", "sync", "defer", "request", "begin", "trace", "context", "index", "forecast", "toDailyConditionDomain", "toHourlyConditionDomain", "toWindDomain", "get", "abbreviation", "float", "float32", "speed", "trend", "temperature", "wind", "gust", "code", "snow", "uvindex", "response", "direction", "grpc", "max", "tracer"], "ast_kind": "class_or_type", "text": "package adapters\n\nimport (\n\t\"context\"\n\t\"github.com/tidwall/limiter\"\n\t\"go.impalastudios.com/log\"\n\t\"go.impalastudios.com/requestid\"\n\t\"go.impalastudios.com/weather/forecasts/internal/forecasts\"\n\tpbv0 \"go.impalastudios.com/weather/forecasts/internal/forecasts/adapters/clients/foreca/v0\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/xotel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\totelcodes \"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype ForecaService struct {\n\tclient pbv0.ForecaProxyClient\n}\n\nfunc NewForecaService(client pbv0.ForecaProxyClient) *ForecaService {\n\treturn &ForecaService{client}\n}\n\nfunc (s *ForecaService) GetForecastForLocation(ctx context.Context, id int) (*forecasts.Forecast, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"foreca-service:get\", trace.WithSpanKind(trace.SpanKindClient))\n\tdefer span.End()\n\n\tspan.SetAttributes(attribute.Int(\"id\", id))\n\n\tctx = metadata.AppendToOutgoingContext(ctx, \"request-id\", requestid.GetRequestID(ctx))\n\tresp, err := s.client.GetForecast(ctx, &pbv0.ForecastRequest{LocationId: int64(id)})\n\n\tif err != nil {\n\t\tspan.SetStatus(otelcodes.Error, \"Cannot get forecasts.\")\n\t\tspan.RecordError(err)\n\n\t\tlog.Error(ctx, \"Error retrieving forecast for location.\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\treturn s.toDomain(resp), nil\n}\n\nfunc (s *ForecaService) GetForecastForLocations(ctx context.Context, ids []int) ([]*forecasts.Forecast, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"foreca-service:batch-get\", trace.WithSpanKind(trace.SpanKindInternal))\n\tdefer span.End()\n\n\tl := limiter.New(5)\n\n\tvar wg sync.WaitGroup\n\twg.Add(len(ids))\n\n\tfcs := make([]*forecasts.Forecast, len(ids))\n\tfor i, id := range ids {\n\t\tgo func(index int, locationId int) {\n\t\t\tl.Begin()\n\t\t\tdefer func() {\n\t\t\t\twg.Done()\n\t\t\t\tl.End()\n\t\t\t}()\n\n\t\t\tctx, span := xotel.Tracer.Start(ctx, \"foreca-service:get\", trace.WithSpanKind(trace.SpanKindClient))\n\t\t\tdefer span.End()\n\n\t\t\tspan.SetAttributes(attribute.Int(\"id\", locationId))\n\n\t\t\tctx = metadata.AppendToOutgoingContext(ctx, \"request-id\", requestid.GetRequestID(ctx))\n\t\t\tresp, err := s.client.GetForecast(ctx, &pbv0.ForecastRequest{LocationId: int64(locationId)})\n\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(ctx, \"Error retrieving forecast for location.\", zap.Int(\"location_id\", locationId), zap.Error(err))\n\t\t\t\tspan.RecordError(err)\n\t\t\t\tspan.SetStatus(otelcodes.Error, \"Error retrieving forecast for location.\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfcs[index] = s.toDomain(resp)\n\t\t}(i, id)\n\t}\n\n\twg.Wait()\n\n\treturn fcs, nil\n}\n\nfunc (s *ForecaService) toDomain(response *pbv0.ForecastResponse) *forecasts.Forecast {\n\n\tvar dcs []*forecasts.DailyCondition\n\tfor _, condition := range response.GetDailyForecasts() {\n\t\tdcs = append(dcs, s.toDailyConditionDomain(condition))\n\t}\n\n\tvar hcs []*forecasts.HourlyCondition\n\tfor _, condition := range response.GetHourlyForecasts() {\n\t\thcs = append(hcs, s.toHourlyConditionDomain(condition))\n\t}\n\n\tcc := s.toCurrentConditionDomain(response.GetCurrentCondition())\n\n\tif len(dcs) > 0 {\n\t\tday := dcs[0]\n\n\t\tif cc.Epoch != nil && day.Sunrise != nil && day.Sunset != nil {\n\t\t\tcc.IsNight = cc.Epoch.Before(*day.Sunrise) || cc.Epoch.After(*day.Sunset)\n\t\t}\n\t}\n\n\treturn &forecasts.Forecast{\n\t\tCurrentCondition: cc,\n\t\tDailyConditions:  dcs,\n\t\tHourlyConditions: hcs,\n\t}\n}\n\nfunc (s *ForecaService) toCurrentConditionDomain(current *pbv0.ForecastResponse_CurrentCondition) *forecasts.CurrentCondition {\n\tcc := &forecasts.CurrentCondition{\n\t\tWeatherCondition: &forecasts.WeatherCondition{},", "n_tokens": 967, "byte_len": 3538, "file_sha1": "a5c3236af602f13a537da0ef889b85830e1ff004", "start_line": 1, "end_line": 121}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/foreca_service.go#2", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/foreca_service.go", "rel_path": "internal/forecasts/adapters/foreca_service.go", "module": "internal.forecasts.adapters.foreca_service", "ext": "go", "chunk_number": 2, "symbols": ["toDailyConditionDomain", "toHourlyConditionDomain", "float", "float32", "get", "trend", "temperature", "wind", "gust", "foreca", "service", "daily", "condition", "code", "sunset", "snow", "index", "uvindex", "direction", "max", "unix", "min", "humidity", "dew", "point", "current", "feels", "precipitation", "percentage", "domain", "NewForecaService", "GetForecastForLocation", "GetForecastForLocations", "toDomain", "toCurrentConditionDomain", "toWindDomain", "ForecaService", "append", "abbreviation", "outgoing", "speed", "set", "status", "adapters", "requestid", "error", "weather", "batch", "with", "span"], "ast_kind": "function_or_method", "text": "\t\tNextHour: struct {\n\t\t\tWeatherCondition *forecasts.WeatherCondition\n\t\t\tPrecipitation    float32\n\t\t}{WeatherCondition: &forecasts.WeatherCondition{}},\n\t\tWindGust: &forecasts.WindGust{Wind: &forecasts.Wind{Direction: &forecasts.WindDirection{}}},\n\t\tPressure: &forecasts.Pressure{},\n\t}\n\n\tif current != nil {\n\t\tt := time.Unix(current.Epoch, 0)\n\t\tcc.Epoch = &t\n\t\tcc.Visibility = current.GetVisibility()\n\t\tcc.WeatherCondition.Code = current.GetWeatherCondition().GetCode()\n\t\tcc.Precipitation = current.GetPrecipitation()\n\n\t\tif current.GetNextHour() != nil {\n\t\t\tif current.GetNextHour().GetWeatherCondition() != nil {\n\t\t\t\tcc.NextHour.WeatherCondition.Code = current.GetNextHour().GetWeatherCondition().GetCode()\n\t\t\t}\n\t\t\tcc.NextHour.Precipitation = current.GetNextHour().GetPrecipitation()\n\t\t}\n\t\tcc.Temperature = current.GetTemperature()\n\t\tcc.TemperatureFeelsLike = current.GetTemperatureFeelsLike()\n\t\tif current.GetWindGust() != nil {\n\t\t\tcc.WindGust.Gust = current.GetWindGust().GetGust()\n\t\t\tif current.GetWindGust().GetWind() != nil {\n\t\t\t\tcc.WindGust.Wind = s.toWindDomain(current.GetWindGust().GetWind())\n\t\t\t}\n\t\t}\n\t\tcc.DewPoint = current.GetDewPoint()\n\t\tcc.HeatIndex = current.GetHeatIndex()\n\n\t\tif current.GetPressure() != nil {\n\t\t\tcc.Pressure.Millibar = current.GetPressure().GetMillibar()\n\t\t\tcc.Pressure.Trend = int(current.GetPressure().GetTrend())\n\t\t}\n\n\t\tcc.UvIndex = current.GetUvIndex()\n\t\tcc.HumidityPercentage = int(current.GetHumidityPercentage())\n\t}\n\n\treturn cc\n}\n\nfunc (s *ForecaService) toDailyConditionDomain(daily *pbv0.ForecastResponse_DailyForecast) *forecasts.DailyCondition {\n\td := &forecasts.DailyCondition{\n\t\tWind:                  &forecasts.Wind{Direction: &forecasts.WindDirection{}},\n\t\tWeatherCondition:      &forecasts.WeatherCondition{},\n\t\tWeatherConditionNight: &forecasts.WeatherCondition{},\n\t}\n\n\tif daily != nil {\n\t\tt := time.Unix(daily.Epoch, 0)\n\t\td.Epoch = &t\n\n\t\td.TemperatureMin = daily.GetTemperatureMin()\n\t\td.TemperatureMax = daily.GetTemperatureMax()\n\t\td.Precipitation = daily.GetPrecipitation()\n\t\td.PrecipitationDay = daily.GetPrecipitationDay()\n\t\td.PrecipitationNight = daily.GetPrecipitationNight()\n\t\td.Snow = daily.GetSnow()\n\t\td.SnowDay = daily.GetSnowDay()\n\t\td.SnowNight = daily.GetSnowNight()\n\t\td.PrecipitationProbability = int(daily.GetPrecipitationProbability())\n\n\t\tif daily.GetWind() != nil {\n\t\t\td.Wind = s.toWindDomain(daily.GetWind())\n\t\t}\n\n\t\td.AverageHumidityPercentage = int(daily.GetAverageHumidityPercentage())\n\t\tif daily.GetWeatherCondition() != nil {\n\t\t\td.WeatherCondition.Code = daily.GetWeatherCondition().GetCode()\n\t\t}\n\t\tif daily.GetWeatherConditionNight() != nil {\n\t\t\td.WeatherConditionNight.Code = daily.GetWeatherConditionNight().GetCode()\n\t\t}\n\t\td.UvIndex = daily.GetUvIndex()\n\n\t\trise := time.Unix(daily.GetSunriseEpoch(), 0)\n\t\td.Sunrise = &rise\n\n\t\tset := time.Unix(daily.GetSunsetEpoch(), 0)\n\t\td.Sunset = &set\n\t}\n\n\treturn d\n}\n\nfunc (s *ForecaService) toHourlyConditionDomain(hourly *pbv0.ForecastResponse_HourlyForecast) *forecasts.HourlyCondition {\n\th := &forecasts.HourlyCondition{\n\t\tWeatherCondition: &forecasts.WeatherCondition{},\n\t\tWind:             &forecasts.Wind{Direction: &forecasts.WindDirection{}},\n\t\tPressure:         &forecasts.Pressure{},\n\t}\n\n\tif hourly != nil {\n\t\tt := time.Unix(hourly.Epoch, 0)\n\t\th.Epoch = &t\n\n\t\th.Temperature = hourly.GetTemperature()\n\t\th.TemperatureFeelsLike = hourly.GetTemperatureFeelsLike()\n\t\tif hourly.GetWeatherCondition() != nil {\n\t\t\th.WeatherCondition.Code = hourly.GetWeatherCondition().GetCode()\n\t\t}\n\n\t\th.Precipitation = hourly.GetPrecipitation()\n\t\th.Snow = hourly.GetSnow()\n\t\th.PrecipitationProbability = int(hourly.GetPrecipitationProbability())\n\t\tif hourly.GetWind() != nil {\n\t\t\th.Wind = s.toWindDomain(hourly.GetWind())\n\t\t}\n\n\t\tif hourly.GetPressure() != nil {\n\t\t\th.Pressure.Millibar = hourly.GetPressure().GetMillibar()\n\t\t\th.Pressure.Trend = int(hourly.GetPressure().GetTrend())\n\t\t}\n\n\t\th.HumidityPercentage = int(hourly.GetHumidityPercentage())\n\t\th.UvIndex = hourly.GetUvIndex()\n\t}\n\n\treturn h\n}\n", "n_tokens": 1133, "byte_len": 3997, "file_sha1": "a5c3236af602f13a537da0ef889b85830e1ff004", "start_line": 122, "end_line": 245}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/foreca_service.go#3", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/foreca_service.go", "rel_path": "internal/forecasts/adapters/foreca_service.go", "module": "internal.forecasts.adapters.foreca_service", "ext": "go", "chunk_number": 3, "symbols": ["toWindDomain", "wind", "forecast", "response", "forecasts", "direction", "get", "abbreviation", "pbv", "pbv0", "speed", "return", "domain", "degrees", "func", "foreca", "service", "NewForecaService", "GetForecastForLocation", "GetForecastForLocations", "toDomain", "toCurrentConditionDomain", "toDailyConditionDomain", "toHourlyConditionDomain", "ForecaService", "append", "float", "float32", "outgoing", "trend", "temperature", "gust", "set", "status", "daily", "condition", "adapters", "code", "requestid", "error", "sunset", "snow", "weather", "batch", "with", "span", "sync", "defer", "request", "begin"], "ast_kind": "function_or_method", "text": "func (s *ForecaService) toWindDomain(wind *pbv0.ForecastResponse_Wind) *forecasts.Wind {\n\tw := &forecasts.Wind{Direction: &forecasts.WindDirection{}}\n\n\tif wind != nil {\n\t\tw.Direction.Abbreviation = wind.GetDirection().GetAbbreviation()\n\t\tw.Direction.Degrees = wind.GetDirection().GetDegrees()\n\t\tw.Speed = wind.GetSpeed()\n\t}\n\n\treturn w\n}\n", "n_tokens": 97, "byte_len": 337, "file_sha1": "a5c3236af602f13a537da0ef889b85830e1ff004", "start_line": 246, "end_line": 257}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/locations_service.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/locations_service.go", "rel_path": "internal/forecasts/adapters/locations_service.go", "module": "internal.forecasts.adapters.locations_service", "ext": "go", "chunk_number": 1, "symbols": ["NewLocationsService", "Get", "GetBatch", "Nearest", "LocationsService", "append", "get", "request", "float", "float32", "from", "error", "outgoing", "locale", "set", "status", "adapters", "code", "requestid", "weather", "batch", "with", "span", "accept", "err", "defer", "trace", "context", "int", "int32", "BatchNearest", "toDomain", "subdivision", "string", "name", "points", "country", "new", "grpc", "tracer", "type", "range", "coordinates", "division", "start", "types", "latitude", "slice", "package", "nearest"], "ast_kind": "class_or_type", "text": "package adapters\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"go.impalastudios.com/log\"\n\t\"go.impalastudios.com/requestid\"\n\t\"go.impalastudios.com/weather/forecasts/internal/forecasts\"\n\tpbv0 \"go.impalastudios.com/weather/forecasts/internal/forecasts/adapters/clients/locations/v0\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/xotel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\totelcodes \"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/text/language\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype LocationsService struct {\n\tclient pbv0.LocationsServiceClient\n}\n\nfunc NewLocationsService(client pbv0.LocationsServiceClient) *LocationsService {\n\treturn &LocationsService{client}\n}\n\nfunc (s *LocationsService) Get(ctx context.Context, id int, locale language.Tag) (*forecasts.Location, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"locations-service:get\", trace.WithSpanKind(trace.SpanKindClient))\n\tdefer span.End()\n\n\tspan.SetAttributes(attribute.Int(\"id\", id), attribute.String(\"locale\", locale.String()))\n\n\tmd := metadata.Pairs(\"accept-language\", locale.String(), \"request-id\", requestid.GetRequestID(ctx))\n\tctx = metadata.NewOutgoingContext(ctx, md)\n\tresp, err := s.client.Get(ctx, &pbv0.GetRequest{Id: int32(id)})\n\n\tif err != nil {\n\t\tspan.SetStatus(otelcodes.Error, \"Cannot get location.\")\n\t\tspan.RecordError(err)\n\n\t\tif statusErr, ok := status.FromError(err); ok && statusErr.Code() == codes.NotFound {\n\t\t\treturn nil, forecasts.ErrLocationNotFound\n\t\t}\n\n\t\tlog.Error(ctx, \"Error retrieving nearest location.\", zap.String(\"locale\", locale.String()), zap.Int(\"id\", id), zap.Error(err))\n\n\t\treturn nil, err\n\t}\n\n\treturn s.toDomain(resp.GetLocation()), nil\n}\n\nfunc (s *LocationsService) GetBatch(ctx context.Context, ids []int, locale language.Tag) ([]*forecasts.Location, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"locations-service:batch-get\", trace.WithSpanKind(trace.SpanKindClient))\n\tdefer span.End()\n\n\tspan.SetAttributes(attribute.IntSlice(\"ids\", ids), attribute.String(\"locale\", locale.String()))\n\n\treq := &pbv0.GetBatchRequest{Ids: []int32{}}\n\tfor _, id := range ids {\n\t\treq.Ids = append(req.Ids, int32(id))\n\t}\n\n\tctx = metadata.AppendToOutgoingContext(ctx, \"accept-language\", locale.String(), \"request-id\", requestid.GetRequestID(ctx))\n\tresp, err := s.client.GetBatch(ctx, req)\n\n\tif err != nil {\n\t\tspan.SetStatus(otelcodes.Error, \"Cannot get locations batch.\")\n\t\tspan.RecordError(err)\n\n\t\tlog.Error(ctx, \"Error retrieving locations.\", zap.Ints(\"ids\", ids), zap.String(\"locale\", locale.String()), zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tlocs := make([]*forecasts.Location, len(resp.GetLocations()))\n\tfor i, l := range resp.GetLocations() {\n\t\tlocs[i] = s.toDomain(l)\n\t}\n\n\treturn locs, nil\n}\n\nfunc (s *LocationsService) Nearest(ctx context.Context, coordinate forecasts.Coordinate, locale language.Tag) (*forecasts.Location, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"locations-service:nearest\", trace.WithSpanKind(trace.SpanKindClient))\n\tdefer span.End()\n\n\tspan.SetAttributes(attribute.String(\"coordinate\", fmt.Sprintf(\"%.6f,%.6f\", coordinate.Lat, coordinate.Lon)), attribute.String(\"locale\", locale.String()))\n\n\tctx = metadata.AppendToOutgoingContext(ctx, \"accept-language\", locale.String(), \"request-id\", requestid.GetRequestID(ctx))\n\tresp, err := s.client.Nearest(ctx,\n\t\t&pbv0.NearestRequest{\n\t\t\tLatitude:  float32(coordinate.Lat),\n\t\t\tLongitude: float32(coordinate.Lon),\n\t\t\tTypes:     []pbv0.Type{pbv0.Type_P, pbv0.Type_T},\n\t\t},\n\t)\n\n\tif err != nil {\n\t\tspan.SetStatus(otelcodes.Error, \"Cannot get nearest location.\")\n\t\tspan.RecordError(err)\n\n\t\tif statusErr, ok := status.FromError(err); ok && statusErr.Code() == codes.NotFound {\n\t\t\treturn nil, forecasts.ErrLocationNotFound\n\t\t}\n\n\t\tlog.Error(ctx, \"Error retrieving nearest location.\", zap.Any(\"coordinate\", coordinate), zap.String(\"locale\", locale.String()), zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\treturn s.toDomain(resp.GetLocation()), nil\n}\n", "n_tokens": 1031, "byte_len": 3996, "file_sha1": "61b92a567893eb2d813f0f9bce07266ffc1cf819", "start_line": 1, "end_line": 114}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/locations_service.go#2", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/locations_service.go", "rel_path": "internal/forecasts/adapters/locations_service.go", "module": "internal.forecasts.adapters.locations_service", "ext": "go", "chunk_number": 2, "symbols": ["BatchNearest", "toDomain", "type", "string", "append", "float", "float32", "division", "name", "context", "start", "outgoing", "types", "error", "locale", "attribute", "latitude", "span", "subdivision", "code", "points", "location", "slice", "forecasts", "nearest", "pbv", "pbv0", "requestid", "batch", "metadata", "NewLocationsService", "Get", "GetBatch", "Nearest", "LocationsService", "get", "request", "from", "set", "status", "adapters", "weather", "with", "accept", "err", "defer", "trace", "country", "int", "int32"], "ast_kind": "function_or_method", "text": "func (s *LocationsService) BatchNearest(ctx context.Context, coordinates []forecasts.Coordinate, locale language.Tag) ([]*forecasts.Location, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"locations-service:batch-nearest\", trace.WithSpanKind(trace.SpanKindClient))\n\tdefer span.End()\n\n\tvar points []*pbv0.BatchNearestRequest_Point\n\tvar pointsTrace []string\n\tfor i := range coordinates {\n\t\tpointsTrace = append(pointsTrace, fmt.Sprintf(\"%.6f,%.6f\", coordinates[i].Lat, coordinates[i].Lon))\n\t\tpoints = append(points, &pbv0.BatchNearestRequest_Point{\n\t\t\tLatitude:  float32(coordinates[i].Lat),\n\t\t\tLongitude: float32(coordinates[i].Lon),\n\t\t})\n\t}\n\tspan.SetAttributes(attribute.StringSlice(\"coordinates\", pointsTrace), attribute.String(\"locale\", locale.String()))\n\n\tctx = metadata.AppendToOutgoingContext(ctx, \"accept-language\", locale.String(), \"request-id\", requestid.GetRequestID(ctx))\n\tresp, err := s.client.BatchNearest(ctx,\n\t\t&pbv0.BatchNearestRequest{Points: points, Types: []pbv0.Type{pbv0.Type_P, pbv0.Type_T}},\n\t)\n\n\tif err != nil {\n\t\tlog.Error(ctx, \"Error retrieving nearest location.\", zap.Any(\"coordinates\", coordinates), zap.String(\"locale\", locale.String()), zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tlocs := make([]*forecasts.Location, len(resp.GetLocations()))\n\tfor i, l := range resp.GetLocations() {\n\t\tlocs[i] = s.toDomain(l)\n\t}\n\n\treturn locs, nil\n}\n\nfunc (s *LocationsService) toDomain(l *pbv0.Location) *forecasts.Location {\n\treturn &forecasts.Location{\n\t\tID:              l.Id,\n\t\tLat:             l.Latitude,\n\t\tLon:             l.Longitude,\n\t\tTimezone:        l.Timezone,\n\t\tName:            l.Name,\n\t\tCountryCode:     l.CountryCode,\n\t\tCountryName:     l.CountryName,\n\t\tDivisionCode:    l.DivisionCode,\n\t\tDivisionName:    l.DivisionName,\n\t\tSubdivisionCode: l.SubdivisionCode,\n\t\tSubdivisionName: l.SubdivisionName,\n\t}\n}\n", "n_tokens": 484, "byte_len": 1830, "file_sha1": "61b92a567893eb2d813f0f9bce07266ffc1cf819", "start_line": 115, "end_line": 163}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location_grpc.pb.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location_grpc.pb.go", "rel_path": "internal/forecasts/adapters/clients/locations/v0/location_grpc.pb.go", "module": "internal.forecasts.adapters.clients.locations.v0.location_grpc.pb", "ext": "go", "chunk_number": 1, "symbols": ["NewLocationsServiceClient", "Get", "GetBatch", "Nearest", "BatchNearest", "mustEmbedUnimplementedLocationsServiceServer", "RegisterLocationsServiceServer", "_LocationsService_Get_Handler", "locationsServiceClient", "UnimplementedLocationsServiceServer", "get", "response", "request", "compatible", "unimplemented", "locations", "call", "option", "https", "code", "rpc", "grpc", "recommended", "service", "compiled", "context", "this", "unsafe", "compile", "register", "_LocationsService_GetBatch_Handler", "_LocationsService_Nearest_Handler", "_LocationsService_BatchNearest_Handler", "name", "metadata", "status", "methods", "intended", "edit", "opts", "must", "embed", "around", "added", "desc", "type", "semantics", "batch", "unary", "server"], "ast_kind": "class_or_type", "text": "// Code generated by protoc-gen-go-grpc. DO NOT EDIT.\n// versions:\n// - protoc-gen-go-grpc v1.2.0\n// - protoc             v3.21.12\n// source: location.proto\n\npackage v0\n\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the grpc package it is being compiled against.\n// Requires gRPC-Go v1.32.0 or later.\nconst _ = grpc.SupportPackageIsVersion7\n\n// LocationsServiceClient is the client API for LocationsService service.\n//\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.\ntype LocationsServiceClient interface {\n\tGet(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)\n\tGetBatch(ctx context.Context, in *GetBatchRequest, opts ...grpc.CallOption) (*GetBatchResponse, error)\n\tNearest(ctx context.Context, in *NearestRequest, opts ...grpc.CallOption) (*NearestResponse, error)\n\tBatchNearest(ctx context.Context, in *BatchNearestRequest, opts ...grpc.CallOption) (*BatchNearestResponse, error)\n}\n\ntype locationsServiceClient struct {\n\tcc grpc.ClientConnInterface\n}\n\nfunc NewLocationsServiceClient(cc grpc.ClientConnInterface) LocationsServiceClient {\n\treturn &locationsServiceClient{cc}\n}\n\nfunc (c *locationsServiceClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {\n\tout := new(GetResponse)\n\terr := c.cc.Invoke(ctx, \"/geo.locations.v0.LocationsService/Get\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nfunc (c *locationsServiceClient) GetBatch(ctx context.Context, in *GetBatchRequest, opts ...grpc.CallOption) (*GetBatchResponse, error) {\n\tout := new(GetBatchResponse)\n\terr := c.cc.Invoke(ctx, \"/geo.locations.v0.LocationsService/GetBatch\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nfunc (c *locationsServiceClient) Nearest(ctx context.Context, in *NearestRequest, opts ...grpc.CallOption) (*NearestResponse, error) {\n\tout := new(NearestResponse)\n\terr := c.cc.Invoke(ctx, \"/geo.locations.v0.LocationsService/Nearest\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nfunc (c *locationsServiceClient) BatchNearest(ctx context.Context, in *BatchNearestRequest, opts ...grpc.CallOption) (*BatchNearestResponse, error) {\n\tout := new(BatchNearestResponse)\n\terr := c.cc.Invoke(ctx, \"/geo.locations.v0.LocationsService/BatchNearest\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// LocationsServiceServer is the server API for LocationsService service.\n// All implementations must embed UnimplementedLocationsServiceServer\n// for forward compatibility\ntype LocationsServiceServer interface {\n\tGet(context.Context, *GetRequest) (*GetResponse, error)\n\tGetBatch(context.Context, *GetBatchRequest) (*GetBatchResponse, error)\n\tNearest(context.Context, *NearestRequest) (*NearestResponse, error)\n\tBatchNearest(context.Context, *BatchNearestRequest) (*BatchNearestResponse, error)\n\tmustEmbedUnimplementedLocationsServiceServer()\n}\n\n// UnimplementedLocationsServiceServer must be embedded to have forward compatible implementations.\ntype UnimplementedLocationsServiceServer struct {\n}\n\nfunc (UnimplementedLocationsServiceServer) Get(context.Context, *GetRequest) (*GetResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method Get not implemented\")\n}\nfunc (UnimplementedLocationsServiceServer) GetBatch(context.Context, *GetBatchRequest) (*GetBatchResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GetBatch not implemented\")\n}\nfunc (UnimplementedLocationsServiceServer) Nearest(context.Context, *NearestRequest) (*NearestResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method Nearest not implemented\")\n}\nfunc (UnimplementedLocationsServiceServer) BatchNearest(context.Context, *BatchNearestRequest) (*BatchNearestResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method BatchNearest not implemented\")\n}\nfunc (UnimplementedLocationsServiceServer) mustEmbedUnimplementedLocationsServiceServer() {}\n\n// UnsafeLocationsServiceServer may be embedded to opt out of forward compatibility for this service.\n// Use of this interface is not recommended, as added methods to LocationsServiceServer will\n// result in compilation errors.\ntype UnsafeLocationsServiceServer interface {\n\tmustEmbedUnimplementedLocationsServiceServer()\n}\n\nfunc RegisterLocationsServiceServer(s grpc.ServiceRegistrar, srv LocationsServiceServer) {\n\ts.RegisterService(&LocationsService_ServiceDesc, srv)\n}\n\nfunc _LocationsService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(GetRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LocationsServiceServer).Get(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/geo.locations.v0.LocationsService/Get\",\n\t}", "n_tokens": 1211, "byte_len": 5156, "file_sha1": "fec6cd8bcb1bf2cdb8155a4f9dc9e225c337ead0", "start_line": 1, "end_line": 126}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location_grpc.pb.go#2", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location_grpc.pb.go", "rel_path": "internal/forecasts/adapters/clients/locations/v0/location_grpc.pb.go", "module": "internal.forecasts.adapters.clients.locations.v0.location_grpc.pb", "ext": "go", "chunk_number": 2, "symbols": ["_LocationsService_GetBatch_Handler", "_LocationsService_Nearest_Handler", "_LocationsService_BatchNearest_Handler", "copy", "stream", "desc", "interface", "get", "request", "register", "service", "context", "methods", "error", "handler", "with", "type", "batch", "locations", "introspected", "location", "unary", "server", "full", "method", "modified", "name", "func", "nearest", "return", "NewLocationsServiceClient", "Get", "GetBatch", "Nearest", "BatchNearest", "mustEmbedUnimplementedLocationsServiceServer", "RegisterLocationsServiceServer", "_LocationsService_Get_Handler", "locationsServiceClient", "UnimplementedLocationsServiceServer", "response", "compatible", "unimplemented", "call", "option", "https", "code", "rpc", "grpc", "recommended"], "ast_kind": "function_or_method", "text": "\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LocationsServiceServer).Get(ctx, req.(*GetRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\nfunc _LocationsService_GetBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(GetBatchRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LocationsServiceServer).GetBatch(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/geo.locations.v0.LocationsService/GetBatch\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LocationsServiceServer).GetBatch(ctx, req.(*GetBatchRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\nfunc _LocationsService_Nearest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(NearestRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LocationsServiceServer).Nearest(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/geo.locations.v0.LocationsService/Nearest\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LocationsServiceServer).Nearest(ctx, req.(*NearestRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\nfunc _LocationsService_BatchNearest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(BatchNearestRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LocationsServiceServer).BatchNearest(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/geo.locations.v0.LocationsService/BatchNearest\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LocationsServiceServer).BatchNearest(ctx, req.(*BatchNearestRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\n// LocationsService_ServiceDesc is the grpc.ServiceDesc for LocationsService service.\n// It's only intended for direct use with grpc.RegisterService,\n// and not to be introspected or modified (even as a copy)\nvar LocationsService_ServiceDesc = grpc.ServiceDesc{\n\tServiceName: \"geo.locations.v0.LocationsService\",\n\tHandlerType: (*LocationsServiceServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"Get\",\n\t\t\tHandler:    _LocationsService_Get_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"GetBatch\",\n\t\t\tHandler:    _LocationsService_GetBatch_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"Nearest\",\n\t\t\tHandler:    _LocationsService_Nearest_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"BatchNearest\",\n\t\t\tHandler:    _LocationsService_BatchNearest_Handler,\n\t\t},\n\t},\n\tStreams:  []grpc.StreamDesc{},\n\tMetadata: \"location.proto\",\n}\n", "n_tokens": 747, "byte_len": 2979, "file_sha1": "fec6cd8bcb1bf2cdb8155a4f9dc9e225c337ead0", "start_line": 127, "end_line": 214}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go", "rel_path": "internal/forecasts/adapters/clients/locations/v0/location.pb.go", "module": "internal.forecasts.adapters.clients.locations.v0.location.pb", "ext": "go", "chunk_number": 1, "symbols": ["Enum", "String", "Descriptor", "Type", "Number", "EnumDescriptor", "Reset", "ProtoMessage", "ProtoReflect", "GetId", "GetLocation", "GetRequest", "GetResponse", "GetBatchRequest", "max", "version", "get", "response", "maps", "request", "load", "message", "store", "min", "value", "getid", "https", "string", "code", "reflect", "GetIds", "GetLocations", "GetPoints", "GetTypes", "GetLatitude", "GetLongitude", "GetTimezone", "GetName", "GetCountryCode", "GetCountryName", "GetDivisionCode", "GetDivisionName", "GetSubdivisionCode", "GetSubdivisionName", "file_location_proto_rawDescGZIP", "init", "file_location_proto_init", "GetBatchResponse", "BatchNearestRequest", "BatchNearestResponse"], "ast_kind": "class_or_type", "text": "// Code generated by protoc-gen-go. DO NOT EDIT.\n// versions:\n// \tprotoc-gen-go v1.28.1\n// \tprotoc        v3.21.12\n// source: location.proto\n\npackage v0\n\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\treflect \"reflect\"\n\tsync \"sync\"\n)\n\nconst (\n\t// Verify that this generated code is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)\n\t// Verify that runtime/protoimpl is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)\n)\n\n// https://www.geonames.org/export/codes.html\ntype Type int32\n\nconst (\n\tType_A Type = 0\n\tType_H Type = 1\n\tType_L Type = 2\n\tType_P Type = 3\n\tType_R Type = 4\n\tType_S Type = 5\n\tType_T Type = 6\n\tType_U Type = 7\n\tType_V Type = 8\n)\n\n// Enum value maps for Type.\nvar (\n\tType_name = map[int32]string{\n\t\t0: \"A\",\n\t\t1: \"H\",\n\t\t2: \"L\",\n\t\t3: \"P\",\n\t\t4: \"R\",\n\t\t5: \"S\",\n\t\t6: \"T\",\n\t\t7: \"U\",\n\t\t8: \"V\",\n\t}\n\tType_value = map[string]int32{\n\t\t\"A\": 0,\n\t\t\"H\": 1,\n\t\t\"L\": 2,\n\t\t\"P\": 3,\n\t\t\"R\": 4,\n\t\t\"S\": 5,\n\t\t\"T\": 6,\n\t\t\"U\": 7,\n\t\t\"V\": 8,\n\t}\n)\n\nfunc (x Type) Enum() *Type {\n\tp := new(Type)\n\t*p = x\n\treturn p\n}\n\nfunc (x Type) String() string {\n\treturn protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))\n}\n\nfunc (Type) Descriptor() protoreflect.EnumDescriptor {\n\treturn file_location_proto_enumTypes[0].Descriptor()\n}\n\nfunc (Type) Type() protoreflect.EnumType {\n\treturn &file_location_proto_enumTypes[0]\n}\n\nfunc (x Type) Number() protoreflect.EnumNumber {\n\treturn protoreflect.EnumNumber(x)\n}\n\n// Deprecated: Use Type.Descriptor instead.\nfunc (Type) EnumDescriptor() ([]byte, []int) {\n\treturn file_location_proto_rawDescGZIP(), []int{0}\n}\n\ntype GetRequest struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tId int32 `protobuf:\"varint,1,opt,name=id,proto3\" json:\"id,omitempty\"`\n}\n\nfunc (x *GetRequest) Reset() {\n\t*x = GetRequest{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_location_proto_msgTypes[0]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *GetRequest) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*GetRequest) ProtoMessage() {}\n\nfunc (x *GetRequest) ProtoReflect() protoreflect.Message {\n\tmi := &file_location_proto_msgTypes[0]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.\nfunc (*GetRequest) Descriptor() ([]byte, []int) {\n\treturn file_location_proto_rawDescGZIP(), []int{0}\n}\n\nfunc (x *GetRequest) GetId() int32 {\n\tif x != nil {\n\t\treturn x.Id\n\t}\n\treturn 0\n}\n\ntype GetResponse struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tLocation *Location `protobuf:\"bytes,1,opt,name=location,proto3\" json:\"location,omitempty\"`\n}\n\nfunc (x *GetResponse) Reset() {\n\t*x = GetResponse{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_location_proto_msgTypes[1]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *GetResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*GetResponse) ProtoMessage() {}\n\nfunc (x *GetResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_location_proto_msgTypes[1]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.\nfunc (*GetResponse) Descriptor() ([]byte, []int) {\n\treturn file_location_proto_rawDescGZIP(), []int{1}\n}\n\nfunc (x *GetResponse) GetLocation() *Location {\n\tif x != nil {\n\t\treturn x.Location\n\t}\n\treturn nil\n}\n\ntype GetBatchRequest struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tIds []int32 `protobuf:\"varint,1,rep,packed,name=ids,proto3\" json:\"ids,omitempty\"`\n}\n", "n_tokens": 1212, "byte_len": 4166, "file_sha1": "5e566c509481ae2efc95b65156428905d4771b19", "start_line": 1, "end_line": 192}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go#2", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go", "rel_path": "internal/forecasts/adapters/clients/locations/v0/location.pb.go", "module": "internal.forecasts.adapters.clients.locations.v0.location.pb", "ext": "go", "chunk_number": 2, "symbols": ["Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetIds", "GetLocations", "GetPoints", "GetTypes", "GetBatchResponse", "BatchNearestRequest", "BatchNearestResponse", "string", "deprecated", "load", "message", "store", "types", "struct", "type", "size", "cache", "json", "state", "packed", "proto", "reflect", "messageof", "proto3", "unknown", "Enum", "Type", "Number", "EnumDescriptor", "GetId", "GetLocation", "GetLatitude", "GetLongitude", "GetTimezone", "GetName", "GetCountryCode", "GetCountryName", "GetDivisionCode", "GetDivisionName", "GetSubdivisionCode", "GetSubdivisionName", "file_location_proto_rawDescGZIP", "init", "file_location_proto_init", "GetRequest"], "ast_kind": "class_or_type", "text": "func (x *GetBatchRequest) Reset() {\n\t*x = GetBatchRequest{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_location_proto_msgTypes[2]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *GetBatchRequest) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*GetBatchRequest) ProtoMessage() {}\n\nfunc (x *GetBatchRequest) ProtoReflect() protoreflect.Message {\n\tmi := &file_location_proto_msgTypes[2]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use GetBatchRequest.ProtoReflect.Descriptor instead.\nfunc (*GetBatchRequest) Descriptor() ([]byte, []int) {\n\treturn file_location_proto_rawDescGZIP(), []int{2}\n}\n\nfunc (x *GetBatchRequest) GetIds() []int32 {\n\tif x != nil {\n\t\treturn x.Ids\n\t}\n\treturn nil\n}\n\ntype GetBatchResponse struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tLocations []*Location `protobuf:\"bytes,1,rep,name=locations,proto3\" json:\"locations,omitempty\"`\n}\n\nfunc (x *GetBatchResponse) Reset() {\n\t*x = GetBatchResponse{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_location_proto_msgTypes[3]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *GetBatchResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*GetBatchResponse) ProtoMessage() {}\n\nfunc (x *GetBatchResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_location_proto_msgTypes[3]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use GetBatchResponse.ProtoReflect.Descriptor instead.\nfunc (*GetBatchResponse) Descriptor() ([]byte, []int) {\n\treturn file_location_proto_rawDescGZIP(), []int{3}\n}\n\nfunc (x *GetBatchResponse) GetLocations() []*Location {\n\tif x != nil {\n\t\treturn x.Locations\n\t}\n\treturn nil\n}\n\ntype BatchNearestRequest struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tPoints []*BatchNearestRequest_Point `protobuf:\"bytes,1,rep,name=points,proto3\" json:\"points,omitempty\"`\n\tTypes  []Type                       `protobuf:\"varint,2,rep,packed,name=types,proto3,enum=geo.locations.v0.Type\" json:\"types,omitempty\"`\n}\n\nfunc (x *BatchNearestRequest) Reset() {\n\t*x = BatchNearestRequest{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_location_proto_msgTypes[4]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *BatchNearestRequest) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*BatchNearestRequest) ProtoMessage() {}\n\nfunc (x *BatchNearestRequest) ProtoReflect() protoreflect.Message {\n\tmi := &file_location_proto_msgTypes[4]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use BatchNearestRequest.ProtoReflect.Descriptor instead.\nfunc (*BatchNearestRequest) Descriptor() ([]byte, []int) {\n\treturn file_location_proto_rawDescGZIP(), []int{4}\n}\n\nfunc (x *BatchNearestRequest) GetPoints() []*BatchNearestRequest_Point {\n\tif x != nil {\n\t\treturn x.Points\n\t}\n\treturn nil\n}\n\nfunc (x *BatchNearestRequest) GetTypes() []Type {\n\tif x != nil {\n\t\treturn x.Types\n\t}\n\treturn nil\n}\n\ntype BatchNearestResponse struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tLocations []*Location `protobuf:\"bytes,1,rep,name=locations,proto3\" json:\"locations,omitempty\"`\n}\n\nfunc (x *BatchNearestResponse) Reset() {\n\t*x = BatchNearestResponse{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_location_proto_msgTypes[5]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *BatchNearestResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*BatchNearestResponse) ProtoMessage() {}\n\nfunc (x *BatchNearestResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_location_proto_msgTypes[5]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n", "n_tokens": 1194, "byte_len": 4545, "file_sha1": "5e566c509481ae2efc95b65156428905d4771b19", "start_line": 193, "end_line": 368}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go#3", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go", "rel_path": "internal/forecasts/adapters/clients/locations/v0/location.pb.go", "module": "internal.forecasts.adapters.clients.locations.v0.location.pb", "ext": "go", "chunk_number": 3, "symbols": ["Descriptor", "GetLocations", "Reset", "String", "ProtoMessage", "ProtoReflect", "GetLatitude", "GetLongitude", "GetTypes", "GetLocation", "NearestRequest", "NearestResponse", "Location", "float", "float32", "timezone", "load", "message", "store", "division", "code", "get", "latitude", "subdivision", "string", "name", "oneof", "byte", "proto", "country", "Enum", "Type", "Number", "EnumDescriptor", "GetId", "GetIds", "GetPoints", "GetTimezone", "GetName", "GetCountryCode", "GetCountryName", "GetDivisionCode", "GetDivisionName", "GetSubdivisionCode", "GetSubdivisionName", "file_location_proto_rawDescGZIP", "init", "file_location_proto_init", "GetRequest", "GetResponse"], "ast_kind": "class_or_type", "text": "// Deprecated: Use BatchNearestResponse.ProtoReflect.Descriptor instead.\nfunc (*BatchNearestResponse) Descriptor() ([]byte, []int) {\n\treturn file_location_proto_rawDescGZIP(), []int{5}\n}\n\nfunc (x *BatchNearestResponse) GetLocations() []*Location {\n\tif x != nil {\n\t\treturn x.Locations\n\t}\n\treturn nil\n}\n\ntype NearestRequest struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tLatitude  float32 `protobuf:\"fixed32,1,opt,name=latitude,proto3\" json:\"latitude,omitempty\"`\n\tLongitude float32 `protobuf:\"fixed32,2,opt,name=longitude,proto3\" json:\"longitude,omitempty\"`\n\tTypes     []Type  `protobuf:\"varint,3,rep,packed,name=types,proto3,enum=geo.locations.v0.Type\" json:\"types,omitempty\"`\n}\n\nfunc (x *NearestRequest) Reset() {\n\t*x = NearestRequest{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_location_proto_msgTypes[6]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *NearestRequest) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*NearestRequest) ProtoMessage() {}\n\nfunc (x *NearestRequest) ProtoReflect() protoreflect.Message {\n\tmi := &file_location_proto_msgTypes[6]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use NearestRequest.ProtoReflect.Descriptor instead.\nfunc (*NearestRequest) Descriptor() ([]byte, []int) {\n\treturn file_location_proto_rawDescGZIP(), []int{6}\n}\n\nfunc (x *NearestRequest) GetLatitude() float32 {\n\tif x != nil {\n\t\treturn x.Latitude\n\t}\n\treturn 0\n}\n\nfunc (x *NearestRequest) GetLongitude() float32 {\n\tif x != nil {\n\t\treturn x.Longitude\n\t}\n\treturn 0\n}\n\nfunc (x *NearestRequest) GetTypes() []Type {\n\tif x != nil {\n\t\treturn x.Types\n\t}\n\treturn nil\n}\n\ntype NearestResponse struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tLocation *Location `protobuf:\"bytes,1,opt,name=location,proto3\" json:\"location,omitempty\"`\n}\n\nfunc (x *NearestResponse) Reset() {\n\t*x = NearestResponse{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_location_proto_msgTypes[7]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *NearestResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*NearestResponse) ProtoMessage() {}\n\nfunc (x *NearestResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_location_proto_msgTypes[7]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use NearestResponse.ProtoReflect.Descriptor instead.\nfunc (*NearestResponse) Descriptor() ([]byte, []int) {\n\treturn file_location_proto_rawDescGZIP(), []int{7}\n}\n\nfunc (x *NearestResponse) GetLocation() *Location {\n\tif x != nil {\n\t\treturn x.Location\n\t}\n\treturn nil\n}\n\ntype Location struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tId              int32   `protobuf:\"varint,1,opt,name=id,proto3\" json:\"id,omitempty\"`\n\tLatitude        float32 `protobuf:\"fixed32,2,opt,name=latitude,proto3\" json:\"latitude,omitempty\"`\n\tLongitude       float32 `protobuf:\"fixed32,3,opt,name=longitude,proto3\" json:\"longitude,omitempty\"`\n\tTimezone        string  `protobuf:\"bytes,4,opt,name=timezone,proto3\" json:\"timezone,omitempty\"`\n\tName            string  `protobuf:\"bytes,5,opt,name=name,proto3\" json:\"name,omitempty\"`\n\tCountryCode     *string `protobuf:\"bytes,6,opt,name=country_code,json=countryCode,proto3,oneof\" json:\"country_code,omitempty\"`\n\tCountryName     *string `protobuf:\"bytes,7,opt,name=country_name,json=countryName,proto3,oneof\" json:\"country_name,omitempty\"`\n\tDivisionCode    *string `protobuf:\"bytes,8,opt,name=division_code,json=divisionCode,proto3,oneof\" json:\"division_code,omitempty\"`\n\tDivisionName    *string `protobuf:\"bytes,9,opt,name=division_name,json=divisionName,proto3,oneof\" json:\"division_name,omitempty\"`\n\tSubdivisionCode *string `protobuf:\"bytes,10,opt,name=subdivision_code,json=subdivisionCode,proto3,oneof\" json:\"subdivision_code,omitempty\"`\n\tSubdivisionName *string `protobuf:\"bytes,11,opt,name=subdivision_name,json=subdivisionName,proto3,oneof\" json:\"subdivision_name,omitempty\"`\n}\n\nfunc (x *Location) Reset() {\n\t*x = Location{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_location_proto_msgTypes[8]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n", "n_tokens": 1218, "byte_len": 4680, "file_sha1": "5e566c509481ae2efc95b65156428905d4771b19", "start_line": 369, "end_line": 517}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go#4", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go", "rel_path": "internal/forecasts/adapters/clients/locations/v0/location.pb.go", "module": "internal.forecasts.adapters.clients.locations.v0.location.pb", "ext": "go", "chunk_number": 4, "symbols": ["String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetId", "GetLatitude", "GetLongitude", "GetTimezone", "GetName", "GetCountryCode", "GetCountryName", "GetDivisionCode", "GetDivisionName", "GetSubdivisionCode", "GetSubdivisionName", "Reset", "BatchNearestRequest_Point", "string", "deprecated", "get", "timezone", "latitude", "float", "float32", "division", "name", "load", "message", "store", "struct", "Enum", "Type", "Number", "EnumDescriptor", "GetLocation", "GetIds", "GetLocations", "GetPoints", "GetTypes", "file_location_proto_rawDescGZIP", "init", "file_location_proto_init", "GetRequest", "GetResponse", "GetBatchRequest", "GetBatchResponse", "BatchNearestRequest", "BatchNearestResponse", "NearestRequest", "NearestResponse"], "ast_kind": "class_or_type", "text": "func (x *Location) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Location) ProtoMessage() {}\n\nfunc (x *Location) ProtoReflect() protoreflect.Message {\n\tmi := &file_location_proto_msgTypes[8]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Location.ProtoReflect.Descriptor instead.\nfunc (*Location) Descriptor() ([]byte, []int) {\n\treturn file_location_proto_rawDescGZIP(), []int{8}\n}\n\nfunc (x *Location) GetId() int32 {\n\tif x != nil {\n\t\treturn x.Id\n\t}\n\treturn 0\n}\n\nfunc (x *Location) GetLatitude() float32 {\n\tif x != nil {\n\t\treturn x.Latitude\n\t}\n\treturn 0\n}\n\nfunc (x *Location) GetLongitude() float32 {\n\tif x != nil {\n\t\treturn x.Longitude\n\t}\n\treturn 0\n}\n\nfunc (x *Location) GetTimezone() string {\n\tif x != nil {\n\t\treturn x.Timezone\n\t}\n\treturn \"\"\n}\n\nfunc (x *Location) GetName() string {\n\tif x != nil {\n\t\treturn x.Name\n\t}\n\treturn \"\"\n}\n\nfunc (x *Location) GetCountryCode() string {\n\tif x != nil && x.CountryCode != nil {\n\t\treturn *x.CountryCode\n\t}\n\treturn \"\"\n}\n\nfunc (x *Location) GetCountryName() string {\n\tif x != nil && x.CountryName != nil {\n\t\treturn *x.CountryName\n\t}\n\treturn \"\"\n}\n\nfunc (x *Location) GetDivisionCode() string {\n\tif x != nil && x.DivisionCode != nil {\n\t\treturn *x.DivisionCode\n\t}\n\treturn \"\"\n}\n\nfunc (x *Location) GetDivisionName() string {\n\tif x != nil && x.DivisionName != nil {\n\t\treturn *x.DivisionName\n\t}\n\treturn \"\"\n}\n\nfunc (x *Location) GetSubdivisionCode() string {\n\tif x != nil && x.SubdivisionCode != nil {\n\t\treturn *x.SubdivisionCode\n\t}\n\treturn \"\"\n}\n\nfunc (x *Location) GetSubdivisionName() string {\n\tif x != nil && x.SubdivisionName != nil {\n\t\treturn *x.SubdivisionName\n\t}\n\treturn \"\"\n}\n\ntype BatchNearestRequest_Point struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tLatitude  float32 `protobuf:\"fixed32,1,opt,name=latitude,proto3\" json:\"latitude,omitempty\"`\n\tLongitude float32 `protobuf:\"fixed32,2,opt,name=longitude,proto3\" json:\"longitude,omitempty\"`\n}\n\nfunc (x *BatchNearestRequest_Point) Reset() {\n\t*x = BatchNearestRequest_Point{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_location_proto_msgTypes[9]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *BatchNearestRequest_Point) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*BatchNearestRequest_Point) ProtoMessage() {}\n\nfunc (x *BatchNearestRequest_Point) ProtoReflect() protoreflect.Message {\n\tmi := &file_location_proto_msgTypes[9]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use BatchNearestRequest_Point.ProtoReflect.Descriptor instead.\nfunc (*BatchNearestRequest_Point) Descriptor() ([]byte, []int) {\n\treturn file_location_proto_rawDescGZIP(), []int{4, 0}\n}\n\nfunc (x *BatchNearestRequest_Point) GetLatitude() float32 {\n\tif x != nil {\n\t\treturn x.Latitude\n\t}\n\treturn 0\n}\n", "n_tokens": 868, "byte_len": 3178, "file_sha1": "5e566c509481ae2efc95b65156428905d4771b19", "start_line": 518, "end_line": 665}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go#5", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go", "rel_path": "internal/forecasts/adapters/clients/locations/v0/location.pb.go", "module": "internal.forecasts.adapters.clients.locations.v0.location.pb", "ext": "go", "chunk_number": 5, "symbols": ["GetLongitude", "get", "longitude", "file", "location", "batch", "nearest", "float", "float32", "sync", "return", "descriptor", "once", "func", "byte", "protoreflect", "Enum", "String", "Descriptor", "Type", "Number", "EnumDescriptor", "Reset", "ProtoMessage", "ProtoReflect", "GetId", "GetLocation", "GetIds", "GetLocations", "GetPoints", "GetTypes", "GetLatitude", "GetTimezone", "GetName", "GetCountryCode", "GetCountryName", "GetDivisionCode", "GetDivisionName", "GetSubdivisionCode", "GetSubdivisionName", "file_location_proto_rawDescGZIP", "init", "file_location_proto_init", "GetRequest", "GetResponse", "GetBatchRequest", "GetBatchResponse", "BatchNearestRequest", "BatchNearestResponse", "NearestRequest"], "ast_kind": "function_or_method", "text": "func (x *BatchNearestRequest_Point) GetLongitude() float32 {\n\tif x != nil {\n\t\treturn x.Longitude\n\t}\n\treturn 0\n}\n\nvar File_location_proto protoreflect.FileDescriptor\n\nvar file_location_proto_rawDesc = []byte{\n\t0x0a, 0x0e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,\n\t0x12, 0x10, 0x67, 0x65, 0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,\n\t0x76, 0x30, 0x22, 0x1c, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,\n\t0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x69, 0x64,\n\t0x22, 0x45, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,\n\t0x36, 0x0a, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28,\n\t0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x65, 0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n\t0x73, 0x2e, 0x76, 0x30, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x6c,\n\t0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x23, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x42, 0x61,\n\t0x74, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x69, 0x64,\n\t0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x03, 0x69, 0x64, 0x73, 0x22, 0x4c, 0x0a, 0x10,\n\t0x47, 0x65, 0x74, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,\n\t0x12, 0x38, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20,\n\t0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x65, 0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69,\n\t0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,\n\t0x09, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0xcb, 0x01, 0x0a, 0x13, 0x42,\n\t0x61, 0x74, 0x63, 0x68, 0x4e, 0x65, 0x61, 0x72, 0x65, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65,\n\t0x73, 0x74, 0x12, 0x43, 0x0a, 0x06, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03,\n\t0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x67, 0x65, 0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f,\n\t0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x4e, 0x65, 0x61, 0x72, 0x65,\n\t0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52,\n\t0x06, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x12, 0x2c, 0x0a, 0x05, 0x74, 0x79, 0x70, 0x65, 0x73,\n\t0x18, 0x02, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x67, 0x65, 0x6f, 0x2e, 0x6c, 0x6f, 0x63,\n\t0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x05,\n\t0x74, 0x79, 0x70, 0x65, 0x73, 0x1a, 0x41, 0x0a, 0x05, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x1a,\n\t0x0a, 0x08, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02,\n\t0x52, 0x08, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6c, 0x6f,\n\t0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x09, 0x6c,\n\t0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x22, 0x50, 0x0a, 0x14, 0x42, 0x61, 0x74, 0x63,\n\t0x68, 0x4e, 0x65, 0x61, 0x72, 0x65, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,\n\t0x12, 0x38, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20,\n\t0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x65, 0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69,\n\t0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,\n\t0x09, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0x78, 0x0a, 0x0e, 0x4e, 0x65,\n\t0x61, 0x72, 0x65, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08,\n\t0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02, 0x52, 0x08,\n\t0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6c, 0x6f, 0x6e, 0x67,\n\t0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x09, 0x6c, 0x6f, 0x6e,\n\t0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x2c, 0x0a, 0x05, 0x74, 0x79, 0x70, 0x65, 0x73, 0x18,\n\t0x03, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x67, 0x65, 0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61,\n\t0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x05, 0x74,\n\t0x79, 0x70, 0x65, 0x73, 0x22, 0x49, 0x0a, 0x0f, 0x4e, 0x65, 0x61, 0x72, 0x65, 0x73, 0x74, 0x52,\n\t0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x36, 0x0a, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74,\n\t0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x65, 0x6f, 0x2e,\n\t0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e, 0x4c, 0x6f, 0x63,\n\t0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22,\n\t0xf8, 0x03, 0x0a, 0x08, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x02,\n\t0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08,\n\t0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x08,\n\t0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6c, 0x6f, 0x6e, 0x67,\n\t0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x52, 0x09, 0x6c, 0x6f, 0x6e,\n\t0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x74, 0x69, 0x6d, 0x65, 0x7a, 0x6f,\n\t0x6e, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x69, 0x6d, 0x65, 0x7a, 0x6f,\n\t0x6e, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,\n\t0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x26, 0x0a, 0x0c, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72,\n\t0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x0b,\n\t0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x88, 0x01, 0x01, 0x12, 0x26,\n\t0x0a, 0x0c, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x07,\n\t0x20, 0x01, 0x28, 0x09, 0x48, 0x01, 0x52, 0x0b, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79, 0x4e,\n\t0x61, 0x6d, 0x65, 0x88, 0x01, 0x01, 0x12, 0x28, 0x0a, 0x0d, 0x64, 0x69, 0x76, 0x69, 0x73, 0x69,\n\t0x6f, 0x6e, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x48, 0x02, 0x52,\n\t0x0c, 0x64, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x88, 0x01, 0x01,\n\t0x12, 0x28, 0x0a, 0x0d, 0x64, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6e, 0x61, 0x6d,\n\t0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x48, 0x03, 0x52, 0x0c, 0x64, 0x69, 0x76, 0x69, 0x73,\n\t0x69, 0x6f, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x88, 0x01, 0x01, 0x12, 0x2e, 0x0a, 0x10, 0x73, 0x75,\n\t0x62, 0x64, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x0a,\n\t0x20, 0x01, 0x28, 0x09, 0x48, 0x04, 0x52, 0x0f, 0x73, 0x75, 0x62, 0x64, 0x69, 0x76, 0x69, 0x73,\n\t0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x88, 0x01, 0x01, 0x12, 0x2e, 0x0a, 0x10, 0x73, 0x75,\n\t0x62, 0x64, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x0b,\n\t0x20, 0x01, 0x28, 0x09, 0x48, 0x05, 0x52, 0x0f, 0x73, 0x75, 0x62, 0x64, 0x69, 0x76, 0x69, 0x73,\n\t0x69, 0x6f, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x88, 0x01, 0x01, 0x42, 0x0f, 0x0a, 0x0d, 0x5f, 0x63,\n\t0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x42, 0x0f, 0x0a, 0x0d, 0x5f,\n\t0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x42, 0x10, 0x0a, 0x0e,\n\t0x5f, 0x64, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x42, 0x10,\n\t0x0a, 0x0e, 0x5f, 0x64, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6e, 0x61, 0x6d, 0x65,\n\t0x42, 0x13, 0x0a, 0x11, 0x5f, 0x73, 0x75, 0x62, 0x64, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e,\n\t0x5f, 0x63, 0x6f, 0x64, 0x65, 0x42, 0x13, 0x0a, 0x11, 0x5f, 0x73, 0x75, 0x62, 0x64, 0x69, 0x76,\n\t0x69, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x2a, 0x45, 0x0a, 0x04, 0x54, 0x79,\n\t0x70, 0x65, 0x12, 0x05, 0x0a, 0x01, 0x41, 0x10, 0x00, 0x12, 0x05, 0x0a, 0x01, 0x48, 0x10, 0x01,\n\t0x12, 0x05, 0x0a, 0x01, 0x4c, 0x10, 0x02, 0x12, 0x05, 0x0a, 0x01, 0x50, 0x10, 0x03, 0x12, 0x05,\n\t0x0a, 0x01, 0x52, 0x10, 0x04, 0x12, 0x05, 0x0a, 0x01, 0x53, 0x10, 0x05, 0x12, 0x05, 0x0a, 0x01,\n\t0x54, 0x10, 0x06, 0x12, 0x05, 0x0a, 0x01, 0x55, 0x10, 0x07, 0x12, 0x05, 0x0a, 0x01, 0x56, 0x10,\n\t0x08, 0x32, 0xe0, 0x02, 0x0a, 0x10, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x53,\n\t0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x44, 0x0a, 0x03, 0x47, 0x65, 0x74, 0x12, 0x1c, 0x2e,\n\t0x67, 0x65, 0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30,\n\t0x2e, 0x47, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x67, 0x65,\n\t0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e, 0x47,\n\t0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x53, 0x0a, 0x08,\n\t0x47, 0x65, 0x74, 0x42, 0x61, 0x74, 0x63, 0x68, 0x12, 0x21, 0x2e, 0x67, 0x65, 0x6f, 0x2e, 0x6c,\n\t0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e, 0x47, 0x65, 0x74, 0x42,\n\t0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x67, 0x65,\n\t0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e, 0x47,\n\t0x65, 0x74, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,\n\t0x00, 0x12, 0x50, 0x0a, 0x07, 0x4e, 0x65, 0x61, 0x72, 0x65, 0x73, 0x74, 0x12, 0x20, 0x2e, 0x67,\n\t0x65, 0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e,\n\t0x4e, 0x65, 0x61, 0x72, 0x65, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21,\n\t0x2e, 0x67, 0x65, 0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x76,\n\t0x30, 0x2e, 0x4e, 0x65, 0x61, 0x72, 0x65, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,\n\t0x65, 0x22, 0x00, 0x12, 0x5f, 0x0a, 0x0c, 0x42, 0x61, 0x74, 0x63, 0x68, 0x4e, 0x65, 0x61, 0x72,\n\t0x65, 0x73, 0x74, 0x12, 0x25, 0x2e, 0x67, 0x65, 0x6f, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69,\n\t0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x4e, 0x65, 0x61, 0x72,\n\t0x65, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x67, 0x65, 0x6f,\n\t0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x76, 0x30, 0x2e, 0x42, 0x61,\n\t0x74, 0x63, 0x68, 0x4e, 0x65, 0x61, 0x72, 0x65, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,\n\t0x73, 0x65, 0x22, 0x00, 0x42, 0x2e, 0x5a, 0x2c, 0x67, 0x6f, 0x2e, 0x69, 0x6d, 0x70, 0x61, 0x6c,\n\t0x61, 0x73, 0x74, 0x75, 0x64, 0x69, 0x6f, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x67, 0x65, 0x6f,\n\t0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x70,\n\t0x62, 0x2f, 0x76, 0x30, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,\n}\n\nvar (\n\tfile_location_proto_rawDescOnce sync.Once\n\tfile_location_proto_rawDescData = file_location_proto_rawDesc\n)\n", "n_tokens": 9199, "byte_len": 10777, "file_sha1": "5e566c509481ae2efc95b65156428905d4771b19", "start_line": 666, "end_line": 790}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go#6", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go", "rel_path": "internal/forecasts/adapters/clients/locations/v0/location.pb.go", "module": "internal.forecasts.adapters.clients.locations.v0.location.pb", "ext": "go", "chunk_number": 6, "symbols": ["file_location_proto_rawDescGZIP", "init", "file_location_proto_init", "extension", "get", "response", "nearest", "interface", "request", "file", "location", "enum", "info", "size", "cache", "batch", "case", "output", "type", "unknown", "fields", "input", "point", "unsafe", "enabled", "name", "make", "func", "message", "byte", "Enum", "String", "Descriptor", "Type", "Number", "EnumDescriptor", "Reset", "ProtoMessage", "ProtoReflect", "GetId", "GetLocation", "GetIds", "GetLocations", "GetPoints", "GetTypes", "GetLatitude", "GetLongitude", "GetTimezone", "GetName", "GetCountryCode"], "ast_kind": "function_or_method", "text": "func file_location_proto_rawDescGZIP() []byte {\n\tfile_location_proto_rawDescOnce.Do(func() {\n\t\tfile_location_proto_rawDescData = protoimpl.X.CompressGZIP(file_location_proto_rawDescData)\n\t})\n\treturn file_location_proto_rawDescData\n}\n\nvar file_location_proto_enumTypes = make([]protoimpl.EnumInfo, 1)\nvar file_location_proto_msgTypes = make([]protoimpl.MessageInfo, 10)\nvar file_location_proto_goTypes = []interface{}{\n\t(Type)(0),                         // 0: geo.locations.v0.Type\n\t(*GetRequest)(nil),                // 1: geo.locations.v0.GetRequest\n\t(*GetResponse)(nil),               // 2: geo.locations.v0.GetResponse\n\t(*GetBatchRequest)(nil),           // 3: geo.locations.v0.GetBatchRequest\n\t(*GetBatchResponse)(nil),          // 4: geo.locations.v0.GetBatchResponse\n\t(*BatchNearestRequest)(nil),       // 5: geo.locations.v0.BatchNearestRequest\n\t(*BatchNearestResponse)(nil),      // 6: geo.locations.v0.BatchNearestResponse\n\t(*NearestRequest)(nil),            // 7: geo.locations.v0.NearestRequest\n\t(*NearestResponse)(nil),           // 8: geo.locations.v0.NearestResponse\n\t(*Location)(nil),                  // 9: geo.locations.v0.Location\n\t(*BatchNearestRequest_Point)(nil), // 10: geo.locations.v0.BatchNearestRequest.Point\n}\nvar file_location_proto_depIdxs = []int32{\n\t9,  // 0: geo.locations.v0.GetResponse.location:type_name -> geo.locations.v0.Location\n\t9,  // 1: geo.locations.v0.GetBatchResponse.locations:type_name -> geo.locations.v0.Location\n\t10, // 2: geo.locations.v0.BatchNearestRequest.points:type_name -> geo.locations.v0.BatchNearestRequest.Point\n\t0,  // 3: geo.locations.v0.BatchNearestRequest.types:type_name -> geo.locations.v0.Type\n\t9,  // 4: geo.locations.v0.BatchNearestResponse.locations:type_name -> geo.locations.v0.Location\n\t0,  // 5: geo.locations.v0.NearestRequest.types:type_name -> geo.locations.v0.Type\n\t9,  // 6: geo.locations.v0.NearestResponse.location:type_name -> geo.locations.v0.Location\n\t1,  // 7: geo.locations.v0.LocationsService.Get:input_type -> geo.locations.v0.GetRequest\n\t3,  // 8: geo.locations.v0.LocationsService.GetBatch:input_type -> geo.locations.v0.GetBatchRequest\n\t7,  // 9: geo.locations.v0.LocationsService.Nearest:input_type -> geo.locations.v0.NearestRequest\n\t5,  // 10: geo.locations.v0.LocationsService.BatchNearest:input_type -> geo.locations.v0.BatchNearestRequest\n\t2,  // 11: geo.locations.v0.LocationsService.Get:output_type -> geo.locations.v0.GetResponse\n\t4,  // 12: geo.locations.v0.LocationsService.GetBatch:output_type -> geo.locations.v0.GetBatchResponse\n\t8,  // 13: geo.locations.v0.LocationsService.Nearest:output_type -> geo.locations.v0.NearestResponse\n\t6,  // 14: geo.locations.v0.LocationsService.BatchNearest:output_type -> geo.locations.v0.BatchNearestResponse\n\t11, // [11:15] is the sub-list for method output_type\n\t7,  // [7:11] is the sub-list for method input_type\n\t7,  // [7:7] is the sub-list for extension type_name\n\t7,  // [7:7] is the sub-list for extension extendee\n\t0,  // [0:7] is the sub-list for field type_name\n}\n\nfunc init() { file_location_proto_init() }\nfunc file_location_proto_init() {\n\tif File_location_proto != nil {\n\t\treturn\n\t}\n\tif !protoimpl.UnsafeEnabled {\n\t\tfile_location_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*GetRequest); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_location_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*GetResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_location_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*GetBatchRequest); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_location_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*GetBatchResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}", "n_tokens": 1208, "byte_len": 4234, "file_sha1": "5e566c509481ae2efc95b65156428905d4771b19", "start_line": 791, "end_line": 889}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go#7", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/locations/v0/location.pb.go", "rel_path": "internal/forecasts/adapters/clients/locations/v0/location.pb.go", "module": "internal.forecasts.adapters.clients.locations.v0.location.pb", "ext": "go", "chunk_number": 7, "symbols": ["x", "nearest", "response", "num", "services", "interface", "file", "location", "dependency", "indexes", "struct", "size", "cache", "type", "enums", "case", "desc", "builder", "unknown", "fields", "batch", "message", "infos", "types", "gotypes", "reflect", "package", "path", "func", "messages", "Enum", "String", "Descriptor", "Type", "Number", "EnumDescriptor", "Reset", "ProtoMessage", "ProtoReflect", "GetId", "GetLocation", "GetIds", "GetLocations", "GetPoints", "GetTypes", "GetLatitude", "GetLongitude", "GetTimezone", "GetName", "GetCountryCode"], "ast_kind": "class_or_type", "text": "\t\tfile_location_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*BatchNearestRequest); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_location_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*BatchNearestResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_location_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*NearestRequest); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_location_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*NearestResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_location_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*Location); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_location_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*BatchNearestRequest_Point); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\tfile_location_proto_msgTypes[8].OneofWrappers = []interface{}{}\n\ttype x struct{}\n\tout := protoimpl.TypeBuilder{\n\t\tFile: protoimpl.DescBuilder{\n\t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n\t\t\tRawDescriptor: file_location_proto_rawDesc,\n\t\t\tNumEnums:      1,\n\t\t\tNumMessages:   10,\n\t\t\tNumExtensions: 0,\n\t\t\tNumServices:   1,\n\t\t},\n\t\tGoTypes:           file_location_proto_goTypes,\n\t\tDependencyIndexes: file_location_proto_depIdxs,\n\t\tEnumInfos:         file_location_proto_enumTypes,\n\t\tMessageInfos:      file_location_proto_msgTypes,\n\t}.Build()\n\tFile_location_proto = out.File\n\tfile_location_proto_rawDesc = nil\n\tfile_location_proto_goTypes = nil\n\tfile_location_proto_depIdxs = nil\n}\n", "n_tokens": 674, "byte_len": 2305, "file_sha1": "5e566c509481ae2efc95b65156428905d4771b19", "start_line": 890, "end_line": 984}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "rel_path": "internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "module": "internal.forecasts.adapters.clients.foreca.v0.service.v0.pb", "ext": "go", "chunk_number": 1, "symbols": ["Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetLocationId", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts", "ForecastRequest", "ForecastResponse", "ForecastResponse_WeatherCondition", "max", "version", "load", "message", "store", "file", "service", "min", "string", "code", "oneof", "reflect", "current", "condition", "sync", "byte", "proto", "enforce", "GetCode", "GetDescription", "GetAbbreviation", "GetDegrees", "GetDirection", "GetSpeed", "GetMillibar", "GetTrend", "GetEpoch", "GetVisibility", "GetWeatherCondition", "GetPrecipitation", "GetNextHour", "GetTemperature", "GetTemperatureFeelsLike", "GetWindGust", "GetDewPoint", "GetHeatIndex", "GetPressure", "GetUvIndex"], "ast_kind": "class_or_type", "text": "// Code generated by protoc-gen-go. DO NOT EDIT.\n// versions:\n// \tprotoc-gen-go v1.28.1\n// \tprotoc        v3.21.9\n// source: service.v0.proto\n\npackage v0\n\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\treflect \"reflect\"\n\tsync \"sync\"\n)\n\nconst (\n\t// Verify that this generated code is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)\n\t// Verify that runtime/protoimpl is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)\n)\n\ntype ForecastRequest struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tLocationId int64 `protobuf:\"varint,1,opt,name=locationId,proto3\" json:\"locationId,omitempty\"` // The Impala Location ID.\n}\n\nfunc (x *ForecastRequest) Reset() {\n\t*x = ForecastRequest{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[0]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastRequest) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastRequest) ProtoMessage() {}\n\nfunc (x *ForecastRequest) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[0]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastRequest.ProtoReflect.Descriptor instead.\nfunc (*ForecastRequest) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{0}\n}\n\nfunc (x *ForecastRequest) GetLocationId() int64 {\n\tif x != nil {\n\t\treturn x.LocationId\n\t}\n\treturn 0\n}\n\ntype ForecastResponse struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tCurrentCondition *ForecastResponse_CurrentCondition `protobuf:\"bytes,1,opt,name=currentCondition,proto3,oneof\" json:\"currentCondition,omitempty\"`\n\tDailyForecasts   []*ForecastResponse_DailyForecast  `protobuf:\"bytes,2,rep,name=dailyForecasts,proto3\" json:\"dailyForecasts,omitempty\"`\n\tHourlyForecasts  []*ForecastResponse_HourlyForecast `protobuf:\"bytes,3,rep,name=hourlyForecasts,proto3\" json:\"hourlyForecasts,omitempty\"`\n}\n\nfunc (x *ForecastResponse) Reset() {\n\t*x = ForecastResponse{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[1]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse) ProtoMessage() {}\n\nfunc (x *ForecastResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[1]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1}\n}\n\nfunc (x *ForecastResponse) GetCurrentCondition() *ForecastResponse_CurrentCondition {\n\tif x != nil {\n\t\treturn x.CurrentCondition\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse) GetDailyForecasts() []*ForecastResponse_DailyForecast {\n\tif x != nil {\n\t\treturn x.DailyForecasts\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse) GetHourlyForecasts() []*ForecastResponse_HourlyForecast {\n\tif x != nil {\n\t\treturn x.HourlyForecasts\n\t}\n\treturn nil\n}\n\ntype ForecastResponse_WeatherCondition struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tCode        string `protobuf:\"bytes,1,opt,name=code,proto3\" json:\"code,omitempty\"`\n\tDescription string `protobuf:\"bytes,2,opt,name=description,proto3\" json:\"description,omitempty\"`\n}\n\nfunc (x *ForecastResponse_WeatherCondition) Reset() {\n\t*x = ForecastResponse_WeatherCondition{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[2]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_WeatherCondition) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_WeatherCondition) ProtoMessage() {}\n\nfunc (x *ForecastResponse_WeatherCondition) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[2]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n", "n_tokens": 1211, "byte_len": 4741, "file_sha1": "2640db73dd4fcdbfc916289704510f06fb220411", "start_line": 1, "end_line": 168}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go#2", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "rel_path": "internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "module": "internal.forecasts.adapters.clients.foreca.v0.service.v0.pb", "ext": "go", "chunk_number": 2, "symbols": ["Descriptor", "GetCode", "GetDescription", "Reset", "String", "ProtoMessage", "ProtoReflect", "GetAbbreviation", "GetDegrees", "GetDirection", "GetSpeed", "ForecastResponse_WindDirection", "ForecastResponse_Wind", "ForecastResponse_Pressure", "string", "deprecated", "get", "abbreviation", "float", "float32", "trend", "load", "message", "store", "file", "service", "struct", "type", "size", "cache", "GetLocationId", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts", "GetMillibar", "GetTrend", "GetEpoch", "GetVisibility", "GetWeatherCondition", "GetPrecipitation", "GetNextHour", "GetTemperature", "GetTemperatureFeelsLike", "GetWindGust", "GetDewPoint", "GetHeatIndex", "GetPressure", "GetUvIndex", "GetHumidityPercentage", "GetTemperatureMin"], "ast_kind": "class_or_type", "text": "// Deprecated: Use ForecastResponse_WeatherCondition.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_WeatherCondition) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 0}\n}\n\nfunc (x *ForecastResponse_WeatherCondition) GetCode() string {\n\tif x != nil {\n\t\treturn x.Code\n\t}\n\treturn \"\"\n}\n\nfunc (x *ForecastResponse_WeatherCondition) GetDescription() string {\n\tif x != nil {\n\t\treturn x.Description\n\t}\n\treturn \"\"\n}\n\ntype ForecastResponse_WindDirection struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tAbbreviation string  `protobuf:\"bytes,1,opt,name=abbreviation,proto3\" json:\"abbreviation,omitempty\"`\n\tDegrees      float32 `protobuf:\"fixed32,2,opt,name=degrees,proto3\" json:\"degrees,omitempty\"`\n}\n\nfunc (x *ForecastResponse_WindDirection) Reset() {\n\t*x = ForecastResponse_WindDirection{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[3]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_WindDirection) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_WindDirection) ProtoMessage() {}\n\nfunc (x *ForecastResponse_WindDirection) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[3]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_WindDirection.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_WindDirection) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 1}\n}\n\nfunc (x *ForecastResponse_WindDirection) GetAbbreviation() string {\n\tif x != nil {\n\t\treturn x.Abbreviation\n\t}\n\treturn \"\"\n}\n\nfunc (x *ForecastResponse_WindDirection) GetDegrees() float32 {\n\tif x != nil {\n\t\treturn x.Degrees\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_Wind struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tDirection *ForecastResponse_WindDirection `protobuf:\"bytes,1,opt,name=direction,proto3\" json:\"direction,omitempty\"`\n\tSpeed     float32                         `protobuf:\"fixed32,2,opt,name=speed,proto3\" json:\"speed,omitempty\"`\n}\n\nfunc (x *ForecastResponse_Wind) Reset() {\n\t*x = ForecastResponse_Wind{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[4]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_Wind) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_Wind) ProtoMessage() {}\n\nfunc (x *ForecastResponse_Wind) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[4]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_Wind.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_Wind) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 2}\n}\n\nfunc (x *ForecastResponse_Wind) GetDirection() *ForecastResponse_WindDirection {\n\tif x != nil {\n\t\treturn x.Direction\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_Wind) GetSpeed() float32 {\n\tif x != nil {\n\t\treturn x.Speed\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_Pressure struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tMillibar float32 `protobuf:\"fixed32,1,opt,name=millibar,proto3\" json:\"millibar,omitempty\"`\n\tTrend    int32   `protobuf:\"varint,2,opt,name=trend,proto3\" json:\"trend,omitempty\"`\n}\n\nfunc (x *ForecastResponse_Pressure) Reset() {\n\t*x = ForecastResponse_Pressure{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[5]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_Pressure) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_Pressure) ProtoMessage() {}\n\nfunc (x *ForecastResponse_Pressure) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[5]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n", "n_tokens": 1181, "byte_len": 4553, "file_sha1": "2640db73dd4fcdbfc916289704510f06fb220411", "start_line": 169, "end_line": 333}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go#3", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "rel_path": "internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "module": "internal.forecasts.adapters.clients.foreca.v0.service.v0.pb", "ext": "go", "chunk_number": 3, "symbols": ["Descriptor", "GetMillibar", "GetTrend", "Reset", "String", "ProtoMessage", "ProtoReflect", "GetEpoch", "GetVisibility", "GetWeatherCondition", "GetPrecipitation", "GetNextHour", "GetTemperature", "GetTemperatureFeelsLike", "GetWindGust", "GetDewPoint", "GetHeatIndex", "GetPressure", "GetUvIndex", "ForecastResponse_CurrentCondition", "float", "float32", "load", "message", "store", "file", "service", "get", "trend", "temperature", "GetLocationId", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts", "GetCode", "GetDescription", "GetAbbreviation", "GetDegrees", "GetDirection", "GetSpeed", "GetHumidityPercentage", "GetTemperatureMin", "GetTemperatureMax", "GetPrecipitationDay", "GetPrecipitationNight", "GetSnow", "GetSnowDay", "GetSnowNight", "GetPrecipitationProbability", "GetWind"], "ast_kind": "class_or_type", "text": "// Deprecated: Use ForecastResponse_Pressure.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_Pressure) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 3}\n}\n\nfunc (x *ForecastResponse_Pressure) GetMillibar() float32 {\n\tif x != nil {\n\t\treturn x.Millibar\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_Pressure) GetTrend() int32 {\n\tif x != nil {\n\t\treturn x.Trend\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_CurrentCondition struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tEpoch                int64                                       `protobuf:\"varint,1,opt,name=epoch,proto3\" json:\"epoch,omitempty\"`\n\tVisibility           float32                                     `protobuf:\"fixed32,2,opt,name=visibility,proto3\" json:\"visibility,omitempty\"`\n\tWeatherCondition     *ForecastResponse_WeatherCondition          `protobuf:\"bytes,3,opt,name=weatherCondition,proto3\" json:\"weatherCondition,omitempty\"`\n\tPrecipitation        float32                                     `protobuf:\"fixed32,4,opt,name=precipitation,proto3\" json:\"precipitation,omitempty\"`\n\tNextHour             *ForecastResponse_CurrentCondition_NextHour `protobuf:\"bytes,5,opt,name=nextHour,proto3\" json:\"nextHour,omitempty\"`\n\tTemperature          float32                                     `protobuf:\"fixed32,6,opt,name=temperature,proto3\" json:\"temperature,omitempty\"`\n\tTemperatureFeelsLike float32                                     `protobuf:\"fixed32,7,opt,name=temperatureFeelsLike,proto3\" json:\"temperatureFeelsLike,omitempty\"`\n\tWindGust             *ForecastResponse_CurrentCondition_WindGust `protobuf:\"bytes,8,opt,name=windGust,proto3\" json:\"windGust,omitempty\"`\n\tDewPoint             float32                                     `protobuf:\"fixed32,9,opt,name=dewPoint,proto3\" json:\"dewPoint,omitempty\"`\n\tHeatIndex            float32                                     `protobuf:\"fixed32,10,opt,name=heatIndex,proto3\" json:\"heatIndex,omitempty\"`\n\tPressure             *ForecastResponse_Pressure                  `protobuf:\"bytes,11,opt,name=pressure,proto3\" json:\"pressure,omitempty\"`\n\tUvIndex              float32                                     `protobuf:\"fixed32,12,opt,name=uvIndex,proto3\" json:\"uvIndex,omitempty\"`\n\tHumidityPercentage   int32                                       `protobuf:\"varint,13,opt,name=humidityPercentage,proto3\" json:\"humidityPercentage,omitempty\"`\n}\n\nfunc (x *ForecastResponse_CurrentCondition) Reset() {\n\t*x = ForecastResponse_CurrentCondition{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[6]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_CurrentCondition) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_CurrentCondition) ProtoMessage() {}\n\nfunc (x *ForecastResponse_CurrentCondition) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[6]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_CurrentCondition.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_CurrentCondition) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 4}\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetEpoch() int64 {\n\tif x != nil {\n\t\treturn x.Epoch\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetVisibility() float32 {\n\tif x != nil {\n\t\treturn x.Visibility\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetWeatherCondition() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherCondition\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetPrecipitation() float32 {\n\tif x != nil {\n\t\treturn x.Precipitation\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetNextHour() *ForecastResponse_CurrentCondition_NextHour {\n\tif x != nil {\n\t\treturn x.NextHour\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetTemperature() float32 {\n\tif x != nil {\n\t\treturn x.Temperature\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetTemperatureFeelsLike() float32 {\n\tif x != nil {\n\t\treturn x.TemperatureFeelsLike\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetWindGust() *ForecastResponse_CurrentCondition_WindGust {\n\tif x != nil {\n\t\treturn x.WindGust\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetDewPoint() float32 {\n\tif x != nil {\n\t\treturn x.DewPoint\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetHeatIndex() float32 {\n\tif x != nil {\n\t\treturn x.HeatIndex\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetPressure() *ForecastResponse_Pressure {\n\tif x != nil {\n\t\treturn x.Pressure\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetUvIndex() float32 {\n\tif x != nil {\n\t\treturn x.UvIndex\n\t}\n\treturn 0\n}\n", "n_tokens": 1210, "byte_len": 5047, "file_sha1": "2640db73dd4fcdbfc916289704510f06fb220411", "start_line": 334, "end_line": 488}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go#4", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "rel_path": "internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "module": "internal.forecasts.adapters.clients.foreca.v0.service.v0.pb", "ext": "go", "chunk_number": 4, "symbols": ["GetHumidityPercentage", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetEpoch", "GetTemperatureMin", "GetTemperatureMax", "GetPrecipitation", "GetPrecipitationDay", "GetPrecipitationNight", "GetSnow", "GetSnowDay", "GetSnowNight", "GetPrecipitationProbability", "GetWind", "ForecastResponse_DailyForecast", "float", "float32", "load", "message", "store", "file", "service", "snow", "string", "get", "byte", "proto", "GetLocationId", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts", "GetCode", "GetDescription", "GetAbbreviation", "GetDegrees", "GetDirection", "GetSpeed", "GetMillibar", "GetTrend", "GetVisibility", "GetWeatherCondition", "GetNextHour", "GetTemperature", "GetTemperatureFeelsLike", "GetWindGust", "GetDewPoint", "GetHeatIndex"], "ast_kind": "class_or_type", "text": "func (x *ForecastResponse_CurrentCondition) GetHumidityPercentage() int32 {\n\tif x != nil {\n\t\treturn x.HumidityPercentage\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_DailyForecast struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tEpoch                     int64                              `protobuf:\"varint,1,opt,name=epoch,proto3\" json:\"epoch,omitempty\"`\n\tTemperatureMin            float32                            `protobuf:\"fixed32,2,opt,name=temperatureMin,proto3\" json:\"temperatureMin,omitempty\"`\n\tTemperatureMax            float32                            `protobuf:\"fixed32,3,opt,name=temperatureMax,proto3\" json:\"temperatureMax,omitempty\"`\n\tPrecipitation             float32                            `protobuf:\"fixed32,4,opt,name=precipitation,proto3\" json:\"precipitation,omitempty\"`\n\tPrecipitationDay          float32                            `protobuf:\"fixed32,5,opt,name=precipitationDay,proto3\" json:\"precipitationDay,omitempty\"`\n\tPrecipitationNight        float32                            `protobuf:\"fixed32,6,opt,name=precipitationNight,proto3\" json:\"precipitationNight,omitempty\"`\n\tSnow                      float32                            `protobuf:\"fixed32,7,opt,name=snow,proto3\" json:\"snow,omitempty\"`\n\tSnowDay                   float32                            `protobuf:\"fixed32,8,opt,name=snowDay,proto3\" json:\"snowDay,omitempty\"`\n\tSnowNight                 float32                            `protobuf:\"fixed32,9,opt,name=snowNight,proto3\" json:\"snowNight,omitempty\"`\n\tPrecipitationProbability  int32                              `protobuf:\"varint,10,opt,name=precipitationProbability,proto3\" json:\"precipitationProbability,omitempty\"`\n\tWind                      *ForecastResponse_Wind             `protobuf:\"bytes,11,opt,name=wind,proto3\" json:\"wind,omitempty\"`\n\tAverageHumidityPercentage int32                              `protobuf:\"varint,12,opt,name=averageHumidityPercentage,proto3\" json:\"averageHumidityPercentage,omitempty\"`\n\tWeatherCondition          *ForecastResponse_WeatherCondition `protobuf:\"bytes,13,opt,name=weatherCondition,proto3\" json:\"weatherCondition,omitempty\"`\n\tWeatherConditionNight     *ForecastResponse_WeatherCondition `protobuf:\"bytes,14,opt,name=weatherConditionNight,proto3\" json:\"weatherConditionNight,omitempty\"`\n\tUvIndex                   float32                            `protobuf:\"fixed32,15,opt,name=uvIndex,proto3\" json:\"uvIndex,omitempty\"`\n\tSunriseEpoch              int64                              `protobuf:\"varint,16,opt,name=sunriseEpoch,proto3\" json:\"sunriseEpoch,omitempty\"`\n\tSunsetEpoch               int64                              `protobuf:\"varint,17,opt,name=sunsetEpoch,proto3\" json:\"sunsetEpoch,omitempty\"`\n}\n\nfunc (x *ForecastResponse_DailyForecast) Reset() {\n\t*x = ForecastResponse_DailyForecast{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[7]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_DailyForecast) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_DailyForecast) ProtoMessage() {}\n\nfunc (x *ForecastResponse_DailyForecast) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[7]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_DailyForecast.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_DailyForecast) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 5}\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetEpoch() int64 {\n\tif x != nil {\n\t\treturn x.Epoch\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetTemperatureMin() float32 {\n\tif x != nil {\n\t\treturn x.TemperatureMin\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetTemperatureMax() float32 {\n\tif x != nil {\n\t\treturn x.TemperatureMax\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetPrecipitation() float32 {\n\tif x != nil {\n\t\treturn x.Precipitation\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetPrecipitationDay() float32 {\n\tif x != nil {\n\t\treturn x.PrecipitationDay\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetPrecipitationNight() float32 {\n\tif x != nil {\n\t\treturn x.PrecipitationNight\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetSnow() float32 {\n\tif x != nil {\n\t\treturn x.Snow\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetSnowDay() float32 {\n\tif x != nil {\n\t\treturn x.SnowDay\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetSnowNight() float32 {\n\tif x != nil {\n\t\treturn x.SnowNight\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetPrecipitationProbability() int32 {\n\tif x != nil {\n\t\treturn x.PrecipitationProbability\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetWind() *ForecastResponse_Wind {\n\tif x != nil {\n\t\treturn x.Wind\n\t}\n\treturn nil\n}\n", "n_tokens": 1228, "byte_len": 5095, "file_sha1": "2640db73dd4fcdbfc916289704510f06fb220411", "start_line": 489, "end_line": 628}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go#5", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "rel_path": "internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "module": "internal.forecasts.adapters.clients.foreca.v0.service.v0.pb", "ext": "go", "chunk_number": 5, "symbols": ["GetAverageHumidityPercentage", "GetWeatherCondition", "GetWeatherConditionNight", "GetUvIndex", "GetSunriseEpoch", "GetSunsetEpoch", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetEpoch", "GetTemperature", "GetTemperatureFeelsLike", "GetPrecipitation", "GetSnow", "GetPrecipitationProbability", "GetWind", "GetPressure", "GetHumidityPercentage", "ForecastResponse_HourlyForecast", "float", "float32", "load", "message", "store", "file", "service", "temperature", "snow", "GetLocationId", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts", "GetCode", "GetDescription", "GetAbbreviation", "GetDegrees", "GetDirection", "GetSpeed", "GetMillibar", "GetTrend", "GetVisibility", "GetNextHour", "GetWindGust", "GetDewPoint", "GetHeatIndex", "GetTemperatureMin", "GetTemperatureMax", "GetPrecipitationDay"], "ast_kind": "class_or_type", "text": "func (x *ForecastResponse_DailyForecast) GetAverageHumidityPercentage() int32 {\n\tif x != nil {\n\t\treturn x.AverageHumidityPercentage\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetWeatherCondition() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherCondition\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetWeatherConditionNight() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherConditionNight\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetUvIndex() float32 {\n\tif x != nil {\n\t\treturn x.UvIndex\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetSunriseEpoch() int64 {\n\tif x != nil {\n\t\treturn x.SunriseEpoch\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetSunsetEpoch() int64 {\n\tif x != nil {\n\t\treturn x.SunsetEpoch\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_HourlyForecast struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tEpoch                    int64                              `protobuf:\"varint,1,opt,name=epoch,proto3\" json:\"epoch,omitempty\"`\n\tTemperature              float32                            `protobuf:\"fixed32,2,opt,name=temperature,proto3\" json:\"temperature,omitempty\"`\n\tTemperatureFeelsLike     float32                            `protobuf:\"fixed32,3,opt,name=temperatureFeelsLike,proto3\" json:\"temperatureFeelsLike,omitempty\"`\n\tWeatherCondition         *ForecastResponse_WeatherCondition `protobuf:\"bytes,4,opt,name=weatherCondition,proto3\" json:\"weatherCondition,omitempty\"`\n\tPrecipitation            float32                            `protobuf:\"fixed32,5,opt,name=precipitation,proto3\" json:\"precipitation,omitempty\"`\n\tSnow                     float32                            `protobuf:\"fixed32,6,opt,name=snow,proto3\" json:\"snow,omitempty\"`\n\tPrecipitationProbability int32                              `protobuf:\"varint,7,opt,name=precipitationProbability,proto3\" json:\"precipitationProbability,omitempty\"`\n\tWind                     *ForecastResponse_Wind             `protobuf:\"bytes,8,opt,name=wind,proto3\" json:\"wind,omitempty\"`\n\tPressure                 *ForecastResponse_Pressure         `protobuf:\"bytes,9,opt,name=pressure,proto3\" json:\"pressure,omitempty\"`\n\tHumidityPercentage       int32                              `protobuf:\"varint,10,opt,name=humidityPercentage,proto3\" json:\"humidityPercentage,omitempty\"`\n\tUvIndex                  float32                            `protobuf:\"fixed32,11,opt,name=uvIndex,proto3\" json:\"uvIndex,omitempty\"`\n}\n\nfunc (x *ForecastResponse_HourlyForecast) Reset() {\n\t*x = ForecastResponse_HourlyForecast{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[8]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_HourlyForecast) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_HourlyForecast) ProtoMessage() {}\n\nfunc (x *ForecastResponse_HourlyForecast) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[8]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_HourlyForecast.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_HourlyForecast) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 6}\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetEpoch() int64 {\n\tif x != nil {\n\t\treturn x.Epoch\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetTemperature() float32 {\n\tif x != nil {\n\t\treturn x.Temperature\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetTemperatureFeelsLike() float32 {\n\tif x != nil {\n\t\treturn x.TemperatureFeelsLike\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetWeatherCondition() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherCondition\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetPrecipitation() float32 {\n\tif x != nil {\n\t\treturn x.Precipitation\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetSnow() float32 {\n\tif x != nil {\n\t\treturn x.Snow\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetPrecipitationProbability() int32 {\n\tif x != nil {\n\t\treturn x.PrecipitationProbability\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetWind() *ForecastResponse_Wind {\n\tif x != nil {\n\t\treturn x.Wind\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetPressure() *ForecastResponse_Pressure {\n\tif x != nil {\n\t\treturn x.Pressure\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetHumidityPercentage() int32 {\n\tif x != nil {\n\t\treturn x.HumidityPercentage\n\t}\n\treturn 0\n}\n", "n_tokens": 1209, "byte_len": 4835, "file_sha1": "2640db73dd4fcdbfc916289704510f06fb220411", "start_line": 629, "end_line": 790}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go#6", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "rel_path": "internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "module": "internal.forecasts.adapters.clients.foreca.v0.service.v0.pb", "ext": "go", "chunk_number": 6, "symbols": ["GetUvIndex", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetWeatherCondition", "GetPrecipitation", "GetWind", "ForecastResponse_CurrentCondition_NextHour", "ForecastResponse_CurrentCondition_WindGust", "forecast", "response", "string", "deprecated", "float", "float32", "load", "message", "store", "file", "service", "struct", "type", "size", "cache", "json", "get", "index", "state", "GetLocationId", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts", "GetCode", "GetDescription", "GetAbbreviation", "GetDegrees", "GetDirection", "GetSpeed", "GetMillibar", "GetTrend", "GetEpoch", "GetVisibility", "GetNextHour", "GetTemperature", "GetTemperatureFeelsLike", "GetWindGust", "GetDewPoint", "GetHeatIndex"], "ast_kind": "class_or_type", "text": "func (x *ForecastResponse_HourlyForecast) GetUvIndex() float32 {\n\tif x != nil {\n\t\treturn x.UvIndex\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_CurrentCondition_NextHour struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tWeatherCondition *ForecastResponse_WeatherCondition `protobuf:\"bytes,1,opt,name=weatherCondition,proto3\" json:\"weatherCondition,omitempty\"`\n\tPrecipitation    float32                            `protobuf:\"fixed32,2,opt,name=precipitation,proto3\" json:\"precipitation,omitempty\"`\n}\n\nfunc (x *ForecastResponse_CurrentCondition_NextHour) Reset() {\n\t*x = ForecastResponse_CurrentCondition_NextHour{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[9]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_CurrentCondition_NextHour) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_CurrentCondition_NextHour) ProtoMessage() {}\n\nfunc (x *ForecastResponse_CurrentCondition_NextHour) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[9]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_CurrentCondition_NextHour.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_CurrentCondition_NextHour) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 4, 0}\n}\n\nfunc (x *ForecastResponse_CurrentCondition_NextHour) GetWeatherCondition() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherCondition\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_CurrentCondition_NextHour) GetPrecipitation() float32 {\n\tif x != nil {\n\t\treturn x.Precipitation\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_CurrentCondition_WindGust struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tWind *ForecastResponse_Wind `protobuf:\"bytes,1,opt,name=wind,proto3\" json:\"wind,omitempty\"`\n\tGust float32                `protobuf:\"fixed32,2,opt,name=gust,proto3\" json:\"gust,omitempty\"`\n}\n\nfunc (x *ForecastResponse_CurrentCondition_WindGust) Reset() {\n\t*x = ForecastResponse_CurrentCondition_WindGust{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[10]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_CurrentCondition_WindGust) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_CurrentCondition_WindGust) ProtoMessage() {}\n\nfunc (x *ForecastResponse_CurrentCondition_WindGust) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[10]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_CurrentCondition_WindGust.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_CurrentCondition_WindGust) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 4, 1}\n}\n\nfunc (x *ForecastResponse_CurrentCondition_WindGust) GetWind() *ForecastResponse_Wind {\n\tif x != nil {\n\t\treturn x.Wind\n\t}\n\treturn nil\n}\n", "n_tokens": 872, "byte_len": 3454, "file_sha1": "2640db73dd4fcdbfc916289704510f06fb220411", "start_line": 791, "end_line": 900}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go#7", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "rel_path": "internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "module": "internal.forecasts.adapters.clients.foreca.v0.service.v0.pb", "ext": "go", "chunk_number": 7, "symbols": ["GetGust", "file", "service", "float", "float32", "byte", "sync", "gust", "once", "return", "descriptor", "forecast", "response", "func", "protoreflect", "get", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetLocationId", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts", "GetCode", "GetDescription", "GetAbbreviation", "GetDegrees", "GetDirection", "GetSpeed", "GetMillibar", "GetTrend", "GetEpoch", "GetVisibility", "GetWeatherCondition", "GetPrecipitation", "GetNextHour", "GetTemperature", "GetTemperatureFeelsLike", "GetWindGust", "GetDewPoint", "GetHeatIndex", "GetPressure", "GetUvIndex", "GetHumidityPercentage", "GetTemperatureMin", "GetTemperatureMax", "GetPrecipitationDay", "GetPrecipitationNight"], "ast_kind": "function_or_method", "text": "func (x *ForecastResponse_CurrentCondition_WindGust) GetGust() float32 {\n\tif x != nil {\n\t\treturn x.Gust\n\t}\n\treturn 0\n}\n\nvar File_service_v0_proto protoreflect.FileDescriptor\n\nvar file_service_v0_proto_rawDesc = []byte{\n\t0x0a, 0x10, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x30, 0x2e, 0x70, 0x72, 0x6f,\n\t0x74, 0x6f, 0x12, 0x1a, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65,\n\t0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x22, 0x31,\n\t0x0a, 0x0f, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,\n\t0x74, 0x12, 0x1e, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x18,\n\t0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49,\n\t0x64, 0x22, 0x92, 0x18, 0x0a, 0x10, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65,\n\t0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x6e, 0x0a, 0x10, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,\n\t0x74, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,\n\t0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63,\n\t0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f,\n\t0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x43,\n\t0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x48,\n\t0x00, 0x52, 0x10, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74,\n\t0x69, 0x6f, 0x6e, 0x88, 0x01, 0x01, 0x12, 0x62, 0x0a, 0x0e, 0x64, 0x61, 0x69, 0x6c, 0x79, 0x46,\n\t0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3a,\n\t0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73,\n\t0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65,\n\t0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x44, 0x61, 0x69,\n\t0x6c, 0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x0e, 0x64, 0x61, 0x69, 0x6c,\n\t0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x12, 0x65, 0x0a, 0x0f, 0x68, 0x6f,\n\t0x75, 0x72, 0x6c, 0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x18, 0x03, 0x20,\n\t0x03, 0x28, 0x0b, 0x32, 0x3b, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f,\n\t0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30,\n\t0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,\n\t0x65, 0x2e, 0x48, 0x6f, 0x75, 0x72, 0x6c, 0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74,\n\t0x52, 0x0f, 0x68, 0x6f, 0x75, 0x72, 0x6c, 0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74,\n\t0x73, 0x1a, 0x48, 0x0a, 0x10, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64,\n\t0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20,\n\t0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73,\n\t0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,\n\t0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x4d, 0x0a, 0x0d, 0x57,\n\t0x69, 0x6e, 0x64, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x22, 0x0a, 0x0c,\n\t0x61, 0x62, 0x62, 0x72, 0x65, 0x76, 0x69, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01,\n\t0x28, 0x09, 0x52, 0x0c, 0x61, 0x62, 0x62, 0x72, 0x65, 0x76, 0x69, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n\t0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x67, 0x72, 0x65, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,\n\t0x02, 0x52, 0x07, 0x64, 0x65, 0x67, 0x72, 0x65, 0x65, 0x73, 0x1a, 0x76, 0x0a, 0x04, 0x57, 0x69,\n\t0x6e, 0x64, 0x12, 0x58, 0x0a, 0x09, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18,\n\t0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e,\n\t0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e,\n\t0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,\n\t0x6e, 0x73, 0x65, 0x2e, 0x57, 0x69, 0x6e, 0x64, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f,\n\t0x6e, 0x52, 0x09, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05,\n\t0x73, 0x70, 0x65, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x05, 0x73, 0x70, 0x65,\n\t0x65, 0x64, 0x1a, 0x3c, 0x0a, 0x08, 0x50, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x12, 0x1a,\n\t0x0a, 0x08, 0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x62, 0x61, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02,\n\t0x52, 0x08, 0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x62, 0x61, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x72,\n\t0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x74, 0x72, 0x65, 0x6e, 0x64,\n\t0x1a, 0xd3, 0x07, 0x0a, 0x10, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x64,\n\t0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x01,\n\t0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x1e, 0x0a, 0x0a, 0x76,\n\t0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52,\n\t0x0a, 0x76, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x69, 0x0a, 0x10, 0x77,\n\t0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18,\n\t0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e,\n\t0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e,\n\t0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,\n\t0x6e, 0x73, 0x65, 0x2e, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69,\n\t0x74, 0x69, 0x6f, 0x6e, 0x52, 0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n\t0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70,\n\t0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0d, 0x70,\n\t0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x62, 0x0a, 0x08,\n\t0x6e, 0x65, 0x78, 0x74, 0x48, 0x6f, 0x75, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x46,\n\t0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73,\n\t0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65,\n\t0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x43, 0x75, 0x72,\n\t0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4e, 0x65,\n\t0x78, 0x74, 0x48, 0x6f, 0x75, 0x72, 0x52, 0x08, 0x6e, 0x65, 0x78, 0x74, 0x48, 0x6f, 0x75, 0x72,\n\t0x12, 0x20, 0x0a, 0x0b, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18,\n\t0x06, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0b, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75,\n\t0x72, 0x65, 0x12, 0x32, 0x0a, 0x14, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72,\n\t0x65, 0x46, 0x65, 0x65, 0x6c, 0x73, 0x4c, 0x69, 0x6b, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x02,\n\t0x52, 0x14, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x46, 0x65, 0x65,\n\t0x6c, 0x73, 0x4c, 0x69, 0x6b, 0x65, 0x12, 0x62, 0x0a, 0x08, 0x77, 0x69, 0x6e, 0x64, 0x47, 0x75,\n\t0x73, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x46, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68,\n\t0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f,\n\t0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65,\n\t0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f,\n\t0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x57, 0x69, 0x6e, 0x64, 0x47, 0x75, 0x73, 0x74,\n\t0x52, 0x08, 0x77, 0x69, 0x6e, 0x64, 0x47, 0x75, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x65,\n\t0x77, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x02, 0x52, 0x08, 0x64, 0x65,\n\t0x77, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x68, 0x65, 0x61, 0x74, 0x49, 0x6e,\n\t0x64, 0x65, 0x78, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x02, 0x52, 0x09, 0x68, 0x65, 0x61, 0x74, 0x49,\n\t0x6e, 0x64, 0x65, 0x78, 0x12, 0x51, 0x0a, 0x08, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65,\n\t0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72,\n\t0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79,\n\t0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70,\n\t0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x50, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x52, 0x08, 0x70,\n\t0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x75, 0x76, 0x49, 0x6e, 0x64,\n\t0x65, 0x78, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x02, 0x52, 0x07, 0x75, 0x76, 0x49, 0x6e, 0x64, 0x65,\n\t0x78, 0x12, 0x2e, 0x0a, 0x12, 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x50, 0x65, 0x72,\n\t0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x05, 0x52, 0x12, 0x68,\n\t0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67,\n\t0x65, 0x1a, 0x9b, 0x01, 0x0a, 0x08, 0x4e, 0x65, 0x78, 0x74, 0x48, 0x6f, 0x75, 0x72, 0x12, 0x69,\n\t0x0a, 0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69,\n\t0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68,\n\t0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f,\n\t0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65,\n\t0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f,\n\t0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72,\n\t0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x70, 0x72, 0x65,\n\t0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02,\n\t0x52, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a,\n\t0x65, 0x0a, 0x08, 0x57, 0x69, 0x6e, 0x64, 0x47, 0x75, 0x73, 0x74, 0x12, 0x45, 0x0a, 0x04, 0x77,\n\t0x69, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x77, 0x65, 0x61, 0x74,\n\t0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72,\n\t0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52,\n\t0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x69, 0x6e, 0x64, 0x52, 0x04, 0x77, 0x69,\n\t0x6e, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x67, 0x75, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02,\n\t0x52, 0x04, 0x67, 0x75, 0x73, 0x74, 0x1a, 0xc4, 0x06, 0x0a, 0x0d, 0x44, 0x61, 0x69, 0x6c, 0x79,\n\t0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x70, 0x6f, 0x63,\n\t0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x26,\n\t0x0a, 0x0e, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4d, 0x69, 0x6e,\n\t0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0e, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74,\n\t0x75, 0x72, 0x65, 0x4d, 0x69, 0x6e, 0x12, 0x26, 0x0a, 0x0e, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72,\n\t0x61, 0x74, 0x75, 0x72, 0x65, 0x4d, 0x61, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0e,\n\t0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4d, 0x61, 0x78, 0x12, 0x24,\n\t0x0a, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18,\n\t0x04, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61,\n\t0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2a, 0x0a, 0x10, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74,\n\t0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x02, 0x52, 0x10,\n\t0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61, 0x79,\n\t0x12, 0x2e, 0x0a, 0x12, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f,\n\t0x6e, 0x4e, 0x69, 0x67, 0x68, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x02, 0x52, 0x12, 0x70, 0x72,\n\t0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x69, 0x67, 0x68, 0x74,\n\t0x12, 0x12, 0x0a, 0x04, 0x73, 0x6e, 0x6f, 0x77, 0x18, 0x07, 0x20, 0x01, 0x28, 0x02, 0x52, 0x04,\n\t0x73, 0x6e, 0x6f, 0x77, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x6e, 0x6f, 0x77, 0x44, 0x61, 0x79, 0x18,\n\t0x08, 0x20, 0x01, 0x28, 0x02, 0x52, 0x07, 0x73, 0x6e, 0x6f, 0x77, 0x44, 0x61, 0x79, 0x12, 0x1c,\n\t0x0a, 0x09, 0x73, 0x6e, 0x6f, 0x77, 0x4e, 0x69, 0x67, 0x68, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28,\n\t0x02, 0x52, 0x09, 0x73, 0x6e, 0x6f, 0x77, 0x4e, 0x69, 0x67, 0x68, 0x74, 0x12, 0x3a, 0x0a, 0x18,\n\t0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f,\n\t0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x52, 0x18,\n\t0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f,\n\t0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x45, 0x0a, 0x04, 0x77, 0x69, 0x6e, 0x64,\n\t0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72,\n\t0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79,\n\t0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70,\n\t0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x69, 0x6e, 0x64, 0x52, 0x04, 0x77, 0x69, 0x6e, 0x64, 0x12,\n\t0x3c, 0x0a, 0x19, 0x61, 0x76, 0x65, 0x72, 0x61, 0x67, 0x65, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69,\n\t0x74, 0x79, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x0c, 0x20, 0x01,\n\t0x28, 0x05, 0x52, 0x19, 0x61, 0x76, 0x65, 0x72, 0x61, 0x67, 0x65, 0x48, 0x75, 0x6d, 0x69, 0x64,\n\t0x69, 0x74, 0x79, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x12, 0x69, 0x0a,\n\t0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f,\n\t0x6e, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65,\n\t0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78,\n\t0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73,\n\t0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n\t0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43,\n\t0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x73, 0x0a, 0x15, 0x77, 0x65, 0x61, 0x74,\n\t0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x69, 0x67, 0x68,\n\t0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65,\n\t0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78,\n\t0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73,\n\t0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n\t0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x15, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43,\n\t0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x69, 0x67, 0x68, 0x74, 0x12, 0x18, 0x0a,\n\t0x07, 0x75, 0x76, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x02, 0x52, 0x07,\n\t0x75, 0x76, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x22, 0x0a, 0x0c, 0x73, 0x75, 0x6e, 0x72, 0x69,\n\t0x73, 0x65, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x10, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0c, 0x73,\n\t0x75, 0x6e, 0x72, 0x69, 0x73, 0x65, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x20, 0x0a, 0x0b, 0x73,\n\t0x75, 0x6e, 0x73, 0x65, 0x74, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x11, 0x20, 0x01, 0x28, 0x03,\n\t0x52, 0x0b, 0x73, 0x75, 0x6e, 0x73, 0x65, 0x74, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x1a, 0xc1, 0x04,\n\t0x0a, 0x0e, 0x48, 0x6f, 0x75, 0x72, 0x6c, 0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74,\n\t0x12, 0x14, 0x0a, 0x05, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52,\n\t0x05, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x20, 0x0a, 0x0b, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72,\n\t0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0b, 0x74, 0x65, 0x6d,\n\t0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x32, 0x0a, 0x14, 0x74, 0x65, 0x6d, 0x70,\n\t0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x46, 0x65, 0x65, 0x6c, 0x73, 0x4c, 0x69, 0x6b, 0x65,\n\t0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x52, 0x14, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74,\n\t0x75, 0x72, 0x65, 0x46, 0x65, 0x65, 0x6c, 0x73, 0x4c, 0x69, 0x6b, 0x65, 0x12, 0x69, 0x0a, 0x10,\n\t0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e,\n\t0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72,\n\t0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79,\n\t0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70,\n\t0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64,\n\t0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f,\n\t0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69,\n\t0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0d,\n\t0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a,\n\t0x04, 0x73, 0x6e, 0x6f, 0x77, 0x18, 0x06, 0x20, 0x01, 0x28, 0x02, 0x52, 0x04, 0x73, 0x6e, 0x6f,\n\t0x77, 0x12, 0x3a, 0x0a, 0x18, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69,\n\t0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x07, 0x20,\n\t0x01, 0x28, 0x05, 0x52, 0x18, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69,\n\t0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x45, 0x0a,\n\t0x04, 0x77, 0x69, 0x6e, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x77, 0x65,\n\t0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e,\n\t0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73,\n\t0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x69, 0x6e, 0x64, 0x52, 0x04,\n\t0x77, 0x69, 0x6e, 0x64, 0x12, 0x51, 0x0a, 0x08, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65,\n\t0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72,\n\t0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79,\n\t0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70,\n\t0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x50, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x52, 0x08, 0x70,\n\t0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x12, 0x2e, 0x0a, 0x12, 0x68, 0x75, 0x6d, 0x69, 0x64,\n\t0x69, 0x74, 0x79, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x0a, 0x20,\n\t0x01, 0x28, 0x05, 0x52, 0x12, 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x50, 0x65, 0x72,\n\t0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x75, 0x76, 0x49, 0x6e, 0x64,\n\t0x65, 0x78, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x02, 0x52, 0x07, 0x75, 0x76, 0x49, 0x6e, 0x64, 0x65,\n\t0x78, 0x42, 0x13, 0x0a, 0x11, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e,\n\t0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x32, 0x77, 0x0a, 0x0b, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61,\n\t0x50, 0x72, 0x6f, 0x78, 0x79, 0x12, 0x68, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x46, 0x6f, 0x72, 0x65,\n\t0x63, 0x61, 0x73, 0x74, 0x12, 0x2b, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66,\n\t0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76,\n\t0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,\n\t0x74, 0x1a, 0x2c, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65,\n\t0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46,\n\t0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42,\n\t0x33, 0x5a, 0x31, 0x67, 0x6f, 0x2e, 0x69, 0x6d, 0x70, 0x61, 0x6c, 0x61, 0x73, 0x74, 0x75, 0x64,\n\t0x69, 0x6f, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2f,\n\t0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x5f, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2f, 0x67, 0x72, 0x70,\n\t0x63, 0x2f, 0x76, 0x30, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,\n}\n\nvar (\n\tfile_service_v0_proto_rawDescOnce sync.Once\n\tfile_service_v0_proto_rawDescData = file_service_v0_proto_rawDesc\n)\n", "n_tokens": 17671, "byte_len": 20785, "file_sha1": "2640db73dd4fcdbfc916289704510f06fb220411", "start_line": 901, "end_line": 1128}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go#8", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "rel_path": "internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "module": "internal.forecasts.adapters.clients.foreca.v0.service.v0.pb", "ext": "go", "chunk_number": 8, "symbols": ["file_service_v0_proto_rawDescGZIP", "init", "file_service_v0_proto_init", "extension", "hourly", "forecast", "response", "interface", "file", "service", "daily", "next", "hour", "wind", "gust", "weather", "condition", "output", "type", "forecasts", "input", "unsafe", "enabled", "name", "make", "pressure", "current", "func", "message", "info", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetLocationId", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts", "GetCode", "GetDescription", "GetAbbreviation", "GetDegrees", "GetDirection", "GetSpeed", "GetMillibar", "GetTrend", "GetEpoch", "GetVisibility", "GetWeatherCondition"], "ast_kind": "function_or_method", "text": "func file_service_v0_proto_rawDescGZIP() []byte {\n\tfile_service_v0_proto_rawDescOnce.Do(func() {\n\t\tfile_service_v0_proto_rawDescData = protoimpl.X.CompressGZIP(file_service_v0_proto_rawDescData)\n\t})\n\treturn file_service_v0_proto_rawDescData\n}\n\nvar file_service_v0_proto_msgTypes = make([]protoimpl.MessageInfo, 11)\nvar file_service_v0_proto_goTypes = []interface{}{\n\t(*ForecastRequest)(nil),                            // 0: weather.forecasts.proxy.v0.ForecastRequest\n\t(*ForecastResponse)(nil),                           // 1: weather.forecasts.proxy.v0.ForecastResponse\n\t(*ForecastResponse_WeatherCondition)(nil),          // 2: weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t(*ForecastResponse_WindDirection)(nil),             // 3: weather.forecasts.proxy.v0.ForecastResponse.WindDirection\n\t(*ForecastResponse_Wind)(nil),                      // 4: weather.forecasts.proxy.v0.ForecastResponse.Wind\n\t(*ForecastResponse_Pressure)(nil),                  // 5: weather.forecasts.proxy.v0.ForecastResponse.Pressure\n\t(*ForecastResponse_CurrentCondition)(nil),          // 6: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition\n\t(*ForecastResponse_DailyForecast)(nil),             // 7: weather.forecasts.proxy.v0.ForecastResponse.DailyForecast\n\t(*ForecastResponse_HourlyForecast)(nil),            // 8: weather.forecasts.proxy.v0.ForecastResponse.HourlyForecast\n\t(*ForecastResponse_CurrentCondition_NextHour)(nil), // 9: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.NextHour\n\t(*ForecastResponse_CurrentCondition_WindGust)(nil), // 10: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.WindGust\n}\nvar file_service_v0_proto_depIdxs = []int32{\n\t6,  // 0: weather.forecasts.proxy.v0.ForecastResponse.currentCondition:type_name -> weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition\n\t7,  // 1: weather.forecasts.proxy.v0.ForecastResponse.dailyForecasts:type_name -> weather.forecasts.proxy.v0.ForecastResponse.DailyForecast\n\t8,  // 2: weather.forecasts.proxy.v0.ForecastResponse.hourlyForecasts:type_name -> weather.forecasts.proxy.v0.ForecastResponse.HourlyForecast\n\t3,  // 3: weather.forecasts.proxy.v0.ForecastResponse.Wind.direction:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WindDirection\n\t2,  // 4: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.weatherCondition:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t9,  // 5: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.nextHour:type_name -> weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.NextHour\n\t10, // 6: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.windGust:type_name -> weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.WindGust\n\t5,  // 7: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.pressure:type_name -> weather.forecasts.proxy.v0.ForecastResponse.Pressure\n\t4,  // 8: weather.forecasts.proxy.v0.ForecastResponse.DailyForecast.wind:type_name -> weather.forecasts.proxy.v0.ForecastResponse.Wind\n\t2,  // 9: weather.forecasts.proxy.v0.ForecastResponse.DailyForecast.weatherCondition:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t2,  // 10: weather.forecasts.proxy.v0.ForecastResponse.DailyForecast.weatherConditionNight:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t2,  // 11: weather.forecasts.proxy.v0.ForecastResponse.HourlyForecast.weatherCondition:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t4,  // 12: weather.forecasts.proxy.v0.ForecastResponse.HourlyForecast.wind:type_name -> weather.forecasts.proxy.v0.ForecastResponse.Wind\n\t5,  // 13: weather.forecasts.proxy.v0.ForecastResponse.HourlyForecast.pressure:type_name -> weather.forecasts.proxy.v0.ForecastResponse.Pressure\n\t2,  // 14: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.NextHour.weatherCondition:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t4,  // 15: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.WindGust.wind:type_name -> weather.forecasts.proxy.v0.ForecastResponse.Wind\n\t0,  // 16: weather.forecasts.proxy.v0.ForecaProxy.GetForecast:input_type -> weather.forecasts.proxy.v0.ForecastRequest\n\t1,  // 17: weather.forecasts.proxy.v0.ForecaProxy.GetForecast:output_type -> weather.forecasts.proxy.v0.ForecastResponse\n\t17, // [17:18] is the sub-list for method output_type\n\t16, // [16:17] is the sub-list for method input_type\n\t16, // [16:16] is the sub-list for extension type_name\n\t16, // [16:16] is the sub-list for extension extendee\n\t0,  // [0:16] is the sub-list for field type_name\n}\n\nfunc init() { file_service_v0_proto_init() }\nfunc file_service_v0_proto_init() {\n\tif File_service_v0_proto != nil {\n\t\treturn\n\t}\n\tif !protoimpl.UnsafeEnabled {", "n_tokens": 1210, "byte_len": 4802, "file_sha1": "2640db73dd4fcdbfc916289704510f06fb220411", "start_line": 1129, "end_line": 1181}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go#9", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "rel_path": "internal/forecasts/adapters/clients/foreca/v0/service.v0.pb.go", "module": "internal.forecasts.adapters.clients.foreca.v0.service.v0.pb", "ext": "go", "chunk_number": 9, "symbols": ["x", "forecast", "response", "num", "services", "interface", "dependency", "indexes", "file", "service", "struct", "size", "cache", "type", "enums", "case", "desc", "builder", "unknown", "fields", "message", "infos", "types", "gotypes", "reflect", "package", "path", "func", "messages", "oneof", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetLocationId", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts", "GetCode", "GetDescription", "GetAbbreviation", "GetDegrees", "GetDirection", "GetSpeed", "GetMillibar", "GetTrend", "GetEpoch", "GetVisibility", "GetWeatherCondition"], "ast_kind": "class_or_type", "text": "\t\tfile_service_v0_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastRequest); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_WeatherCondition); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_WindDirection); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_Wind); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_Pressure); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_CurrentCondition); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_DailyForecast); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_HourlyForecast); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_CurrentCondition_NextHour); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_CurrentCondition_WindGust); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\tfile_service_v0_proto_msgTypes[1].OneofWrappers = []interface{}{}\n\ttype x struct{}\n\tout := protoimpl.TypeBuilder{\n\t\tFile: protoimpl.DescBuilder{\n\t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n\t\t\tRawDescriptor: file_service_v0_proto_rawDesc,\n\t\t\tNumEnums:      0,\n\t\t\tNumMessages:   11,\n\t\t\tNumExtensions: 0,\n\t\t\tNumServices:   1,\n\t\t},\n\t\tGoTypes:           file_service_v0_proto_goTypes,\n\t\tDependencyIndexes: file_service_v0_proto_depIdxs,\n\t\tMessageInfos:      file_service_v0_proto_msgTypes,\n\t}.Build()\n\tFile_service_v0_proto = out.File\n\tfile_service_v0_proto_rawDesc = nil\n\tfile_service_v0_proto_goTypes = nil\n\tfile_service_v0_proto_depIdxs = nil\n}\n", "n_tokens": 1125, "byte_len": 3776, "file_sha1": "2640db73dd4fcdbfc916289704510f06fb220411", "start_line": 1182, "end_line": 1335}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0_grpc.pb.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/clients/foreca/v0/service.v0_grpc.pb.go", "rel_path": "internal/forecasts/adapters/clients/foreca/v0/service.v0_grpc.pb.go", "module": "internal.forecasts.adapters.clients.foreca.v0.service.v0_grpc.pb", "ext": "go", "chunk_number": 1, "symbols": ["NewForecaProxyClient", "GetForecast", "mustEmbedUnimplementedForecaProxyServer", "RegisterForecaProxyServer", "_ForecaProxy_GetForecast_Handler", "forecaProxyClient", "UnimplementedForecaProxyServer", "must", "embed", "compatible", "call", "option", "https", "code", "rpc", "grpc", "recommended", "weather", "compiled", "context", "service", "name", "this", "proxy", "compile", "unimplemented", "foreca", "forecast", "response", "metadata", "status", "methods", "intended", "edit", "opts", "register", "around", "added", "desc", "type", "semantics", "unary", "server", "package", "unsafe", "source", "requires", "client", "conn", "new"], "ast_kind": "class_or_type", "text": "// Code generated by protoc-gen-go-grpc. DO NOT EDIT.\n// versions:\n// - protoc-gen-go-grpc v1.2.0\n// - protoc             v3.21.9\n// source: service.v0.proto\n\npackage v0\n\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the grpc package it is being compiled against.\n// Requires gRPC-Go v1.32.0 or later.\nconst _ = grpc.SupportPackageIsVersion7\n\n// ForecaProxyClient is the client API for ForecaProxy service.\n//\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.\ntype ForecaProxyClient interface {\n\tGetForecast(ctx context.Context, in *ForecastRequest, opts ...grpc.CallOption) (*ForecastResponse, error)\n}\n\ntype forecaProxyClient struct {\n\tcc grpc.ClientConnInterface\n}\n\nfunc NewForecaProxyClient(cc grpc.ClientConnInterface) ForecaProxyClient {\n\treturn &forecaProxyClient{cc}\n}\n\nfunc (c *forecaProxyClient) GetForecast(ctx context.Context, in *ForecastRequest, opts ...grpc.CallOption) (*ForecastResponse, error) {\n\tout := new(ForecastResponse)\n\terr := c.cc.Invoke(ctx, \"/weather.forecasts.proxy.v0.ForecaProxy/GetForecast\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// ForecaProxyServer is the server API for ForecaProxy service.\n// All implementations must embed UnimplementedForecaProxyServer\n// for forward compatibility\ntype ForecaProxyServer interface {\n\tGetForecast(context.Context, *ForecastRequest) (*ForecastResponse, error)\n\tmustEmbedUnimplementedForecaProxyServer()\n}\n\n// UnimplementedForecaProxyServer must be embedded to have forward compatible implementations.\ntype UnimplementedForecaProxyServer struct {\n}\n\nfunc (UnimplementedForecaProxyServer) GetForecast(context.Context, *ForecastRequest) (*ForecastResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GetForecast not implemented\")\n}\nfunc (UnimplementedForecaProxyServer) mustEmbedUnimplementedForecaProxyServer() {}\n\n// UnsafeForecaProxyServer may be embedded to opt out of forward compatibility for this service.\n// Use of this interface is not recommended, as added methods to ForecaProxyServer will\n// result in compilation errors.\ntype UnsafeForecaProxyServer interface {\n\tmustEmbedUnimplementedForecaProxyServer()\n}\n\nfunc RegisterForecaProxyServer(s grpc.ServiceRegistrar, srv ForecaProxyServer) {\n\ts.RegisterService(&ForecaProxy_ServiceDesc, srv)\n}\n\nfunc _ForecaProxy_GetForecast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ForecastRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(ForecaProxyServer).GetForecast(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/weather.forecasts.proxy.v0.ForecaProxy/GetForecast\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(ForecaProxyServer).GetForecast(ctx, req.(*ForecastRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\n// ForecaProxy_ServiceDesc is the grpc.ServiceDesc for ForecaProxy service.\n// It's only intended for direct use with grpc.RegisterService,\n// and not to be introspected or modified (even as a copy)\nvar ForecaProxy_ServiceDesc = grpc.ServiceDesc{\n\tServiceName: \"weather.forecasts.proxy.v0.ForecaProxy\",\n\tHandlerType: (*ForecaProxyServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"GetForecast\",\n\t\t\tHandler:    _ForecaProxy_GetForecast_Handler,\n\t\t},\n\t},\n\tStreams:  []grpc.StreamDesc{},\n\tMetadata: \"service.v0.proto\",\n}\n", "n_tokens": 908, "byte_len": 3763, "file_sha1": "7af66c44d84a6e32b7b284eba9b55acf9943cc51", "start_line": 1, "end_line": 106}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/health.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/health.go", "rel_path": "internal/forecasts/adapters/handlers/http/health.go", "module": "internal.forecasts.adapters.handlers.http.health", "ext": "go", "chunk_number": 1, "symbols": ["NewHealthHandler", "Register", "health", "HealthHandler", "logger", "new", "response", "status", "statusok", "context", "httpresponses", "struct", "type", "register", "string", "package", "forecasts", "time", "http", "weather", "github", "func", "format", "healthy", "import", "rfc3339", "handler", "pure", "json", "return", "impalastudios", "gonic", "router", "group", "uber"], "ast_kind": "class_or_type", "text": "package http\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/httpresponses\"\n\t\"go.uber.org/zap\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype HealthHandler struct {\n\tlogger *zap.Logger\n}\n\nfunc NewHealthHandler(logger *zap.Logger) *HealthHandler {\n\treturn &HealthHandler{\n\t\tlogger: logger,\n\t}\n}\n\nfunc (h *HealthHandler) Register(g *gin.RouterGroup) {\n\tg.GET(\"/health\", h.health)\n}\n\nfunc (h *HealthHandler) health(c *gin.Context) {\n\tnow := time.Now().UTC().Format(time.RFC3339)\n\tc.PureJSON(\n\t\thttp.StatusOK,\n\t\thttpresponses.NewResponse[string](now, \"ok\", \"I'm healthy.\"),\n\t)\n}\n", "n_tokens": 162, "byte_len": 591, "file_sha1": "ba65a9812cb40a8f2c9418fba6d0efb0704d1e58", "start_line": 1, "end_line": 32}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/handler.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/handler.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/handler.go", "module": "internal.forecasts.adapters.handlers.http.v0.handler", "ext": "go", "chunk_number": 1, "symbols": ["Parse", "New", "Register", "toLocationResource", "Handler", "forecasts", "service", "strings", "latitude", "interface", "division", "name", "context", "struct", "type", "error", "handler", "get", "locale", "register", "text", "value", "single", "subdivision", "code", "string", "package", "split", "nearest", "coordinate", "weather", "github", "func", "language", "parse", "float", "batch", "strconv", "import", "internal", "invalid", "golang", "return", "country", "wrap", "errors", "pieces", "impalastudios", "gonic", "longitude"], "ast_kind": "class_or_type", "text": "package v0\n\nimport (\n\t\"context\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/pkg/errors\"\n\t\"go.impalastudios.com/weather/forecasts/internal/forecasts\"\n\t\"golang.org/x/text/language\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype Coordinate string\n\nfunc (c Coordinate) Parse() (forecasts.Coordinate, error) {\n\tpieces := strings.Split(string(c), \",\")\n\tif len(pieces) != 2 {\n\t\treturn forecasts.Coordinate{}, errors.New(\"invalid value\")\n\t}\n\n\tlat, err := strconv.ParseFloat(pieces[0], 64)\n\tif err != nil {\n\t\treturn forecasts.Coordinate{}, errors.Wrap(err, \"invalid latitude value\")\n\t}\n\n\tlon, err := strconv.ParseFloat(pieces[1], 64)\n\tif err != nil {\n\t\treturn forecasts.Coordinate{}, errors.Wrap(err, \"invalid longitude value\")\n\t}\n\n\treturn forecasts.Coordinate{\n\t\tLat: lat,\n\t\tLon: lon,\n\t}, nil\n}\n\ntype Handler struct {\n\tforecasts forecastsService\n}\n\ntype forecastsService interface {\n\tGetForecastsForLocation(context.Context, int, language.Tag) (*forecasts.Forecast, *forecasts.Location, error)\n\tGetForecastsForLocations(ctx context.Context, ids []int, locale language.Tag) ([]*forecasts.Forecast, []*forecasts.Location, error)\n\tGetForecastForClosestLocation(ctx context.Context, coordinate forecasts.Coordinate, locale language.Tag) (*forecasts.Forecast, *forecasts.Location, error)\n\tGetForecastForClosestLocations(ctx context.Context, coordinates []forecasts.Coordinate, locale language.Tag) ([]*forecasts.Forecast, []*forecasts.Location, error)\n}\n\nfunc New(forecasts forecastsService) *Handler {\n\treturn &Handler{forecasts}\n}\n\n// Register gin routes\nfunc (h *Handler) Register(g *gin.RouterGroup) {\n\tg.GET(\"/v0/single/:id\", h.single)\n\tg.GET(\"/v0/batch\", h.batch)\n\tg.GET(\"/v0/nearest/:coordinate\", h.nearest)\n\tg.GET(\"/v0/nearest/batch\", h.nearestBatch)\n}\n\nfunc (h *Handler) toLocationResource(l *forecasts.Location) *Location {\n\tloc := &Location{\n\t\tID:        l.ID,\n\t\tLatitude:  l.Lat,\n\t\tLongitude: l.Lon,\n\t\tTimezone:  &l.Timezone,\n\t\tName:      l.Name,\n\t}\n\n\tif l.DivisionCode != nil {\n\t\tloc.Division = &Division{\n\t\t\tCode: l.DivisionCode,\n\t\t\tName: l.DivisionName,\n\t\t}\n\t}\n\n\tif l.SubdivisionCode != nil {\n\t\tloc.Subdivision = &Subdivision{\n\t\t\tCode: l.SubdivisionCode,\n\t\t\tName: l.SubdivisionName,\n\t\t}\n\t}\n\n\tif l.CountryCode != nil {\n\t\tloc.Country = Country{\n\t\t\tCode: *l.CountryCode,\n\t\t\tName: *l.CountryName,\n\t\t}\n\t}\n\n\treturn loc\n}\n", "n_tokens": 616, "byte_len": 2297, "file_sha1": "d4f94fb3fb096aef4bd475b8aae6727d61c8b11f", "start_line": 1, "end_line": 92}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/single.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/single.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/single.go", "module": "internal.forecasts.adapters.handlers.http.v0.single", "ext": "go", "chunk_number": 1, "symbols": ["single", "singleLocationForecastRequest", "went", "timezone", "status", "statusok", "httpresponses", "locale", "atoi", "snow", "hourly", "presenter", "unique", "string", "warn", "current", "fields", "index", "internal", "error", "oneof", "weather", "heat", "request", "load", "distance", "unit", "location", "dive", "message", "binding", "temperature", "max", "wind", "daily", "conditions", "response", "not", "found", "type", "humidity", "validation", "average", "package", "timestamp", "cannot", "present", "http", "precipitation", "get"], "ast_kind": "class_or_type", "text": "package v0\n\nimport (\n\t\"errors\"\n\t\"github.com/gin-gonic/gin\"\n\t\"go.impalastudios.com/log\"\n\t\"go.impalastudios.com/weather/forecasts/internal/forecasts\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/httpresponses\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/i18n\"\n\t\"go.uber.org/zap\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype singleLocationForecastRequest struct {\n\tDailyFields     []string `form:\"daily[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* temperature_min temperature_max precipitation snow wind_max humidity_average condition condition_night uv_index\"`\n\tDailyDays       *int     `form:\"daily[days],default=10\" binding:\"omitempty,min=1,max=10\"`\n\tHourlyFields    []string `form:\"hourly[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* timestamp temperature temperature_feels_like precipitation snow wind pressure condition humidity uv_index\"`\n\tHourlyDays      *int     `form:\"hourly[days],default=10\" binding:\"omitempty,min=1,max=10\"`\n\tHourlyHours     []string `form:\"hourly[hours][]\" binding:\"omitempty,unique,star,dive,oneof=* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\"`\n\tCurrentFields   []string `form:\"current[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* condition uv_index temperature temperature_feels_like heat_index dew_point visibility pressure wind humidity precipitation\"`\n\tDistanceUnit    string   `form:\"distanceUnit,default=km\" binding:\"omitempty,oneof=km mi\"`\n\tTemperatureUnit string   `form:\"temperatureUnit,default=C\" binding:\"omitempty,oneof=C F\"`\n}\n\nfunc (h *Handler) single(c *gin.Context) {\n\tlocale := i18n.GetLocaleFromHeader(c.GetHeader(\"Accept-Language\"))\n\n\tlog.Debug(c, \"Request detected locale.\", zap.String(\"locale\", locale.String()))\n\n\tpathId := c.Param(\"id\")\n\tid, err := strconv.Atoi(pathId)\n\tif err != nil {\n\t\tlog.Warn(c, \"Cannot parse ID.\", zap.String(\"id\", pathId), zap.Error(err))\n\n\t\tc.JSON(\n\t\t\thttp.StatusBadRequest,\n\t\t\thttpresponses.NewErrorResponse[*Response](\"invalid_parameters\", \"The location ID is invalid.\"),\n\t\t)\n\t\treturn\n\t}\n\n\trequest := singleLocationForecastRequest{\n\t\tHourlyHours: []string{\"*\"},\n\t}\n\n\tif err = c.ShouldBind(&request); err != nil {\n\t\tlog.Warn(c, \"Validation errors.\", zap.Error(err))\n\n\t\tmessage := i18n.GetFirstValidationErrorMessage(err)\n\n\t\tc.PureJSON(\n\t\t\thttp.StatusBadRequest,\n\t\t\thttpresponses.NewErrorResponse[*Location](\"invalid_parameters\", message),\n\t\t)\n\t\treturn\n\t}\n\n\tif len(request.CurrentFields) == 0 && len(request.DailyFields) == 0 && len(request.HourlyFields) == 0 {\n\t\tlog.Debug(c, \"current[fields], daily[fields], and hourly[fields] cannot be null at the same time.\", zap.Any(\"request\", request))\n\t\tc.JSON(\n\t\t\thttp.StatusBadRequest,\n\t\t\thttpresponses.NewErrorResponse[*Response](\"invalid_parameters\", \"At least one of current[fields], daily[fields], or hourly[fields] must be present.\"),\n\t\t)\n\n\t\treturn\n\t}\n\n\tforecast, location, err := h.forecasts.GetForecastsForLocation(c.Request.Context(), id, locale)\n\n\tif err != nil {\n\t\tlog.Error(c, \"Something went wrong while retrieving the forecast for location.\", zap.Any(\"request\", request), zap.Int(\"location_id\", id), zap.Error(err))\n\n\t\tif errors.Is(err, forecasts.ErrLocationNotFound) {\n\t\t\tc.JSON(\n\t\t\t\thttp.StatusNotFound,\n\t\t\t\thttpresponses.NewErrorResponse[*Response](\"not_found\", \"Location cannot be found.\"),\n\t\t\t)\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(\n\t\t\thttp.StatusInternalServerError,\n\t\t\thttpresponses.NewErrorResponse[*Response](\"internal_error\", \"Something went wrong. Retry later.\"),\n\t\t)\n\t\treturn\n\t}\n\n\tcurrentPresenter := NewCurrentConditionPresenter(request.CurrentFields, 2, request.DistanceUnit, request.TemperatureUnit, locale)\n\tdailyPresenter := NewDailyConditionPresenter(request.DailyFields, 2, *request.DailyDays, request.DistanceUnit, request.TemperatureUnit, locale)\n\thourlyPresenter := NewHourlyConditionPresenter(request.HourlyFields, 2, *request.HourlyDays, request.HourlyHours, request.DistanceUnit, request.TemperatureUnit, locale)\n\n\tloc, err := time.LoadLocation(location.Timezone)\n\tif err != nil {\n\t\tlog.Error(c, \"Cannot load timezone.\", zap.Int(\"id\", id), zap.Any(\"request\", request), zap.Error(err))\n\n\t\tc.JSON(\n\t\t\thttp.StatusInternalServerError,\n\t\t\thttpresponses.NewErrorResponse[*Response](\"internal_error\", \"Something went wrong. Retry later.\"),\n\t\t)\n\t\treturn\n\t}\n\n\tres := &Response{\n\t\tLocation: h.toLocationResource(location),\n\t\tForecast: &Forecast{\n\t\t\tCurrentCondition: currentPresenter.Present(forecast.CurrentCondition, loc),\n\t\t\tDailyConditions:  dailyPresenter.Present(forecast.DailyConditions, loc),\n\t\t\tHourlyConditions: hourlyPresenter.Present(forecast.HourlyConditions, loc),\n\t\t},\n\t}\n\n\tc.JSON(\n\t\thttp.StatusOK,\n\t\thttpresponses.NewResponse[*Response](res, \"ok\", \"Forecast retrieved.\"),\n\t)\n}\n", "n_tokens": 1175, "byte_len": 4672, "file_sha1": "e81f2962b08e987356af0d743bdc641bec593d98", "start_line": 1, "end_line": 119}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/batch.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/batch.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/batch.go", "module": "internal.forecasts.adapters.handlers.http.v0.batch", "ext": "go", "chunk_number": 1, "symbols": ["batch", "batchLocationsForecastRequest", "went", "append", "timezone", "status", "statusok", "httpresponses", "locale", "snow", "hourly", "presenter", "unique", "string", "warn", "current", "fields", "index", "internal", "error", "oneof", "weather", "provided", "heat", "request", "load", "distance", "unit", "please", "dive", "message", "binding", "temperature", "max", "wind", "range", "daily", "conditions", "response", "not", "found", "get", "forecasts", "type", "humidity", "validation", "average", "package", "timestamp", "cannot"], "ast_kind": "class_or_type", "text": "package v0\n\nimport (\n\t\"errors\"\n\t\"github.com/gin-gonic/gin\"\n\t\"go.impalastudios.com/log\"\n\t\"go.impalastudios.com/weather/forecasts/internal/forecasts\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/httpresponses\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/i18n\"\n\t\"go.uber.org/zap\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype batchLocationsForecastRequest struct {\n\tIDs             []int    `form:\"ids[]\" binding:\"required,unique,min=1,max=25,dive,gt=0\"`\n\tDailyFields     []string `form:\"daily[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* temperature_min temperature_max precipitation snow wind_max humidity_average condition condition_night uv_index\"`\n\tDailyDays       *int     `form:\"daily[days],default=10\" binding:\"omitempty,min=1,max=10\"`\n\tHourlyFields    []string `form:\"hourly[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* timestamp temperature temperature_feels_like precipitation snow wind pressure condition humidity uv_index\"`\n\tHourlyDays      *int     `form:\"hourly[days],default=10\" binding:\"omitempty,min=1,max=10\"`\n\tHourlyHours     []string `form:\"hourly[hours][]\" binding:\"omitempty,unique,star,dive,oneof=* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\"`\n\tCurrentFields   []string `form:\"current[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* condition uv_index temperature temperature_feels_like heat_index dew_point visibility pressure wind humidity precipitation\"`\n\tDistanceUnit    string   `form:\"distanceUnit,default=km\" binding:\"omitempty,oneof=km mi\"`\n\tTemperatureUnit string   `form:\"temperatureUnit,default=C\" binding:\"omitempty,oneof=C F\"`\n}\n\nfunc (h *Handler) batch(c *gin.Context) {\n\tlocale := i18n.GetLocaleFromHeader(c.GetHeader(\"Accept-Language\"))\n\n\tlog.Debug(c, \"Request detected locale.\", zap.String(\"locale\", locale.String()))\n\n\trequest := batchLocationsForecastRequest{\n\t\tHourlyHours: []string{\"*\"},\n\t}\n\n\tif err := c.ShouldBind(&request); err != nil {\n\t\tlog.Debug(c, \"Validation errors.\", zap.Any(\"request\", request), zap.Error(err))\n\n\t\tmessage := i18n.GetFirstValidationErrorMessage(err)\n\n\t\tc.PureJSON(\n\t\t\thttp.StatusBadRequest,\n\t\t\thttpresponses.NewErrorResponse[*Response](\"invalid_parameters\", message),\n\t\t)\n\t\treturn\n\t}\n\n\tif len(request.CurrentFields) == 0 && len(request.DailyFields) == 0 && len(request.HourlyFields) == 0 {\n\t\tlog.Debug(c, \"current[fields], daily[fields], and hourly[fields] cannot be null at the same time.\", zap.Any(\"request\", request))\n\t\tc.JSON(\n\t\t\thttp.StatusBadRequest,\n\t\t\thttpresponses.NewErrorResponse[[]*Response](\"invalid_parameters\", \"At least one of current[fields], daily[fields], or hourly[fields] must be present.\"),\n\t\t)\n\n\t\treturn\n\t}\n\n\tfcs, locations, err := h.forecasts.GetForecastsForLocations(c.Request.Context(), request.IDs, locale)\n\n\tif err != nil {\n\t\tlog.Error(c, \"Something went wrong while retrieving the forecast for locations.\", zap.Any(\"request\", request), zap.Error(err))\n\t\tif errors.Is(err, forecasts.ErrLocationNotFound) {\n\t\t\tc.JSON(\n\t\t\t\thttp.StatusNotFound,\n\t\t\t\thttpresponses.NewErrorResponse[[]*Response](\"not_found\", \"Location cannot be found.\"),\n\t\t\t)\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(\n\t\t\thttp.StatusInternalServerError,\n\t\t\thttpresponses.NewErrorResponse[[]*Response](\"internal_error\", \"Something went wrong while retrieving the forecasts. Please retry later.\"),\n\t\t)\n\t\treturn\n\t}\n\n\tcurrentPresenter := NewCurrentConditionPresenter(request.CurrentFields, 2, request.DistanceUnit, request.TemperatureUnit, locale)\n\tdailyPresenter := NewDailyConditionPresenter(request.DailyFields, 2, *request.DailyDays, request.DistanceUnit, request.TemperatureUnit, locale)\n\thourlyPresenter := NewHourlyConditionPresenter(request.HourlyFields, 2, *request.HourlyDays, request.HourlyHours, request.DistanceUnit, request.TemperatureUnit, locale)\n\n\tvar res []*Response\n\tfor i := range fcs {\n\t\tif locations[i] == nil || fcs[i] == nil {\n\t\t\tlog.Warn(c, \"Cannot find proper location or forecast for provided ID.\", zap.Int(\"id\", request.IDs[i]), zap.Any(\"location\", locations[i]), zap.Any(\"forecast\", fcs[i]))\n\t\t\tcontinue\n\t\t}\n\n\t\tloc, err := time.LoadLocation(locations[i].Timezone)\n\t\tif err != nil {\n\t\t\tlog.Warn(c, \"Cannot load timezone.\", zap.Int(\"id\", request.IDs[i]), zap.Any(\"location\", locations[i]), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tres = append(res, &Response{\n\t\t\tLocation: h.toLocationResource(locations[i]),\n\t\t\tForecast: &Forecast{\n\t\t\t\tCurrentCondition: currentPresenter.Present(fcs[i].CurrentCondition, loc),\n\t\t\t\tDailyConditions:  dailyPresenter.Present(fcs[i].DailyConditions, loc),\n\t\t\t\tHourlyConditions: hourlyPresenter.Present(fcs[i].HourlyConditions, loc),\n\t\t\t},\n\t\t})\n\t}\n\n\tc.JSON(http.StatusOK, httpresponses.NewResponse(res, \"ok\", \"Forecasts retrieved.\"))\n}\n", "n_tokens": 1193, "byte_len": 4652, "file_sha1": "750e61c3b95e1f5b2d7b527ccbdaf34364f83346", "start_line": 1, "end_line": 106}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/resources.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/resources.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/resources.go", "module": "internal.forecasts.adapters.handlers.http.v0.resources", "ext": "go", "chunk_number": 1, "symbols": ["Country", "Division", "Subdivision", "Location", "Direction", "CurrentPrecipitation", "CurrentCondition", "WeatherCondition", "DailyPrecipitation", "DailySnow", "DailyCondition", "Wind", "Pressure", "HourlyPrecipitation", "HourlyCondition", "Forecast", "Response", "float", "float32", "timezone", "speed", "abbreviation", "temperature", "humidity", "snow", "string", "name", "code", "index", "probability", "heat", "uvindex", "int", "int32", "trend", "description", "max", "degrees", "wind", "min", "night", "daily", "conditions", "dew", "point", "current", "response", "feels", "subdivision", "division"], "ast_kind": "class_or_type", "text": "package v0\n\ntype Country struct {\n\tCode string `json:\"code\"`\n\tName string `json:\"name\"`\n}\n\ntype Division struct {\n\tCode *string `json:\"code\"`\n\tName *string `json:\"name\"`\n}\n\ntype Subdivision struct {\n\tCode *string `json:\"code\"`\n\tName *string `json:\"name\"`\n}\n\ntype Location struct {\n\tID          int32        `json:\"id\"`\n\tLatitude    float32      `json:\"latitude\"`\n\tLongitude   float32      `json:\"longitude\"`\n\tName        string       `json:\"name\"`\n\tDivision    *Division    `json:\"division\"`\n\tSubdivision *Subdivision `json:\"subdivision\"`\n\tCountry     Country      `json:\"country\"`\n\tTimezone    *string      `json:\"timezone\"`\n}\n\ntype Direction struct {\n\tAbbreviation string `json:\"abbreviation\"`\n\tDegrees      int    `json:\"degrees\"`\n}\n\ntype CurrentPrecipitation struct {\n\tNextHour int     `json:\"next_hour\"`\n\tAmount   float32 `json:\"amount\"`\n}\n\ntype CurrentCondition struct {\n\tTimestamp            *int64                `json:\"timestamp,omitempty\"`\n\tCondition            *WeatherCondition     `json:\"condition,omitempty\"`\n\tUvIndex              *int                  `json:\"uv_index,omitempty\"`\n\tTemperature          *int                  `json:\"temperature,omitempty\"`\n\tTemperatureFeelsLike *int                  `json:\"temperature_feels_like,omitempty\"`\n\tHeatIndex            *int                  `json:\"heat_index,omitempty\"`\n\tDewPoint             *int                  `json:\"dew_point,omitempty\"`\n\tVisibility           *int                  `json:\"visibility,omitempty\"`\n\tPressure             *Pressure             `json:\"pressure,omitempty\"`\n\tWind                 *Wind                 `json:\"wind,omitempty\"`\n\tHumidity             *int                  `json:\"humidity,omitempty\"`\n\tPrecipitation        *CurrentPrecipitation `json:\"precipitation,omitempty\"`\n}\n\ntype WeatherCondition struct {\n\tCode        string `json:\"code\"`\n\tDescription string `json:\"description\"`\n}\n\ntype DailyPrecipitation struct {\n\tProbability int     `json:\"probability\"`\n\tAmount      float32 `json:\"amount\"`\n\tDay         float32 `json:\"day\"`\n\tNight       float32 `json:\"night\"`\n}\n\ntype DailySnow struct {\n\tAmount float32 `json:\"amount\"`\n\tDay    float32 `json:\"day\"`\n\tNight  float32 `json:\"night\"`\n}\n\ntype DailyCondition struct {\n\tTimestamp       int64               `json:\"timestamp,omitempty\"`\n\tTemperatureMin  *int                `json:\"temperature_min,omitempty\"`\n\tTemperatureMax  *int                `json:\"temperature_max,omitempty\"`\n\tPrecipitation   *DailyPrecipitation `json:\"precipitation,omitempty\"`\n\tSnow            *DailySnow          `json:\"snow,omitempty\"`\n\tWindMax         *Wind               `json:\"wind_max,omitempty\"`\n\tHumidityAverage *int                `json:\"humidity_average,omitempty\"`\n\tCondition       *WeatherCondition   `json:\"condition,omitempty\"`\n\tConditionNight  *WeatherCondition   `json:\"condition_night,omitempty\"`\n\tUvIndex         *int                `json:\"uv_index,omitempty\"`\n}\n\ntype Wind struct {\n\tDirection Direction `json:\"direction\"`\n\tSpeed     int       `json:\"speed\"`\n\tGust      *int      `json:\"gust,omitempty\"`\n}\n\ntype Pressure struct {\n\tMillibar int `json:\"millibar\"`\n\tTrend    int `json:\"trend\"`\n}\n\ntype HourlyPrecipitation struct {\n\tAmount      float32 `json:\"amount\"`\n\tProbability int     `json:\"probability\"`\n}\n\ntype HourlyCondition struct {\n\tTimestamp            int64                `json:\"timestamp,omitempty\"`\n\tTemperature          *int                 `json:\"temperature,omitempty\"`\n\tTemperatureFeelsLike *int                 `json:\"temperature_feels_like,omitempty\"`\n\tPrecipitation        *HourlyPrecipitation `json:\"precipitation,omitempty\"`\n\tSnow                 *float32             `json:\"snow,omitempty\"`\n\tWind                 *Wind                `json:\"wind,omitempty\"`\n\tPressure             *Pressure            `json:\"pressure,omitempty\"`\n\tCondition            *WeatherCondition    `json:\"condition,omitempty\"`\n\tHumidity             *int                 `json:\"humidity,omitempty\"`\n\tUvIndex              *int                 `json:\"uv_index,omitempty\"`\n}\n\ntype Forecast struct {\n\tCurrentCondition *CurrentCondition  `json:\"current,omitempty\"`\n\tDailyConditions  []*DailyCondition  `json:\"daily,omitempty\"`\n\tHourlyConditions []*HourlyCondition `json:\"hourly,omitempty\"`\n}\n\ntype Response struct {\n\tLocation *Location `json:\"location\"`\n\tForecast *Forecast `json:\"forecast\"`\n}\n", "n_tokens": 934, "byte_len": 4317, "file_sha1": "dcfcf70f4e0b730b6a5e8681d1082ee0585b96cf", "start_line": 1, "end_line": 124}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/presenters.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/presenters.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/presenters.go", "module": "internal.forecasts.adapters.handlers.http.v0.presenters", "ext": "go", "chunk_number": 1, "symbols": ["NewCurrentConditionPresenter", "CurrentConditionPresenter", "interface", "temperature", "fahrenheit", "struct", "type", "locale", "text", "current", "condition", "feels", "humidity", "string", "pressure", "forecasts", "package", "index", "projection", "distance", "unit", "precision", "time", "present", "miles", "precipitation", "visibility", "wind", "weather", "language", "Present", "shouldProject", "NewDailyConditionPresenter", "presentCondition", "NewHourlyConditionPresenter", "DailyConditionPresenter", "HourlyConditionPresenter", "append", "length", "hour", "speed", "number", "days", "gust", "snow", "atoi", "code", "probability", "contains", "daily"], "ast_kind": "class_or_type", "text": "package v0\n\nimport (\n\t\"go.impalastudios.com/weather/forecasts/internal/forecasts\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/i18n\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/utilities\"\n\t\"golang.org/x/text/language\"\n\t\"sort\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype Presenter[In any, Out any] interface {\n\tPresent(In, *time.Location) Out\n}\n\nconst (\n\tTemperatureCelsius    string = \"C\"\n\tTemperatureFahrenheit string = \"F\"\n)\n\nconst (\n\tDistanceKilometres string = \"km\"\n\tDistanceMiles      string = \"mi\"\n)\n\nconst (\n\tCurrentConditionProjection            string = \"condition\"\n\tCurrentUvIndexProjection              string = \"uv_index\"\n\tCurrentTemperatureProjection          string = \"temperature\"\n\tCurrentTemperatureFeelsLikeProjection string = \"temperature_feels_like\"\n\tCurrentHeatIndexProjection            string = \"heat_index\"\n\tCurrentDewPointProjection             string = \"dew_point\"\n\tCurrentVisibilityProjection           string = \"visibility\"\n\tCurrentPressureProjection             string = \"pressure\"\n\tCurrentWindProjection                 string = \"wind\"\n\tCurrentHumidityProjection             string = \"humidity\"\n\tCurrentPrecipitationProjection        string = \"precipitation\"\n)\n\ntype CurrentConditionPresenter struct {\n\tprojection      utilities.Set[string]\n\tdistanceUnit    string\n\ttemperatureUnit string\n\tprecision       int\n\tlocale          language.Tag\n}\n\nfunc NewCurrentConditionPresenter(projection []string, precision int, distanceUnit, temperatureUnit string, locale language.Tag) Presenter[*forecasts.CurrentCondition, *CurrentCondition] {\n\treturn &CurrentConditionPresenter{\n\t\tprojection:      utilities.NewSetFromSlice(projection),\n\t\tdistanceUnit:    distanceUnit,\n\t\ttemperatureUnit: temperatureUnit,\n\t\tprecision:       precision,\n\t\tlocale:          locale,\n\t}\n}\n", "n_tokens": 394, "byte_len": 1770, "file_sha1": "292189e1f0feb72d1c92c9758ea73e16ff9cc0d3", "start_line": 1, "end_line": 58}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/presenters.go#2", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/presenters.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/presenters.go", "module": "internal.forecasts.adapters.handlers.http.v0.presenters", "ext": "go", "chunk_number": 2, "symbols": ["Present", "shouldProject", "NewDailyConditionPresenter", "DailyConditionPresenter", "length", "speed", "number", "days", "locale", "temperature", "humidity", "wind", "gust", "snow", "string", "code", "index", "projection", "contains", "daily", "uvindex", "precipitation", "mostlyclear", "trend", "description", "max", "current", "localise", "degrees", "celsius", "NewCurrentConditionPresenter", "presentCondition", "NewHourlyConditionPresenter", "CurrentConditionPresenter", "HourlyConditionPresenter", "append", "hour", "atoi", "probability", "weather", "heat", "sort", "new", "set", "unix", "condition", "range", "min", "night", "dew"], "ast_kind": "class_or_type", "text": "func (p *CurrentConditionPresenter) Present(in *forecasts.CurrentCondition, loc *time.Location) *CurrentCondition {\n\tif p.projection.Length() == 0 {\n\t\treturn nil\n\t}\n\n\ttimestamp := in.Epoch.Unix()\n\tcc := &CurrentCondition{\n\t\tTimestamp: &timestamp,\n\t}\n\n\tif p.shouldProject(CurrentConditionProjection) && in.WeatherCondition != nil {\n\t\tvar wd = in.WeatherCondition.Code\n\t\tif in.IsNight && in.WeatherCondition.Code == \"mostlysunny\" {\n\t\t\twd = \"mostlyclear\"\n\t\t}\n\n\t\tcc.Condition = &WeatherCondition{\n\t\t\tCode:        in.WeatherCondition.Code,\n\t\t\tDescription: i18n.Localise(p.locale, wd),\n\t\t}\n\t}\n\n\tif p.shouldProject(CurrentUvIndexProjection) {\n\t\tuv := int(in.UvIndex)\n\t\tcc.UvIndex = &uv\n\t}\n\n\tif p.shouldProject(CurrentTemperatureProjection) {\n\t\tif p.temperatureUnit == TemperatureCelsius {\n\t\t\tt := int(in.Temperature)\n\t\t\tcc.Temperature = &t\n\t\t} else if p.temperatureUnit == TemperatureFahrenheit {\n\t\t\tt := int(utilities.CelsiusToFahrenheit(in.Temperature))\n\t\t\tcc.Temperature = &t\n\t\t}\n\t}\n\n\tif p.shouldProject(CurrentTemperatureFeelsLikeProjection) || p.shouldProject(CurrentTemperatureProjection) {\n\t\tif p.temperatureUnit == TemperatureCelsius {\n\t\t\tt := int(in.TemperatureFeelsLike)\n\t\t\tcc.TemperatureFeelsLike = &t\n\t\t} else if p.temperatureUnit == TemperatureFahrenheit {\n\t\t\tt := int(utilities.CelsiusToFahrenheit(in.TemperatureFeelsLike))\n\t\t\tcc.TemperatureFeelsLike = &t\n\t\t}\n\t}\n\n\tif p.shouldProject(CurrentHeatIndexProjection) {\n\t\tif p.temperatureUnit == TemperatureCelsius {\n\t\t\tt := int(in.HeatIndex)\n\t\t\tcc.HeatIndex = &t\n\t\t} else if p.temperatureUnit == TemperatureFahrenheit {\n\t\t\tt := int(utilities.CelsiusToFahrenheit(in.HeatIndex))\n\t\t\tcc.HeatIndex = &t\n\t\t}\n\t}\n\n\tif p.shouldProject(CurrentDewPointProjection) {\n\t\tif p.temperatureUnit == TemperatureCelsius {\n\t\t\tt := int(in.DewPoint)\n\t\t\tcc.DewPoint = &t\n\t\t} else if p.temperatureUnit == TemperatureFahrenheit {\n\t\t\tt := int(utilities.CelsiusToFahrenheit(in.DewPoint))\n\t\t\tcc.DewPoint = &t\n\t\t}\n\t}\n\n\tif p.shouldProject(CurrentVisibilityProjection) {\n\t\tv := int(in.Visibility)\n\t\tcc.Visibility = &v\n\t}\n\n\tif p.shouldProject(CurrentPressureProjection) && in.Pressure != nil {\n\t\tp := Pressure{Millibar: int(in.Pressure.Millibar), Trend: in.Pressure.Trend}\n\t\tcc.Pressure = &p\n\t}\n\n\tif p.shouldProject(CurrentWindProjection) && in.WindGust != nil && in.WindGust.Wind != nil {\n\t\tvar speed int\n\t\tvar gust *int\n\t\tif p.distanceUnit == DistanceKilometres {\n\t\t\tspeed = int(in.WindGust.Wind.Speed)\n\t\t\tg := int(in.WindGust.Gust)\n\t\t\tgust = &g\n\t\t} else if p.distanceUnit == DistanceMiles {\n\t\t\tspeed = int(utilities.KilometresToMiles(in.WindGust.Wind.Speed))\n\t\t\tg := int(utilities.KilometresToMiles(in.WindGust.Gust))\n\t\t\tgust = &g\n\t\t}\n\n\t\tcc.Wind = &Wind{\n\t\t\tDirection: Direction{\n\t\t\t\tAbbreviation: in.WindGust.Wind.Direction.Abbreviation,\n\t\t\t\tDegrees:      int(in.WindGust.Wind.Direction.Degrees),\n\t\t\t},\n\t\t\tSpeed: speed,\n\t\t\tGust:  gust,\n\t\t}\n\t}\n\n\tif p.shouldProject(CurrentHumidityProjection) {\n\t\th := in.HumidityPercentage\n\t\tcc.Humidity = &h\n\t}\n\n\tif p.shouldProject(CurrentPrecipitationProjection) {\n\t\tcc.Precipitation = &CurrentPrecipitation{\n\t\t\tNextHour: int(in.NextHour.Precipitation),\n\t\t\tAmount:   utilities.RoundFloat32(in.Precipitation, p.precision),\n\t\t}\n\t}\n\n\treturn cc\n}\n\nfunc (p *CurrentConditionPresenter) shouldProject(projection string) bool {\n\treturn p.projection.Contains(\"*\") || p.projection.Contains(projection)\n}\n\nconst (\n\tDailyTemperatureMinProjection  string = \"temperature_min\"\n\tDailyTemperatureMaxProjection  string = \"temperature_max\"\n\tDailyPrecipitationProjection   string = \"precipitation\"\n\tDailySnowProjection            string = \"snow\"\n\tDailyWindMaxProjection         string = \"wind_max\"\n\tDailyHumidityAverageProjection string = \"humidity_average\"\n\tDailyConditionProjection       string = \"condition\"\n\tDailyConditionNightProjection  string = \"condition_night\"\n\tDailyUvIndexProjection         string = \"uv_index\"\n)\n\ntype DailyConditionPresenter struct {\n\tprojection      utilities.Set[string]\n\tprecision       int\n\tnumberOfDays    int\n\ttemperatureUnit string\n\tdistanceUnit    string\n\tlocale          language.Tag\n}\n\nfunc NewDailyConditionPresenter(projections []string, precision int, numberOfDays int, distanceUnit, temperatureUnit string, locale language.Tag) Presenter[[]*forecasts.DailyCondition, []*DailyCondition] {\n\treturn &DailyConditionPresenter{\n\t\tprojection:      utilities.NewSetFromSlice(projections),\n\t\tprecision:       precision,\n\t\tnumberOfDays:    numberOfDays,\n\t\ttemperatureUnit: temperatureUnit,\n\t\tdistanceUnit:    distanceUnit,\n\t\tlocale:          locale,\n\t}\n}\n", "n_tokens": 1199, "byte_len": 4525, "file_sha1": "292189e1f0feb72d1c92c9758ea73e16ff9cc0d3", "start_line": 59, "end_line": 209}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/presenters.go#3", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/presenters.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/presenters.go", "module": "internal.forecasts.adapters.handlers.http.v0.presenters", "ext": "go", "chunk_number": 3, "symbols": ["Present", "presentCondition", "shouldProject", "NewHourlyConditionPresenter", "HourlyConditionPresenter", "append", "length", "speed", "number", "days", "locale", "snow", "string", "probability", "code", "index", "projection", "contains", "daily", "temperature", "uvindex", "precipitation", "description", "max", "localise", "degrees", "celsius", "new", "set", "unix", "NewCurrentConditionPresenter", "NewDailyConditionPresenter", "CurrentConditionPresenter", "DailyConditionPresenter", "hour", "humidity", "wind", "gust", "atoi", "weather", "heat", "mostlyclear", "trend", "current", "sort", "condition", "range", "min", "night", "dew"], "ast_kind": "class_or_type", "text": "func (p *DailyConditionPresenter) Present(in []*forecasts.DailyCondition, loc *time.Location) []*DailyCondition {\n\tif p.projection.Length() == 0 {\n\t\treturn nil\n\t}\n\n\tvar ds []*DailyCondition\n\n\tfor i, d := range in {\n\t\tds = append(ds, p.presentCondition(d))\n\n\t\tif i+1 == p.numberOfDays {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn ds\n}\n\nfunc (p *DailyConditionPresenter) presentCondition(in *forecasts.DailyCondition) *DailyCondition {\n\tdc := &DailyCondition{\n\t\tTimestamp: in.Epoch.Unix(),\n\t}\n\n\tif p.shouldProject(DailyTemperatureMinProjection) {\n\t\tif p.temperatureUnit == TemperatureCelsius {\n\t\t\tt := int(in.TemperatureMin)\n\t\t\tdc.TemperatureMin = &t\n\t\t} else if p.temperatureUnit == TemperatureFahrenheit {\n\t\t\tt := int(utilities.CelsiusToFahrenheit(in.TemperatureMin))\n\t\t\tdc.TemperatureMin = &t\n\t\t}\n\t}\n\n\tif p.shouldProject(DailyTemperatureMaxProjection) {\n\t\tif p.temperatureUnit == TemperatureCelsius {\n\t\t\tt := int(in.TemperatureMax)\n\t\t\tdc.TemperatureMax = &t\n\t\t} else if p.temperatureUnit == TemperatureFahrenheit {\n\t\t\tt := int(utilities.CelsiusToFahrenheit(in.TemperatureMax))\n\t\t\tdc.TemperatureMax = &t\n\t\t}\n\t}\n\n\tif p.shouldProject(DailyPrecipitationProjection) {\n\t\tdc.Precipitation = &DailyPrecipitation{\n\t\t\tProbability: in.PrecipitationProbability,\n\t\t\tAmount:      utilities.RoundFloat32(in.Precipitation, p.precision),\n\t\t\tDay:         utilities.RoundFloat32(in.PrecipitationDay, p.precision),\n\t\t\tNight:       utilities.RoundFloat32(in.PrecipitationNight, p.precision),\n\t\t}\n\t}\n\n\tif p.shouldProject(DailySnowProjection) {\n\t\tdc.Snow = &DailySnow{\n\t\t\tAmount: utilities.RoundFloat32(in.Snow, p.precision),\n\t\t\tDay:    utilities.RoundFloat32(in.SnowDay, p.precision),\n\t\t\tNight:  utilities.RoundFloat32(in.SnowNight, p.precision),\n\t\t}\n\t}\n\n\tif p.shouldProject(DailyWindMaxProjection) && in.Wind != nil {\n\t\tvar speed int\n\t\tif p.distanceUnit == DistanceKilometres {\n\t\t\tspeed = int(in.Wind.Speed)\n\t\t} else if p.distanceUnit == DistanceMiles {\n\t\t\tspeed = int(utilities.KilometresToMiles(in.Wind.Speed))\n\t\t}\n\n\t\tdc.WindMax = &Wind{\n\t\t\tDirection: Direction{\n\t\t\t\tAbbreviation: in.Wind.Direction.Abbreviation,\n\t\t\t\tDegrees:      int(in.Wind.Direction.Degrees),\n\t\t\t},\n\t\t\tSpeed: speed,\n\t\t}\n\t}\n\n\tif p.shouldProject(DailyHumidityAverageProjection) {\n\t\th := in.AverageHumidityPercentage\n\t\tdc.HumidityAverage = &h\n\t}\n\n\tif p.shouldProject(DailyConditionProjection) && in.WeatherCondition != nil {\n\t\tdc.Condition = &WeatherCondition{\n\t\t\tCode:        in.WeatherCondition.Code,\n\t\t\tDescription: i18n.Localise(p.locale, in.WeatherCondition.Code),\n\t\t}\n\t}\n\n\tif p.shouldProject(DailyConditionNightProjection) && in.WeatherConditionNight != nil {\n\t\tdc.ConditionNight = &WeatherCondition{\n\t\t\tCode:        in.WeatherConditionNight.Code,\n\t\t\tDescription: i18n.Localise(p.locale, in.WeatherConditionNight.Code),\n\t\t}\n\t}\n\n\tif p.shouldProject(DailyUvIndexProjection) {\n\t\tu := int(in.UvIndex)\n\t\tdc.UvIndex = &u\n\t}\n\n\treturn dc\n}\n\nfunc (p *DailyConditionPresenter) shouldProject(projection string) bool {\n\treturn p.projection.Contains(\"*\") || p.projection.Contains(projection)\n}\n\nconst (\n\tHourlyTemperatureProjection          string = \"temperature\"\n\tHourlyTemperatureFeelsLikeProjection string = \"temperature_feels_like\"\n\tHourlyPrecipitationProjection        string = \"precipitation\"\n\tHourlySnowProjection                 string = \"snow\"\n\tHourlyWindProjection                 string = \"wind\"\n\tHourlyPressureProjection             string = \"pressure\"\n\tHourlyConditionProjection            string = \"condition\"\n\tHourlyHumidityProjection             string = \"humidity\"\n\tHourlyUvIndexProjection              string = \"uv_index\"\n)\n\ntype HourlyConditionPresenter struct {\n\tprojection      utilities.Set[string]\n\tprecision       int\n\tnumberOfDays    int\n\thours           []string\n\ttemperatureUnit string\n\tdistanceUnit    string\n\tlocale          language.Tag\n}\n\nfunc NewHourlyConditionPresenter(projections []string, precision int, numberOfDays int, hours []string, distanceUnit, temperatureUnit string, locale language.Tag) Presenter[[]*forecasts.HourlyCondition, []*HourlyCondition] {\n\treturn &HourlyConditionPresenter{\n\t\tprojection:      utilities.NewSetFromSlice(projections),\n\t\tprecision:       precision,\n\t\tnumberOfDays:    numberOfDays,\n\t\thours:           hours,\n\t\ttemperatureUnit: temperatureUnit,\n\t\tdistanceUnit:    distanceUnit,\n\t\tlocale:          locale,\n\t}\n}\n", "n_tokens": 1098, "byte_len": 4303, "file_sha1": "292189e1f0feb72d1c92c9758ea73e16ff9cc0d3", "start_line": 210, "end_line": 351}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/presenters.go#4", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/presenters.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/presenters.go", "module": "internal.forecasts.adapters.handlers.http.v0.presenters", "ext": "go", "chunk_number": 4, "symbols": ["Present", "presentCondition", "shouldProject", "append", "length", "hour", "speed", "number", "days", "temperature", "atoi", "locale", "humidity", "string", "probability", "code", "projection", "contains", "index", "uvindex", "trend", "description", "localise", "sort", "degrees", "celsius", "unix", "range", "feels", "percentage", "NewCurrentConditionPresenter", "NewDailyConditionPresenter", "NewHourlyConditionPresenter", "CurrentConditionPresenter", "DailyConditionPresenter", "HourlyConditionPresenter", "wind", "gust", "snow", "weather", "daily", "heat", "precipitation", "mostlyclear", "max", "current", "new", "set", "condition", "min"], "ast_kind": "function_or_method", "text": "func (p *HourlyConditionPresenter) Present(in []*forecasts.HourlyCondition, loc *time.Location) []*HourlyCondition {\n\tif p.projection.Length() == 0 {\n\t\treturn nil\n\t}\n\n\tvar hours []int\n\tif len(p.hours) == 1 && p.hours[0] == \"*\" {\n\t\thours = []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23}\n\t} else {\n\t\tfor _, hour := range p.hours {\n\t\t\th, _ := strconv.Atoi(hour)\n\t\t\thours = append(hours, h)\n\t\t}\n\t\tsort.Ints(hours)\n\t}\n\n\tvar observations []int64\n\tyear, month, day := time.Now().UTC().Date()\n\n\tfor d := 0; d < p.numberOfDays; d++ {\n\t\tfor _, h := range hours {\n\t\t\tt := time.\n\t\t\t\tDate(year, month, day, 0, 0, 0, 0, loc).\n\t\t\t\tAdd(time.Duration((d*24)+h) * time.Hour)\n\t\t\tobservations = append(observations, t.Unix())\n\t\t}\n\t}\n\n\tvar hs []*HourlyCondition\n\thourlyConditions := map[int64]*forecasts.HourlyCondition{}\n\tfor _, h := range in {\n\t\thourlyConditions[h.Epoch.In(loc).Unix()] = h\n\t}\n\n\tfor _, ts := range observations {\n\t\tif h, found := hourlyConditions[ts]; found {\n\t\t\ths = append(hs, p.presentCondition(h))\n\t\t}\n\t}\n\n\treturn hs\n}\n\nfunc (p *HourlyConditionPresenter) presentCondition(in *forecasts.HourlyCondition) *HourlyCondition {\n\thc := &HourlyCondition{\n\t\tTimestamp: in.Epoch.Unix(),\n\t}\n\n\tif p.shouldProject(HourlyTemperatureProjection) {\n\t\tif p.temperatureUnit == TemperatureCelsius {\n\t\t\tt := int(in.Temperature)\n\t\t\thc.Temperature = &t\n\t\t} else if p.temperatureUnit == TemperatureFahrenheit {\n\t\t\tt := int(utilities.CelsiusToFahrenheit(in.Temperature))\n\t\t\thc.Temperature = &t\n\t\t}\n\t}\n\n\tif p.shouldProject(HourlyTemperatureFeelsLikeProjection) {\n\t\tif p.temperatureUnit == TemperatureCelsius {\n\t\t\tt := int(in.TemperatureFeelsLike)\n\t\t\thc.TemperatureFeelsLike = &t\n\t\t} else if p.temperatureUnit == TemperatureFahrenheit {\n\t\t\tt := int(utilities.CelsiusToFahrenheit(in.TemperatureFeelsLike))\n\t\t\thc.TemperatureFeelsLike = &t\n\t\t}\n\t}\n\n\tif p.shouldProject(HourlyPrecipitationProjection) {\n\t\thc.Precipitation = &HourlyPrecipitation{\n\t\t\tAmount:      in.Precipitation,\n\t\t\tProbability: in.PrecipitationProbability,\n\t\t}\n\t}\n\n\tif p.shouldProject(HourlySnowProjection) {\n\t\ts := in.Snow\n\t\thc.Snow = &s\n\t}\n\n\tif p.shouldProject(HourlyWindProjection) && in.Wind != nil {\n\t\tvar speed int\n\t\tif p.distanceUnit == DistanceKilometres {\n\t\t\tspeed = int(in.Wind.Speed)\n\t\t} else if p.distanceUnit == DistanceMiles {\n\t\t\tspeed = int(utilities.KilometresToMiles(in.Wind.Speed))\n\t\t}\n\n\t\thc.Wind = &Wind{\n\t\t\tDirection: Direction{\n\t\t\t\tAbbreviation: in.Wind.Direction.Abbreviation,\n\t\t\t\tDegrees:      int(in.Wind.Direction.Degrees),\n\t\t\t},\n\t\t\tSpeed: speed,\n\t\t}\n\t}\n\n\tif p.shouldProject(HourlyPressureProjection) && in.Pressure != nil {\n\t\thc.Pressure = &Pressure{\n\t\t\tMillibar: int(in.Pressure.Millibar),\n\t\t\tTrend:    in.Pressure.Trend,\n\t\t}\n\t}\n\n\tif p.shouldProject(HourlyConditionProjection) && in.WeatherCondition != nil {\n\t\thc.Condition = &WeatherCondition{\n\t\t\tCode:        in.WeatherCondition.Code,\n\t\t\tDescription: i18n.Localise(p.locale, in.WeatherCondition.Code),\n\t\t}\n\t}\n\n\tif p.shouldProject(HourlyHumidityProjection) {\n\t\th := in.HumidityPercentage\n\t\thc.Humidity = &h\n\t}\n\n\tif p.shouldProject(HourlyUvIndexProjection) {\n\t\tu := int(in.UvIndex)\n\t\thc.UvIndex = &u\n\t}\n\n\treturn hc\n}\n\nfunc (p *HourlyConditionPresenter) shouldProject(projection string) bool {\n\treturn p.projection.Contains(\"*\") || p.projection.Contains(projection)\n}\n", "n_tokens": 1032, "byte_len": 3327, "file_sha1": "292189e1f0feb72d1c92c9758ea73e16ff9cc0d3", "start_line": 352, "end_line": 479}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/nearest.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/nearest.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/nearest.go", "module": "internal.forecasts.adapters.handlers.http.v0.nearest", "ext": "go", "chunk_number": 1, "symbols": ["nearestLocationForecastUriRequest", "nearestLocationForecastRequest", "current", "condition", "night", "httpresponses", "temperature", "struct", "type", "unit", "snow", "feels", "nearest", "location", "unique", "humidity", "daily", "fields", "string", "hourly", "hours", "average", "package", "forecasts", "index", "min", "time", "timestamp", "http", "distance", "went", "timezone", "status", "statusok", "locale", "presenter", "warn", "internal", "error", "oneof", "weather", "provided", "heat", "request", "load", "dive", "message", "binding", "max", "wind"], "ast_kind": "class_or_type", "text": "package v0\n\nimport (\n\t\"errors\"\n\t\"github.com/gin-gonic/gin\"\n\t\"go.impalastudios.com/log\"\n\t\"go.impalastudios.com/weather/forecasts/internal/forecasts\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/httpresponses\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/i18n\"\n\t\"go.uber.org/zap\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype nearestLocationForecastUriRequest struct {\n\tCoordinate Coordinate `uri:\"coordinate\" binding:\"required,coord\"`\n}\n\ntype nearestLocationForecastRequest struct {\n\tDailyFields     []string `form:\"daily[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* temperature_min temperature_max precipitation snow wind_max humidity_average condition condition_night uv_index\"`\n\tDailyDays       *int     `form:\"daily[days],default=10\" binding:\"omitempty,min=1,max=10\"`\n\tHourlyFields    []string `form:\"hourly[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* timestamp temperature temperature_feels_like precipitation snow wind pressure condition humidity uv_index\"`\n\tHourlyDays      *int     `form:\"hourly[days],default=10\" binding:\"omitempty,min=1,max=10\"`\n\tHourlyHours     []string `form:\"hourly[hours][]\" binding:\"omitempty,unique,star,dive,oneof=* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\"`\n\tCurrentFields   []string `form:\"current[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* condition uv_index temperature temperature_feels_like heat_index dew_point visibility pressure wind humidity precipitation\"`\n\tDistanceUnit    string   `form:\"distanceUnit,default=km\" binding:\"omitempty,oneof=km mi\"`\n\tTemperatureUnit string   `form:\"temperatureUnit,default=C\" binding:\"omitempty,oneof=C F\"`\n}\n", "n_tokens": 437, "byte_len": 1621, "file_sha1": "cabbf38f8ef2c60703e056f62d283fc3ee99647a", "start_line": 1, "end_line": 29}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/nearest.go#2", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/nearest.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/nearest.go", "module": "internal.forecasts.adapters.handlers.http.v0.nearest", "ext": "go", "chunk_number": 2, "symbols": ["nearest", "went", "timezone", "status", "statusok", "httpresponses", "locale", "hourly", "presenter", "string", "warn", "current", "fields", "internal", "error", "provided", "request", "load", "distance", "unit", "message", "daily", "conditions", "response", "not", "found", "location", "validation", "cannot", "invalid", "nearestLocationForecastUriRequest", "nearestLocationForecastRequest", "snow", "unique", "index", "oneof", "weather", "heat", "dive", "binding", "temperature", "max", "wind", "type", "humidity", "average", "package", "timestamp", "present", "http"], "ast_kind": "function_or_method", "text": "func (h *Handler) nearest(c *gin.Context) {\n\tlocale := i18n.GetLocaleFromHeader(c.GetHeader(\"Accept-Language\"))\n\n\tlog.Debug(c, \"Request detected locale.\", zap.String(\"locale\", locale.String()))\n\n\turi := nearestLocationForecastUriRequest{}\n\tif err := c.ShouldBindUri(&uri); err != nil {\n\t\tlog.Warn(c, \"Validation errors on URI.\", zap.Any(\"uri\", uri), zap.Error(err))\n\t\tmessage := i18n.GetFirstValidationErrorMessage(err)\n\n\t\tc.PureJSON(\n\t\t\thttp.StatusBadRequest,\n\t\t\thttpresponses.NewErrorResponse[*Response](\"invalid_parameters\", message),\n\t\t)\n\t\treturn\n\t}\n\n\treq := nearestLocationForecastRequest{\n\t\tHourlyHours: []string{\"*\"},\n\t}\n\n\tif err := c.ShouldBind(&req); err != nil {\n\t\tlog.Warn(c, \"Validation errors on request.\", zap.Any(\"request\", req))\n\n\t\tmessage := i18n.GetFirstValidationErrorMessage(err)\n\n\t\tc.PureJSON(\n\t\t\thttp.StatusBadRequest,\n\t\t\thttpresponses.NewErrorResponse[*Response](\"invalid_parameters\", message),\n\t\t)\n\t\treturn\n\t}\n\n\tif len(req.CurrentFields) == 0 && len(req.DailyFields) == 0 && len(req.HourlyFields) == 0 {\n\t\tlog.Warn(c, \"Invalid request.\", zap.Any(\"request\", req))\n\t\tc.JSON(http.StatusBadRequest, httpresponses.NewErrorResponse[*Response](\"invalid_parameters\", \"At least one of current[fields], daily[fields], or hourly[fields] must be present.\"))\n\t\treturn\n\t}\n\n\tcoord, err := uri.Coordinate.Parse()\n\tif err != nil {\n\t\tlog.Error(c, \"Cannot parse coordinate.\", zap.Any(\"uri\", uri))\n\n\t\tc.PureJSON(\n\t\t\thttp.StatusBadRequest,\n\t\t\thttpresponses.NewErrorResponse[*Location](\"invalid_parameters\", \"Cannot parse the provided coordinate.\"),\n\t\t)\n\t\treturn\n\t}\n\n\tforecast, location, err := h.forecasts.GetForecastForClosestLocation(c.Request.Context(), coord, locale)\n\tif err != nil {\n\t\tlog.Error(c, \"Something went wrong while retrieving the forecast for location.\", zap.Any(\"request\", req), zap.Error(err))\n\n\t\tif errors.Is(err, forecasts.ErrLocationNotFound) {\n\t\t\tc.JSON(\n\t\t\t\thttp.StatusNotFound,\n\t\t\t\thttpresponses.NewErrorResponse[*Response](\"not_found\", \"Location cannot be found.\"),\n\t\t\t)\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(\n\t\t\thttp.StatusInternalServerError,\n\t\t\thttpresponses.NewErrorResponse[*Response](\"internal_error\", \"Something went wrong. Retry later.\"),\n\t\t)\n\t\treturn\n\t}\n\n\tcurrentPresenter := NewCurrentConditionPresenter(req.CurrentFields, 2, req.DistanceUnit, req.TemperatureUnit, locale)\n\tdailyPresenter := NewDailyConditionPresenter(req.DailyFields, 2, *req.DailyDays, req.DistanceUnit, req.TemperatureUnit, locale)\n\thourlyPresenter := NewHourlyConditionPresenter(req.HourlyFields, 2, *req.HourlyDays, req.HourlyHours, req.DistanceUnit, req.TemperatureUnit, locale)\n\n\tloc, err := time.LoadLocation(location.Timezone)\n\tif err != nil {\n\t\tlog.Error(c, \"Cannot load timezone.\", zap.Any(\"req\", req), zap.Any(\"uri\", uri), zap.Error(err))\n\n\t\tc.JSON(\n\t\t\thttp.StatusInternalServerError,\n\t\t\thttpresponses.NewErrorResponse[*Response](\"internal_error\", \"Something went wrong. Retry later.\"),\n\t\t)\n\t\treturn\n\t}\n\n\tres := &Response{\n\t\tLocation: h.toLocationResource(location),\n\t\tForecast: &Forecast{\n\t\t\tCurrentCondition: currentPresenter.Present(forecast.CurrentCondition, loc),\n\t\t\tDailyConditions:  dailyPresenter.Present(forecast.DailyConditions, loc),\n\t\t\tHourlyConditions: hourlyPresenter.Present(forecast.HourlyConditions, loc),\n\t\t},\n\t}\n\tc.JSON(http.StatusOK, httpresponses.NewResponse(res, \"ok\", \"Forecasts retrieved.\"))\n}\n", "n_tokens": 806, "byte_len": 3322, "file_sha1": "cabbf38f8ef2c60703e056f62d283fc3ee99647a", "start_line": 30, "end_line": 124}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/single_test.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/single_test.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/single_test.go", "module": "internal.forecasts.adapters.handlers.http.v0.single_test", "ext": "go", "chunk_number": 1, "symbols": ["append", "current", "assert", "not", "nil", "temperature", "wind", "gust", "locationid", "daily", "invalid", "value", "string", "clear", "code", "projection", "temp", "unit", "create", "test", "forecast", "response", "that", "meta", "trend", "description", "raw", "query", "hourly", "direction", "forecasts", "data", "kaboom", "degrees", "metadata", "responses", "bytes", "conditions", "request", "encode", "package", "params", "new", "nop", "http", "recorder", "actual", "hours", "mock", "weather"], "ast_kind": "unknown", "text": "package v0_test\n\n//func TestThatItShouldReturnAValidWeatherForecastResponse(t *testing.T) {\n//\tw := httptest.NewRecorder()\n//\tctx, _ := gin.CreateTestContext(w)\n//\tctx.Request = &http.Request{URL: &url.URL{}, Header: map[string][]string{}}\n//\tctx.Params = append(ctx.Params, gin.Param{Key: \"id\", Value: \"24\"})\n//\tctx.Request.Header.Set(\"AcceptLanguage\", \"en;q=1.0,en-GB;q=0.8\")\n//\n//\tu := url.Values{}\n//\tu.Add(\"current[fields][]\", \"temperature\")\n//\tu.Add(\"current[fields][]\", \"condition\")\n//\tu.Add(\"daily[fields][]\", \"condition\")\n//\tu.Add(\"daily[days]\", \"5\")\n//\tu.Add(\"hourly[fields][]\", \"temperature\")\n//\tu.Add(\"hourly[fields][]\", \"condition\")\n//\tu.Add(\"hourly[days]\", \"3\")\n//\tu.Add(\"hourly[hours][]\", \"0\")\n//\tu.Add(\"hourly[hours][]\", \"12\")\n//\tu.Add(\"hourly[hours][]\", \"13\")\n//\tctx.Request.URL.RawQuery = u.Encode()\n//\n//\tnow := time.Date(2023, 4, 26, 11, 36, 0, 0, time.UTC)\n//\n//\twf := new(MockForecastService)\n//\twf.On(\"GetForecastsForLocation\", 24).\n//\t\tReturn(&models.ForecastResponse{\n//\t\t\tCurrentCondition: &models.CurrentCondition{\n//\t\t\t\tEpoch: &now,\n//\t\t\t\tWeatherCondition: &models.WeatherCondition{\n//\t\t\t\t\tCode: \"clear\",\n//\t\t\t\t},\n//\t\t\t\tPressure: &models.Pressure{\n//\t\t\t\t\tMillibar: 1.0,\n//\t\t\t\t\tTrend:    1,\n//\t\t\t\t},\n//\t\t\t\tWindGust: &models.WindGust{\n//\t\t\t\t\tWind: &models.Wind{\n//\t\t\t\t\t\tDirection: &models.WindDirection{\n//\t\t\t\t\t\t\tAbbreviation: \"N\",\n//\t\t\t\t\t\t\tDegrees:      0,\n//\t\t\t\t\t\t},\n//\t\t\t\t\t},\n//\t\t\t\t},\n//\t\t\t},\n//\t\t\tDailyConditions:  []*models.DailyCondition{},\n//\t\t\tHourlyConditions: []*models.HourlyCondition{},\n//\t\t}, nil)\n//\n//\tv0.Single(wf, zap.NewNop())(ctx)\n//\tassert.Equal(t, 200, w.Code)\n//}\n//\n//func TestThatItShouldReturnInvalidLocationId(t *testing.T) {\n//\tw := httptest.NewRecorder()\n//\tctx, _ := gin.CreateTestContext(w)\n//\tctx.Request = &http.Request{URL: &url.URL{}, Header: map[string][]string{}}\n//\tctx.Params = append(ctx.Params, gin.Param{Key: \"id\", Value: \"locationid\"})\n//\tctx.Request.Header.Set(\"AcceptLanguage\", \"en;q=1.0,enGB;q=0.8\")\n//\n//\tu := url.Values{}\n//\tu.Add(\"current[fields][]\", \"temperature\")\n//\tu.Add(\"current[fields][]\", \"condition\")\n//\tu.Add(\"daily[fields][]\", \"condition\")\n//\tu.Add(\"daily[days]\", \"5\")\n//\tu.Add(\"hourly[fields][]\", \"temperature\")\n//\tu.Add(\"hourly[fields][]\", \"condition\")\n//\tu.Add(\"hourly[days]\", \"3\")\n//\tu.Add(\"hourly[hours][]\", \"0\")\n//\tu.Add(\"hourly[hours][]\", \"12\")\n//\tu.Add(\"hourly[hours][]\", \"13\")\n//\tctx.Request.URL.RawQuery = u.Encode()\n//\n//\twf := new(MockForecastService)\n//\twf.On(\"GetForecastsForLocation\", 24).\n//\t\tReturn(&models.ForecastResponse{\n//\t\t\tCurrentCondition: &models.CurrentCondition{\n//\t\t\t\tWeatherCondition: &models.WeatherCondition{\n//\t\t\t\t\tCode: \"clear\",\n//\t\t\t\t},\n//\t\t\t\tPressure: &models.Pressure{\n//\t\t\t\t\tMillibar: 1.0,\n//\t\t\t\t\tTrend:    1,\n//\t\t\t\t},\n//\t\t\t\tWindGust: &models.WindGust{\n//\t\t\t\t\tWind: &models.Wind{\n//\t\t\t\t\t\tDirection: &models.WindDirection{\n//\t\t\t\t\t\t\tAbbreviation: \"N\",\n//\t\t\t\t\t\t\tDegrees:      0,\n//\t\t\t\t\t\t},\n//\t\t\t\t\t},\n//\t\t\t\t},\n//\t\t\t},\n//\t\t\tDailyConditions:  []*models.DailyCondition{},\n//\t\t\tHourlyConditions: []*models.HourlyCondition{},\n//\t\t}, nil)\n//\n//\tv0.Single(wf, zap.NewNop())(ctx)\n//\tassert.Equal(t, 400, w.Code)\n//\n//\tvar actual *responses.Response[*v0.ForecastResponse]\n//\t_ = json.Unmarshal(w.Body.Bytes(), &actual)\n//\n//\tfmt.Println(string(w.Body.Bytes()))\n//\n//\tassert.Equal(t, \"invalid_parameters\", actual.Metadata.Code)\n//\tassert.Equal(t, \"The location ID is invalid.\", actual.Metadata.Message)\n//}\n\n//\n//func TestThatItShouldReturnDailyInvalidProjection(t *testing.T) {\n//\tw := httptest.NewRecorder()\n//\tctx, _ := gin.CreateTestContext(w)\n//\tctx.Request = &http.Request{URL: &url.URL{}, Header: map[string][]string{}}\n//\tctx.Params = append(ctx.Params, gin.Param{Key: \"id\", Value: \"24\"})\n//\tctx.Request.Header.Set(\"AcceptLanguage\", \"en;q=1.0,enGB;q=0.8\")\n//\n//\tu := url.Values{}\n//\tu.Add(\"current[fields]\", \"temperature,condition\")\n//\tu.Add(\"daily[fields]\", \"kaboom\")\n//\tu.Add(\"daily[days]\", \"5\")\n//\tu.Add(\"hourly[fields]\", \"temperature,condition\")\n//\tu.Add(\"hourly[days]\", \"3\")\n//\tu.Add(\"hourly[hours]\", \"0,12,13\")\n//\tctx.Request.URL.RawQuery = u.Encode()\n//\n//\twf := new(MockWeatherForecaService)\n//\twf.On(\"GetForecaResponse\", 24).\n//\t\tReturn(&pb.ForecastResponse{\n//\t\t\tCurrentCondition: &pb.ForecastResponse_CurrentCondition{\n//\t\t\t\tWeatherCondition: &pb.ForecastResponse_WeatherCondition{\n//\t\t\t\t\tCode:        \"clear\",\n//\t\t\t\t\tDescription: \"clear\",\n//\t\t\t\t},\n//\t\t\t\tPressure: &pb.ForecastResponse_Pressure{\n//\t\t\t\t\tMillibar: 1.0,\n//\t\t\t\t\tTrend:    1,\n//\t\t\t\t},\n//\t\t\t\tWindGust: &pb.ForecastResponse_CurrentCondition_WindGust{\n//\t\t\t\t\tWind: &pb.ForecastResponse_Wind{\n//\t\t\t\t\t\tDirection: &pb.ForecastResponse_WindDirection{\n//\t\t\t\t\t\t\tAbbreviation: \"test\",\n//\t\t\t\t\t\t},\n//\t\t\t\t\t},\n//\t\t\t\t},\n//\t\t\t},\n//\t\t\tDailyForecasts:  []*pb.ForecastResponse_DailyForecast{},\n//\t\t\tHourlyForecasts: []*pb.ForecastResponse_HourlyForecast{},\n//\t\t}, nil)\n//\n//\tv0.Weather(wf, zap.NewNop())(ctx)\n//\tassert.Equal(t, 400, w.Code)\n//\tvar actual *model.ForecaResponse\n//\t_ = json.Unmarshal(w.Body.Bytes(), &actual)\n//\n//\tassert.Equal(t, \"daily_invalid_projection.\", actual.Meta.Code)\n//\tassert.Equal(t, \"The daily projection contains invalid value. Invalid values: kaboom\", actual.Meta.Message)\n//}\n//\n//func TestThatItShouldReturnHourlyInvalidProjection(t *testing.T) {\n//\tw := httptest.NewRecorder()\n//\tctx, _ := gin.CreateTestContext(w)\n//\tctx.Request = &http.Request{URL: &url.URL{}, Header: map[string][]string{}}\n//\tctx.Params = append(ctx.Params, gin.Param{Key: \"id\", Value: \"24\"})\n//\tctx.Request.Header.Set(\"AcceptLanguage\", \"en;q=1.0,enGB;q=0.8\")\n//\n//\tu := url.Values{}\n//\tu.Add(\"current[fields]\", \"temperature,condition\")\n//\tu.Add(\"daily[fields]\", \"condition\")\n//\tu.Add(\"daily[days]\", \"5\")\n//\tu.Add(\"hourly[fields]\", \"kaboom\")\n//\tu.Add(\"hourly[days]\", \"3\")\n//\tu.Add(\"hourly[hours]\", \"0,12,13\")\n//\tctx.Request.URL.RawQuery = u.Encode()\n//\n//\twf := new(MockWeatherForecaService)\n//\twf.On(\"GetForecaResponse\", 24).\n//\t\tReturn(&pb.ForecastResponse{\n//\t\t\tCurrentCondition: &pb.ForecastResponse_CurrentCondition{\n//\t\t\t\tWeatherCondition: &pb.ForecastResponse_WeatherCondition{\n//\t\t\t\t\tCode:        \"clear\",\n//\t\t\t\t\tDescription: \"clear\",\n//\t\t\t\t},\n//\t\t\t\tPressure: &pb.ForecastResponse_Pressure{\n//\t\t\t\t\tMillibar: 1.0,\n//\t\t\t\t\tTrend:    1,\n//\t\t\t\t},\n//\t\t\t\tWindGust: &pb.ForecastResponse_CurrentCondition_WindGust{\n//\t\t\t\t\tWind: &pb.ForecastResponse_Wind{\n//\t\t\t\t\t\tDirection: &pb.ForecastResponse_WindDirection{\n//\t\t\t\t\t\t\tAbbreviation: \"test\",\n//\t\t\t\t\t\t},\n//\t\t\t\t\t},\n//\t\t\t\t},\n//\t\t\t},\n//\t\t\tDailyForecasts:  []*pb.ForecastResponse_DailyForecast{},\n//\t\t\tHourlyForecasts: []*pb.ForecastResponse_HourlyForecast{},\n//\t\t}, nil)\n//\n//\tv0.Weather(wf, zap.NewNop())(ctx)\n//\tassert.Equal(t, 400, w.Code)\n//\tvar actual *model.ForecaResponse\n//\t_ = json.Unmarshal(w.Body.Bytes(), &actual)\n//\n//\tassert.Equal(t, \"hourly_invalid_projection.\", actual.Meta.Code)\n//\tassert.Equal(t, \"The hourly projection contains invalid value. Invalid values: kaboom\", actual.Meta.Message)\n//}\n//\n//func TestThatItShouldReturnCurrentInvalidProjection(t *testing.T) {\n//\tw := httptest.NewRecorder()\n//\tctx, _ := gin.CreateTestContext(w)\n//\tctx.Request = &http.Request{URL: &url.URL{}, Header: map[string][]string{}}\n//\tctx.Params = append(ctx.Params, gin.Param{Key: \"id\", Value: \"24\"})\n//\tctx.Request.Header.Set(\"AcceptLanguage\", \"en;q=1.0,enGB;q=0.8\")\n//\n//\tu := url.Values{}\n//\tu.Add(\"current[fields]\", \"kaboom\")\n//\tu.Add(\"daily[fields]\", \"temperatureMin,condition\")\n//\tu.Add(\"daily[days]\", \"5\")\n//\tu.Add(\"hourly[fields]\", \"temperature,condition\")\n//\tu.Add(\"hourly[days]\", \"3\")\n//\tu.Add(\"hourly[hours]\", \"0,12,13\")\n//\tctx.Request.URL.RawQuery = u.Encode()\n//\n//\twf := new(MockWeatherForecaService)\n//\twf.On(\"GetForecaResponse\", 24).\n//\t\tReturn(&pb.ForecastResponse{\n//\t\t\tCurrentCondition: &pb.ForecastResponse_CurrentCondition{\n//\t\t\t\tWeatherCondition: &pb.ForecastResponse_WeatherCondition{\n//\t\t\t\t\tCode:        \"clear\",\n//\t\t\t\t\tDescription: \"clear\",\n//\t\t\t\t},\n//\t\t\t\tPressure: &pb.ForecastResponse_Pressure{\n//\t\t\t\t\tMillibar: 1.0,\n//\t\t\t\t\tTrend:    1,\n//\t\t\t\t},\n//\t\t\t\tWindGust: &pb.ForecastResponse_CurrentCondition_WindGust{\n//\t\t\t\t\tWind: &pb.ForecastResponse_Wind{\n//\t\t\t\t\t\tDirection: &pb.ForecastResponse_WindDirection{\n//\t\t\t\t\t\t\tAbbreviation: \"test\",\n//\t\t\t\t\t\t},\n//\t\t\t\t\t},\n//\t\t\t\t},\n//\t\t\t},\n//\t\t\tDailyForecasts:  []*pb.ForecastResponse_DailyForecast{},\n//\t\t\tHourlyForecasts: []*pb.ForecastResponse_HourlyForecast{},\n//\t\t}, nil)\n//\n//\tv0.Weather(wf, zap.NewNop())(ctx)\n//\tassert.Equal(t, 400, w.Code)\n//\tvar actual *model.ForecaResponse\n//\t_ = json.Unmarshal(w.Body.Bytes(), &actual)\n//\n//\tassert.Equal(t, \"Current_invalid_projection.\", actual.Meta.Code)\n//\tassert.Equal(t, \"The current projection contains invalid value. Invalid values: kaboom\", actual.Meta.Message)\n//}\n//\n//func TestThatItShouldReturnExpectedForcastResponseForCurrent(t *testing.T) {\n//\tw := httptest.NewRecorder()\n//\tctx, _ := gin.CreateTestContext(w)\n//\tctx.Request = &http.Request{URL: &url.URL{}, Header: map[string][]string{}}\n//\tctx.Params = append(ctx.Params, gin.Param{Key: \"id\", Value: \"24\"})\n//\tctx.Request.Header.Set(\"AcceptLanguage\", \"en;q=1.0,enGB;q=0.8\")\n//\n//\tu := url.Values{}\n//\tu.Add(\"current[fields]\", \"temperature,condition\")\n//\tu.Add(\"hourly[hours]\", \"0\")\n//\tctx.Request.URL.RawQuery = u.Encode()\n//\n//\twf := new(MockWeatherForecaService)\n//\twf.On(\"GetForecaResponse\", 24).\n//\t\tReturn(&pb.ForecastResponse{\n//\t\t\tCurrentCondition: &pb.ForecastResponse_CurrentCondition{\n//\t\t\t\tTemperature: 27,\n//\t\t\t\tWeatherCondition: &pb.ForecastResponse_WeatherCondition{\n//\t\t\t\t\tCode:        \"clear\",\n//\t\t\t\t\tDescription: \"clear\",\n//\t\t\t\t},\n//\t\t\t\tPressure: &pb.ForecastResponse_Pressure{\n//\t\t\t\t\tMillibar: 1.0,\n//\t\t\t\t\tTrend:    1,\n//\t\t\t\t},\n//\t\t\t\tWindGust: &pb.ForecastResponse_CurrentCondition_WindGust{\n//\t\t\t\t\tWind: &pb.ForecastResponse_Wind{\n//\t\t\t\t\t\tDirection: &pb.ForecastResponse_WindDirection{\n//\t\t\t\t\t\t\tAbbreviation: \"test\",\n//\t\t\t\t\t\t},\n//\t\t\t\t\t},\n//\t\t\t\t},\n//\t\t\t},\n//\t\t\tDailyForecasts:  []*pb.ForecastResponse_DailyForecast{},\n//\t\t\tHourlyForecasts: []*pb.ForecastResponse_HourlyForecast{},\n//\t\t}, nil)\n//\n//\tv0.Weather(wf, zap.NewNop())(ctx)\n//\tassert.Equal(t, 200, w.Code)\n//\n//\tvar actual *model.ForecaResponse\n//\t_ = json.Unmarshal(w.Body.Bytes(), &actual)\n//\n//\tassert.Equal(t, \"ok\", actual.Meta.Code)\n//\tassert.Equal(t, \"Forecast retrieved.\", actual.Meta.Message)\n//\tassert.NotNil(t, actual.Data.Current)\n//\tassert.Nil(t, actual.Data.Daily)\n//\tassert.Nil(t, actual.Data.Hourly)\n//\tassert.Equal(t, 24, actual.Data.ID)\n//\n//\tc := actual.Data.Current\n//\tassert.Equal(t, 27.0, c[\"temperature\"])\n//\tassert.Equal(t, \"clear\", c[\"condition\"].(map[string]interface{})[\"code\"])\n//}\n//\n//func TestThatItShouldReturnResponseWithConvertedTempValues(t *testing.T) {\n//\tw := httptest.NewRecorder()\n//\tctx, _ := gin.CreateTestContext(w)\n//\tctx.Request = &http.Request{URL: &url.URL{}, Header: map[string][]string{}}\n//\tctx.Params = append(ctx.Params, gin.Param{Key: \"id\", Value: \"24\"})\n//\tctx.Request.Header.Set(\"AcceptLanguage\", \"en;q=1.0,enGB;q=0.8\")\n//\n//\tu := url.Values{}\n//\tu.Add(\"tempUnit\", \"F\")\n//\tu.Add(\"current[fields]\", \"temperature, wind\")\n//\tu.Add(\"hourly[hours]\", \"0\")\n//\n//\tctx.Request.URL.RawQuery = u.Encode()\n//\n//\twf := new(MockWeatherForecaService)\n//\twf.On(\"GetForecaResponse\", 24).\n//\t\tReturn(&pb.ForecastResponse{\n//\t\t\tCurrentCondition: &pb.ForecastResponse_CurrentCondition{\n//\t\t\t\tTemperature: 80.6,\n//\t\t\t\tWeatherCondition: &pb.ForecastResponse_WeatherCondition{\n//\t\t\t\t\tCode:        \"clear\",\n//\t\t\t\t\tDescription: \"clear\",\n//\t\t\t\t},\n//\t\t\t\tPressure: &pb.ForecastResponse_Pressure{\n//\t\t\t\t\tMillibar: 1.0,\n//\t\t\t\t\tTrend:    1,\n//\t\t\t\t},\n//\t\t\t\tWindGust: &pb.ForecastResponse_CurrentCondition_WindGust{\n//\t\t\t\t\tWind: &pb.ForecastResponse_Wind{\n//\t\t\t\t\t\tDirection: &pb.ForecastResponse_WindDirection{\n//\t\t\t\t\t\t\tAbbreviation: \"test\",\n//\t\t\t\t\t\t},\n//\t\t\t\t\t},\n//\t\t\t\t},\n//\t\t\t},\n//\t\t\tDailyForecasts:  []*pb.ForecastResponse_DailyForecast{},\n//\t\t\tHourlyForecasts: []*pb.ForecastResponse_HourlyForecast{},\n//\t\t}, nil)\n//\n//\tv0.Weather(wf, zap.NewNop())(ctx)\n//\tassert.Equal(t, 200, w.Code)\n//\n//\tvar actual *model.ForecaResponse\n//\t_ = json.Unmarshal(w.Body.Bytes(), &actual)\n//\n//\tassert.Equal(t, \"ok\", actual.Meta.Code)\n//\tassert.Equal(t, \"Forecast retrieved.\", actual.Meta.Message)\n//\tassert.NotNil(t, actual.Data.Current)\n//\tassert.Nil(t, actual.Data.Daily)\n//\tassert.Nil(t, actual.Data.Hourly)\n//\tassert.Equal(t, 24, actual.Data.ID)\n//\n//\tc := actual.Data.Current\n//\tassert.Equal(t, 177.0, c[\"temperature\"])\n//\n//}\n//\n//func TestThatItShouldReturnExpectedLocalisedForcastResponseForDescription(t *testing.T) {\n//\tw := httptest.NewRecorder()\n//\tctx, _ := gin.CreateTestContext(w)\n//\tctx.Request = &http.Request{URL: &url.URL{}, Header: map[string][]string{}}\n//\tctx.Params = append(ctx.Params, gin.Param{Key: \"id\", Value: \"24\"})\n//\tctx.Request.Header.Set(\"AcceptLanguage\", \"da;q=1.0,enGB;q=0.8\")\n//\n//\tu := url.Values{}\n//\tu.Add(\"current[fields]\", \"condition\")\n//\tctx.Request.URL.RawQuery = u.Encode()\n//\n//\twf := new(MockWeatherForecaService)\n//\twf.On(\"GetForecaResponse\", 24).\n//\t\tReturn(&pb.ForecastResponse{\n//\t\t\tCurrentCondition: &pb.ForecastResponse_CurrentCondition{\n//\t\t\t\tTemperature: 27,\n//\t\t\t\tWeatherCondition: &pb.ForecastResponse_WeatherCondition{\n//\t\t\t\t\tCode:        \"klart\",\n//\t\t\t\t\tDescription: \"klart\",\n//\t\t\t\t},\n//\t\t\t\tPressure: &pb.ForecastResponse_Pressure{\n//\t\t\t\t\tMillibar: 1.0,\n//\t\t\t\t\tTrend:    1,\n//\t\t\t\t},\n//\t\t\t\tWindGust: &pb.ForecastResponse_CurrentCondition_WindGust{\n//\t\t\t\t\tWind: &pb.ForecastResponse_Wind{\n//\t\t\t\t\t\tDirection: &pb.ForecastResponse_WindDirection{\n//\t\t\t\t\t\t\tAbbreviation: \"test\",\n//\t\t\t\t\t\t},\n//\t\t\t\t\t},\n//\t\t\t\t},\n//\t\t\t},\n//\t\t\tDailyForecasts:  []*pb.ForecastResponse_DailyForecast{},\n//\t\t\tHourlyForecasts: []*pb.ForecastResponse_HourlyForecast{},\n//\t\t}, nil)\n//\n//\tv0.Weather(wf, zap.NewNop())(ctx)\n//\tassert.Equal(t, 200, w.Code)\n//\n//\tvar actual *model.ForecaResponse\n//\t_ = json.Unmarshal(w.Body.Bytes(), &actual)\n//\n//\tassert.Equal(t, \"ok\", actual.Meta.Code)\n//\tassert.Equal(t, \"Forecast retrieved.\", actual.Meta.Message)\n//\tassert.Equal(t, 24, actual.Data.ID)\n//\n//\tc := actual.Data.Current\n//\tassert.Equal(t, \"klart\", c[\"condition\"].(map[string]interface{})[\"description\"])\n//}\n", "n_tokens": 4228, "byte_len": 14111, "file_sha1": "4e2b124b924c90bc560fc6f7fa445b6c70e4b56e", "start_line": 1, "end_line": 419}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/nearestBatch.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/internal/forecasts/adapters/handlers/http/v0/nearestBatch.go", "rel_path": "internal/forecasts/adapters/handlers/http/v0/nearestBatch.go", "module": "internal.forecasts.adapters.handlers.http.v0.nearestBatch", "ext": "go", "chunk_number": 1, "symbols": ["nearestBatch", "batchNearestLocationsForecastRequest", "went", "append", "timezone", "status", "statusok", "httpresponses", "locale", "snow", "hourly", "presenter", "coords", "unique", "string", "warn", "current", "fields", "index", "internal", "error", "oneof", "weather", "provided", "heat", "request", "load", "distance", "unit", "please", "dive", "message", "binding", "temperature", "max", "wind", "coordinates", "range", "daily", "conditions", "response", "type", "batch", "nearest", "humidity", "validation", "average", "package", "timestamp", "cannot"], "ast_kind": "class_or_type", "text": "package v0\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"go.impalastudios.com/log\"\n\t\"go.impalastudios.com/weather/forecasts/internal/forecasts\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/httpresponses\"\n\t\"go.impalastudios.com/weather/forecasts/pkg/i18n\"\n\t\"go.uber.org/zap\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype batchNearestLocationsForecastRequest struct {\n\tCoordinates     []Coordinate `form:\"coordinates[]\" binding:\"required,min=1,max=25,dive,coord\"`\n\tDailyFields     []string     `form:\"daily[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* temperature_min temperature_max precipitation snow wind_max humidity_average condition condition_night uv_index\"`\n\tDailyDays       *int         `form:\"daily[days],default=10\" binding:\"omitempty,min=1,max=10\"`\n\tHourlyFields    []string     `form:\"hourly[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* timestamp temperature temperature_feels_like precipitation snow wind pressure condition humidity uv_index\"`\n\tHourlyDays      *int         `form:\"hourly[days],default=10\" binding:\"omitempty,min=1,max=10\"`\n\tHourlyHours     []string     `form:\"hourly[hours][]\" binding:\"omitempty,unique,star,dive,oneof=* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\"`\n\tCurrentFields   []string     `form:\"current[fields][]\" binding:\"omitempty,unique,star,dive,oneof=* condition uv_index temperature temperature_feels_like heat_index dew_point visibility pressure wind humidity precipitation\"`\n\tDistanceUnit    string       `form:\"distanceUnit,default=km\" binding:\"omitempty,oneof=km mi\"`\n\tTemperatureUnit string       `form:\"temperatureUnit,default=C\" binding:\"omitempty,oneof=C F\"`\n}\n\nfunc (h *Handler) nearestBatch(c *gin.Context) {\n\tlocale := i18n.GetLocaleFromHeader(c.GetHeader(\"Accept-Language\"))\n\n\tlog.Debug(c, \"Request detected locale.\", zap.String(\"locale\", locale.String()))\n\n\treq := batchNearestLocationsForecastRequest{\n\t\tHourlyHours: []string{\"*\"},\n\t}\n\n\tif err := c.ShouldBind(&req); err != nil {\n\t\tlog.Debug(c, \"Validation errors.\", zap.Any(\"request\", req), zap.Error(err))\n\t\tmessage := i18n.GetFirstValidationErrorMessage(err)\n\n\t\tc.PureJSON(http.StatusBadRequest, httpresponses.NewErrorResponse[*Response](\"invalid_parameters\", message))\n\n\t\treturn\n\t}\n\n\tif len(req.CurrentFields) == 0 && len(req.DailyFields) == 0 && len(req.HourlyFields) == 0 {\n\t\tlog.Debug(c, \"current[fields], daily[fields], and hourly[fields] cannot be null at the same time.\", zap.Any(\"request\", req))\n\t\tc.JSON(http.StatusBadRequest, httpresponses.NewErrorResponse[[]*Response](\"invalid_parameters\", \"At least one of current[fields], daily[fields], or hourly[fields] must be present.\"))\n\n\t\treturn\n\t}\n\n\tcoords := make([]forecasts.Coordinate, len(req.Coordinates))\n\tfor i, coord := range req.Coordinates {\n\t\tco, err := coord.Parse()\n\t\tif err != nil {\n\t\t\tlog.Error(c, \"Cannot parse coordinate.\", zap.Any(\"coordinate\", coord))\n\n\t\t\tc.PureJSON(\n\t\t\t\thttp.StatusBadRequest,\n\t\t\t\thttpresponses.NewErrorResponse[*Location](\"invalid_parameters\", \"Cannot parse the provided coordinate.\"),\n\t\t\t)\n\t\t\treturn\n\t\t}\n\t\tcoords[i] = co\n\t}\n\n\tfs, locations, err := h.forecasts.GetForecastForClosestLocations(c.Request.Context(), coords, locale)\n\tif err != nil {\n\t\tc.JSON(http.StatusInternalServerError, httpresponses.NewErrorResponse[[]*Response](\"internal_error\", \"Something went wrong. Please try again later.\"))\n\t\treturn\n\t}\n\n\tcurrentPresenter := NewCurrentConditionPresenter(req.CurrentFields, 2, req.DistanceUnit, req.TemperatureUnit, locale)\n\tdailyPresenter := NewDailyConditionPresenter(req.DailyFields, 2, *req.DailyDays, req.DistanceUnit, req.TemperatureUnit, locale)\n\thourlyPresenter := NewHourlyConditionPresenter(req.HourlyFields, 2, *req.HourlyDays, req.HourlyHours, req.DistanceUnit, req.TemperatureUnit, locale)\n\n\tvar res []*Response\n\tfor i := range fs {\n\t\tif locations[i] == nil || fs[i] == nil {\n\t\t\tlog.Warn(c, \"Cannot find proper location or forecast for provided ID.\", zap.Any(\"id\", req.Coordinates[i]), zap.Any(\"location\", locations[i]), zap.Any(\"forecast\", fs[i]))\n\t\t\tcontinue\n\t\t}\n\n\t\tloc, err := time.LoadLocation(locations[i].Timezone)\n\t\tif err != nil {\n\t\t\tlog.Warn(c, \"Cannot load timezone.\", zap.Any(\"id\", req.Coordinates[i]), zap.Any(\"location\", locations[i]), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tres = append(res, &Response{\n\t\t\tLocation: h.toLocationResource(locations[i]),\n\t\t\tForecast: &Forecast{\n\t\t\t\tCurrentCondition: currentPresenter.Present(fs[i].CurrentCondition, loc),\n\t\t\t\tDailyConditions:  dailyPresenter.Present(fs[i].DailyConditions, loc),\n\t\t\t\tHourlyConditions: hourlyPresenter.Present(fs[i].HourlyConditions, loc),\n\t\t\t},\n\t\t})\n\t}\n\n\tc.JSON(http.StatusOK, httpresponses.NewResponse(res, \"ok\", \"Forecasts retrieved.\"))\n}\n", "n_tokens": 1196, "byte_len": 4652, "file_sha1": "9dec84493e618946a30126338afad50c1fdc9dd6", "start_line": 1, "end_line": 101}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/xotel/provider.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/xotel/provider.go", "rel_path": "pkg/xotel/provider.go", "module": "pkg.xotel.provider", "ext": "go", "chunk_number": 1, "symbols": ["NewTracerProvider", "SetGlobalTracer", "NewMeterProvider", "SetGlobalMeter", "getResource", "TracerProviderConfig", "MeterProviderConfig", "otlptracegrpc", "new", "with", "interval", "string", "failed", "configuration", "batch", "endpoint", "providers", "exporter", "defer", "trace", "context", "wrap", "meter", "spf", "spf13", "always", "tracer", "resource", "get", "reader", "semconv", "type", "periodic", "cockroachdb", "creates", "otlptrace", "package", "tracesdk", "sample", "opentelemetry", "set", "default", "metric", "xotel", "open", "telemetry", "return", "errors", "initialize", "mapstructure"], "ast_kind": "class_or_type", "text": "package xotel\n\nimport (\n\t\"context\"\n\t\"go.opentelemetry.io/otel/metric\"\n\t\"time\"\n\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/spf13/viper\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc\"\n\tmetricsdk \"go.opentelemetry.io/otel/sdk/metric\"\n\t\"go.opentelemetry.io/otel/sdk/resource\"\n\ttracesdk \"go.opentelemetry.io/otel/sdk/trace\"\n\tsemconv \"go.opentelemetry.io/otel/semconv/v1.26.0\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n\n// TracerProviderConfig is the configuration for the OpenTelemetry Tracer provider\ntype TracerProviderConfig struct {\n\tEndpoint string `mapstructure:\"endpoint\"`\n}\n\n// NewTracerProvider creates a new TracerProvider provider\n// Usage:\n//\n//\ttp, err := xotel.NewTracerProvider(ctx, cfg)\n//\tif err != nil {\n//\t\treturn nil, errors.Wrap(err, \"failed to create trace provider\")\n//\t}\n//\totel.SetTracerProvider(tp)\n//\txotel.SetGlobalTracer(tp.Tracer(viper.GetString(\"app.name\")))\n//\n//\tdefer tp.Shutdown(ctx)\nfunc NewTracerProvider(ctx context.Context, cfg TracerProviderConfig) (*tracesdk.TracerProvider, error) {\n\tr, err := getResource()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"cannot get resource\")\n\t}\n\n\ttracer := otlptracegrpc.NewClient(\n\t\totlptracegrpc.WithEndpoint(cfg.Endpoint),\n\t\totlptracegrpc.WithInsecure(),\n\t)\n\texporter, err := otlptrace.New(ctx, tracer)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to initialize trace exporter\")\n\t}\n\n\ttp := tracesdk.NewTracerProvider(\n\t\t// Always be sure to batch in production.\n\t\ttracesdk.WithBatcher(exporter),\n\t\ttracesdk.WithResource(r),\n\t\ttracesdk.WithSampler(tracesdk.ParentBased(tracesdk.AlwaysSample())),\n\t)\n\n\treturn tp, nil\n}\n\n// Tracer is the global tracer\nvar Tracer trace.Tracer = nil\n\n// SetGlobalTracer sets global tracer\nfunc SetGlobalTracer(tracer trace.Tracer) {\n\tTracer = tracer\n}\n\n// MeterProviderConfig is the configuration for the OpenTelemetry providers\ntype MeterProviderConfig struct {\n\tEndpoint string        `mapstructure:\"endpoint\"`\n\tInterval time.Duration `mapstructure:\"interval\"`\n}\n\nfunc NewMeterProvider(ctx context.Context, cfg MeterProviderConfig) (*metricsdk.MeterProvider, error) {\n\tctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\tdefer cancel()\n\n\tr, err := getResource()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"cannot get resource\")\n\t}\n\n\texporter, err := otlpmetricgrpc.New(\n\t\tctx,\n\t\totlpmetricgrpc.WithEndpoint(cfg.Endpoint),\n\t\totlpmetricgrpc.WithInsecure(),\n\t)\n\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to initialize metric exporter\")\n\t}\n\n\treader := metricsdk.NewPeriodicReader(exporter, metricsdk.WithInterval(cfg.Interval))\n\n\tprovider := metricsdk.NewMeterProvider(\n\t\tmetricsdk.WithResource(r),\n\t\tmetricsdk.WithReader(reader),\n\t)\n\n\treturn provider, nil\n}\n\n// Meter is the global tracer\nvar Meter metric.Meter = nil\n\n// SetGlobalMeter sets global tracer\nfunc SetGlobalMeter(meter metric.Meter) {\n\tMeter = meter\n}\n\nfunc getResource() (*resource.Resource, error) {\n\tr, err := resource.Merge(\n\t\tresource.Default(),\n\t\tresource.NewWithAttributes(\n\t\t\tsemconv.SchemaURL,\n\t\t\tsemconv.ServiceNameKey.String(viper.GetString(\"app.name\")),\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"cannot merge resource\")\n\t}\n\n\treturn r, nil\n}\n", "n_tokens": 877, "byte_len": 3309, "file_sha1": "4af03d233855925bd85305a739b8a87add5c64e0", "start_line": 1, "end_line": 126}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/httpresponses/response.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/httpresponses/response.go", "rel_path": "pkg/httpresponses/response.go", "module": "pkg.httpresponses.response", "ext": "go", "chunk_number": 1, "symbols": ["Pagination", "Metadata", "response", "new", "data", "httpresponses", "next", "struct", "type", "error", "json", "about", "creates", "string", "package", "code", "paginated", "metadata", "http", "format", "func", "page", "limit", "omitempty", "return", "pagination", "get", "zero", "message", "represents", "meta", "information", "contains"], "ast_kind": "class_or_type", "text": "package httpresponses\n\n// Pagination represents the pagination metadata\ntype Pagination struct {\n\tLimit int     `json:\"limit\"`\n\tNext  *string `json:\"next\"`\n}\n\n// Metadata contains the information about the response\ntype Metadata struct {\n\tCode       string      `json:\"code\"`\n\tMessage    string      `json:\"message\"`\n\tPagination *Pagination `json:\"pagination,omitempty\"`\n}\n\n// Response is the http response format\ntype Response[T any] struct {\n\tMetadata Metadata `json:\"meta\"`\n\tData     T        `json:\"data\"`\n}\n\n// NewResponse creates a new response\nfunc NewResponse[T any](data T, code string, message string) *Response[T] {\n\treturn &Response[T]{\n\t\tMetadata: Metadata{\n\t\t\tCode:    code,\n\t\t\tMessage: message,\n\t\t},\n\t\tData: data,\n\t}\n}\n\n// NewPaginatedResponse creates a new paginated response\nfunc NewPaginatedResponse[T any](data T, code, message string, limit int, nextPageToken *string) *Response[T] {\n\treturn &Response[T]{\n\t\tMetadata: Metadata{\n\t\t\tCode:    code,\n\t\t\tMessage: message,\n\t\t\tPagination: &Pagination{\n\t\t\t\tLimit: limit,\n\t\t\t\tNext:  nextPageToken,\n\t\t\t},\n\t\t},\n\t\tData: data,\n\t}\n}\n\n// NewErrorResponse creates a new error response\nfunc NewErrorResponse[T any](code string, message string) *Response[T] {\n\treturn &Response[T]{\n\t\tMetadata: Metadata{\n\t\t\tCode:    code,\n\t\t\tMessage: message,\n\t\t},\n\t\tData: getZero[T](),\n\t}\n}\n\nfunc getZero[T any]() T {\n\tvar z T\n\treturn z\n}\n", "n_tokens": 350, "byte_len": 1375, "file_sha1": "5e14e200c6abae9db724e5d93d857ed4274e732c", "start_line": 1, "end_line": 63}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/utilities/conversion.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/utilities/conversion.go", "rel_path": "pkg/utilities/conversion.go", "module": "pkg.utilities.conversion", "ext": "go", "chunk_number": 1, "symbols": ["KilometresToMiles", "CelsiusToFahrenheit", "package", "float", "float32", "return", "miles", "factor", "kilometres", "func", "celsius", "fahrenheit", "const", "utilities"], "ast_kind": "function_or_method", "text": "package utilities\n\nconst (\n\tkmToMilesFactor float32 = 0.62137119\n)\n\nfunc KilometresToMiles(in float32) float32 {\n\treturn in * kmToMilesFactor\n}\n\nfunc CelsiusToFahrenheit(in float32) float32 {\n\treturn (in * 1.8) + 32\n}\n", "n_tokens": 71, "byte_len": 218, "file_sha1": "444dcf037f94b90d3f480b0da219a48324ddb47a", "start_line": 1, "end_line": 14}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/utilities/data_structure.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/utilities/data_structure.go", "rel_path": "pkg/utilities/data_structure.go", "module": "pkg.utilities.data_structure", "ext": "go", "chunk_number": 1, "symbols": ["Add", "Length", "Contains", "Elements", "String", "string", "append", "strings", "length", "type", "join", "package", "utilities", "element", "contains", "found", "func", "import", "elements", "return", "true", "bool", "new", "set", "range", "needle"], "ast_kind": "function_or_method", "text": "package utilities\n\nimport \"strings\"\n\ntype Set[T string] map[T]bool\n\nfunc NewSetFromSlice[T string](elements []T) Set[T] {\n\ts := Set[T]{}\n\tfor _, element := range elements {\n\t\ts.Add(element)\n\t}\n\n\treturn s\n}\n\nfunc (s Set[T]) Add(element T) {\n\ts[element] = true\n}\n\nfunc (s Set[T]) Length() int {\n\treturn len(s)\n}\n\nfunc (s Set[T]) Contains(needle T) bool {\n\t_, found := s[needle]\n\n\treturn found\n}\n\nfunc (s Set[T]) Elements() []string {\n\tvar elements []string\n\n\tfor key := range s {\n\t\telements = append(elements, string(key))\n\t}\n\n\treturn elements\n}\n\nfunc (s Set[T]) String() string {\n\tvar elements []string\n\tfor key := range s {\n\t\telements = append(elements, string(key))\n\t}\n\n\treturn strings.Join(elements, \", \")\n}\n", "n_tokens": 193, "byte_len": 710, "file_sha1": "9326b40d7d0548ff9ff251e613c750d65e0cda04", "start_line": 1, "end_line": 48}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/utilities/math.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/utilities/math.go", "rel_path": "pkg/utilities/math.go", "module": "pkg.utilities.math", "ext": "go", "chunk_number": 1, "symbols": ["RoundFloat32", "round", "package", "precision", "float", "float32", "float64", "return", "pow", "pow10", "func", "import", "math", "utilities"], "ast_kind": "function_or_method", "text": "package utilities\n\nimport \"math\"\n\nfunc RoundFloat32(in float32, precision int) float32 {\n\treturn float32(math.Round(float64(in)*math.Pow10(precision)) / math.Pow10(precision))\n}\n", "n_tokens": 44, "byte_len": 178, "file_sha1": "1f04d8dfa17b0f39616c190edcc84f8e44ec5c54", "start_line": 1, "end_line": 8}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/i18n/catalog.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/i18n/catalog.go", "rel_path": "pkg/i18n/catalog.go", "module": "pkg.i18n.catalog", "ext": "go", "chunk_number": 1, "symbols": ["Lookup", "dictionary", "edit", "data", "lookup", "false", "struct", "type", "text", "string", "code", "package", "running", "language", "func", "start", "import", "golang", "return", "catalog", "index", "true", "message", "key", "bool", "i18n", "generate", "uint", "uint32", "generated", "init", "tstorms", "schnee", "x02schnee", "nuageux", "nebel", "x02nebel", "pre", "x02pre", "tordenve", "x02tordenve", "ensolarado", "nebbia", "x02nebbia", "x02l", "predomin", "x02predomin", "regn", "frindex", "snow"], "ast_kind": "class_or_type", "text": "// Code generated by running \"go generate\" in golang.org/x/text. DO NOT EDIT.\n\npackage i18n\n\nimport (\n\t\"golang.org/x/text/language\"\n\t\"golang.org/x/text/message\"\n\t\"golang.org/x/text/message/catalog\"\n)\n\ntype dictionary struct {\n\tindex []uint32\n\tdata  string\n}\n\nfunc (d *dictionary) Lookup(key string) (data string, ok bool) {\n\tp, ok := messageKeyToIndex[key]\n\tif !ok {\n\t\treturn \"\", false\n\t}\n\tstart, end := d.index[p], d.index[p+1]\n\tif start == end {\n\t\treturn \"\", false\n\t}\n\treturn d.data[start:end], true\n}\n", "n_tokens": 141, "byte_len": 504, "file_sha1": "e34cc5f1628afc4a2bc08c982aa761041e9c21a6", "start_line": 1, "end_line": 27}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/i18n/catalog.go#2", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/i18n/catalog.go", "rel_path": "pkg/i18n/catalog.go", "module": "pkg.i18n.catalog", "ext": "go", "chunk_number": 2, "symbols": ["init", "tstorms", "schnee", "x02schnee", "nuageux", "nebel", "x02nebel", "pre", "x02pre", "tordenve", "x02tordenve", "ensolarado", "nebbia", "x02nebbia", "data", "x02l", "predomin", "x02predomin", "regn", "index", "frindex", "snow", "probabil", "x02probabil", "x02regn", "string", "clear", "usvaa", "x02usvaa", "fondue", "Lookup", "dictionary", "lookup", "code", "pioggia", "sunny", "niebla", "x02niebla", "mist", "x02mist", "x02t", "probabilidad", "x02probabilidad", "granizo", "x02granizo", "neige", "mest", "x02mest", "heiig", "x02heiig"], "ast_kind": "function_or_method", "text": "func init() {\n\tdict := map[string]catalog.Dictionary{\n\t\t\"da\": &dictionary{index: daIndex, data: daData},\n\t\t\"de\": &dictionary{index: deIndex, data: deData},\n\t\t\"en\": &dictionary{index: enIndex, data: enData},\n\t\t\"es\": &dictionary{index: esIndex, data: esData},\n\t\t\"fi\": &dictionary{index: fiIndex, data: fiData},\n\t\t\"fr\": &dictionary{index: frIndex, data: frData},\n\t\t\"it\": &dictionary{index: itIndex, data: itData},\n\t\t\"ja\": &dictionary{index: jaIndex, data: jaData},\n\t\t\"ko\": &dictionary{index: koIndex, data: koData},\n\t\t\"nl\": &dictionary{index: nlIndex, data: nlData},\n\t\t\"no\": &dictionary{index: noIndex, data: noData},\n\t\t\"pt\": &dictionary{index: ptIndex, data: ptData},\n\t\t\"ru\": &dictionary{index: ruIndex, data: ruData},\n\t\t\"sv\": &dictionary{index: svIndex, data: svData},\n\t\t\"zh\": &dictionary{index: zhIndex, data: zhData},\n\t}\n\tfallback := language.MustParse(\"en\")\n\tcat, err := catalog.NewFromMap(dict, catalog.Fallback(fallback))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tmessage.DefaultCatalog = cat\n}\n\nvar messageKeyToIndex = map[string]int{\n\t\"chancerain\":    7,\n\t\"chancesleet\":   11,\n\t\"chancesnow\":    13,\n\t\"chancetstorms\": 9,\n\t\"clear\":         0,\n\t\"cloudy\":        4,\n\t\"fog\":           6,\n\t\"hazy\":          5,\n\t\"mostlyclear\":   15,\n\t\"mostlycloudy\":  3,\n\t\"mostlysunny\":   1,\n\t\"partlycloudy\":  2,\n\t\"rain\":          8,\n\t\"sleet\":         12,\n\t\"snow\":          14,\n\t\"tstorms\":       10,\n}\n\nvar daIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000006, 0x0000000f, 0x0000001c,\n\t0x00000027, 0x0000002d, 0x00000031, 0x00000037,\n\t0x00000049, 0x0000004e, 0x00000066, 0x00000071,\n\t0x00000083, 0x00000088, 0x00000099, 0x0000009d,\n\t0x000000a8,\n} // Size: 92 bytes\n\nconst daData string = \"\" + // Size: 168 bytes\n\t\"\\x02Klart\\x02Mest sol\\x02Delvis skyet\\x02Mest skyet\\x02Skyet\\x02Dis\\x02T\" +\n\t\"åge\\x02Mulighed for regn\\x02Regn\\x02Mulighed for tordenvejr\\x02Tordenve\" +\n\t\"jr\\x02Mulighed for slud\\x02Slud\\x02Mulighed for sne\\x02Sne\\x02Mest klart\"\n\nvar deIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000005, 0x00000012, 0x00000025,\n\t0x00000034, 0x0000003d, 0x00000043, 0x00000049,\n\t0x00000061, 0x00000067, 0x00000082, 0x0000008b,\n\t0x000000a9, 0x000000b5, 0x000000ce, 0x000000d5,\n\t0x000000e0,\n} // Size: 92 bytes\n\nconst deData string = \"\" + // Size: 224 bytes\n\t\"\\x02Klar\\x02Meist sonnig\\x02Teilweise bewölkt\\x02Meist bewölkt\\x02Bewölk\" +\n\t\"t\\x02Dunst\\x02Nebel\\x02Regenwahrscheinlichkeit\\x02Regen\\x02Gewitterwahrs\" +\n\t\"cheinlichkeit\\x02Gewitter\\x02Schneeregenwahrscheinlichkeit\\x02Schneerege\" +\n\t\"n\\x02Schneewahrscheinlichkeit\\x02Schnee\\x02Meist klar\"\n\nvar enIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000006, 0x00000013, 0x00000021,\n\t0x0000002f, 0x00000036, 0x0000003b, 0x0000003f,\n\t0x0000004e, 0x00000053, 0x0000006b, 0x00000079,\n\t0x00000089, 0x0000008f, 0x0000009e, 0x000000a3,\n\t0x000000b0,\n} // Size: 92 bytes\n\nconst enData string = \"\" + // Size: 176 bytes\n\t\"\\x02Clear\\x02Mostly sunny\\x02Partly cloudy\\x02Mostly cloudy\\x02Cloudy\" +\n\t\"\\x02Haze\\x02Fog\\x02Chance of rain\\x02Rain\\x02Chance of thunderstorms\\x02\" +\n\t\"Thunderstorms\\x02Chance of sleet\\x02Sleet\\x02Chance of snow\\x02Snow\\x02M\" +\n\t\"ostly clear\"\n\nvar esIndex = []uint32{ // 17 elements\n\t0x00000000, 0x0000000a, 0x0000001d, 0x00000032,\n\t0x00000045, 0x0000004d, 0x00000055, 0x0000005c,\n\t0x00000073, 0x0000007a, 0x00000093, 0x0000009c,\n\t0x000000b6, 0x000000c0, 0x000000d6, 0x000000dc,\n\t0x000000f1,\n} // Size: 92 bytes\n\nconst esData string = \"\" + // Size: 241 bytes\n\t\"\\x02Despejado\\x02Mayormente soleado\\x02Parcialmente nublado\\x02Mayorment\" +\n\t\"e nublado\\x02Nublado\\x02Neblina\\x02Niebla\\x02Probabilidad de lluvia\\x02L\" +\n\t\"luvia\\x02Probabilidad de tormenta\\x02Tormenta\\x02Probabilidad de aguanie\" +\n\t\"ve\\x02Aguanieve\\x02Probabilidad de nieve\\x02Nieve\\x02Mayormente despejad\" +\n\t\"o\"\n\nvar fiIndex = []uint32{ // 17 elements\n\t0x00000000, 0x0000000a, 0x00000023, 0x00000036,\n\t0x0000004d, 0x00000057, 0x0000005d, 0x00000063,\n\t0x00000077, 0x0000007f, 0x00000094, 0x0000009c,\n\t0x000000b8, 0x000000c0, 0x000000da, 0x000000e0,\n\t0x000000f7,\n} // Size: 92 bytes\n\nconst fiData string = \"\" + // Size: 247 bytes\n\t\"\\x02Selkeää\\x02Enimmäkseen aurinkoista\\x02Osittain pilvistä\\x02Enimmäkse\" +\n\t\"en pilvistä\\x02Pilvistä\\x02Usvaa\\x02Sumua\\x02Sateen mahdollisuus\\x02Sade\" +\n\t\"tta\\x02Ukkosen mahdollisuus\\x02Ukkosta\\x02Räntä sateen mahdollisuus\\x02R\" +\n\t\"äntä\\x02Mahdollisesti lumisadetta\\x02Lunta\\x02Enimmäkseen selkeää\"\n\nvar frIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000006, 0x0000001a, 0x00000030,\n\t0x0000003e, 0x00000046, 0x0000004c, 0x00000057,\n\t0x00000067, 0x0000006d, 0x0000007c, 0x00000082,\n\t0x00000099, 0x000000a6, 0x000000b6, 0x000000bc,\n\t0x000000ca,\n} // Size: 92 bytes\n\nconst frData string = \"\" + // Size: 202 bytes\n\t\"\\x02Clair\\x02Plutôt ensoleillé\\x02Partiellement nuageux\\x02Très nuageux\" +\n\t\"\\x02Nuageux\\x02Brume\\x02Brouillard\\x02Risque de pluie\\x02Pluie\\x02Risque\" +\n\t\" d'orage\\x02Orage\\x02Risque de neige fondue\\x02Neige fondue\\x02Risque de\" +\n\t\" neige\\x02Neige\\x02Plutôt clair\"\n\nvar itIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000007, 0x00000022, 0x00000038,\n\t0x00000051, 0x0000005a, 0x00000062, 0x00000069,\n\t0x00000081, 0x00000089, 0x000000a3, 0x000000ad,\n\t0x000000c7, 0x000000d1, 0x000000e6, 0x000000eb,\n\t0x00000102,\n} // Size: 92 bytes\n\nconst itData string = \"\" + // Size: 258 bytes\n\t\"\\x02Sereno\\x02Prevalentemente soleggiato\\x02Parzialmente nuvoloso\\x02Pre\" +\n\t\"valentemente nuvoloso\\x02Nuvoloso\\x02Foschia\\x02Nebbia\\x02Probabilità di\" +\n\t\" pioggia\\x02Pioggia\\x02Probabilità di temporali\\x02Temporali\\x02Probabil\" +\n\t\"ità di nevischio\\x02Nevischio\\x02Probabilità di neve\\x02Neve\\x02Prevalen\" +\n\t\"temente sereno\"\n\nvar jaIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000007, 0x00000014, 0x0000002d,\n\t0x0000003a, 0x00000041, 0x00000048, 0x0000004c,\n\t0x00000059, 0x0000005d, 0x0000006d, 0x00000074,\n\t0x00000087, 0x0000008e, 0x0000009b, 0x0000009f,\n\t0x000000ac,\n} // Size: 92 bytes\n\nconst jaData string = \"\" + // Size: 172 bytes\n\t\"\\x02晴天\\x02概ね晴れ\\x02晴れときどき曇り\\x02概ね曇り\\x02曇り\\x02もや\\x02霧\\x02降水確率\\x02雨\\x02雷雨の確\" +\n\t\"率\\x02雷雨\\x02雨氷の可能性\\x02雨氷\\x02降雪確率\\x02雪\\x02概ね晴れ\"\n\nvar koIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000007, 0x0000001b, 0x00000030,\n\t0x00000041, 0x00000048, 0x0000004f, 0x00000056,\n\t0x00000064, 0x00000068, 0x00000076, 0x0000007d,\n\t0x00000094, 0x000000a1, 0x000000b0, 0x000000b4,\n\t0x000000c5,\n} // Size: 92 bytes\n\nconst koData string = \"\" + // Size: 197 bytes\n\t\"\\x02맑음\\x02대체로 화창함\\x02곳에 따라 흐림\\x02대체로 흐림\\x02흐림\\x02연무\\x02안개\\x02강우 확률\\x02비\" +\n\t\"\\x02뇌우 확률\\x02뇌우\\x02진눈깨비 가능성\\x02진눈깨비\\x02눈 올 확률\\x02눈\\x02대체로 맑음\"\n\nvar nlIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000007, 0x00000019, 0x0000002e,\n\t0x00000041, 0x00000049, 0x0000004f, 0x00000054,\n\t0x00000062, 0x00000068, 0x0000007d, 0x00000088,\n\t0x00000096, 0x0000009c, 0x000000ab, 0x000000b2,\n\t0x000000c4,\n} // Size: 92 bytes\n\nconst nlData string = \"\" + // Size: 196 bytes\n\t\"\\x02Helder\\x02Overwegend zonnig\\x02Gedeeltelijk bewolkt\\x02Overwegend be\" +\n\t\"wolkt\\x02Bewolkt\\x02Heiig\\x02Mist\\x02Kans op regen\\x02Regen\\x02Kans op o\" +\n\t\"nweersbuien\\x02Onweersbui\\x02Kans op ijzel\\x02Ijzel\\x02Kans op sneeuw\" +\n\t\"\\x02Sneeuw\\x02Overwegend helder\"\n\nvar noIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000006, 0x00000018, 0x00000025,\n\t0x00000039, 0x0000003f, 0x00000043, 0x00000049,\n\t0x0000005b, 0x00000060, 0x00000079, 0x00000085,\n\t0x00000098, 0x0000009e, 0x000000b0, 0x000000b5,\n\t0x000000c9,\n} // Size: 92 bytes\n\nconst noData string = \"\" + // Size: 201 bytes\n\t\"\\x02Klart\\x02For det meste sol\\x02Delvis skyet\\x02For det meste skyet\" +\n\t\"\\x02Skyet\\x02Dis\\x02Tåke\\x02Mulighet for regn\\x02Regn\\x02Mulighet for to\" +\n\t\"rdenbyger\\x02Tordenbyger\\x02Mulighet for sludd\\x02Sludd\\x02Mulighet for \" +\n\t\"snø\\x02Snø\\x02For det meste klart\"\n\nvar ptIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000006, 0x00000023, 0x00000038,\n\t0x00000052, 0x0000005a, 0x00000062, 0x0000006b,\n\t0x00000082, 0x00000088, 0x000000a2, 0x000000ab,\n\t0x000000c4, 0x000000cc, 0x000000e2, 0x000000e7,\n\t0x000000ff,\n} // Size: 92 bytes\n\nconst ptData string = \"\" + // Size: 255 bytes\n\t\"\\x02Limpo\\x02Predominantemente ensolarado\\x02Parcialmente nublado\\x02Pre\" +\n\t\"dominantemente nublado\\x02Nublado\\x02Neblina\\x02Nevoeiro\\x02Possibilidad\" +\n\t\"e de chuva\\x02Chuva\\x02Possibilidade de trovoada\\x02Trovoada\\x02Possibil\" +\n\t\"idade de granizo\\x02Granizo\\x02Possibilidade de neve\\x02Neve\\x02Predomin\" +\n\t\"antemente limpo\"\n\nvar ruIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000009, 0x00000020, 0x0000004b,\n\t0x00000079, 0x00000088, 0x00000093, 0x0000009e,\n\t0x000000ba, 0x000000c5, 0x000000e1, 0x000000ec,\n\t0x0000011d, 0x00000133, 0x0000014d, 0x00000156,\n\t0x0000017e,\n} // Size: 92 bytes\n\nconst ruData string = \"\" + // Size: 382 bytes\n\t\"\\x02Ясно\\x02Малооблачно\\x02Облачно с прояснениями\\x02Значительная облачн\" +\n\t\"ость\\x02Облачно\\x02Дымка\\x02Туман\\x02Возможен дождь\\x02Дождь\\x02Возможн\" +\n\t\"а гроза\\x02Грозы\\x02Вероятность мокрого снега\\x02Мокрый снег\\x02Возможе\" +\n\t\"н снег\\x02Снег\\x02Преимущественно ясно\"\n\nvar svIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000006, 0x00000017, 0x00000026,\n\t0x00000038, 0x00000040, 0x00000044, 0x0000004a,\n\t0x00000059, 0x0000005e, 0x00000073, 0x0000007e,\n\t0x0000009a, 0x000000ab, 0x000000bb, 0x000000c0,\n\t0x000000d0,\n} // Size: 92 bytes\n\nconst svData string = \"\" + // Size: 208 bytes\n\t\"\\x02Klart\\x02Mestadels soligt\\x02Delvis molnigt\\x02Mestadels molnigt\\x02\" +\n\t\"Molnigt\\x02Dis\\x02Dimma\\x02Risk för regn\\x02Regn\\x02Risk för åskväder\" +\n\t\"\\x02Åskväder\\x02Chans för snöblandat regn\\x02Snöblandat regn\\x02Chans fö\" +\n\t\"r snö\\x02Snö\\x02Mestadels klart\"\n\nvar zhIndex = []uint32{ // 17 elements\n\t0x00000000, 0x00000004, 0x00000011, 0x0000001e,\n\t0x0000002b, 0x00000032, 0x00000036, 0x0000003a,\n\t0x0000004a, 0x0000004e, 0x0000005e, 0x00000065,\n\t0x00000072, 0x0000007d, 0x0000008d, 0x00000091,\n\t0x000000a1,\n} // Size: 92 bytes\n\nconst zhData string = \"\" + // Size: 161 bytes\n\t\"\\x02晴\\x02以晴为主\\x02局部多云\\x02多云时阴\\x02多云\\x02霾\\x02雾\\x02降雨可能性\\x02雨\\x02雷暴可能性\\x02\" +\n\t\"雷暴\\x02冻雨概率\\x02<Sleet ZH>\\x02降雪可能性\\x02雪\\x02大部分晴朗\"\n\n\t// Total table size 4668 bytes (4KiB); checksum: 1C1228F3\n", "n_tokens": 4730, "byte_len": 10490, "file_sha1": "e34cc5f1628afc4a2bc08c982aa761041e9c21a6", "start_line": 28, "end_line": 280}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/i18n/supported.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/i18n/supported.go", "rel_path": "pkg/i18n/supported.go", "module": "pkg.i18n.supported", "ext": "go", "chunk_number": 1, "symbols": ["GetLocaleFromHeader", "Localise", "supported", "languages", "german", "korean", "russian", "parse", "accept", "locale", "text", "italian", "string", "package", "tags", "spanish", "language", "norwegian", "func", "sprintf", "french", "new", "matcher", "import", "vietnamese", "finnish", "danish", "match", "golang", "return", "thai", "chinese", "swedish", "printer", "get", "header", "portuguese", "message", "malay", "english", "localise", "dutch", "i18n", "japanese"], "ast_kind": "function_or_method", "text": "package i18n\n\nimport (\n\t\"golang.org/x/text/language\"\n\t\"golang.org/x/text/message\"\n)\n\nvar SupportedLanguages = language.NewMatcher([]language.Tag{\n\tlanguage.English,\n\tlanguage.Dutch,\n\tlanguage.French,\n\tlanguage.German,\n\tlanguage.Italian,\n\tlanguage.Japanese,\n\tlanguage.Korean,\n\tlanguage.Portuguese,\n\tlanguage.Russian,\n\tlanguage.Spanish,\n\tlanguage.Swedish,\n\tlanguage.Thai,\n\tlanguage.Vietnamese,\n\tlanguage.Malay,\n\tlanguage.Chinese,\n\tlanguage.Finnish,\n\tlanguage.Norwegian,\n\tlanguage.Danish,\n})\n\nfunc GetLocaleFromHeader(acceptHeader string) language.Tag {\n\ttags, _, _ := language.ParseAcceptLanguage(acceptHeader)\n\tlocale, _, _ := SupportedLanguages.Match(tags...)\n\treturn locale\n}\n\nfunc Localise(locale language.Tag, text string) string {\n\tp := message.NewPrinter(locale)\n\n\treturn p.Sprintf(text)\n}\n", "n_tokens": 200, "byte_len": 795, "file_sha1": "f39e6a84d3e5af389628561d4126a855ed2a3c41", "start_line": 1, "end_line": 40}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/i18n/weathercodes.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/i18n/weathercodes.go", "rel_path": "pkg/i18n/weathercodes.go", "module": "pkg.i18n.weathercodes", "ext": "go", "chunk_number": 1, "symbols": ["main", "tstorms", "cloudy", "function", "lint", "chancerain", "snow", "sleet", "text", "lang", "update", "clear", "forecasts", "package", "weather", "language", "unused", "func", "sprintf", "import", "rain", "intentionally", "mostlysunny", "golang", "partlycloudy", "hazy", "printer", "mostlyclear", "chancesnow", "this", "chancetstorms", "srclang", "catalog", "mostlycloudy", "new", "u1000", "message", "impalastudios", "chancesleet", "gotext", "english", "i18n", "generate", "purposes", "ignore"], "ast_kind": "function_or_method", "text": "//go:generate gotext -srclang=en update -out=catalog.go -lang=da,de,en,es,fi,fr,it,ja,ko,nl,no,pt,ru,sv,zh go.impalastudios.com/weather/forecasts/pkg/i18n\n\npackage i18n\n\nimport (\n\t\"golang.org/x/text/language\"\n\tprinter \"golang.org/x/text/message\"\n)\n\n//lint:ignore U1000 This function is intentionally unused, for gotext purposes\nfunc main() {\n\tp := printer.NewPrinter(language.English)\n\tp.Sprintf(\"clear\")\n\tp.Sprintf(\"mostlysunny\")\n\tp.Sprintf(\"partlycloudy\")\n\tp.Sprintf(\"mostlycloudy\")\n\tp.Sprintf(\"cloudy\")\n\tp.Sprintf(\"hazy\")\n\tp.Sprintf(\"fog\")\n\tp.Sprintf(\"chancerain\")\n\tp.Sprintf(\"rain\")\n\tp.Sprintf(\"chancetstorms\")\n\tp.Sprintf(\"tstorms\")\n\tp.Sprintf(\"chancesleet\")\n\tp.Sprintf(\"sleet\")\n\tp.Sprintf(\"chancesnow\")\n\tp.Sprintf(\"snow\")\n\tp.Sprintf(\"mostlyclear\")\n}\n", "n_tokens": 220, "byte_len": 755, "file_sha1": "1a16fb6880f87065ed423a563b6dfbd470af9175", "start_line": 1, "end_line": 30}
{"id": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/i18n/validation.go#1", "repo_id": "crunding-weather_forecasts_service-ff3f82fda128", "language": "go", "path": "/Users/zack.alatrash/Company Repos/crunding-weather_forecasts_service-ff3f82fda128/pkg/i18n/validation.go", "rel_path": "pkg/i18n/validation.go", "module": "pkg.i18n.validation", "ext": "go", "chunk_number": 1, "symbols": ["init", "GetFirstValidationErrorMessage", "error", "validation", "errors", "string", "universal", "package", "get", "translator", "translations", "entranslations", "register", "default", "github", "func", "else", "import", "invalid", "input", "locale", "enlocale", "parameters", "return", "playground", "validator", "engine", "message", "binding", "gonic", "first", "i18n", "locales", "validate", "translate"], "ast_kind": "function_or_method", "text": "package i18n\n\nimport (\n\t\"github.com/gin-gonic/gin/binding\"\n\t\"github.com/go-playground/locales/en\"\n\tut \"github.com/go-playground/universal-translator\"\n\t\"github.com/go-playground/validator/v10\"\n\tenTranslations \"github.com/go-playground/validator/v10/translations/en\"\n)\n\nvar (\n\tTranslator ut.Translator\n)\n\nfunc init() {\n\tif v, ok := binding.Validator.Engine().(*validator.Validate); ok {\n\t\tenLocale := en.New()\n\t\tuni := ut.New(enLocale, enLocale)\n\t\tTranslator, _ = uni.GetTranslator(\"en\")\n\t\t_ = enTranslations.RegisterDefaultTranslations(v, Translator)\n\t}\n}\n\nfunc GetFirstValidationErrorMessage(err error) string {\n\tvar message string\n\tif validationErrors, ok := err.(validator.ValidationErrors); ok {\n\t\tif len(validationErrors) > 0 {\n\t\t\tmessage = validationErrors[0].Translate(Translator)\n\t\t} else {\n\t\t\tmessage = \"The input parameters are invalid.\"\n\t\t}\n\t}\n\n\treturn message\n}\n", "n_tokens": 218, "byte_len": 873, "file_sha1": "7dc00b3d1ebbe0d148be16a6d691eee1a005c44c", "start_line": 1, "end_line": 36}
