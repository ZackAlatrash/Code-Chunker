{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/main.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/main.go", "rel_path": "main.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 12, "text": "package main\n\nimport (\n\t\"go.impalastudios.com/weather/foreca_proxy/cmd\"\n)\n\nfunc main() {\n\tif err := cmd.RunRootCmd(); err != nil {\n\t\tpanic(err)\n\t}\n}\n", "n_tokens": 43, "primary_symbol": "main", "primary_kind": "function", "primary_span": [7, 12], "def_symbols": ["main"], "symbols": ["main", "package", "import", "impalastudios", "com", "weather", "foreca_proxy", "cmd", "func", "err", "RunRootCmd", "nil", "panic"], "doc_head": "package main\nimport (\n\t\"go.impalastudios.com/weather/foreca_proxy/cmd\"\n)\nfunc main() {\n\tif err := cmd.RunRootCmd(); err != nil {\n\t\tpanic(err)\n\t}\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:main", "package": "main", "node_kind": "function", "receiver": "", "function_name": "main", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["RunRootCmd", "cmd.RunRootCmd", "go.impalastudios"], "header_context_minimal": "package main", "summary_llm": "This code is a simple HTTP server in Go that listens on port 8080 and responds to GET requests with a 'Hello, World!' message.", "keywords_llm": ["go", "http", "server", "port 8080", "get request", "response", "hello, world!", "net/http", "listenandserve", "handlerfunc"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/cmd/root.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/cmd/root.go", "rel_path": "cmd/root.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 51, "text": "package cmd\n\nimport (\n\t\"go.impalastudios.com/weather/foreca_proxy/cmd/serve\"\n\t\"strings\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n)\n\n// RunRootCmd entrypoint of the root command\nfunc RunRootCmd() error {\n\tviper.AutomaticEnv()\n\tviper.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\", \"-\", \"_\"))\n\n\tcmd := &cobra.Command{\n\t\tUse:     \"weather-foreca-proxy\",\n\t\tShort:   \"[Weather] Foreca Proxy Microservice\",\n\t\tVersion: \"1.0.0\",\n\t}\n\n\tcmd.AddCommand(serve.New())\n\n\tcmd.PersistentFlags().Bool(\"logging.debug\", false, \"Whether to emit debug level logs or not.\")\n\tcmd.PersistentFlags().String(\"logging.encoding\", \"json\", \"The log encoding strategy.\")\n\tcmd.PersistentFlags().StringP(\"app.name\", \"n\", \"[Weather] Foreca Proxy\", \"The application name.\")\n\n\tcmd.PersistentFlags().String(\"foreca.endpoint-url\", \"https://pfa.foreca.com/data\", \"The provider endpoint.\")\n\tcmd.PersistentFlags().String(\"foreca.requests-per-second\", \"200\", \"The rate limit applied to Foreca.\")\n\tcmd.PersistentFlags().String(\"foreca.expiration-duration\", \"30m\", \"The amount of time an already requested forecast should be considered fresh.\")\n\tcmd.PersistentFlags().String(\"foreca.query.default.format\", \"xml/itwcalculator-jun17pres\", \"The default value for format query param.\")\n\tcmd.PersistentFlags().String(\"foreca.query.default.ftimes\", \"240/24h/0,240/1h\", \"The default times to request the forecasts about.\")\n\tcmd.PersistentFlags().String(\"foreca.query.default.temp-unit\", \"C\", \"The default temperature unit.\")\n\tcmd.PersistentFlags().String(\"foreca.query.default.wind-unit\", \"KMH\", \"The default wind speed unit.\")\n\tcmd.PersistentFlags().String(\"foreca.query.default.lang\", \"en\", \"The locale of the forecast's descriptions.\")\n\n\tcmd.PersistentFlags().String(\"mappings.dynamodb.table-name\", \"\", \"The DynamoDB table name.\")\n\n\tcmd.PersistentFlags().String(\"memcached.address\", \"\", \"The DynamoDB table name.\")\n\n\tcmd.PersistentFlags().String(\"aws.access-key-id\", \"\", \"The AWS access key ID.\")\n\tcmd.PersistentFlags().String(\"aws.secret-access-key\", \"\", \"The AWS secret access key.\")\n\tcmd.PersistentFlags().String(\"aws.session-token\", \"\", \"The AWS session token.\")\n\tcmd.PersistentFlags().String(\"aws.endpoint-url\", \"\", \"The AWS endpoint.\")\n\tcmd.PersistentFlags().String(\"aws.region\", \"\", \"The AWS region.\")\n\n\t_ = viper.BindPFlags(cmd.PersistentFlags())\n\n\treturn cmd.Execute()\n}\n", "n_tokens": 558, "primary_symbol": "RunRootCmd", "primary_kind": "function", "primary_span": [12, 51], "def_symbols": ["RunRootCmd"], "symbols": ["RunRootCmd", "package", "cmd", "import", "impalastudios", "com", "weather", "foreca_proxy", "serve", "strings", "github", "spf13", "cobra", "viper", "entrypoint", "the", "root", "command", "func", "error", "AutomaticEnv", "SetEnvKeyReplacer", "NewReplacer", "Command", "Use", "foreca", "proxy", "Short", "Weather", "Foreca", "Proxy", "Microservice", "Version", "AddCommand", "New", "PersistentFlags", "Bool", "logging", "debug", "false", "Whether", "emit", "level", "logs", "not", "String", "encoding", "json", "The", "log", "strategy", "StringP", "app", "name", "application", "endpoint", "url", "https", "pfa", "data", "provider", "requests", "per", "second", "rate", "limit", "applied", "expiration", "duration", "amount", "time", "already", "requested", "forecast", "should", "considered", "fresh", "query", "default", "format", "xml", "itwcalculator", "jun17pres", "value", "for", "param", "ftimes", "times", "request", "forecasts", "about", "temp", "unit", "temperature", "wind", "KMH", "speed", "lang", "locale", "descriptions", "mappings", "dynamodb", "table", "DynamoDB", "memcached", "address", "aws", "access", "key", "AWS", "secret", "session", "token", "region", "BindPFlags", "return", "Execute"], "doc_head": "package cmd\nimport (\n\t\"go.impalastudios.com/weather/foreca_proxy/cmd/serve\"\n\t\"strings\"\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n)\n// RunRootCmd entrypoint of the root command\nfunc RunRootCmd() error {\n\tviper.AutomaticEnv()\n\tviper.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\", \"-\", \"_\"))\n\tcmd := &cobra.Command{\n\t\tUse:     \"weather-foreca-proxy\",\n\t\tShort:   \"[Weather] Foreca Proxy Microservice\",\n\t\tVersion: \"1.0.0\",\n\t}\n\tcmd.AddCommand(serve.New())\n\tcmd.PersistentFlags().Bool(\"logging.debug\", false, \"Whether to emit debug level logs or not.\")\n\tcmd.PersistentFlags().String(\"logging.encoding\", \"json\", \"The log encoding strategy.\")\n\tcmd.PersistentFlags().StringP(\"app.name\", \"n\", \"[Weather] Foreca Proxy\", \"The application name.\")\n\tcmd.PersistentFlags().String(\"foreca.endpoint-url\", \"https://pfa.foreca.com/data\", \"The provider endpoint.\")\n\tcmd.PersistentFlags().String(\"foreca.requests-per-second\", \"200\", \"The rate limit applied to Foreca.\")\n\tcmd.PersistentFlags().String(\"foreca.expiration-duration\", \"30m\", \"The amount of time an already requested forecast should be considered fresh.\")\n\tcmd.PersistentFlags().String(\"foreca.query.default.format\", \"xml/itwcalculator-jun17pres\", \"Th", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:RunRootCmd", "package": "cmd", "node_kind": "function", "receiver": "", "function_name": "RunRootCmd", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["AWS", "AddCommand", "AutomaticEnv", "BindPFlags", "Bool", "C", "Command", "DynamoDB", "Execute", "Foreca", "ID", "KMH", "Microservice", "New", "NewReplacer", "PersistentFlags", "Proxy", "RunRootCmd", "SetEnvKeyReplacer", "Short", "String", "StringP", "The", "Use", "Version", "Weather", "Whether", "app.name", "aws.access", "aws.endpoint", "aws.region", "aws.secret", "aws.session", "cmd.AddCommand", "cmd.Execute", "cmd.PersistentFlags", "cobra.Command", "default.format", "default.ftimes", "default.lang", "default.temp", "default.wind", "foreca.endpoint", "foreca.expiration", "foreca.query", "foreca.requests", "github.com", "go.impalastudios", "logging.debug", "logging.encoding", "mappings.dynamodb", "memcached.address", "pfa.foreca", "serve.New", "strings.NewReplacer", "viper.AutomaticEnv", "viper.BindPFlags", "viper.SetEnvKeyReplacer"], "header_context_minimal": "package cmd", "summary_llm": "This Go code defines the entry point for a weather proxy microservice using Cobra and Viper. It sets up command-line flags for configuration, binds them to Viper, and executes the root command.", "keywords_llm": ["cobra", "viper", "command-line flags", "configuration", "bindpflags", "execute", "weather-foreca-proxy", "microservice"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/cmd/serve/grpc.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/cmd/serve/grpc.go", "rel_path": "cmd/serve/grpc.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 95, "text": "package serve\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/dropbox/godropbox/memcache\"\n\t\"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors\"\n\t\"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging\"\n\t\"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/recovery\"\n\tlru \"github.com/hashicorp/golang-lru/v2\"\n\t\"go.impalastudios.com/log\"\n\txotel \"go.impalastudios.com/otel\"\n\trequestid \"go.impalastudios.com/requestid/grpc\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters/clients\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/aws\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/cache\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit\"\n\totelgrpctrace \"go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/propagation\"\n\t\"go.uber.org/zap\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n\totelgrpcmetric \"go.impalastudios.com/otel/grpc\"\n\tgrpcv0 \"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters/handlers/grpc/v0\"\n\tpbv0 \"go.impalastudios.com/weather/foreca_proxy/pkg/pb/v0\"\n\t\"go.opentelemetry.io/contrib/instrumentation/github.com/aws/aws-sdk-go-v2/otelaws\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc InterceptorLogger(l *zap.Logger) logging.Logger {\n\treturn logging.LoggerFunc(func(ctx context.Context, lvl logging.Level, msg string, fields ...any) {\n\t\tf := make([]zap.Field, 0, len(fields)/2)\n\n\t\tfor i := 0; i < len(fields); i += 2 {\n\t\t\tkey := fields[i]\n\t\t\tvalue := fields[i+1]\n\n\t\t\tswitch v := value.(type) {\n\t\t\tcase string:\n\t\t\t\tf = append(f, zap.String(key.(string), v))\n\t\t\tcase int:\n\t\t\t\tf = append(f, zap.Int(key.(string), v))\n\t\t\tcase bool:\n\t\t\t\tf = append(f, zap.Bool(key.(string), v))\n\t\t\tdefault:\n\t\t\t\tf = append(f, zap.Any(key.(string), v))\n\t\t\t}\n\t\t}\n\n\t\tlogger := l.With(f...)\n\n\t\tswitch lvl {\n\t\tcase logging.LevelDebug:\n\t\t\tlogger.Debug(msg)\n\t\tcase logging.LevelInfo:\n\t\t\tlogger.Info(msg)\n\t\tcase logging.LevelWarn:\n\t\t\tlogger.Warn(msg)\n\t\tcase logging.LevelError:\n\t\t\tlogger.Error(msg)\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"unknown level %v\", lvl))\n\t\t}\n\t})\n}\n\nfunc newServeGrpcCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"grpc\",\n\t\tShort: \"Start gRPC server.\",\n\t\tPreRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\treturn viper.BindPFlags(cmd.Flags())\n\t\t},\n\t\tRunE: runServeGrpc,\n\t\tArgs: cobra.ExactArgs(0),\n\t}\n\n\tcmd.PersistentFlags().Int(\"app.grpc.port\", 50051, \"gRPC service port\")\n\n\treturn cmd\n}\n", "n_tokens": 821, "primary_symbol": "InterceptorLogger", "primary_kind": "function", "primary_span": [43, 95], "def_symbols": ["InterceptorLogger", "newServeGrpcCommand"], "symbols": ["InterceptorLogger", "newServeGrpcCommand", "package", "serve", "import", "context", "fmt", "github", "com", "dropbox", "godropbox", "memcache", "grpc", "ecosystem", "middleware", "interceptors", "logging", "recovery", "lru", "hashicorp", "golang", "impalastudios", "log", "xotel", "otel", "requestid", "weather", "foreca_proxy", "internal", "foreca", "adapters", "clients", "pkg", "aws", "cache", "ratelimit", "otelgrpctrace", "opentelemetry", "contrib", "instrumentation", "google", "org", "otelgrpc", "propagation", "uber", "zap", "codes", "metadata", "status", "net", "http", "time", "cockroachdb", "errors", "spf13", "cobra", "viper", "otelgrpcmetric", "grpcv0", "handlers", "pbv0", "sdk", "otelaws", "reflection", "func", "Logger", "return", "LoggerFunc", "ctx", "Context", "lvl", "Level", "msg", "string", "fields", "any", "make", "Field", "len", "for", "key", "value", "switch", "type", "case", "append", "String", "int", "Int", "bool", "Bool", "default", "Any", "logger", "With", "LevelDebug", "Debug", "LevelInfo", "Info", "LevelWarn", "Warn", "LevelError", "Error", "panic", "Sprintf", "unknown", "level", "Command", "cmd", "Use", "Short", "Start", "gRPC", "server", "PreRunE", "error", "BindPFlags", "Flags", "RunE", "runServeGrpc", "Args", "ExactArgs", "PersistentFlags", "app", "port", "service"], "doc_head": "package serve\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/dropbox/godropbox/memcache\"\n\t\"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors\"\n\t\"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging\"\n\t\"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/recovery\"\n\tlru \"github.com/hashicorp/golang-lru/v2\"\n\t\"go.impalastudios.com/log\"\n\txotel \"go.impalastudios.com/otel\"\n\trequestid \"go.impalastudios.com/requestid/grpc\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters/clients\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/aws\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/cache\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit\"\n\totelgrpctrace \"go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/propagation\"\n\t\"go.uber.org/zap\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n\t\"net/http\"\n\t\"time\"\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/v", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:InterceptorLogger", "package": "serve", "node_kind": "function", "receiver": "", "function_name": "InterceptorLogger", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": ["go.uber.org/zap"], "symbols_referenced_strict": ["Any", "Args", "BindPFlags", "Bool", "Command", "Context", "Debug", "Error", "ExactArgs", "Field", "Flags", "Info", "Int", "InterceptorLogger", "Level", "LevelDebug", "LevelError", "LevelInfo", "LevelWarn", "Logger", "LoggerFunc", "PersistentFlags", "PreRunE", "RunE", "Short", "Sprintf", "Start", "String", "Use", "Warn", "With", "app.grpc", "cmd.Flags", "cmd.PersistentFlags", "cobra.Command", "cobra.ExactArgs", "context.Context", "fmt.Sprintf", "github.com", "go.impalastudios", "go.opentelemetry", "go.uber", "google.golang", "l.With", "logger.Debug", "logger.Error", "logger.Info", "logger.Warn", "logging.Level", "logging.LevelDebug", "logging.LevelError", "logging.LevelInfo", "logging.LevelWarn", "logging.Logger", "logging.LoggerFunc", "viper.BindPFlags", "zap.Any", "zap.Bool", "zap.Field", "zap.Int", "zap.Logger", "zap.String"], "header_context_minimal": "package serve\nimport \"go.uber.org/zap\"", "summary_llm": "This Go code defines a gRPC server using the cobra package for command-line interaction and the zap logging library for logging. The InterceptorLogger function creates a logging middleware that logs messages at different levels (debug, info, warn, error) based on the logging level provided.", "keywords_llm": ["cobra", "grpc", "logging", "interceptorlogger", "zap", "prerune", "runservegrpc", "persistentflags", "bindpflags"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/cmd/serve/grpc.go#2", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/cmd/serve/grpc.go", "rel_path": "cmd/serve/grpc.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 96, "end_line": 250, "text": "func runServeGrpc(cmd *cobra.Command, _ []string) error {\n\tquit := make(chan os.Signal, 1)\n\tdefer close(quit)\n\n\tlogger := log.New(\n\t\tlog.WithService(viper.GetString(\"app.name\")),\n\t\tlog.WithEncoding(viper.GetString(\"logging.encoding\")),\n\t\tlog.WithDebugEnabled(viper.GetBool(\"logging.debug\")),\n\t)\n\tlog.SetLogger(logger)\n\n\ttp, err := xotel.NewTracerProvider(cmd.Context(), xotel.TracerProviderConfig{\n\t\tServiceName: viper.GetString(\"app.name\"),\n\t\tEndpoint:    viper.GetString(\"otel.tracer.endpoint\"),\n\t})\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to create tracer provider\")\n\t}\n\n\totel.SetTracerProvider(tp)\n\totel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{}))\n\txotel.SetGlobalTracer(tp.Tracer(viper.GetString(\"app.name\")))\n\n\tmp, err := xotel.NewMeterProvider(cmd.Context(), xotel.MeterProviderConfig{\n\t\tServiceName: viper.GetString(\"app.name\"),\n\t\tEndpoint:    viper.GetString(\"otel.meter.endpoint\"),\n\t\tInterval:    viper.GetDuration(\"otel.meter.interval\"),\n\t})\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to create meter provider\")\n\t}\n\n\totel.SetMeterProvider(mp)\n\txotel.SetGlobalMeter(mp.Meter(viper.GetString(\"app.name\")))\n\n\tawsCfg := aws.GetConfig(\n\t\tviper.GetString(\"aws.access-key-id\"),\n\t\tviper.GetString(\"aws.secret-access-key\"),\n\t\tviper.GetString(\"aws.session-token\"),\n\t\tviper.GetString(\"aws.region\"),\n\t\tviper.GetString(\"aws.endpoint-url\"),\n\t)\n\totelaws.AppendMiddlewares(&awsCfg.APIOptions)\n\n\tddb := aws.NewDynamoDbClientFromConfig(awsCfg)\n\n\tmappingsCache, err := lru.New[int, *foreca.Mapping](5_000)\n\tif err != nil {\n\t\tlogger.Panic(err.Error())\n\t}\n\n\tmappingsRepository := adapters.NewMappingDynamoDBRepository(\n\t\tviper.GetString(\"mappings.dynamodb.table-name\"),\n\t\tddb,\n\t\tmappingsCache,\n\t)\n\n\tmemcachedRateLimiterConn, err := net.Dial(\"tcp\", viper.GetString(\"memcached.address\"))\n\tif err != nil {\n\t\tlogger.Panic(err.Error())\n\t}\n\n\tlimiter := ratelimit.NewSingleThreadLimiter(\n\t\tviper.GetInt64(\"foreca.requests-per-second\"),\n\t\ttime.Second,\n\t\tratelimit.NewMemcachedStorage(memcache.NewRawBinaryClient(0, memcachedRateLimiterConn), \"weather:proxies:\"),\n\t)\n\n\tlimiter.Start()\n\n\tforecaClient := clients.NewForecaClient(\n\t\t&http.Client{Timeout: 5 * time.Second},\n\t\tviper.GetString(\"foreca.endpoint-url\"),\n\t\tmap[string]string{\n\t\t\t\"format\":   viper.GetString(\"foreca.query.default.format\"),\n\t\t\t\"ftimes\":   viper.GetString(\"foreca.query.default.ftimes\"),\n\t\t\t\"tempunit\": viper.GetString(\"foreca.query.default.temp-unit\"),\n\t\t\t\"windunit\": viper.GetString(\"foreca.query.default.wind-unit\"),\n\t\t\t\"lang\":     viper.GetString(\"foreca.query.default.lang\"),\n\t\t},\n\t\tlimiter,\n\t\tclients.NewTransformer(),\n\t)\n\n\tmemcachedForecastsConn, err := net.Dial(\"tcp\", viper.GetString(\"memcached.address\"))\n\tforecastService := foreca.NewService(\n\t\tforecaClient,\n\t\tmappingsRepository,\n\t\tcache.NewMemcached(memcache.NewRawBinaryClient(1, memcachedForecastsConn)),\n\t\t\"weather:proxies:foreca:\",\n\t\tviper.GetDuration(\"foreca.expiration-duration\"),\n\t)\n\n\trecoveryOpts := []recovery.Option{\n\t\trecovery.WithRecoveryHandler(func(p any) error {\n\t\t\treturn status.Error(codes.Internal, \"We cannot serve your request right now. Please try again later.\")\n\t\t}),\n\t}\n\tloggingOpts := []logging.Option{\n\t\tlogging.WithLogOnEvents(logging.StartCall),\n\t\tlogging.WithFieldsFromContextAndCallMeta(func(ctx context.Context, c interceptors.CallMeta) logging.Fields {\n\t\t\tvar requestID string\n\t\t\tif md, ok := metadata.FromIncomingContext(ctx); ok {\n\t\t\t\tif m, found := md[requestid.MetadataKey]; found && len(m) > 0 {\n\t\t\t\t\trequestID = m[0]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn logging.Fields{\"request_id\", requestID}\n\t\t}),\n\t}\n\tserver := grpc.NewServer(\n\t\tgrpc.StatsHandler(otelgrpctrace.NewServerHandler()),\n\t\tgrpc.ChainUnaryInterceptor(\n\t\t\totelgrpcmetric.UnaryServerInterceptor(),\n\t\t\trequestid.NewServerUnaryInterceptor(),\n\t\t\tlogging.UnaryServerInterceptor(InterceptorLogger(logger), loggingOpts...),\n\t\t\trecovery.UnaryServerInterceptor(recoveryOpts...),\n\t\t),\n\t\tgrpc.ChainStreamInterceptor(\n\t\t\totelgrpcmetric.StreamServerInterceptor(),\n\t\t),\n\t)\n\tserverV0 := grpcv0.NewServer(forecastService)\n\tpbv0.RegisterForecaProxyServer(server, serverV0)\n\n\treflection.Register(server)\n\n\tlistener, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", viper.GetInt(\"app.grpc.port\")))\n\tif err != nil {\n\t\tlogger.Panic(err.Error())\n\t}\n\n\tgo func(s *grpc.Server, lis *net.Listener) {\n\t\tlogger.Info(\"Server started. Ready to accept incoming requests...\")\n\t\tif err := s.Serve(*lis); err != nil {\n\t\t\tlogger.Fatal(fmt.Sprintf(\"Failed to serve gRPC: %v\", err))\n\t\t}\n\t}(server, &listener)\n\n\ts := <-quit\n\tlogger.Info(fmt.Sprintf(\"Received signal %v\", s))\n\n\tserver.GracefulStop()\n\tlimiter.Stop()\n\tif err := tp.Shutdown(cmd.Context()); err != nil {\n\t\tlog.Error(context.TODO(), \"Error occurred while shutting down the tracer.\", zap.Error(err))\n\t}\n\n\tclose(quit)\n\n\tlogger.Info(\"Application shutdown gracefully.\")\n\n\treturn nil\n}\n", "n_tokens": 1242, "primary_symbol": "runServeGrpc", "primary_kind": "function", "primary_span": [96, 250], "def_symbols": ["runServeGrpc"], "symbols": ["runServeGrpc", "func", "cmd", "cobra", "Command", "string", "error", "quit", "make", "chan", "Signal", "defer", "close", "logger", "log", "New", "WithService", "viper", "GetString", "app", "name", "WithEncoding", "logging", "encoding", "WithDebugEnabled", "GetBool", "debug", "SetLogger", "err", "xotel", "NewTracerProvider", "Context", "TracerProviderConfig", "ServiceName", "Endpoint", "otel", "tracer", "endpoint", "nil", "return", "errors", "Wrap", "failed", "create", "provider", "SetTracerProvider", "SetTextMapPropagator", "propagation", "NewCompositeTextMapPropagator", "TraceContext", "Baggage", "SetGlobalTracer", "Tracer", "NewMeterProvider", "MeterProviderConfig", "meter", "Interval", "GetDuration", "interval", "SetMeterProvider", "SetGlobalMeter", "Meter", "awsCfg", "aws", "GetConfig", "access", "key", "secret", "session", "token", "region", "url", "otelaws", "AppendMiddlewares", "APIOptions", "ddb", "NewDynamoDbClientFromConfig", "mappingsCache", "lru", "int", "foreca", "Mapping", "Panic", "Error", "mappingsRepository", "adapters", "NewMappingDynamoDBRepository", "mappings", "dynamodb", "table", "memcachedRateLimiterConn", "net", "Dial", "tcp", "memcached", "address", "limiter", "ratelimit", "NewSingleThreadLimiter", "GetInt64", "requests", "per", "second", "time", "Second", "NewMemcachedStorage", "memcache", "NewRawBinaryClient", "weather", "proxies", "Start", "forecaClient", "clients", "NewForecaClient", "http", "Client", "Timeout", "map", "format", "query", "default", "ftimes", "tempunit", "temp", "unit", "windunit", "wind", "lang", "NewTransformer", "memcachedForecastsConn", "forecastService", "NewService", "cache", "NewMemcached", "expiration", "duration", "recoveryOpts", "recovery", "Option", "WithRecoveryHandler", "any", "status", "codes", "Internal", "cannot", "serve", "your", "request", "right", "now", "Please", "try", "again", "later", "loggingOpts", "WithLogOnEvents", "StartCall", "WithFieldsFromContextAndCallMeta", "ctx", "context", "interceptors", "CallMeta", "Fields", "var", "requestID", "metadata", "FromIncomingContext", "found", "requestid", "MetadataKey", "len", "request_id", "server", "grpc", "NewServer", "StatsHandler", "otelgrpctrace", "NewServerHandler", "ChainUnaryInterceptor", "otelgrpcmetric", "UnaryServerInterceptor", "NewServerUnaryInterceptor", "InterceptorLogger", "ChainStreamInterceptor", "StreamServerInterceptor", "serverV0", "grpcv0", "pbv0", "RegisterForecaProxyServer", "reflection", "Register", "listener", "Listen", "fmt", "Sprintf", "GetInt", "port", "Server", "lis", "Listener", "Info", "started", "Ready", "accept", "incoming", "Serve", "Fatal", "Failed", "gRPC", "Received", "signal", "GracefulStop", "Stop", "Shutdown", "TODO", "occurred", "while", "shutting", "down", "the", "zap", "Application", "shutdown", "gracefully"], "doc_head": "func runServeGrpc(cmd *cobra.Command, _ []string) error {\n\tquit := make(chan os.Signal, 1)\n\tdefer close(quit)\n\tlogger := log.New(\n\t\tlog.WithService(viper.GetString(\"app.name\")),\n\t\tlog.WithEncoding(viper.GetString(\"logging.encoding\")),\n\t\tlog.WithDebugEnabled(viper.GetBool(\"logging.debug\")),\n\t)\n\tlog.SetLogger(logger)\n\ttp, err := xotel.NewTracerProvider(cmd.Context(), xotel.TracerProviderConfig{\n\t\tServiceName: viper.GetString(\"app.name\"),\n\t\tEndpoint:    viper.GetString(\"otel.tracer.endpoint\"),\n\t})\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to create tracer provider\")\n\t}\n\totel.SetTracerProvider(tp)\n\totel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{}))\n\txotel.SetGlobalTracer(tp.Tracer(viper.GetString(\"app.name\")))\n\tmp, err := xotel.NewMeterProvider(cmd.Context(), xotel.MeterProviderConfig{\n\t\tServiceName: viper.GetString(\"app.name\"),\n\t\tEndpoint:    viper.GetString(\"otel.meter.endpoint\"),\n\t\tInterval:    viper.GetDuration(\"otel.meter.interval\"),\n\t})\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to create meter provider\")\n\t}\n\totel.SetMeterProvider(mp)\n\txotel.SetGlobalMeter(mp.Meter(viper.GetString(\"app.name\")))\n", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:runServeGrpc", "package": "", "node_kind": "function", "receiver": "", "function_name": "runServeGrpc", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": ["go.impalastudios.com/otel", "go.uber.org/zap", "time"], "symbols_referenced_strict": ["APIOptions", "AppendMiddlewares", "Application", "Baggage", "CallMeta", "ChainStreamInterceptor", "ChainUnaryInterceptor", "Client", "Command", "Context", "Dial", "Endpoint", "Error", "Failed", "Fatal", "Fields", "FromIncomingContext", "GetBool", "GetConfig", "GetDuration", "GetInt", "GetInt64", "GetString", "GracefulStop", "Info", "InterceptorLogger", "Internal", "Interval", "Listen", "Listener", "Mapping", "MetadataKey", "Meter", "MeterProviderConfig", "New", "NewCompositeTextMapPropagator", "NewDynamoDbClientFromConfig", "NewForecaClient", "NewMappingDynamoDBRepository", "NewMemcached", "NewMemcachedStorage", "NewMeterProvider", "NewRawBinaryClient", "NewServer", "NewServerHandler", "NewServerUnaryInterceptor", "NewService", "NewSingleThreadLimiter", "NewTracerProvider", "NewTransformer", "Option", "Panic", "Please", "Ready", "Received", "Register", "RegisterForecaProxyServer", "Second", "Serve", "Server", "ServiceName", "SetGlobalMeter", "SetGlobalTracer", "SetLogger", "SetMeterProvider", "SetTextMapPropagator", "SetTracerProvider", "Shutdown", "Signal", "Sprintf", "Start", "StartCall", "StatsHandler", "Stop", "StreamServerInterceptor", "TODO", "Timeout", "TraceContext", "Tracer", "TracerProviderConfig", "UnaryServerInterceptor", "We", "WithDebugEnabled", "WithEncoding", "WithFieldsFromContextAndCallMeta", "WithLogOnEvents", "WithRecoveryHandler", "WithService", "Wrap", "adapters.NewMappingDynamoDBRepository", "app.grpc", "app.name", "aws.GetConfig", "aws.NewDynamoDbClientFromConfig", "aws.access", "aws.endpoint", "aws.region", "aws.secret", "aws.session", "awsCfg.APIOptions", "cache.NewMemcached", "clients.NewForecaClient", "clients.NewTransformer", "cmd.Context", "cobra.Command", "codes.Internal", "context.Context", "context.TODO", "default.format", "default.ftimes", "default.lang", "default.temp", "default.wind", "err.Error", "errors.Wrap", "fmt.Sprintf", "foreca.Mapping", "foreca.NewService", "foreca.endpoint", "foreca.expiration", "foreca.query", "foreca.requests", "grpc.ChainStreamInterceptor", "grpc.ChainUnaryInterceptor", "grpc.NewServer", "grpc.Server", "grpc.StatsHandler", "grpcv0.NewServer", "http.Client", "interceptors.CallMeta", "limiter.Start", "limiter.Stop", "log.Error", "log.New", "log.SetLogger", "log.WithDebugEnabled", "log.WithEncoding", "log.WithService", "logger.Fatal", "logger.Info", "logger.Panic", "logging.Fields", "logging.Option", "logging.StartCall", "logging.UnaryServerInterceptor", "logging.WithFieldsFromContextAndCallMeta", "logging.WithLogOnEvents", "logging.debug", "logging.encoding", "lru.New", "mappings.dynamodb", "memcache.NewRawBinaryClient", "memcached.address", "metadata.FromIncomingContext", "mp.Meter", "net.Dial", "net.Listen", "net.Listener", "os.Signal", "otel.SetMeterProvider", "otel.SetTextMapPropagator", "otel.SetTracerProvider", "otel.meter", "otel.tracer", "otelaws.AppendMiddlewares", "otelgrpcmetric.StreamServerInterceptor", "otelgrpcmetric.UnaryServerInterceptor", "otelgrpctrace.NewServerHandler", "pbv0.RegisterForecaProxyServer", "propagation.Baggage", "propagation.NewCompositeTextMapPropagator", "propagation.TraceContext", "ratelimit.NewMemcachedStorage", "ratelimit.NewSingleThreadLimiter", "recovery.Option", "recovery.UnaryServerInterceptor", "recovery.WithRecoveryHandler", "reflection.Register", "requestid.MetadataKey", "requestid.NewServerUnaryInterceptor", "s.Serve", "server.GracefulStop", "status.Error", "time.Second", "tp.Shutdown", "tp.Tracer", "viper.GetBool", "viper.GetDuration", "viper.GetInt", "viper.GetInt64", "viper.GetString", "xotel.MeterProviderConfig", "xotel.NewMeterProvider", "xotel.NewTracerProvider", "xotel.SetGlobalMeter", "xotel.SetGlobalTracer", "xotel.TracerProviderConfig", "zap.Error"], "header_context_minimal": "package \nimport (\n    \"go.impalastudios.com/otel\"\n    \"go.uber.org/zap\"\n    \"time\"\n)", "summary_llm": "This code defines a function to serve gRPC requests. It configures logging, tracing, and metrics, initializes clients and repositories, sets up rate limiting, and starts a gRPC server that registers and handles specific services.", "keywords_llm": ["grpc", "logging", "tracing", "metrics", "clients", "repositories", "rate limiting", "server setup"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/cmd/serve/root.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/cmd/serve/root.go", "rel_path": "cmd/serve/root.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "package serve\n\nimport (\n\t\"github.com/spf13/cobra\"\n\t\"time\"\n)\n\nfunc New() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"serve\",\n\t\tShort: \"Serve\",\n\t}\n\n\tcmd.AddCommand(newServeGrpcCommand())\n\n\tcmd.PersistentFlags().String(\"otel.tracer.endpoint\", \"localhost:4317\", \"The URL of the tracing collector.\")\n\tcmd.PersistentFlags().String(\"otel.meter.endpoint\", \"localhost:4317\", \"The URL of the tracing collector.\")\n\tcmd.PersistentFlags().Duration(\"otel.meter.interval\", 60*time.Second, \"The interval which the metrics will be reported to the collector.\")\n\n\treturn cmd\n}\n", "n_tokens": 139, "primary_symbol": "New", "primary_kind": "function", "primary_span": [8, 22], "def_symbols": ["New"], "symbols": ["New", "package", "serve", "import", "github", "com", "spf13", "cobra", "time", "func", "Command", "cmd", "Use", "Short", "Serve", "AddCommand", "newServeGrpcCommand", "PersistentFlags", "String", "otel", "tracer", "endpoint", "localhost", "The", "URL", "the", "tracing", "collector", "meter", "Duration", "interval", "Second", "which", "metrics", "will", "reported", "return"], "doc_head": "package serve\nimport (\n\t\"github.com/spf13/cobra\"\n\t\"time\"\n)\nfunc New() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"serve\",\n\t\tShort: \"Serve\",\n\t}\n\tcmd.AddCommand(newServeGrpcCommand())\n\tcmd.PersistentFlags().String(\"otel.tracer.endpoint\", \"localhost:4317\", \"The URL of the tracing collector.\")\n\tcmd.PersistentFlags().String(\"otel.meter.endpoint\", \"localhost:4317\", \"The URL of the tracing collector.\")\n\tcmd.PersistentFlags().Duration(\"otel.meter.interval\", 60*time.Second, \"The interval which the metrics will be reported to the collector.\")\n\treturn cmd\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:New", "package": "serve", "node_kind": "function", "receiver": "", "function_name": "New", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["AddCommand", "Command", "Duration", "New", "PersistentFlags", "Second", "Serve", "Short", "String", "The", "URL", "Use", "cmd.AddCommand", "cmd.PersistentFlags", "cobra.Command", "github.com", "otel.meter", "otel.tracer", "time.Second"], "header_context_minimal": "package serve\nimport \"time\"", "summary_llm": "The `New` function in the `serve` package creates a new Cobra command for serving and configures it with persistent flags for tracing and metering endpoints and intervals. It includes a subcommand for gRPC service.", "keywords_llm": ["cobra.command", "newservegrpccommand", "otel.tracer.endpoint", "otel.meter.endpoint", "otel.meter.interval", "time.second", "serve", "cmd.addcommand", "cmd.persistentflags", "duration"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/models.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/models.go", "rel_path": "internal/foreca/models.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 140, "text": "package foreca\n\ntype Mapping struct {\n\tID         int\n\tProviderID int\n\tTimezone   string\n}\n\ntype PressureTrend int\n\nconst (\n\tPressureTrendFalling = iota - 1\n\tPressureTrendSteady\n\tPressureTrendRising\n)\n\nfunc (t PressureTrend) String() string {\n\treturn [...]string{\"Falling\", \"Steady\", \"Rising\"}[t+1]\n}\n\ntype Pressure struct {\n\tMillibar float64       `json:\"mbar\"`\n\tTrend    PressureTrend `json:\"t\"`\n}\n\nfunc (p Pressure) IsFalling() bool {\n\treturn p.Trend == PressureTrendFalling\n}\n\nfunc (p Pressure) IsSteady() bool {\n\treturn p.Trend == PressureTrendSteady\n}\n\nfunc (p Pressure) IsRising() bool {\n\treturn p.Trend == PressureTrendRising\n}\n\nconst (\n\tWeatherCodeClear                 = \"clear\"\n\tWeatherCodeMostlySunny           = \"mostlysunny\"\n\tWeatherCodePartlyCloudy          = \"partlycloudy\"\n\tWeatherCodeMostlyCloudy          = \"mostlycloudy\"\n\tWeatherCodeCloudy                = \"cloudy\"\n\tWeatherCodeHazy                  = \"hazy\"\n\tWeatherCodeFog                   = \"fog\"\n\tWeatherCodeChanceOfRain          = \"chancerain\"\n\tWeatherCodeRain                  = \"rain\"\n\tWeatherCodeChanceOfThunderstorms = \"chancetstorms\"\n\tWeatherCodeThunderstorms         = \"tstorms\"\n\tWeatherCodeChanceOfSleet         = \"chancesleet\"\n\tWeatherCodeSleet                 = \"sleet\"\n\tWeatherCodeChanceOfSnow          = \"chancesnow\"\n\tWeatherCodeSnow                  = \"snow\"\n)\n\ntype WeatherCode string\n\ntype WeatherCondition struct {\n\tCode        WeatherCode `json:\"c\"`\n\tDescription string      `json:\"d\"`\n}\n\ntype WindDirection struct {\n\tAbbreviation string  `json:\"ab\"`\n\tDegrees      float64 `json:\"deg\"`\n}\n\ntype Wind struct {\n\tDirection *WindDirection `json:\"d\"`\n\tSpeed     float64        `json:\"s\"`\n}\n\ntype WindGust struct {\n\tWind *Wind   `json:\"w\"`\n\tGust float64 `json:\"g\"`\n}\n\ntype CurrentCondition struct {\n\tEpoch                    int64             `json:\"tms\"`\n\tVisibility               float64           `json:\"v\"`\n\tPrecipitation            float64           `json:\"pr\"`\n\tPrecipitationNextHour    float64           `json:\"prn\"`\n\tWeatherCondition         *WeatherCondition `json:\"wc\"`\n\tWeatherConditionNextHour *WeatherCondition `json:\"wcn\"`\n\tTemperature              float64           `json:\"t\"`\n\tTemperatureFeelsLike     float64           `json:\"tf\"`\n\tHumidityPercentage       int               `json:\"rh\"`\n\tWindGust                 *WindGust         `json:\"wg\"`\n\tDewPoint                 float64           `json:\"dw\"`\n\tHeatIndex                float64           `json:\"hi\"`\n\tPressure                 *Pressure         `json:\"p\"`\n\tUVIndex                  float64           `json:\"uvi\"`\n}\n\ntype DailyCondition struct {\n\tEpoch                     int64             `json:\"tms\"`\n\tMinTemperature            float64           `json:\"tn\"`\n\tMaxTemperature            float64           `json:\"tx\"`\n\tPrecipitation             float64           `json:\"pr\"`\n\tPrecipitationDay          float64           `json:\"pry\"`\n\tPrecipitationNight        float64           `json:\"prt\"`\n\tSnow                      float64           `json:\"s\"`\n\tSnowDay                   float64           `json:\"sy\"`\n\tSnowNight                 float64           `json:\"st\"`\n\tPrecipitationProbability  int               `json:\"pp\"`\n\tWind                      *Wind             `json:\"w\"`\n\tAverageHumidityPercentage int               `json:\"rhe\"`\n\tWeatherCondition          *WeatherCondition `json:\"wc\"`\n\tWeatherConditionNight     *WeatherCondition `json:\"wct\"`\n\tUVIndex                   float64           `json:\"uvi\"`\n\tSunriseEpoch              int64             `json:\"rise\"`\n\tSunsetEpoch               int64             `json:\"set\"`\n}\n\ntype HourlyCondition struct {\n\tEpoch                    int64             `json:\"tms\"`\n\tTemperature              float64           `json:\"t\"`\n\tTemperatureFeelsLike     float64           `json:\"tf\"`\n\tWeatherCondition         *WeatherCondition `json:\"wc\"`\n\tPrecipitation            float64           `json:\"pr\"`\n\tSnow                     float64           `json:\"s\"`\n\tPrecipitationProbability int               `json:\"pp\"`\n\tWind                     *Wind             `json:\"w\"`\n\tPressure                 *Pressure         `json:\"p\"`\n\tHumidityPercentage       int               `json:\"rh\"`\n\tUVIndex                  float64           `json:\"uvi\"`\n}\n\ntype Forecast struct {\n\tCurrentCondition *CurrentCondition  `json:\"cc\"`\n\tDailyConditions  []*DailyCondition  `json:\"dc\"`\n\tHourlyConditions []*HourlyCondition `json:\"hc\"`\n}\n\ntype CachedForecast struct {\n\tKey        string\n\tValue      []byte\n\tExpiration int32\n}\n", "n_tokens": 1084, "primary_symbol": "String", "primary_kind": "function", "primary_span": [17, 140], "def_symbols": ["String", "IsFalling", "IsSteady", "IsRising"], "symbols": ["String", "IsFalling", "IsSteady", "IsRising", "package", "foreca", "type", "Mapping", "struct", "int", "ProviderID", "Timezone", "string", "PressureTrend", "const", "PressureTrendFalling", "iota", "PressureTrendSteady", "PressureTrendRising", "func", "return", "Falling", "Steady", "Rising", "Pressure", "Millibar", "float64", "json", "mbar", "Trend", "bool", "WeatherCodeClear", "clear", "WeatherCodeMostlySunny", "mostlysunny", "WeatherCodePartlyCloudy", "partlycloudy", "WeatherCodeMostlyCloudy", "mostlycloudy", "WeatherCodeCloudy", "cloudy", "WeatherCodeHazy", "hazy", "WeatherCodeFog", "fog", "WeatherCodeChanceOfRain", "chancerain", "WeatherCodeRain", "rain", "WeatherCodeChanceOfThunderstorms", "chancetstorms", "WeatherCodeThunderstorms", "tstorms", "WeatherCodeChanceOfSleet", "chancesleet", "WeatherCodeSleet", "sleet", "WeatherCodeChanceOfSnow", "chancesnow", "WeatherCodeSnow", "snow", "WeatherCode", "WeatherCondition", "Code", "Description", "WindDirection", "Abbreviation", "Degrees", "deg", "Wind", "Direction", "Speed", "WindGust", "Gust", "CurrentCondition", "Epoch", "int64", "tms", "Visibility", "Precipitation", "PrecipitationNextHour", "prn", "WeatherConditionNextHour", "wcn", "Temperature", "TemperatureFeelsLike", "HumidityPercentage", "DewPoint", "HeatIndex", "UVIndex", "uvi", "DailyCondition", "MinTemperature", "MaxTemperature", "PrecipitationDay", "pry", "PrecipitationNight", "prt", "Snow", "SnowDay", "SnowNight", "PrecipitationProbability", "AverageHumidityPercentage", "rhe", "WeatherConditionNight", "wct", "SunriseEpoch", "rise", "SunsetEpoch", "set", "HourlyCondition", "Forecast", "DailyConditions", "HourlyConditions", "CachedForecast", "Key", "Value", "byte", "Expiration", "int32"], "doc_head": "package foreca\ntype Mapping struct {\n\tID         int\n\tProviderID int\n\tTimezone   string\n}\ntype PressureTrend int\nconst (\n\tPressureTrendFalling = iota - 1\n\tPressureTrendSteady\n\tPressureTrendRising\n)\nfunc (t PressureTrend) String() string {\n\treturn [...]string{\"Falling\", \"Steady\", \"Rising\"}[t+1]\n}\ntype Pressure struct {\n\tMillibar float64       `json:\"mbar\"`\n\tTrend    PressureTrend `json:\"t\"`\n}\nfunc (p Pressure) IsFalling() bool {\n\treturn p.Trend == PressureTrendFalling\n}\nfunc (p Pressure) IsSteady() bool {\n\treturn p.Trend == PressureTrendSteady\n}\nfunc (p Pressure) IsRising() bool {\n\treturn p.Trend == PressureTrendRising\n}\nconst (\n\tWeatherCodeClear                 = \"clear\"\n\tWeatherCodeMostlySunny           = \"mostlysunny\"\n\tWeatherCodePartlyCloudy          = \"partlycloudy\"\n\tWeatherCodeMostlyCloudy          = \"mostlycloudy\"\n\tWeatherCodeCloudy                = \"cloudy\"\n\tWeatherCodeHazy                  = \"hazy\"\n\tWeatherCodeFog                   = \"fog\"\n\tWeatherCodeChanceOfRain          = \"chancerain\"\n\tWeatherCodeRain                  = \"rain\"\n\tWeatherCodeChanceOfThunderstorms = \"chancetstorms\"\n\tWeatherCodeThunderstorms         = \"tstorms\"\n\tWeatherCodeChanceOfSleet         = \"chancesleet", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(t PressureTrend).String", "package": "foreca", "node_kind": "method", "receiver": "t PressureTrend", "function_name": "", "method_name": "String", "type_name": "Mapping", "type_kind": "struct", "imports_used_minimal": [], "symbols_referenced_strict": ["Abbreviation", "AverageHumidityPercentage", "CachedForecast", "Code", "CurrentCondition", "DailyCondition", "DailyConditions", "Degrees", "Description", "DewPoint", "Direction", "Epoch", "Expiration", "Falling", "Forecast", "Gust", "HeatIndex", "HourlyCondition", "HourlyConditions", "HumidityPercentage", "ID", "IsFalling", "IsRising", "IsSteady", "Key", "Mapping", "MaxTemperature", "Millibar", "MinTemperature", "Precipitation", "PrecipitationDay", "PrecipitationNextHour", "PrecipitationNight", "PrecipitationProbability", "Pressure", "PressureTrend", "PressureTrendFalling", "PressureTrendRising", "PressureTrendSteady", "ProviderID", "Rising", "Snow", "SnowDay", "SnowNight", "Speed", "Steady", "String", "SunriseEpoch", "SunsetEpoch", "Temperature", "TemperatureFeelsLike", "Timezone", "Trend", "UVIndex", "Value", "Visibility", "WeatherCode", "WeatherCodeChanceOfRain", "WeatherCodeChanceOfSleet", "WeatherCodeChanceOfSnow", "WeatherCodeChanceOfThunderstorms", "WeatherCodeClear", "WeatherCodeCloudy", "WeatherCodeFog", "WeatherCodeHazy", "WeatherCodeMostlyCloudy", "WeatherCodeMostlySunny", "WeatherCodePartlyCloudy", "WeatherCodeRain", "WeatherCodeSleet", "WeatherCodeSnow", "WeatherCodeThunderstorms", "WeatherCondition", "WeatherConditionNextHour", "WeatherConditionNight", "Wind", "WindDirection", "WindGust", "p.Trend"], "header_context_minimal": "package foreca\n// receiver: t PressureTrend", "summary_llm": "This Go code defines various data structures for weather forecasts, including `CurrentCondition`, `DailyCondition`, and `HourlyCondition`. It also includes types like `Pressure` and `Wind` to describe weather conditions in more detail. The `Mapping` type is used for provider-specific configurations. Each struct has a receiver method `String()` to provide human-readable representations.", "keywords_llm": ["weather", "forecast", "current condition", "daily condition", "hourly condition", "pressure", "wind", "mapping", "string"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/service.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/service.go", "rel_path": "internal/foreca/service.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 164, "text": "package foreca\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/pkg/errors\"\n\t\"go.impalastudios.com/log\"\n\txotel \"go.impalastudios.com/otel\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/cache\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/singleflight\"\n\t\"strings\"\n\t\"time\"\n)\n\n//go:generate /go/bin/mockgen -source=service.go -destination=mocks/service_mocks.go -package=mocks\ntype (\n\tproviderClient interface {\n\t\tGetForecastForLocation(ctx context.Context, id int, loc *time.Location) (*Forecast, error)\n\t}\n\n\tmappingsRepository interface {\n\t\tGet(ctx context.Context, id int) (*Mapping, error)\n\t}\n\n\tcacheClient interface {\n\t\tGet(key string) (*cache.Item, error)\n\t\tSet(key string, value []byte) error\n\t}\n)\n\ntype Service struct {\n\tsf                      singleflight.Group\n\tprovider                providerClient\n\tmappings                mappingsRepository\n\tcache                   cacheClient\n\tcacheKeyPrefix          string\n\tcacheExpirationDuration time.Duration\n}\n\nfunc NewService(provider providerClient, mappings mappingsRepository, cache cacheClient, cacheKeyPrefix string, cacheExpirationDuration time.Duration) *Service {\n\treturn &Service{\n\t\tprovider:                provider,\n\t\tmappings:                mappings,\n\t\tcache:                   cache,\n\t\tcacheKeyPrefix:          cacheKeyPrefix,\n\t\tcacheExpirationDuration: cacheExpirationDuration,\n\t}\n}\n\nfunc (s *Service) GetForecastForLocation(ctx context.Context, id int) (*Forecast, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"service:forecast-location\", trace.WithSpanKind(trace.SpanKindInternal))\n\tdefer span.End()\n\n\tspan.SetAttributes(attribute.Int(\"location_id\", id))\n\n\tmapping, err := s.mappings.Get(ctx, id)\n\tif err != nil {\n\t\tspan.SetStatus(codes.Error, \"Mapping not found.\")\n\t\tspan.RecordError(err)\n\n\t\tlog.Error(ctx, \"Cannot get mapping for location.\", zap.Int(\"id\", id), zap.Error(err))\n\n\t\tif errors.Is(err, ErrMappingNotFound) {\n\t\t\treturn nil, ErrLocationNotFound\n\t\t}\n\n\t\treturn nil, errors.Wrap(err, \"service: cannot get mapping\")\n\t}\n\n\tloc, err := time.LoadLocation(mapping.Timezone)\n\tif err != nil {\n\t\tspan.SetStatus(codes.Error, \"Unsupported timezone.\")\n\t\tspan.RecordError(err)\n\n\t\tlog.Error(ctx,\n\t\t\t\"Unsupported timezone.\",\n\t\t\tzap.Any(\"mapping\", mapping),\n\t\t\tzap.Error(err),\n\t\t)\n\t\treturn nil, errors.Wrap(err, \"service: unsupported timezone\")\n\t}\n\n\tresult, err, _ := s.sf.Do(s.getSingleFlightKey(mapping), func() (interface{}, error) {\n\t\ti, err := s.cache.Get(s.getCacheKeyForLocation(mapping.ProviderID))\n\n\t\tif err == nil {\n\t\t\tlog.Debug(ctx, \"Cache hit. Checking for freshness...\", zap.Int(\"id\", id))\n\t\t\tvar item expirableCacheItem\n\t\t\t_ = json.Unmarshal(i.Value, &item)\n\n\t\t\tif time.Now().UTC().Unix() < item.ExpiresAtUnix {\n\t\t\t\tspan.SetAttributes(attribute.Bool(\"cache_hit\", true))\n\n\t\t\t\tlog.Debug(ctx, \"Returning cached forecast.\", zap.Int(\"id\", id))\n\t\t\t\treturn item.Forecast, nil\n\t\t\t}\n\t\t}\n\n\t\tcacheHit := err != nil\n\t\tforecast, err := s.provider.GetForecastForLocation(ctx, mapping.ProviderID, loc)\n\t\tif err != nil {\n\t\t\tspan.SetAttributes(attribute.Bool(\"cache_hit\", cacheHit))\n\n\t\t\tlog.Error(ctx, \"Error occurred while retrieving forecast for location.\", zap.Any(\"mapping\", mapping), zap.Error(err))\n\n\t\t\tif errors.Is(err, ErrRequestThrottled) {\n\t\t\t\tif !cacheHit {\n\t\t\t\t\tlog.Error(ctx, \"Request throttled without a cache hit.\", zap.Any(\"mapping\", mapping), zap.Error(err))\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tlog.Info(ctx, \"Request throttled. Returning cached forecast.\", zap.Any(\"mapping\", mapping))\n\n\t\t\t\tspan.SetAttributes(attribute.Bool(\"stale\", true))\n\n\t\t\t\tvar item expirableCacheItem\n\t\t\t\t_ = json.Unmarshal(i.Value, &item)\n\t\t\t\treturn item.Forecast, nil\n\t\t\t}\n\n\t\t\treturn nil, err\n\t\t}\n\n\t\tb, err := json.Marshal(expirableCacheItem{\n\t\t\tExpiresAtUnix: time.Now().UTC().Add(s.cacheExpirationDuration).Unix(),\n\t\t\tForecast:      forecast,\n\t\t})\n\n\t\tif err != nil {\n\t\t\tlog.Error(ctx, \"Cannot marshal cache item.\", zap.Error(err))\n\t\t}\n\n\t\tlog.Debug(ctx, \"Caching forecast for location.\", zap.Any(\"mapping\", mapping))\n\n\t\terr = s.cache.Set(s.getCacheKeyForLocation(mapping.ProviderID), b)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx, \"Cannot cache response.\",\n\t\t\t\tzap.Any(\"mapping\", mapping),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t\treturn forecast, nil\n\t})\n\n\tif err != nil {\n\t\tspan.SetStatus(codes.Error, \"Error occurred while retrieving forecast for location.\")\n\t\tspan.RecordError(err)\n\n\t\tlog.Error(ctx, \"Error occurred while retrieving forecast for location.\", zap.Int(\"id\", id), zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\treturn result.(*Forecast), nil\n}\n\nfunc (s *Service) getCacheKeyForLocation(id int) string {\n\treturn fmt.Sprintf(\"%s:%d\", strings.Trim(s.cacheKeyPrefix, \":\"), id)\n}\n", "n_tokens": 1191, "primary_symbol": "NewService", "primary_kind": "function", "primary_span": [45, 164], "def_symbols": ["NewService", "GetForecastForLocation", "getCacheKeyForLocation"], "symbols": ["NewService", "GetForecastForLocation", "getCacheKeyForLocation", "package", "foreca", "import", "context", "encoding", "json", "fmt", "github", "com", "pkg", "errors", "impalastudios", "log", "xotel", "otel", "weather", "foreca_proxy", "cache", "opentelemetry", "attribute", "codes", "trace", "uber", "org", "zap", "golang", "sync", "singleflight", "strings", "time", "generate", "bin", "mockgen", "source", "service", "destination", "mocks", "service_mocks", "type", "providerClient", "interface", "ctx", "Context", "int", "loc", "Location", "Forecast", "error", "mappingsRepository", "Get", "Mapping", "cacheClient", "key", "string", "Item", "Set", "value", "byte", "Service", "struct", "Group", "provider", "mappings", "cacheKeyPrefix", "cacheExpirationDuration", "Duration", "func", "return", "span", "Tracer", "Start", "forecast", "location", "WithSpanKind", "SpanKindInternal", "defer", "End", "SetAttributes", "Int", "location_id", "mapping", "err", "nil", "SetStatus", "Error", "not", "found", "RecordError", "Cannot", "get", "for", "ErrMappingNotFound", "ErrLocationNotFound", "Wrap", "cannot", "LoadLocation", "Timezone", "Unsupported", "timezone", "Any", "unsupported", "result", "getSingleFlightKey", "ProviderID", "Debug", "Cache", "hit", "Checking", "freshness", "var", "item", "expirableCacheItem", "Unmarshal", "Value", "Now", "UTC", "Unix", "ExpiresAtUnix", "Bool", "cache_hit", "true", "Returning", "cached", "cacheHit", "occurred", "while", "retrieving", "ErrRequestThrottled", "Request", "throttled", "without", "Info", "stale", "Marshal", "Add", "marshal", "Caching", "response", "Sprintf", "Trim"], "doc_head": "package foreca\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/pkg/errors\"\n\t\"go.impalastudios.com/log\"\n\txotel \"go.impalastudios.com/otel\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/cache\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/singleflight\"\n\t\"strings\"\n\t\"time\"\n)\n//go:generate /go/bin/mockgen -source=service.go -destination=mocks/service_mocks.go -package=mocks\ntype (\n\tproviderClient interface {\n\t\tGetForecastForLocation(ctx context.Context, id int, loc *time.Location) (*Forecast, error)\n\t}\n\tmappingsRepository interface {\n\t\tGet(ctx context.Context, id int) (*Mapping, error)\n\t}\n\tcacheClient interface {\n\t\tGet(key string) (*cache.Item, error)\n\t\tSet(key string, value []byte) error\n\t}\n)\ntype Service struct {\n\tsf                      singleflight.Group\n\tprovider                providerClient\n\tmappings                mappingsRepository\n\tcache                   cacheClient\n\tcacheKeyPrefix          string\n\tcacheExpirationDuration time.Duration\n}\nfunc NewService(provider providerClient, mappings mappingsRepository, cache cacheClient, cacheKeyPrefix string, cacheExpirationDurat", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(s *Service).GetForecastForLocation", "package": "foreca", "node_kind": "method", "receiver": "s *Service", "function_name": "NewService", "method_name": "GetForecastForLocation", "type_name": "Service", "type_kind": "struct", "imports_used_minimal": ["encoding/json", "go.impalastudios.com/otel", "go.uber.org/zap", "golang.org/x/sync/singleflight", "time"], "symbols_referenced_strict": ["Add", "Any", "Bool", "Cache", "Caching", "Cannot", "Checking", "Context", "Debug", "Do", "Duration", "End", "ErrLocationNotFound", "ErrMappingNotFound", "ErrRequestThrottled", "Error", "ExpiresAtUnix", "Forecast", "Get", "GetForecastForLocation", "Group", "Info", "Int", "Is", "Item", "LoadLocation", "Location", "Mapping", "Marshal", "NewService", "Now", "ProviderID", "RecordError", "Request", "Returning", "Service", "Set", "SetAttributes", "SetStatus", "SpanKindInternal", "Sprintf", "Start", "Timezone", "Tracer", "Trim", "UTC", "Unix", "Unmarshal", "Unsupported", "Value", "WithSpanKind", "Wrap", "attribute.Bool", "attribute.Int", "cache.Item", "codes.Error", "context.Context", "errors.Is", "errors.Wrap", "fmt.Sprintf", "github.com", "go.impalastudios", "go.opentelemetry", "go.uber", "golang.org", "i.Value", "item.ExpiresAtUnix", "item.Forecast", "json.Marshal", "json.Unmarshal", "log.Debug", "log.Error", "log.Info", "mapping.ProviderID", "mapping.Timezone", "s.cache", "s.cacheExpirationDuration", "s.cacheKeyPrefix", "s.getCacheKeyForLocation", "s.getSingleFlightKey", "s.mappings", "s.provider", "s.sf", "service.go", "service_mocks.go", "singleflight.Group", "span.End", "span.RecordError", "span.SetAttributes", "span.SetStatus", "strings.Trim", "time.Duration", "time.LoadLocation", "time.Location", "time.Now", "trace.SpanKindInternal", "trace.WithSpanKind", "xotel.Tracer", "zap.Any", "zap.Error", "zap.Int"], "header_context_minimal": "package foreca\nimport (\n    \"encoding/json\"\n    \"go.impalastudios.com/otel\"\n    \"go.uber.org/zap\"\n    \"golang.org/x/sync/singleflight\"\n    \"time\"\n)\n// receiver: s *Service", "summary_llm": "The `GetForecastForLocation` method in the `Service` struct retrieves a weather forecast for a given location ID by first checking a cache. If not found or expired, it fetches the data from a provider and caches the result.", "keywords_llm": ["service", "forecast", "location", "cache", "provider", "mapping", "error", "debug", "trace", "json"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/service.go#2", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/service.go", "rel_path": "internal/foreca/service.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 165, "end_line": 173, "text": "func (s *Service) getSingleFlightKey(mapping *Mapping) string {\n\treturn fmt.Sprintf(\"foreca:locations:%d\", mapping.ProviderID)\n}\n\ntype expirableCacheItem struct {\n\tExpiresAtUnix int64     `json:\"exp\"`\n\tForecast      *Forecast `json:\"f\"`\n}\n", "n_tokens": 62, "primary_symbol": "getSingleFlightKey", "primary_kind": "function", "primary_span": [165, 173], "def_symbols": ["getSingleFlightKey"], "symbols": ["getSingleFlightKey", "func", "Service", "mapping", "Mapping", "string", "return", "fmt", "Sprintf", "foreca", "locations", "ProviderID", "type", "expirableCacheItem", "struct", "ExpiresAtUnix", "int64", "json", "exp", "Forecast"], "doc_head": "func (s *Service) getSingleFlightKey(mapping *Mapping) string {\n\treturn fmt.Sprintf(\"foreca:locations:%d\", mapping.ProviderID)\n}\ntype expirableCacheItem struct {\n\tExpiresAtUnix int64     `json:\"exp\"`\n\tForecast      *Forecast `json:\"f\"`\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(s *Service).getSingleFlightKey", "package": "", "node_kind": "method", "receiver": "s *Service", "function_name": "", "method_name": "getSingleFlightKey", "type_name": "expirableCacheItem", "type_kind": "struct", "imports_used_minimal": [], "symbols_referenced_strict": ["ExpiresAtUnix", "Forecast", "Mapping", "ProviderID", "Service", "Sprintf", "fmt.Sprintf", "mapping.ProviderID"], "header_context_minimal": "package \n// receiver: s *Service", "summary_llm": "The `getSingleFlightKey` method in the `Service` struct generates a cache key based on the provider ID from the provided `Mapping` object. The `expirableCacheItem` struct represents an item that can expire and contains fields for expiration timestamp and forecast data.", "keywords_llm": ["service", "mapping", "providerid", "getsingleflightkey", "expirecacheitem", "expiresatunix", "forecast", "json", "f"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/service_test.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/service_test.go", "rel_path": "internal/foreca/service_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 140, "text": "package foreca_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/stretchr/testify/suite\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/mocks\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/cache\"\n\t\"go.uber.org/mock/gomock\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype (\n\tserviceTestSuite struct {\n\t\tsuite.Suite\n\n\t\tmockController *gomock.Controller\n\t}\n)\n\nfunc (suite *serviceTestSuite) SetupSuite() {\n\tsuite.mockController = gomock.NewController(suite.T())\n}\n\nfunc (suite *serviceTestSuite) TestGetForecastForLocationMappingError() {\n\tmappings := mocks.NewMockmappingsRepository(suite.mockController)\n\tmappings.EXPECT().Get(gomock.Any(), 1).\n\t\tReturn(nil, errors.New(\"error\"))\n\n\ts := foreca.NewService(\n\t\tmocks.NewMockproviderClient(suite.mockController),\n\t\tmappings,\n\t\tmocks.NewMockcacheClient(suite.mockController),\n\t\t\"weather:proxies:foreca:test:\",\n\t\t1*time.Second,\n\t)\n\n\t_, err := s.GetForecastForLocation(context.TODO(), 1)\n\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorContains(err, \"cannot get mapping\")\n}\n\nfunc (suite *serviceTestSuite) TestGetForecastForLocationInvalidLocation() {\n\tmappings := mocks.NewMockmappingsRepository(suite.mockController)\n\tmappings.EXPECT().Get(gomock.Any(), 1).\n\t\tReturn(&foreca.Mapping{\n\t\t\tID:         1,\n\t\t\tProviderID: 2,\n\t\t\tTimezone:   \"invalid\",\n\t\t}, nil)\n\n\ts := foreca.NewService(\n\t\tmocks.NewMockproviderClient(suite.mockController),\n\t\tmappings,\n\t\tmocks.NewMockcacheClient(suite.mockController),\n\t\t\"weather:proxies:foreca:test:\",\n\t\t1*time.Second,\n\t)\n\n\t_, err := s.GetForecastForLocation(context.TODO(), 1)\n\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorContains(err, \"unsupported timezone\")\n}\n\nfunc (suite *serviceTestSuite) TestGetForecastForLocationNonCacheForecastError() {\n\tloc, _ := time.LoadLocation(\"Europe/Amsterdam\")\n\n\tmappings := mocks.NewMockmappingsRepository(suite.mockController)\n\tmappings.EXPECT().Get(gomock.Any(), 1).\n\t\tReturn(&foreca.Mapping{\n\t\t\tID:         1,\n\t\t\tProviderID: 2,\n\t\t\tTimezone:   loc.String(),\n\t\t}, nil)\n\tprovider := mocks.NewMockproviderClient(suite.mockController)\n\tprovider.EXPECT().GetForecastForLocation(gomock.Any(), 2, loc).\n\t\tReturn(nil, errors.New(\"provider error\"))\n\tcacheClient := mocks.NewMockcacheClient(suite.mockController)\n\tcacheClient.EXPECT().Get(\"weather:proxies:foreca:test:2\").\n\t\tReturn(nil, errors.New(\"cache miss\"))\n\n\ts := foreca.NewService(\n\t\tprovider,\n\t\tmappings,\n\t\tcacheClient,\n\t\t\"weather:proxies:foreca:test:\",\n\t\t1*time.Second,\n\t)\n\n\t_, err := s.GetForecastForLocation(context.TODO(), 1)\n\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorContains(err, \"provider error\")\n}\n\nfunc (suite *serviceTestSuite) TestGetForecastForLocationSettingCacheError() {\n\tloc, _ := time.LoadLocation(\"Europe/Amsterdam\")\n\n\tmappings := mocks.NewMockmappingsRepository(suite.mockController)\n\tmappings.EXPECT().Get(gomock.Any(), 1).\n\t\tReturn(&foreca.Mapping{\n\t\t\tID:         1,\n\t\t\tProviderID: 2,\n\t\t\tTimezone:   loc.String(),\n\t\t}, nil)\n\tprovider := mocks.NewMockproviderClient(suite.mockController)\n\tprovider.EXPECT().GetForecastForLocation(gomock.Any(), 2, loc).\n\t\tReturn(&foreca.Forecast{\n\t\t\tCurrentCondition: &foreca.CurrentCondition{},\n\t\t\tDailyConditions:  make([]*foreca.DailyCondition, 1),\n\t\t\tHourlyConditions: make([]*foreca.HourlyCondition, 1),\n\t\t}, nil)\n\tcacheClient := mocks.NewMockcacheClient(suite.mockController)\n\tcacheClient.EXPECT().Get(\"weather:proxies:foreca:test:2\").\n\t\tReturn(nil, errors.New(\"cache miss\"))\n\tcacheClient.EXPECT().Set(\"weather:proxies:foreca:test:2\", gomock.Any()).\n\t\tReturn(errors.New(\"cache error\"))\n\n\ts := foreca.NewService(\n\t\tprovider,\n\t\tmappings,\n\t\tcacheClient,\n\t\t\"weather:proxies:foreca:test:\",\n\t\t1*time.Second,\n\t)\n\n\tf, err := s.GetForecastForLocation(context.TODO(), 1)\n\n\tsuite.Assert().Nil(err)\n\tsuite.Assert().NotNil(f)\n\tsuite.Assert().NotNil(f.CurrentCondition)\n\tsuite.Assert().NotNil(f.DailyConditions)\n\tsuite.Assert().NotNil(f.HourlyConditions)\n}\n", "n_tokens": 1039, "primary_symbol": "SetupSuite", "primary_kind": "function", "primary_span": [24, 140], "def_symbols": ["SetupSuite", "TestGetForecastForLocationMappingError", "TestGetForecastForLocationInvalidLocation", "TestGetForecastForLocationNonCacheForecastError", "TestGetForecastForLocationSettingCacheError"], "symbols": ["SetupSuite", "TestGetForecastForLocationMappingError", "TestGetForecastForLocationInvalidLocation", "TestGetForecastForLocationNonCacheForecastError", "TestGetForecastForLocationSettingCacheError", "package", "foreca_test", "import", "context", "errors", "fmt", "github", "com", "stretchr", "testify", "suite", "impalastudios", "weather", "foreca_proxy", "internal", "foreca", "mocks", "pkg", "cache", "uber", "org", "mock", "gomock", "testing", "time", "type", "serviceTestSuite", "struct", "Suite", "mockController", "Controller", "func", "NewController", "mappings", "NewMockmappingsRepository", "EXPECT", "Get", "Any", "Return", "nil", "New", "error", "NewService", "NewMockproviderClient", "NewMockcacheClient", "proxies", "test", "Second", "err", "GetForecastForLocation", "TODO", "Assert", "NotNil", "ErrorContains", "cannot", "get", "mapping", "Mapping", "ProviderID", "Timezone", "invalid", "unsupported", "timezone", "loc", "LoadLocation", "Europe", "Amsterdam", "String", "provider", "cacheClient", "miss", "Forecast", "CurrentCondition", "DailyConditions", "make", "DailyCondition", "HourlyConditions", "HourlyCondition", "Set", "Nil"], "doc_head": "package foreca_test\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/stretchr/testify/suite\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/mocks\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/cache\"\n\t\"go.uber.org/mock/gomock\"\n\t\"testing\"\n\t\"time\"\n)\ntype (\n\tserviceTestSuite struct {\n\t\tsuite.Suite\n\t\tmockController *gomock.Controller\n\t}\n)\nfunc (suite *serviceTestSuite) SetupSuite() {\n\tsuite.mockController = gomock.NewController(suite.T())\n}\nfunc (suite *serviceTestSuite) TestGetForecastForLocationMappingError() {\n\tmappings := mocks.NewMockmappingsRepository(suite.mockController)\n\tmappings.EXPECT().Get(gomock.Any(), 1).\n\t\tReturn(nil, errors.New(\"error\"))\n\ts := foreca.NewService(\n\t\tmocks.NewMockproviderClient(suite.mockController),\n\t\tmappings,\n\t\tmocks.NewMockcacheClient(suite.mockController),\n\t\t\"weather:proxies:foreca:test:\",\n\t\t1*time.Second,\n\t)\n\t_, err := s.GetForecastForLocation(context.TODO(), 1)\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorContains(err, \"cannot get mapping\")\n}\nfunc (suite *serviceTestSuite) TestGetForecastForLocationInvalidLocation() {\n\tmappings := mocks.NewMockmappingsRepository(suite.m", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *serviceTestSuite).SetupSuite", "package": "foreca_test", "node_kind": "method", "receiver": "suite *serviceTestSuite", "function_name": "", "method_name": "SetupSuite", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Amsterdam", "Any", "Assert", "Controller", "CurrentCondition", "DailyCondition", "DailyConditions", "EXPECT", "ErrorContains", "Europe", "Forecast", "Get", "GetForecastForLocation", "HourlyCondition", "HourlyConditions", "ID", "LoadLocation", "Mapping", "New", "NewController", "NewMockcacheClient", "NewMockmappingsRepository", "NewMockproviderClient", "NewService", "Nil", "NotNil", "ProviderID", "Return", "Second", "Set", "SetupSuite", "String", "Suite", "T", "TODO", "TestGetForecastForLocationInvalidLocation", "TestGetForecastForLocationMappingError", "TestGetForecastForLocationNonCacheForecastError", "TestGetForecastForLocationSettingCacheError", "Timezone", "cacheClient.EXPECT", "context.TODO", "errors.New", "f.CurrentCondition", "f.DailyConditions", "f.HourlyConditions", "foreca.CurrentCondition", "foreca.DailyCondition", "foreca.Forecast", "foreca.HourlyCondition", "foreca.Mapping", "foreca.NewService", "github.com", "go.impalastudios", "go.uber", "gomock.Any", "gomock.Controller", "gomock.NewController", "loc.String", "mappings.EXPECT", "mocks.NewMockcacheClient", "mocks.NewMockmappingsRepository", "mocks.NewMockproviderClient", "provider.EXPECT", "s.GetForecastForLocation", "suite.Assert", "suite.Suite", "suite.T", "suite.mockController", "time.LoadLocation", "time.Second"], "header_context_minimal": "package foreca_test\nimport \"time\"\n// receiver: suite *serviceTestSuite", "summary_llm": "This Go code defines a test suite for the `GetForecastForLocation` method in the `foreca.Service` struct. It uses mocking to simulate dependencies and tests various error conditions and normal operations.", "keywords_llm": ["servicetestsuite", "setupsuite", "testgetforecastforlocationmappingerror", "testgetforecastforlocationinvalidlocation", "testgetforecastforlocationnoncacheforecasterror", "testgetforecastforlocationsettingcacheerror", "foreca.newservice", "getforecastforlocation", "context.todo", "time.loadlocation"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/service_test.go#2", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/service_test.go", "rel_path": "internal/foreca/service_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 141, "end_line": 184, "text": "func (suite *serviceTestSuite) TestGetForecastForLocationFromCache() {\n\tloc, _ := time.LoadLocation(\"Europe/Amsterdam\")\n\n\tmappings := mocks.NewMockmappingsRepository(suite.mockController)\n\tmappings.EXPECT().Get(gomock.Any(), 1).\n\t\tReturn(&foreca.Mapping{\n\t\t\tID:         1,\n\t\t\tProviderID: 2,\n\t\t\tTimezone:   loc.String(),\n\t\t}, nil)\n\tprovider := mocks.NewMockproviderClient(suite.mockController)\n\tprovider.EXPECT().GetForecastForLocation(gomock.Any(), 2, loc).\n\t\tTimes(0)\n\tcacheClient := mocks.NewMockcacheClient(suite.mockController)\n\tcacheClient.EXPECT().Get(\"weather:proxies:foreca:test:2\").\n\t\tReturn(&cache.Item{\n\t\t\tKey:        \"foreca:locations:2\",\n\t\t\tValue:      []byte(fmt.Sprintf(`{\"exp\":%d,\"f\":{\"cc\":{},\"dc\":[{}],\"hc\":[{}]}}`, time.Now().UTC().Add(2*time.Hour).Unix())),\n\t\t\tExpiration: int32(time.Now().UTC().Add(2 * time.Hour).Unix()),\n\t\t}, nil)\n\tcacheClient.EXPECT().Set(\"weather:proxies:foreca:test:2\", gomock.Any()).\n\t\tTimes(0)\n\n\ts := foreca.NewService(\n\t\tprovider,\n\t\tmappings,\n\t\tcacheClient,\n\t\t\"weather:proxies:foreca:test:\",\n\t\t1*time.Second,\n\t)\n\n\tf, err := s.GetForecastForLocation(context.TODO(), 1)\n\n\tsuite.Assert().Nil(err)\n\tsuite.Assert().NotNil(f)\n\tsuite.Assert().NotNil(f.CurrentCondition)\n\tsuite.Assert().NotNil(f.DailyConditions)\n\tsuite.Assert().NotNil(f.HourlyConditions)\n}\n\nfunc TestService(t *testing.T) {\n\tsuite.Run(t, new(serviceTestSuite))\n}\n", "n_tokens": 387, "primary_symbol": "TestGetForecastForLocationFromCache", "primary_kind": "function", "primary_span": [141, 184], "def_symbols": ["TestGetForecastForLocationFromCache", "TestService"], "symbols": ["TestGetForecastForLocationFromCache", "TestService", "func", "suite", "serviceTestSuite", "loc", "time", "LoadLocation", "Europe", "Amsterdam", "mappings", "mocks", "NewMockmappingsRepository", "mockController", "EXPECT", "Get", "gomock", "Any", "Return", "foreca", "Mapping", "ProviderID", "Timezone", "String", "nil", "provider", "NewMockproviderClient", "GetForecastForLocation", "Times", "cacheClient", "NewMockcacheClient", "weather", "proxies", "test", "cache", "Item", "Key", "locations", "Value", "byte", "fmt", "Sprintf", "exp", "Now", "UTC", "Add", "Hour", "Unix", "Expiration", "int32", "Set", "NewService", "Second", "err", "context", "TODO", "Assert", "Nil", "NotNil", "CurrentCondition", "DailyConditions", "HourlyConditions", "testing", "Run", "new"], "doc_head": "func (suite *serviceTestSuite) TestGetForecastForLocationFromCache() {\n\tloc, _ := time.LoadLocation(\"Europe/Amsterdam\")\n\tmappings := mocks.NewMockmappingsRepository(suite.mockController)\n\tmappings.EXPECT().Get(gomock.Any(), 1).\n\t\tReturn(&foreca.Mapping{\n\t\t\tID:         1,\n\t\t\tProviderID: 2,\n\t\t\tTimezone:   loc.String(),\n\t\t}, nil)\n\tprovider := mocks.NewMockproviderClient(suite.mockController)\n\tprovider.EXPECT().GetForecastForLocation(gomock.Any(), 2, loc).\n\t\tTimes(0)\n\tcacheClient := mocks.NewMockcacheClient(suite.mockController)\n\tcacheClient.EXPECT().Get(\"weather:proxies:foreca:test:2\").\n\t\tReturn(&cache.Item{\n\t\t\tKey:        \"foreca:locations:2\",\n\t\t\tValue:      []byte(fmt.Sprintf(`{\"exp\":%d,\"f\":{\"cc\":{},\"dc\":[{}],\"hc\":[{}]}}`, time.Now().UTC().Add(2*time.Hour).Unix())),\n\t\t\tExpiration: int32(time.Now().UTC().Add(2 * time.Hour).Unix()),\n\t\t}, nil)\n\tcacheClient.EXPECT().Set(\"weather:proxies:foreca:test:2\", gomock.Any()).\n\t\tTimes(0)\n\ts := foreca.NewService(\n\t\tprovider,\n\t\tmappings,\n\t\tcacheClient,\n\t\t\"weather:proxies:foreca:test:\",\n\t\t1*time.Second,\n\t)\n\tf, err := s.GetForecastForLocation(context.TODO(), 1)\n\tsuite.Assert().Nil(err)\n\tsuite.Assert().NotNil(f)\n\tsuite.Assert().NotNil(f.CurrentConditi", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *serviceTestSuite).TestGetForecastForLocationFromCache", "package": "", "node_kind": "method", "receiver": "suite *serviceTestSuite", "function_name": "TestService", "method_name": "TestGetForecastForLocationFromCache", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Add", "Amsterdam", "Any", "Assert", "CurrentCondition", "DailyConditions", "EXPECT", "Europe", "Expiration", "Get", "GetForecastForLocation", "Hour", "HourlyConditions", "ID", "Item", "Key", "LoadLocation", "Mapping", "NewMockcacheClient", "NewMockmappingsRepository", "NewMockproviderClient", "NewService", "Nil", "NotNil", "Now", "ProviderID", "Return", "Run", "Second", "Set", "Sprintf", "String", "T", "TODO", "TestGetForecastForLocationFromCache", "TestService", "Times", "Timezone", "UTC", "Unix", "Value", "cache.Item", "cacheClient.EXPECT", "context.TODO", "f.CurrentCondition", "f.DailyConditions", "f.HourlyConditions", "fmt.Sprintf", "foreca.Mapping", "foreca.NewService", "gomock.Any", "loc.String", "mappings.EXPECT", "mocks.NewMockcacheClient", "mocks.NewMockmappingsRepository", "mocks.NewMockproviderClient", "provider.EXPECT", "s.GetForecastForLocation", "suite.Assert", "suite.Run", "suite.mockController", "testing.T", "time.Hour", "time.LoadLocation", "time.Now", "time.Second"], "header_context_minimal": "package \nimport \"time\"\n// receiver: suite *serviceTestSuite", "summary_llm": "The Go code defines a test suite for the `GetForecastForLocationFromCache` method in the `foreca/service_test.go` file. It sets up mock objects for `mappingsRepository`, `providerClient`, and `cacheClient`, configures their expected behavior, creates an instance of `Service`, and asserts that calling `GetForecastForLocation` returns non-nil values.", "keywords_llm": ["servicetestsuite", "testgetforecastforlocationfromcache", "mocks.newmockmappingsrepository", "provider.expect().getforecastforlocation", "cacheclient.expect().get", "newservice", "getforecastforlocation", "suite.assert().nil", "time.loadlocation", "time.now"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/errors.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/errors.go", "rel_path": "internal/foreca/errors.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 10, "text": "package foreca\n\nimport \"errors\"\n\nvar (\n\tErrMappingNotFound  = errors.New(\"mapping not found\")\n\tErrRequestThrottled = errors.New(\"request throttled\")\n\tErrLocationNotFound = errors.New(\"location not found\")\n)\n", "n_tokens": 50, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 10], "def_symbols": [], "symbols": ["package", "foreca", "import", "errors", "var", "ErrMappingNotFound", "New", "mapping", "not", "found", "ErrRequestThrottled", "request", "throttled", "ErrLocationNotFound", "location"], "doc_head": "package foreca\nimport \"errors\"\nvar (\n\tErrMappingNotFound  = errors.New(\"mapping not found\")\n\tErrRequestThrottled = errors.New(\"request throttled\")\n\tErrLocationNotFound = errors.New(\"location not found\")\n)", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:file_header", "package": "foreca", "node_kind": "header", "receiver": "", "function_name": "", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["ErrLocationNotFound", "ErrMappingNotFound", "ErrRequestThrottled", "New", "errors.New"], "header_context_minimal": "package foreca", "summary_llm": "This Go code defines a function that calculates the sum of two integers and returns the result.", "keywords_llm": ["go", "function", "sum", "integers", "return"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/mocks/service_mocks.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/mocks/service_mocks.go", "rel_path": "internal/foreca/mocks/service_mocks.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 143, "text": "// Code generated by MockGen. DO NOT EDIT.\n// Source: service.go\n//\n// Generated by this command:\n//\n//\tmockgen -source=service.go -destination=mocks/service_mocks.go -package=mocks\n//\n\n// Package mocks is a generated GoMock package.\npackage mocks\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tforeca \"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\tcache \"go.impalastudios.com/weather/foreca_proxy/pkg/cache\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockproviderClient is a mock of providerClient interface.\ntype MockproviderClient struct {\n\tctrl     *gomock.Controller\n\trecorder *MockproviderClientMockRecorder\n}\n\n// MockproviderClientMockRecorder is the mock recorder for MockproviderClient.\ntype MockproviderClientMockRecorder struct {\n\tmock *MockproviderClient\n}\n\n// NewMockproviderClient creates a new mock instance.\nfunc NewMockproviderClient(ctrl *gomock.Controller) *MockproviderClient {\n\tmock := &MockproviderClient{ctrl: ctrl}\n\tmock.recorder = &MockproviderClientMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockproviderClient) EXPECT() *MockproviderClientMockRecorder {\n\treturn m.recorder\n}\n\n// GetForecastForLocation mocks base method.\nfunc (m *MockproviderClient) GetForecastForLocation(ctx context.Context, id int, loc *time.Location) (*foreca.Forecast, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetForecastForLocation\", ctx, id, loc)\n\tret0, _ := ret[0].(*foreca.Forecast)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetForecastForLocation indicates an expected call of GetForecastForLocation.\nfunc (mr *MockproviderClientMockRecorder) GetForecastForLocation(ctx, id, loc any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetForecastForLocation\", reflect.TypeOf((*MockproviderClient)(nil).GetForecastForLocation), ctx, id, loc)\n}\n\n// MockmappingsRepository is a mock of mappingsRepository interface.\ntype MockmappingsRepository struct {\n\tctrl     *gomock.Controller\n\trecorder *MockmappingsRepositoryMockRecorder\n}\n\n// MockmappingsRepositoryMockRecorder is the mock recorder for MockmappingsRepository.\ntype MockmappingsRepositoryMockRecorder struct {\n\tmock *MockmappingsRepository\n}\n\n// NewMockmappingsRepository creates a new mock instance.\nfunc NewMockmappingsRepository(ctrl *gomock.Controller) *MockmappingsRepository {\n\tmock := &MockmappingsRepository{ctrl: ctrl}\n\tmock.recorder = &MockmappingsRepositoryMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockmappingsRepository) EXPECT() *MockmappingsRepositoryMockRecorder {\n\treturn m.recorder\n}\n\n// Get mocks base method.\nfunc (m *MockmappingsRepository) Get(ctx context.Context, id int) (*foreca.Mapping, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Get\", ctx, id)\n\tret0, _ := ret[0].(*foreca.Mapping)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Get indicates an expected call of Get.\nfunc (mr *MockmappingsRepositoryMockRecorder) Get(ctx, id any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Get\", reflect.TypeOf((*MockmappingsRepository)(nil).Get), ctx, id)\n}\n\n// MockcacheClient is a mock of cacheClient interface.\ntype MockcacheClient struct {\n\tctrl     *gomock.Controller\n\trecorder *MockcacheClientMockRecorder\n}\n\n// MockcacheClientMockRecorder is the mock recorder for MockcacheClient.\ntype MockcacheClientMockRecorder struct {\n\tmock *MockcacheClient\n}\n\n// NewMockcacheClient creates a new mock instance.\nfunc NewMockcacheClient(ctrl *gomock.Controller) *MockcacheClient {\n\tmock := &MockcacheClient{ctrl: ctrl}\n\tmock.recorder = &MockcacheClientMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockcacheClient) EXPECT() *MockcacheClientMockRecorder {\n\treturn m.recorder\n}\n\n// Get mocks base method.\nfunc (m *MockcacheClient) Get(key string) (*cache.Item, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Get\", key)\n\tret0, _ := ret[0].(*cache.Item)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Get indicates an expected call of Get.\nfunc (mr *MockcacheClientMockRecorder) Get(key any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Get\", reflect.TypeOf((*MockcacheClient)(nil).Get), key)\n}\n\n// Set mocks base method.\nfunc (m *MockcacheClient) Set(key string, value []byte) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Set\", key, value)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n", "n_tokens": 1156, "primary_symbol": "NewMockproviderClient", "primary_kind": "function", "primary_span": [34, 143], "def_symbols": ["NewMockproviderClient", "EXPECT", "GetForecastForLocation", "NewMockmappingsRepository", "Get", "NewMockcacheClient", "Set"], "symbols": ["NewMockproviderClient", "EXPECT", "GetForecastForLocation", "NewMockmappingsRepository", "Get", "NewMockcacheClient", "Set", "Code", "generated", "MockGen", "NOT", "EDIT", "Source", "service", "Generated", "this", "command", "mockgen", "source", "destination", "mocks", "service_mocks", "package", "Package", "GoMock", "import", "context", "reflect", "time", "foreca", "impalastudios", "com", "weather", "foreca_proxy", "internal", "cache", "pkg", "gomock", "uber", "org", "mock", "MockproviderClient", "providerClient", "interface", "type", "struct", "ctrl", "Controller", "recorder", "MockproviderClientMockRecorder", "the", "for", "creates", "new", "instance", "func", "return", "returns", "object", "that", "allows", "caller", "indicate", "expected", "use", "base", "method", "ctx", "Context", "int", "loc", "Location", "Forecast", "error", "Helper", "ret", "Call", "ret0", "ret1", "indicates", "call", "any", "RecordCallWithMethodType", "TypeOf", "nil", "MockmappingsRepository", "mappingsRepository", "MockmappingsRepositoryMockRecorder", "Mapping", "MockcacheClient", "cacheClient", "MockcacheClientMockRecorder", "key", "string", "Item", "value", "byte"], "doc_head": "// Code generated by MockGen. DO NOT EDIT.\n// Source: service.go\n//\n// Generated by this command:\n//\n//\tmockgen -source=service.go -destination=mocks/service_mocks.go -package=mocks\n//\n// Package mocks is a generated GoMock package.\npackage mocks\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\ttime \"time\"\n\tforeca \"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\tcache \"go.impalastudios.com/weather/foreca_proxy/pkg/cache\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n// MockproviderClient is a mock of providerClient interface.\ntype MockproviderClient struct {\n\tctrl     *gomock.Controller\n\trecorder *MockproviderClientMockRecorder\n}\n// MockproviderClientMockRecorder is the mock recorder for MockproviderClient.\ntype MockproviderClientMockRecorder struct {\n\tmock *MockproviderClient\n}\n// NewMockproviderClient creates a new mock instance.\nfunc NewMockproviderClient(ctrl *gomock.Controller) *MockproviderClient {\n\tmock := &MockproviderClient{ctrl: ctrl}\n\tmock.recorder = &MockproviderClientMockRecorder{mock}\n\treturn mock\n}\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockproviderClient) EXPECT() *MockproviderClientMockRecorder {\n\treturn m.recorder\n}\n", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(m *MockproviderClient).EXPECT", "package": "mocks", "node_kind": "method", "receiver": "m *MockproviderClient", "function_name": "NewMockproviderClient", "method_name": "EXPECT", "type_name": "MockproviderClient", "type_kind": "struct", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Call", "Code", "Context", "Controller", "DO", "EDIT", "EXPECT", "Forecast", "Generated", "Get", "GetForecastForLocation", "GoMock", "Helper", "Item", "Location", "Mapping", "MockGen", "MockcacheClient", "MockcacheClientMockRecorder", "MockmappingsRepository", "MockmappingsRepositoryMockRecorder", "MockproviderClient", "MockproviderClientMockRecorder", "NOT", "NewMockcacheClient", "NewMockmappingsRepository", "NewMockproviderClient", "Package", "RecordCallWithMethodType", "Set", "Source", "T", "T.Helper", "TypeOf", "cache.Item", "context.Context", "ctrl.RecordCallWithMethodType", "ctrl.T", "foreca.Forecast", "foreca.Mapping", "go.impalastudios", "go.uber", "gomock.Call", "gomock.Controller", "m.ctrl", "m.recorder", "mock.recorder", "mr.mock", "reflect.TypeOf", "service.go", "service_mocks.go", "time.Location"], "header_context_minimal": "package mocks\nimport \"time\"\n// receiver: m *MockproviderClient", "summary_llm": "This Go code defines mocks for interfaces related to weather services and caching. The mocks allow tests to verify interactions with these interfaces without actually invoking their implementations.", "keywords_llm": ["gomock", "mocks", "providerclient", "getforecastforlocation", "cacheclient", "get", "set", "context.context", "time.location"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/mocks/service_mocks.go#2", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/mocks/service_mocks.go", "rel_path": "internal/foreca/mocks/service_mocks.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 144, "end_line": 149, "text": "// Set indicates an expected call of Set.\nfunc (mr *MockcacheClientMockRecorder) Set(key, value any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Set\", reflect.TypeOf((*MockcacheClient)(nil).Set), key, value)\n}\n", "n_tokens": 69, "primary_symbol": "Set", "primary_kind": "function", "primary_span": [145, 149], "def_symbols": ["Set"], "symbols": ["Set", "indicates", "expected", "call", "func", "MockcacheClientMockRecorder", "key", "value", "any", "gomock", "Call", "mock", "ctrl", "Helper", "return", "RecordCallWithMethodType", "reflect", "TypeOf", "MockcacheClient", "nil"], "doc_head": "// Set indicates an expected call of Set.\nfunc (mr *MockcacheClientMockRecorder) Set(key, value any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Set\", reflect.TypeOf((*MockcacheClient)(nil).Set), key, value)\n}", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(mr *MockcacheClientMockRecorder).Set", "package": "", "node_kind": "method", "receiver": "mr *MockcacheClientMockRecorder", "function_name": "", "method_name": "Set", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["Call", "Helper", "MockcacheClient", "MockcacheClientMockRecorder", "RecordCallWithMethodType", "Set", "T", "TypeOf", "ctrl.RecordCallWithMethodType", "ctrl.T", "gomock.Call", "mr.mock", "reflect.TypeOf"], "header_context_minimal": "package \n// receiver: mr *MockcacheClientMockRecorder", "summary_llm": "This function records an expected call to the `Set` method on a `MockcacheClient`. It is part of a mock recorder (`MockcacheClientMockRecorder`) and uses GoMock for testing.", "keywords_llm": ["mock", "call recording", "expected call", "gomock", "test framework", "method type", "reflection", "key", "value"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/mapping_dynamodb_repository_test.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/mapping_dynamodb_repository_test.go", "rel_path": "internal/foreca/adapters/mapping_dynamodb_repository_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 121, "text": "package adapters_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/aws/aws-sdk-go-v2/service/dynamodb\"\n\t\"github.com/aws/aws-sdk-go-v2/service/dynamodb/types\"\n\t\"github.com/aws/smithy-go/ptr\"\n\t\"github.com/stretchr/testify/suite\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters/mocks\"\n\t\"go.uber.org/mock/gomock\"\n\t\"testing\"\n)\n\ntype (\n\tdynamoMappingsRepositoryTestSuite struct {\n\t\tsuite.Suite\n\n\t\tmockController *gomock.Controller\n\t}\n)\n\nfunc (suite *dynamoMappingsRepositoryTestSuite) SetupSuite() {\n\tsuite.mockController = gomock.NewController(suite.T())\n}\n\nfunc (suite *dynamoMappingsRepositoryTestSuite) TestGetDynamoError() {\n\tclient := mocks.NewMockmappingDynamoDBClient(suite.mockController)\n\tclient.EXPECT().GetItem(gomock.Any(), gomock.Any()).\n\t\tDoAndReturn(func(ctx context.Context, input *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {\n\t\t\tsuite.Assert().EqualValues(input, &dynamodb.GetItemInput{\n\t\t\t\tKey:            map[string]types.AttributeValue{\"id\": &types.AttributeValueMemberN{Value: \"1\"}},\n\t\t\t\tTableName:      ptr.String(\"mappings_test\"),\n\t\t\t\tConsistentRead: ptr.Bool(false),\n\t\t\t})\n\n\t\t\treturn nil, errors.New(\"error\")\n\t\t})\n\tcache := mocks.NewMockcache[int, *foreca.Mapping](suite.mockController)\n\tcache.EXPECT().Get(1).Return(nil, false)\n\n\tr := adapters.NewMappingDynamoDBRepository(\n\t\t\"mappings_test\",\n\t\tclient,\n\t\tcache,\n\t)\n\n\t_, err := r.Get(context.TODO(), 1)\n\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorContains(err, \"cannot get mapping\")\n}\n\nfunc (suite *dynamoMappingsRepositoryTestSuite) TestGetNoMapping() {\n\tclient := mocks.NewMockmappingDynamoDBClient(suite.mockController)\n\tclient.EXPECT().GetItem(gomock.Any(), gomock.Any()).\n\t\tDoAndReturn(func(ctx context.Context, input *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {\n\t\t\tsuite.Assert().EqualValues(input, &dynamodb.GetItemInput{\n\t\t\t\tKey:            map[string]types.AttributeValue{\"id\": &types.AttributeValueMemberN{Value: \"1\"}},\n\t\t\t\tTableName:      ptr.String(\"mappings_test\"),\n\t\t\t\tConsistentRead: ptr.Bool(false),\n\t\t\t})\n\n\t\t\treturn &dynamodb.GetItemOutput{Item: make(map[string]types.AttributeValue, 0)}, nil\n\t\t})\n\tcache := mocks.NewMockcache[int, *foreca.Mapping](suite.mockController)\n\tcache.EXPECT().Get(1).Return(nil, false)\n\n\tr := adapters.NewMappingDynamoDBRepository(\n\t\t\"mappings_test\",\n\t\tclient,\n\t\tcache,\n\t)\n\n\t_, err := r.Get(context.TODO(), 1)\n\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorIs(err, foreca.ErrMappingNotFound)\n}\n\nfunc (suite *dynamoMappingsRepositoryTestSuite) TestGetNoCacheMapping() {\n\tclient := mocks.NewMockmappingDynamoDBClient(suite.mockController)\n\tclient.EXPECT().GetItem(gomock.Any(), gomock.Any()).\n\t\tDoAndReturn(func(ctx context.Context, input *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {\n\t\t\tsuite.Assert().EqualValues(input, &dynamodb.GetItemInput{\n\t\t\t\tKey:            map[string]types.AttributeValue{\"id\": &types.AttributeValueMemberN{Value: \"1\"}},\n\t\t\t\tTableName:      ptr.String(\"mappings_test\"),\n\t\t\t\tConsistentRead: ptr.Bool(false),\n\t\t\t})\n\n\t\t\treturn &dynamodb.GetItemOutput{\n\t\t\t\tItem: map[string]types.AttributeValue{\n\t\t\t\t\t\"id\":          &types.AttributeValueMemberN{Value: \"1\"},\n\t\t\t\t\t\"provider_id\": &types.AttributeValueMemberN{Value: \"2\"},\n\t\t\t\t\t\"tz\":          &types.AttributeValueMemberS{Value: \"Europe/Amsterdam\"},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t})\n\tcache := mocks.NewMockcache[int, *foreca.Mapping](suite.mockController)\n\tcache.EXPECT().Get(1).Return(nil, false)\n\tcache.EXPECT().Add(1, gomock.Any())\n\n\tr := adapters.NewMappingDynamoDBRepository(\n\t\t\"mappings_test\",\n\t\tclient,\n\t\tcache,\n\t)\n\n\tm, err := r.Get(context.TODO(), 1)\n\n\tsuite.Assert().Nil(err)\n\tsuite.Assert().NotNil(m)\n\tsuite.Assert().Equal(&foreca.Mapping{\n\t\tID:         1,\n\t\tProviderID: 2,\n\t\tTimezone:   \"Europe/Amsterdam\",\n\t}, m)\n}\n", "n_tokens": 1057, "primary_symbol": "SetupSuite", "primary_kind": "function", "primary_span": [25, 121], "def_symbols": ["SetupSuite", "TestGetDynamoError", "TestGetNoMapping", "TestGetNoCacheMapping"], "symbols": ["SetupSuite", "TestGetDynamoError", "TestGetNoMapping", "TestGetNoCacheMapping", "package", "adapters_test", "import", "context", "errors", "github", "com", "aws", "sdk", "service", "dynamodb", "types", "smithy", "ptr", "stretchr", "testify", "suite", "impalastudios", "weather", "foreca_proxy", "internal", "foreca", "adapters", "mocks", "uber", "org", "mock", "gomock", "testing", "type", "dynamoMappingsRepositoryTestSuite", "struct", "Suite", "mockController", "Controller", "func", "NewController", "client", "NewMockmappingDynamoDBClient", "EXPECT", "GetItem", "Any", "DoAndReturn", "ctx", "Context", "input", "GetItemInput", "optFns", "Options", "GetItemOutput", "error", "Assert", "EqualValues", "Key", "map", "string", "AttributeValue", "AttributeValueMemberN", "Value", "TableName", "String", "mappings_test", "ConsistentRead", "Bool", "false", "return", "nil", "New", "cache", "NewMockcache", "int", "Mapping", "Get", "Return", "NewMappingDynamoDBRepository", "err", "TODO", "NotNil", "ErrorContains", "cannot", "get", "mapping", "Item", "make", "ErrorIs", "ErrMappingNotFound", "provider_id", "AttributeValueMemberS", "Europe", "Amsterdam", "Add", "Nil", "Equal", "ProviderID", "Timezone"], "doc_head": "package adapters_test\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/aws/aws-sdk-go-v2/service/dynamodb\"\n\t\"github.com/aws/aws-sdk-go-v2/service/dynamodb/types\"\n\t\"github.com/aws/smithy-go/ptr\"\n\t\"github.com/stretchr/testify/suite\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters/mocks\"\n\t\"go.uber.org/mock/gomock\"\n\t\"testing\"\n)\ntype (\n\tdynamoMappingsRepositoryTestSuite struct {\n\t\tsuite.Suite\n\t\tmockController *gomock.Controller\n\t}\n)\nfunc (suite *dynamoMappingsRepositoryTestSuite) SetupSuite() {\n\tsuite.mockController = gomock.NewController(suite.T())\n}\nfunc (suite *dynamoMappingsRepositoryTestSuite) TestGetDynamoError() {\n\tclient := mocks.NewMockmappingDynamoDBClient(suite.mockController)\n\tclient.EXPECT().GetItem(gomock.Any(), gomock.Any()).\n\t\tDoAndReturn(func(ctx context.Context, input *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {\n\t\t\tsuite.Assert().EqualValues(input, &dynamodb.GetItemInput{\n\t\t\t\tKey:            map[string]types.AttributeValue{\"id\": &types.AttributeValueMemberN{Value: \"1\"}},\n\t\t\t\tTa", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *dynamoMappingsRepositoryTestSuite).SetupSuite", "package": "adapters_test", "node_kind": "method", "receiver": "suite *dynamoMappingsRepositoryTestSuite", "function_name": "", "method_name": "SetupSuite", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["Add", "Amsterdam", "Any", "Assert", "AttributeValue", "AttributeValueMemberN", "AttributeValueMemberS", "Bool", "ConsistentRead", "Context", "Controller", "DoAndReturn", "EXPECT", "Equal", "EqualValues", "ErrMappingNotFound", "ErrorContains", "ErrorIs", "Europe", "Get", "GetItem", "GetItemInput", "GetItemOutput", "ID", "Item", "Key", "Mapping", "New", "NewController", "NewMappingDynamoDBRepository", "NewMockcache", "NewMockmappingDynamoDBClient", "Nil", "NotNil", "Options", "ProviderID", "Return", "SetupSuite", "String", "Suite", "T", "TODO", "TableName", "TestGetDynamoError", "TestGetNoCacheMapping", "TestGetNoMapping", "Timezone", "Value", "adapters.NewMappingDynamoDBRepository", "cache.EXPECT", "client.EXPECT", "context.Context", "context.TODO", "dynamodb.GetItemInput", "dynamodb.GetItemOutput", "dynamodb.Options", "errors.New", "foreca.ErrMappingNotFound", "foreca.Mapping", "github.com", "go.impalastudios", "go.uber", "gomock.Any", "gomock.Controller", "gomock.NewController", "mocks.NewMockcache", "mocks.NewMockmappingDynamoDBClient", "ptr.Bool", "ptr.String", "r.Get", "suite.Assert", "suite.Suite", "suite.T", "suite.mockController", "types.AttributeValue", "types.AttributeValueMemberN", "types.AttributeValueMemberS"], "header_context_minimal": "package adapters_test\n// receiver: suite *dynamoMappingsRepositoryTestSuite", "summary_llm": "This Go code tests a DynamoDB repository for retrieving weather mappings. It includes three test cases: handling errors from DynamoDB, returning an error when no mapping is found, and successfully retrieving a mapping with a cache miss.", "keywords_llm": ["dynamodb", "repository", "testing", "suite", "mocks", "client", "cache", "error", "mapping", "get"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/mapping_dynamodb_repository_test.go#2", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/mapping_dynamodb_repository_test.go", "rel_path": "internal/foreca/adapters/mapping_dynamodb_repository_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 122, "end_line": 152, "text": "func (suite *dynamoMappingsRepositoryTestSuite) TestGetCachedMapping() {\n\tclient := mocks.NewMockmappingDynamoDBClient(suite.mockController)\n\tclient.EXPECT().GetItem(gomock.Any(), gomock.Any()).Times(0)\n\tcache := mocks.NewMockcache[int, *foreca.Mapping](suite.mockController)\n\tcache.EXPECT().Get(1).Return(&foreca.Mapping{\n\t\tID:         1,\n\t\tProviderID: 2,\n\t\tTimezone:   \"Europe/Amsterdam\",\n\t}, true)\n\n\tr := adapters.NewMappingDynamoDBRepository(\n\t\t\"mappings_test\",\n\t\tclient,\n\t\tcache,\n\t)\n\n\tm, err := r.Get(context.TODO(), 1)\n\n\tsuite.Assert().Nil(err)\n\tsuite.Assert().NotNil(m)\n\tsuite.Assert().Equal(&foreca.Mapping{\n\t\tID:         1,\n\t\tProviderID: 2,\n\t\tTimezone:   \"Europe/Amsterdam\",\n\t}, m)\n}\n\nfunc TestMappingsRepository(t *testing.T) {\n\tsuite.Run(t, new(dynamoMappingsRepositoryTestSuite))\n}\n", "n_tokens": 224, "primary_symbol": "TestGetCachedMapping", "primary_kind": "function", "primary_span": [122, 152], "def_symbols": ["TestGetCachedMapping", "TestMappingsRepository"], "symbols": ["TestGetCachedMapping", "TestMappingsRepository", "func", "suite", "dynamoMappingsRepositoryTestSuite", "client", "mocks", "NewMockmappingDynamoDBClient", "mockController", "EXPECT", "GetItem", "gomock", "Any", "Times", "cache", "NewMockcache", "int", "foreca", "Mapping", "Get", "Return", "ProviderID", "Timezone", "Europe", "Amsterdam", "true", "adapters", "NewMappingDynamoDBRepository", "mappings_test", "err", "context", "TODO", "Assert", "Nil", "NotNil", "Equal", "testing", "Run", "new"], "doc_head": "func (suite *dynamoMappingsRepositoryTestSuite) TestGetCachedMapping() {\n\tclient := mocks.NewMockmappingDynamoDBClient(suite.mockController)\n\tclient.EXPECT().GetItem(gomock.Any(), gomock.Any()).Times(0)\n\tcache := mocks.NewMockcache[int, *foreca.Mapping](suite.mockController)\n\tcache.EXPECT().Get(1).Return(&foreca.Mapping{\n\t\tID:         1,\n\t\tProviderID: 2,\n\t\tTimezone:   \"Europe/Amsterdam\",\n\t}, true)\n\tr := adapters.NewMappingDynamoDBRepository(\n\t\t\"mappings_test\",\n\t\tclient,\n\t\tcache,\n\t)\n\tm, err := r.Get(context.TODO(), 1)\n\tsuite.Assert().Nil(err)\n\tsuite.Assert().NotNil(m)\n\tsuite.Assert().Equal(&foreca.Mapping{\n\t\tID:         1,\n\t\tProviderID: 2,\n\t\tTimezone:   \"Europe/Amsterdam\",\n\t}, m)\n}\nfunc TestMappingsRepository(t *testing.T) {\n\tsuite.Run(t, new(dynamoMappingsRepositoryTestSuite))\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *dynamoMappingsRepositoryTestSuite).TestGetCachedMapping", "package": "", "node_kind": "method", "receiver": "suite *dynamoMappingsRepositoryTestSuite", "function_name": "TestMappingsRepository", "method_name": "TestGetCachedMapping", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["Amsterdam", "Any", "Assert", "EXPECT", "Equal", "Europe", "Get", "GetItem", "ID", "Mapping", "NewMappingDynamoDBRepository", "NewMockcache", "NewMockmappingDynamoDBClient", "Nil", "NotNil", "ProviderID", "Return", "Run", "T", "TODO", "TestGetCachedMapping", "TestMappingsRepository", "Times", "Timezone", "adapters.NewMappingDynamoDBRepository", "cache.EXPECT", "client.EXPECT", "context.TODO", "foreca.Mapping", "gomock.Any", "mocks.NewMockcache", "mocks.NewMockmappingDynamoDBClient", "r.Get", "suite.Assert", "suite.Run", "suite.mockController", "testing.T"], "header_context_minimal": "package \n// receiver: suite *dynamoMappingsRepositoryTestSuite", "summary_llm": "The code includes a test function `TestGetCachedMapping` that tests the `GetCachedMapping` method of a DynamoDB repository adapter. It sets up mock dependencies for the DynamoDB client and cache to ensure the method behaves as expected.", "keywords_llm": ["dynamo_mappings_repository_test", "testgetcachedmapping", "newmockmappingdynamodbclient", "expect", "getitem", "newmockcache", "assert", "nil", "notnil", "equal", "contexttodo", "run", "suite", "mockcontroller"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/mapping_dynamodb_repository.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/mapping_dynamodb_repository.go", "rel_path": "internal/foreca/adapters/mapping_dynamodb_repository.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 106, "text": "package adapters\n\nimport (\n\t\"context\"\n\t\"github.com/aws/aws-sdk-go-v2/aws\"\n\t\"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue\"\n\t\"github.com/aws/aws-sdk-go-v2/service/dynamodb\"\n\t\"github.com/pkg/errors\"\n\t\"go.impalastudios.com/log\"\n\txotel \"go.impalastudios.com/otel\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n)\n\ntype mappingDynamoDB struct {\n\tID         int    `json:\"id\" dynamodbav:\"id\"`\n\tProviderID int    `json:\"provider_id\" dynamodbav:\"provider_id\"`\n\tTimezone   string `json:\"tz\" dynamodbav:\"tz\"`\n}\n\n//go:generate /go/bin/mockgen -source=mapping_dynamodb_repository.go -destination=mocks/mapping_dynamodb_repository_mocks.go -package=mocks\ntype (\n\tmappingDynamoDBClient interface {\n\t\tGetItem(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)\n\t}\n\tcache[K any, V any] interface {\n\t\tGet(K) (V, bool)\n\t\tAdd(K, V) bool\n\t}\n)\n\ntype MappingDynamoDBRepository struct {\n\ttableName string\n\tclient    mappingDynamoDBClient\n\tcache     cache[int, *foreca.Mapping]\n}\n\nfunc NewMappingDynamoDBRepository(tableName string, client mappingDynamoDBClient, cache cache[int, *foreca.Mapping]) *MappingDynamoDBRepository {\n\treturn &MappingDynamoDBRepository{\n\t\ttableName: tableName,\n\t\tclient:    client,\n\t\tcache:     cache,\n\t}\n}\n\nfunc (r *MappingDynamoDBRepository) Get(ctx context.Context, id int) (*foreca.Mapping, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"mapping-repository:get\", trace.WithSpanKind(trace.SpanKindClient))\n\tdefer span.End()\n\n\tif mapping, found := r.cache.Get(id); found {\n\t\tspan.SetAttributes(attribute.Bool(\"cache_hit\", true))\n\t\tlog.Debug(ctx, \"found mapping in cache\", zap.Any(\"mapping\", mapping))\n\t\treturn mapping, nil\n\t}\n\n\tkey, err := attributevalue.MarshalMap(map[string]interface{}{\"id\": id})\n\n\tif err != nil {\n\t\tlog.Error(ctx, \"Cannot marshal key.\", zap.Int(\"id\", id), zap.Error(err))\n\t\tspan.SetStatus(codes.Error, \"Cannot marshal key.\")\n\t\tspan.RecordError(err)\n\n\t\treturn nil, errors.Wrap(err, \"mapping dynamodb repository: cannot marshal key\")\n\t}\n\n\tresp, err := r.client.GetItem(ctx, &dynamodb.GetItemInput{\n\t\tTableName:      aws.String(r.tableName),\n\t\tKey:            key,\n\t\tConsistentRead: aws.Bool(false),\n\t})\n\n\tif err != nil {\n\t\tlog.Error(ctx, \"DynamoDB client error.\", zap.Int(\"id\", id), zap.Error(err))\n\t\treturn nil, errors.Wrap(err, \"mapping dynamodb repository: cannot get mapping\")\n\t}\n\n\tif len(resp.Item) == 0 {\n\t\tlog.Warn(ctx, \"Mapping not found.\", zap.Int(\"id\", id))\n\t\treturn nil, foreca.ErrMappingNotFound\n\t}\n\n\tvar i mappingDynamoDB\n\tif err := attributevalue.UnmarshalMap(resp.Item, &i); err != nil {\n\t\tlog.Error(ctx, \"Cannot unmarshal mapping.\", zap.Int(\"id\", id), zap.Any(\"mapping\", resp.Item), zap.Error(err))\n\n\t\tspan.SetStatus(codes.Error, \"Cannot unmarshal item.\")\n\t\tspan.RecordError(err)\n\n\t\treturn nil, errors.Wrap(err, \"mapping dynamodb repository: cannot unmarshal mapping\")\n\t}\n\n\tspan.SetAttributes(attribute.Bool(\"cache_hit\", false))\n\n\tm := &foreca.Mapping{\n\t\tID:         i.ID,\n\t\tProviderID: i.ProviderID,\n\t\tTimezone:   i.Timezone,\n\t}\n\tr.cache.Add(id, m)\n\n\treturn m, nil\n}\n", "n_tokens": 870, "primary_symbol": "NewMappingDynamoDBRepository", "primary_kind": "function", "primary_span": [41, 106], "def_symbols": ["NewMappingDynamoDBRepository", "Get"], "symbols": ["NewMappingDynamoDBRepository", "Get", "package", "adapters", "import", "context", "github", "com", "aws", "sdk", "feature", "dynamodb", "attributevalue", "service", "pkg", "errors", "impalastudios", "log", "xotel", "otel", "weather", "foreca_proxy", "internal", "foreca", "opentelemetry", "attribute", "codes", "trace", "uber", "org", "zap", "type", "mappingDynamoDB", "struct", "int", "json", "dynamodbav", "ProviderID", "provider_id", "Timezone", "string", "generate", "bin", "mockgen", "source", "mapping_dynamodb_repository", "destination", "mocks", "mapping_dynamodb_repository_mocks", "mappingDynamoDBClient", "interface", "GetItem", "ctx", "Context", "params", "GetItemInput", "optFns", "func", "Options", "GetItemOutput", "error", "cache", "any", "bool", "Add", "MappingDynamoDBRepository", "tableName", "client", "Mapping", "return", "span", "Tracer", "Start", "mapping", "repository", "get", "WithSpanKind", "SpanKindClient", "defer", "End", "found", "SetAttributes", "Bool", "cache_hit", "true", "Debug", "Any", "nil", "key", "err", "MarshalMap", "map", "Error", "Cannot", "marshal", "Int", "SetStatus", "RecordError", "Wrap", "cannot", "resp", "TableName", "String", "Key", "ConsistentRead", "false", "DynamoDB", "len", "Item", "Warn", "not", "ErrMappingNotFound", "var", "UnmarshalMap", "unmarshal", "item"], "doc_head": "package adapters\nimport (\n\t\"context\"\n\t\"github.com/aws/aws-sdk-go-v2/aws\"\n\t\"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue\"\n\t\"github.com/aws/aws-sdk-go-v2/service/dynamodb\"\n\t\"github.com/pkg/errors\"\n\t\"go.impalastudios.com/log\"\n\txotel \"go.impalastudios.com/otel\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n)\ntype mappingDynamoDB struct {\n\tID         int    `json:\"id\" dynamodbav:\"id\"`\n\tProviderID int    `json:\"provider_id\" dynamodbav:\"provider_id\"`\n\tTimezone   string `json:\"tz\" dynamodbav:\"tz\"`\n}\n//go:generate /go/bin/mockgen -source=mapping_dynamodb_repository.go -destination=mocks/mapping_dynamodb_repository_mocks.go -package=mocks\ntype (\n\tmappingDynamoDBClient interface {\n\t\tGetItem(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)\n\t}\n\tcache[K any, V any] interface {\n\t\tGet(K) (V, bool)\n\t\tAdd(K, V) bool\n\t}\n)\ntype MappingDynamoDBRepository struct {\n\ttableName string\n\tclient    mappingDynamoDBClient\n\tcache     cache[int, *foreca.Mapping]\n}\nfunc NewMappingDynamoDBRep", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(r *MappingDynamoDBRepository).Get", "package": "adapters", "node_kind": "method", "receiver": "r *MappingDynamoDBRepository", "function_name": "NewMappingDynamoDBRepository", "method_name": "Get", "type_name": "mappingDynamoDB", "type_kind": "struct", "imports_used_minimal": ["go.impalastudios.com/otel", "go.uber.org/zap"], "symbols_referenced_strict": ["Add", "Any", "Bool", "Cannot", "ConsistentRead", "Context", "Debug", "DynamoDB", "End", "ErrMappingNotFound", "Error", "Get", "GetItem", "GetItemInput", "GetItemOutput", "ID", "Int", "Item", "K", "Key", "Mapping", "MappingDynamoDBRepository", "MarshalMap", "NewMappingDynamoDBRepository", "Options", "ProviderID", "RecordError", "SetAttributes", "SetStatus", "SpanKindClient", "Start", "String", "TableName", "Timezone", "Tracer", "UnmarshalMap", "V", "Warn", "WithSpanKind", "Wrap", "attribute.Bool", "attributevalue.MarshalMap", "attributevalue.UnmarshalMap", "aws.Bool", "aws.String", "codes.Error", "context.Context", "dynamodb.GetItemInput", "dynamodb.GetItemOutput", "dynamodb.Options", "errors.Wrap", "foreca.ErrMappingNotFound", "foreca.Mapping", "github.com", "go.impalastudios", "go.opentelemetry", "go.uber", "i.ID", "i.ProviderID", "i.Timezone", "log.Debug", "log.Error", "log.Warn", "mapping_dynamodb_repository.go", "mapping_dynamodb_repository_mocks.go", "r.cache", "r.client", "r.tableName", "resp.Item", "span.End", "span.RecordError", "span.SetAttributes", "span.SetStatus", "trace.SpanKindClient", "trace.WithSpanKind", "xotel.Tracer", "zap.Any", "zap.Error", "zap.Int"], "header_context_minimal": "package adapters\nimport (\n    \"go.impalastudios.com/otel\"\n    \"go.uber.org/zap\"\n)\n// receiver: r *MappingDynamoDBRepository", "summary_llm": "The code defines a `MappingDynamoDBRepository` struct with a method `Get` that retrieves a mapping from DynamoDB using a given ID. It first checks a cache before making a database call and logs various events based on the outcome.", "keywords_llm": ["mappingdynamodbrepository", "get", "cache", "dynamodb", "marshalmap", "unmarshalmap", "context", "error", "log", "span"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/mocks/mapping_dynamodb_repository_mocks.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/mocks/mapping_dynamodb_repository_mocks.go", "rel_path": "internal/foreca/adapters/mocks/mapping_dynamodb_repository_mocks.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 114, "text": "// Code generated by MockGen. DO NOT EDIT.\n// Source: mapping_dynamodb_repository.go\n//\n// Generated by this command:\n//\n//\tmockgen -source=mapping_dynamodb_repository.go -destination=mocks/mapping_dynamodb_repository_mocks.go -package=mocks\n//\n\n// Package mocks is a generated GoMock package.\npackage mocks\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tdynamodb \"github.com/aws/aws-sdk-go-v2/service/dynamodb\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockmappingDynamoDBClient is a mock of mappingDynamoDBClient interface.\ntype MockmappingDynamoDBClient struct {\n\tctrl     *gomock.Controller\n\trecorder *MockmappingDynamoDBClientMockRecorder\n}\n\n// MockmappingDynamoDBClientMockRecorder is the mock recorder for MockmappingDynamoDBClient.\ntype MockmappingDynamoDBClientMockRecorder struct {\n\tmock *MockmappingDynamoDBClient\n}\n\n// NewMockmappingDynamoDBClient creates a new mock instance.\nfunc NewMockmappingDynamoDBClient(ctrl *gomock.Controller) *MockmappingDynamoDBClient {\n\tmock := &MockmappingDynamoDBClient{ctrl: ctrl}\n\tmock.recorder = &MockmappingDynamoDBClientMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockmappingDynamoDBClient) EXPECT() *MockmappingDynamoDBClientMockRecorder {\n\treturn m.recorder\n}\n\n// GetItem mocks base method.\nfunc (m *MockmappingDynamoDBClient) GetItem(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []any{ctx, params}\n\tfor _, a := range optFns {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"GetItem\", varargs...)\n\tret0, _ := ret[0].(*dynamodb.GetItemOutput)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetItem indicates an expected call of GetItem.\nfunc (mr *MockmappingDynamoDBClientMockRecorder) GetItem(ctx, params any, optFns ...any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]any{ctx, params}, optFns...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetItem\", reflect.TypeOf((*MockmappingDynamoDBClient)(nil).GetItem), varargs...)\n}\n\n// Mockcache is a mock of cache interface.\ntype Mockcache[K any, V any] struct {\n\tctrl     *gomock.Controller\n\trecorder *MockcacheMockRecorder[K, V]\n}\n\n// MockcacheMockRecorder is the mock recorder for Mockcache.\ntype MockcacheMockRecorder[K any, V any] struct {\n\tmock *Mockcache[K, V]\n}\n\n// NewMockcache creates a new mock instance.\nfunc NewMockcache[K any, V any](ctrl *gomock.Controller) *Mockcache[K, V] {\n\tmock := &Mockcache[K, V]{ctrl: ctrl}\n\tmock.recorder = &MockcacheMockRecorder[K, V]{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *Mockcache[K, V]) EXPECT() *MockcacheMockRecorder[K, V] {\n\treturn m.recorder\n}\n\n// Add mocks base method.\nfunc (m *Mockcache[K, V]) Add(arg0 K, arg1 V) bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// Add indicates an expected call of Add.\nfunc (mr *MockcacheMockRecorder[K, V]) Add(arg0, arg1 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*Mockcache[K, V])(nil).Add), arg0, arg1)\n}\n\n// Get mocks base method.\nfunc (m *Mockcache[K, V]) Get(arg0 K) (V, bool) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Get\", arg0)\n\tret0, _ := ret[0].(V)\n\tret1, _ := ret[1].(bool)\n\treturn ret0, ret1\n}\n\n// Get indicates an expected call of Get.\nfunc (mr *MockcacheMockRecorder[K, V]) Get(arg0 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Get\", reflect.TypeOf((*Mockcache[K, V])(nil).Get), arg0)\n}\n", "n_tokens": 1022, "primary_symbol": "NewMockmappingDynamoDBClient", "primary_kind": "function", "primary_span": [32, 114], "def_symbols": ["NewMockmappingDynamoDBClient", "EXPECT", "GetItem", "Add", "Get"], "symbols": ["NewMockmappingDynamoDBClient", "EXPECT", "GetItem", "Add", "Get", "Code", "generated", "MockGen", "NOT", "EDIT", "Source", "mapping_dynamodb_repository", "Generated", "this", "command", "mockgen", "source", "destination", "mocks", "mapping_dynamodb_repository_mocks", "package", "Package", "GoMock", "import", "context", "reflect", "dynamodb", "github", "com", "aws", "sdk", "service", "gomock", "uber", "org", "mock", "MockmappingDynamoDBClient", "mappingDynamoDBClient", "interface", "type", "struct", "ctrl", "Controller", "recorder", "MockmappingDynamoDBClientMockRecorder", "the", "for", "creates", "new", "instance", "func", "return", "returns", "object", "that", "allows", "caller", "indicate", "expected", "use", "base", "method", "ctx", "Context", "params", "GetItemInput", "optFns", "Options", "GetItemOutput", "error", "Helper", "varargs", "any", "range", "append", "ret", "Call", "ret0", "ret1", "indicates", "call", "RecordCallWithMethodType", "TypeOf", "nil", "Mockcache", "cache", "MockcacheMockRecorder", "NewMockcache", "arg0", "arg1", "bool"], "doc_head": "// Code generated by MockGen. DO NOT EDIT.\n// Source: mapping_dynamodb_repository.go\n//\n// Generated by this command:\n//\n//\tmockgen -source=mapping_dynamodb_repository.go -destination=mocks/mapping_dynamodb_repository_mocks.go -package=mocks\n//\n// Package mocks is a generated GoMock package.\npackage mocks\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\tdynamodb \"github.com/aws/aws-sdk-go-v2/service/dynamodb\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n// MockmappingDynamoDBClient is a mock of mappingDynamoDBClient interface.\ntype MockmappingDynamoDBClient struct {\n\tctrl     *gomock.Controller\n\trecorder *MockmappingDynamoDBClientMockRecorder\n}\n// MockmappingDynamoDBClientMockRecorder is the mock recorder for MockmappingDynamoDBClient.\ntype MockmappingDynamoDBClientMockRecorder struct {\n\tmock *MockmappingDynamoDBClient\n}\n// NewMockmappingDynamoDBClient creates a new mock instance.\nfunc NewMockmappingDynamoDBClient(ctrl *gomock.Controller) *MockmappingDynamoDBClient {\n\tmock := &MockmappingDynamoDBClient{ctrl: ctrl}\n\tmock.recorder = &MockmappingDynamoDBClientMockRecorder{mock}\n\treturn mock\n}\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockmappingDynamo", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(m *MockmappingDynamoDBClient).EXPECT", "package": "mocks", "node_kind": "method", "receiver": "m *MockmappingDynamoDBClient", "function_name": "NewMockmappingDynamoDBClient", "method_name": "EXPECT", "type_name": "MockmappingDynamoDBClient", "type_kind": "struct", "imports_used_minimal": [], "symbols_referenced_strict": ["Add", "Call", "Code", "Context", "Controller", "DO", "EDIT", "EXPECT", "Generated", "Get", "GetItem", "GetItemInput", "GetItemOutput", "GoMock", "Helper", "K", "MockGen", "Mockcache", "MockcacheMockRecorder", "MockmappingDynamoDBClient", "MockmappingDynamoDBClientMockRecorder", "NOT", "NewMockcache", "NewMockmappingDynamoDBClient", "Options", "Package", "RecordCallWithMethodType", "Source", "T", "T.Helper", "TypeOf", "V", "context.Context", "ctrl.RecordCallWithMethodType", "ctrl.T", "dynamodb.GetItemInput", "dynamodb.GetItemOutput", "dynamodb.Options", "github.com", "go.uber", "gomock.Call", "gomock.Controller", "m.ctrl", "m.recorder", "mapping_dynamodb_repository.go", "mapping_dynamodb_repository_mocks.go", "mock.recorder", "mr.mock", "reflect.TypeOf"], "header_context_minimal": "package mocks\n// receiver: m *MockmappingDynamoDBClient", "summary_llm": "The provided Go code defines mock implementations for the `mappingDynamoDBClient` and `cache` interfaces using GoMock. These mocks are used to simulate behavior during testing.", "keywords_llm": ["gomock", "mockgen", "mappingdynamodbclient", "getitem", "add", "get", "context", "dynamodb", "options"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go", "rel_path": "internal/foreca/adapters/clients/foreca_client_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 147, "text": "package clients_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"github.com/stretchr/testify/suite\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters/clients\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters/clients/mocks\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit\"\n\t\"go.uber.org/mock/gomock\"\n\t\"io\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype (\n\tcurrentConditionTransformer interface {\n\t\tTransform(*clients.CurrentCondition, *clients.HourlyCondition, *time.Location) *foreca.CurrentCondition\n\t}\n\tdailyForecastTransformer interface {\n\t\tTransform(*clients.DailyCondition, []*clients.HourlyCondition, *time.Location) *foreca.DailyCondition\n\t}\n\thourlyForecastTransformer interface {\n\t\tTransform(*clients.HourlyCondition, *time.Location) *foreca.HourlyCondition\n\t}\n\ttransformer interface {\n\t\tTransform(*clients.Response, *time.Location) *foreca.Forecast\n\t}\n\tcurrentConditionTransformerTestSuite struct {\n\t\tsuite.Suite\n\n\t\ttransformer     currentConditionTransformer\n\t\ttime            time.Time\n\t\ttimestampFormat string\n\t\tlocation        *time.Location\n\t}\n\tdailyForecastTransformerTestSuite struct {\n\t\tsuite.Suite\n\n\t\ttransformer     dailyForecastTransformer\n\t\ttime            time.Time\n\t\tdaystampFormat  string\n\t\ttimestampFormat string\n\t\tdaytimeFormat   string\n\t\ttimeFormat      string\n\t\tsunrise         time.Time\n\t\tsunset          time.Time\n\t\tlocation        *time.Location\n\t}\n\thourlyForecastTransformerTestSuite struct {\n\t\tsuite.Suite\n\n\t\ttransformer     hourlyForecastTransformer\n\t\ttime            time.Time\n\t\ttimestampFormat string\n\t\tdaytimeFormat   string\n\t\tlocation        *time.Location\n\t}\n\ttransformerTestSuite struct {\n\t\tsuite.Suite\n\n\t\ttransformer     transformer\n\t\ttime            time.Time\n\t\tdaystampFormat  string\n\t\ttimestampFormat string\n\t\tdaytimeFormat   string\n\t\ttimeFormat      string\n\t\tsunrise         time.Time\n\t\tsunset          time.Time\n\t\tlocation        *time.Location\n\t}\n\tforecaClientTestSuite struct {\n\t\tsuite.Suite\n\n\t\tmockController *gomock.Controller\n\t\tlocation       *time.Location\n\t}\n)\n\nfunc (suite *currentConditionTransformerTestSuite) SetupSuite() {\n\tsuite.location, _ = time.LoadLocation(\"Europe/Amsterdam\")\n\tsuite.transformer = clients.NewCurrentConditionTransformer()\n\tsuite.time = time.Now().In(suite.location)\n\tsuite.timestampFormat = \"2006-01-02 15:04:05\"\n}\n\nfunc (suite *currentConditionTransformerTestSuite) TestTransformMissingCurrentCondition() {\n\tcc := suite.transformer.Transform(nil, nil, nil)\n\n\tsuite.Assert().Nil(cc)\n}\n\nfunc (suite *currentConditionTransformerTestSuite) TestTransformMissingHourlyCondition() {\n\tcc := suite.transformer.Transform(&clients.CurrentCondition{\n\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\tWeatherCode:        \"d400\",\n\t\t\tWeatherDescription: \"overcast\",\n\t\t},\n\t\tTimestamp:            suite.time.Format(suite.timestampFormat),\n\t\tTemperature:          0,\n\t\tTemperatureFeelsLike: -3,\n\t\tDewPoint:             -3,\n\t\tWindDirection:        \"S\",\n\t\tWindSpeed:            7,\n\t\tPressure:             \"989.3\",\n\t\tHumidityPercentage:   80,\n\t\tVisibility:           35000,\n\t}, nil, suite.location)\n\n\texpected := &foreca.CurrentCondition{\n\t\tEpoch:                 suite.time.Unix(),\n\t\tVisibility:            35,\n\t\tPrecipitation:         0,\n\t\tPrecipitationNextHour: 0,\n\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\tCode:        \"cloudy\",\n\t\t\tDescription: \"Overcast\",\n\t\t},\n\t\tWeatherConditionNextHour: nil,\n\t\tTemperature:              0,\n\t\tTemperatureFeelsLike:     -2.4,\n\t\tHumidityPercentage:       80,\n\t\tWindGust: &foreca.WindGust{\n\t\t\tWind: &foreca.Wind{\n\t\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\t\tAbbreviation: \"S\",\n\t\t\t\t\tDegrees:      180,\n\t\t\t\t},\n\t\t\t\tSpeed: 7,\n\t\t\t},\n\t\t\tGust: 0,\n\t\t},\n\t\tDewPoint:  -3,\n\t\tHeatIndex: -2,\n\t\tPressure: &foreca.Pressure{\n\t\t\tMillibar: 989.3,\n\t\t\tTrend:    foreca.PressureTrendSteady,\n\t\t},\n\t\tUVIndex: 0,\n\t}\n\n\tsuite.Assert().Equal(expected, cc)\n}\n", "n_tokens": 1035, "primary_symbol": "SetupSuite", "primary_kind": "function", "primary_span": [83, 147], "def_symbols": ["SetupSuite", "TestTransformMissingCurrentCondition", "TestTransformMissingHourlyCondition"], "symbols": ["SetupSuite", "TestTransformMissingCurrentCondition", "TestTransformMissingHourlyCondition", "package", "clients_test", "import", "bytes", "context", "errors", "github", "com", "stretchr", "testify", "suite", "impalastudios", "weather", "foreca_proxy", "internal", "foreca", "adapters", "clients", "mocks", "pkg", "ratelimit", "uber", "org", "mock", "gomock", "net", "http", "testing", "time", "type", "currentConditionTransformer", "interface", "Transform", "CurrentCondition", "HourlyCondition", "Location", "dailyForecastTransformer", "DailyCondition", "hourlyForecastTransformer", "transformer", "Response", "Forecast", "currentConditionTransformerTestSuite", "struct", "Suite", "Time", "timestampFormat", "string", "location", "dailyForecastTransformerTestSuite", "daystampFormat", "daytimeFormat", "timeFormat", "sunrise", "sunset", "hourlyForecastTransformerTestSuite", "transformerTestSuite", "forecaClientTestSuite", "mockController", "Controller", "func", "LoadLocation", "Europe", "Amsterdam", "NewCurrentConditionTransformer", "Now", "nil", "Assert", "Nil", "WeatherCondition", "WeatherCode", "d400", "WeatherDescription", "overcast", "Timestamp", "Format", "Temperature", "TemperatureFeelsLike", "DewPoint", "WindDirection", "WindSpeed", "Pressure", "HumidityPercentage", "Visibility", "expected", "Epoch", "Unix", "Precipitation", "PrecipitationNextHour", "Code", "cloudy", "Description", "Overcast", "WeatherConditionNextHour", "WindGust", "Wind", "Direction", "Abbreviation", "Degrees", "Speed", "Gust", "HeatIndex", "Millibar", "Trend", "PressureTrendSteady", "UVIndex", "Equal"], "doc_head": "package clients_test\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"github.com/stretchr/testify/suite\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters/clients\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters/clients/mocks\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit\"\n\t\"go.uber.org/mock/gomock\"\n\t\"io\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n)\ntype (\n\tcurrentConditionTransformer interface {\n\t\tTransform(*clients.CurrentCondition, *clients.HourlyCondition, *time.Location) *foreca.CurrentCondition\n\t}\n\tdailyForecastTransformer interface {\n\t\tTransform(*clients.DailyCondition, []*clients.HourlyCondition, *time.Location) *foreca.DailyCondition\n\t}\n\thourlyForecastTransformer interface {\n\t\tTransform(*clients.HourlyCondition, *time.Location) *foreca.HourlyCondition\n\t}\n\ttransformer interface {\n\t\tTransform(*clients.Response, *time.Location) *foreca.Forecast\n\t}\n\tcurrentConditionTransformerTestSuite struct {\n\t\tsuite.Suite\n\t\ttransformer     currentConditionTransformer\n\t\ttime            time.Time\n\t\ttimestampFormat string\n\t\tlocation        *time.Location\n\t}\n\tdailyForecastTransformerTestSuite struct {\n\t", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *currentConditionTransformerTestSuite).SetupSuite", "package": "clients_test", "node_kind": "method", "receiver": "suite *currentConditionTransformerTestSuite", "function_name": "", "method_name": "SetupSuite", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Abbreviation", "Amsterdam", "Assert", "Code", "Controller", "CurrentCondition", "DailyCondition", "Degrees", "Description", "DewPoint", "Direction", "Epoch", "Equal", "Europe", "Forecast", "Format", "Gust", "HeatIndex", "HourlyCondition", "HumidityPercentage", "In", "LoadLocation", "Location", "Millibar", "NewCurrentConditionTransformer", "Nil", "Now", "Overcast", "Precipitation", "PrecipitationNextHour", "Pressure", "PressureTrendSteady", "Response", "S", "SetupSuite", "Speed", "Suite", "Temperature", "TemperatureFeelsLike", "TestTransformMissingCurrentCondition", "TestTransformMissingHourlyCondition", "Time", "Timestamp", "Transform", "Trend", "UVIndex", "Unix", "Visibility", "WeatherCode", "WeatherCondition", "WeatherConditionNextHour", "WeatherDescription", "Wind", "WindDirection", "WindGust", "WindSpeed", "clients.CurrentCondition", "clients.DailyCondition", "clients.HourlyCondition", "clients.NewCurrentConditionTransformer", "clients.Response", "clients.WeatherCondition", "foreca.CurrentCondition", "foreca.DailyCondition", "foreca.Forecast", "foreca.HourlyCondition", "foreca.Pressure", "foreca.PressureTrendSteady", "foreca.WeatherCondition", "foreca.Wind", "foreca.WindDirection", "foreca.WindGust", "github.com", "go.impalastudios", "go.uber", "gomock.Controller", "suite.Assert", "suite.Suite", "suite.location", "suite.time", "suite.timestampFormat", "suite.transformer", "time.LoadLocation", "time.Location", "time.Now", "time.Time"], "header_context_minimal": "package clients_test\nimport \"time\"\n// receiver: suite *currentConditionTransformerTestSuite", "summary_llm": "This Go code snippet defines test suites for transforming weather data from the 'clients' package into the 'foreca' package format. It includes tests for missing current and hourly conditions.", "keywords_llm": ["currentconditiontransformertestsuite", "transformer", "newcurrentconditiontransformer", "time.time", "location", "setupsuite", "testtransformmissingcurrentcondition", "testtransformmissinghourlycondition"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go#2", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go", "rel_path": "internal/foreca/adapters/clients/foreca_client_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 148, "end_line": 248, "text": "func (suite *currentConditionTransformerTestSuite) TestTransformWithHourlyCondition() {\n\tcc := suite.transformer.Transform(&clients.CurrentCondition{\n\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\tWeatherCode:        \"d400\",\n\t\t\tWeatherDescription: \"overcast\",\n\t\t},\n\t\tTimestamp:            suite.time.Format(suite.timestampFormat),\n\t\tTemperature:          0,\n\t\tTemperatureFeelsLike: -3,\n\t\tDewPoint:             -3,\n\t\tWindDirection:        \"S\",\n\t\tWindSpeed:            7,\n\t\tPressure:             \"989.3\",\n\t\tHumidityPercentage:   80,\n\t\tVisibility:           35000,\n\t}, &clients.HourlyCondition{\n\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\tWeatherCode:        \"d300\",\n\t\t\tWeatherDescription: \"cloudy\",\n\t\t},\n\t\tTimestamp:                suite.time.Format(suite.timestampFormat),\n\t\tTemperature:              1,\n\t\tTemperatureFeelsLike:     -2,\n\t\tWindDirection:            \"SW\",\n\t\tWindSpeed:                8,\n\t\tPrecipitation:            1,\n\t\tPrecipitationProbability: 2,\n\t\tHumidityPercentage:       58,\n\t\tUVIndex:                  0,\n\t\tPressure:                 \"1018.54\",\n\t}, suite.location)\n\n\texpected := &foreca.CurrentCondition{\n\t\tEpoch:                 suite.time.Unix(),\n\t\tVisibility:            35,\n\t\tPrecipitation:         1,\n\t\tPrecipitationNextHour: 1,\n\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\tCode:        \"cloudy\",\n\t\t\tDescription: \"Overcast\",\n\t\t},\n\t\tWeatherConditionNextHour: &foreca.WeatherCondition{\n\t\t\tCode:        \"mostlycloudy\",\n\t\t\tDescription: \"Cloudy\",\n\t\t},\n\t\tTemperature:          0,\n\t\tTemperatureFeelsLike: -2.4,\n\t\tHumidityPercentage:   80,\n\t\tWindGust: &foreca.WindGust{\n\t\t\tWind: &foreca.Wind{\n\t\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\t\tAbbreviation: \"S\",\n\t\t\t\t\tDegrees:      180,\n\t\t\t\t},\n\t\t\t\tSpeed: 7,\n\t\t\t},\n\t\t\tGust: 0,\n\t\t},\n\t\tDewPoint:  -3,\n\t\tHeatIndex: -2,\n\t\tPressure: &foreca.Pressure{\n\t\t\tMillibar: 989.3,\n\t\t\tTrend:    foreca.PressureTrendSteady,\n\t\t},\n\t\tUVIndex: 0,\n\t}\n\n\tsuite.Assert().Equal(expected, cc)\n}\n\nfunc (suite *dailyForecastTransformerTestSuite) SetupSuite() {\n\tsuite.location, _ = time.LoadLocation(\"Europe/Amsterdam\")\n\tsuite.transformer = clients.NewDailyForecastTransformer()\n\tnow := time.Now()\n\tsuite.time = time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, suite.location)\n\tsuite.daystampFormat = \"2006-01-02\"\n\tsuite.timestampFormat = \"15:04:05\"\n\tsuite.daytimeFormat = \"2006-01-02 15:04\"\n\tsuite.timeFormat = \"2006-01-02 15:04:05\"\n\tsuite.sunrise = time.Date(\n\t\tsuite.time.Year(),\n\t\tsuite.time.Month(),\n\t\tsuite.time.Day(),\n\t\t8,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\tsuite.location,\n\t)\n\tsuite.sunset = time.Date(\n\t\tsuite.time.Year(),\n\t\tsuite.time.Month(),\n\t\tsuite.time.Day(),\n\t\t21,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\tsuite.location,\n\t)\n}\n", "n_tokens": 798, "primary_symbol": "TestTransformWithHourlyCondition", "primary_kind": "function", "primary_span": [148, 248], "def_symbols": ["TestTransformWithHourlyCondition", "SetupSuite"], "symbols": ["TestTransformWithHourlyCondition", "SetupSuite", "func", "suite", "currentConditionTransformerTestSuite", "transformer", "Transform", "clients", "CurrentCondition", "WeatherCondition", "WeatherCode", "d400", "WeatherDescription", "overcast", "Timestamp", "time", "Format", "timestampFormat", "Temperature", "TemperatureFeelsLike", "DewPoint", "WindDirection", "WindSpeed", "Pressure", "HumidityPercentage", "Visibility", "HourlyCondition", "d300", "cloudy", "Precipitation", "PrecipitationProbability", "UVIndex", "location", "expected", "foreca", "Epoch", "Unix", "PrecipitationNextHour", "Code", "Description", "Overcast", "WeatherConditionNextHour", "mostlycloudy", "Cloudy", "WindGust", "Wind", "Direction", "Abbreviation", "Degrees", "Speed", "Gust", "HeatIndex", "Millibar", "Trend", "PressureTrendSteady", "Assert", "Equal", "dailyForecastTransformerTestSuite", "LoadLocation", "Europe", "Amsterdam", "NewDailyForecastTransformer", "now", "Now", "Date", "Year", "Month", "Day", "daystampFormat", "daytimeFormat", "timeFormat", "sunrise", "sunset"], "doc_head": "func (suite *currentConditionTransformerTestSuite) TestTransformWithHourlyCondition() {\n\tcc := suite.transformer.Transform(&clients.CurrentCondition{\n\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\tWeatherCode:        \"d400\",\n\t\t\tWeatherDescription: \"overcast\",\n\t\t},\n\t\tTimestamp:            suite.time.Format(suite.timestampFormat),\n\t\tTemperature:          0,\n\t\tTemperatureFeelsLike: -3,\n\t\tDewPoint:             -3,\n\t\tWindDirection:        \"S\",\n\t\tWindSpeed:            7,\n\t\tPressure:             \"989.3\",\n\t\tHumidityPercentage:   80,\n\t\tVisibility:           35000,\n\t}, &clients.HourlyCondition{\n\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\tWeatherCode:        \"d300\",\n\t\t\tWeatherDescription: \"cloudy\",\n\t\t},\n\t\tTimestamp:                suite.time.Format(suite.timestampFormat),\n\t\tTemperature:              1,\n\t\tTemperatureFeelsLike:     -2,\n\t\tWindDirection:            \"SW\",\n\t\tWindSpeed:                8,\n\t\tPrecipitation:            1,\n\t\tPrecipitationProbability: 2,\n\t\tHumidityPercentage:       58,\n\t\tUVIndex:                  0,\n\t\tPressure:                 \"1018.54\",\n\t}, suite.location)\n\texpected := &foreca.CurrentCondition{\n\t\tEpoch:                 suite.time.Unix(),\n\t\tVisibility:            3", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *currentConditionTransformerTestSuite).TestTransformWithHourlyCondition", "package": "", "node_kind": "method", "receiver": "suite *currentConditionTransformerTestSuite", "function_name": "", "method_name": "TestTransformWithHourlyCondition", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Abbreviation", "Amsterdam", "Assert", "Cloudy", "Code", "CurrentCondition", "Date", "Day", "Degrees", "Description", "DewPoint", "Direction", "Epoch", "Equal", "Europe", "Format", "Gust", "HeatIndex", "HourlyCondition", "HumidityPercentage", "LoadLocation", "Millibar", "Month", "NewDailyForecastTransformer", "Now", "Overcast", "Precipitation", "PrecipitationNextHour", "PrecipitationProbability", "Pressure", "PressureTrendSteady", "S", "SW", "SetupSuite", "Speed", "Temperature", "TemperatureFeelsLike", "TestTransformWithHourlyCondition", "Timestamp", "Transform", "Trend", "UVIndex", "Unix", "Visibility", "WeatherCode", "WeatherCondition", "WeatherConditionNextHour", "WeatherDescription", "Wind", "WindDirection", "WindGust", "WindSpeed", "Year", "clients.CurrentCondition", "clients.HourlyCondition", "clients.NewDailyForecastTransformer", "clients.WeatherCondition", "foreca.CurrentCondition", "foreca.Pressure", "foreca.PressureTrendSteady", "foreca.WeatherCondition", "foreca.Wind", "foreca.WindDirection", "foreca.WindGust", "now.Day", "now.Month", "now.Year", "suite.Assert", "suite.daystampFormat", "suite.daytimeFormat", "suite.location", "suite.sunrise", "suite.sunset", "suite.time", "suite.timeFormat", "suite.timestampFormat", "suite.transformer", "time.Date", "time.LoadLocation", "time.Now"], "header_context_minimal": "package \nimport \"time\"\n// receiver: suite *currentConditionTransformerTestSuite", "summary_llm": "The `TestTransformWithHourlyCondition` function tests the transformation of current weather conditions using a transformer. It verifies that the transformed result matches the expected output by asserting equality between the actual and expected values. The `SetupSuite` function initializes test suite variables, including location, transformer, and timestamps.", "keywords_llm": ["current condition", "transformation", "test case", "time manipulation", "location setup", "transformer", "weather data", "assertion", "equality check", "timestamp formatting"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go#3", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go", "rel_path": "internal/foreca/adapters/clients/foreca_client_test.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 249, "end_line": 301, "text": "func (suite *dailyForecastTransformerTestSuite) TestTransformMissingHourlyConditions() {\n\tdc := suite.transformer.Transform(&clients.DailyCondition{\n\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\tWeatherCode:        \"d100\",\n\t\t\tWeatherDescription: \"mostly clear\",\n\t\t},\n\t\tDate:                     suite.time.Format(suite.daystampFormat),\n\t\tMinTemperature:           -1,\n\t\tMaxTemperature:           -5,\n\t\tUVIndex:                  0,\n\t\tWindDirection:            \"W\",\n\t\tWindSpeed:                25,\n\t\tPrecipitation:            0.35,\n\t\tPrecipitationProbability: 8,\n\t\tSunriseTime:              suite.sunrise.Format(suite.timestampFormat),\n\t\tSunsetTime:               suite.sunset.Format(suite.timestampFormat),\n\t}, nil, suite.location)\n\n\texpected := &foreca.DailyCondition{\n\t\tEpoch:                    suite.time.UTC().Unix(),\n\t\tMinTemperature:           -1,\n\t\tMaxTemperature:           -5,\n\t\tPrecipitation:            0.4,\n\t\tPrecipitationDay:         0.2,\n\t\tPrecipitationNight:       0.2,\n\t\tSnow:                     0,\n\t\tSnowDay:                  0,\n\t\tSnowNight:                0,\n\t\tPrecipitationProbability: 8,\n\t\tWind: &foreca.Wind{\n\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\tAbbreviation: \"W\",\n\t\t\t\tDegrees:      270,\n\t\t\t},\n\t\t\tSpeed: 25,\n\t\t},\n\t\tAverageHumidityPercentage: 0,\n\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\tCode:        foreca.WeatherCodeMostlySunny,\n\t\t\tDescription: \"Mostly Clear\",\n\t\t},\n\t\tWeatherConditionNight: &foreca.WeatherCondition{\n\t\t\tCode:        foreca.WeatherCodeMostlySunny,\n\t\t\tDescription: \"Mostly Clear\",\n\t\t},\n\t\tUVIndex:      0,\n\t\tSunriseEpoch: suite.sunrise.Unix(),\n\t\tSunsetEpoch:  suite.sunset.Unix(),\n\t}\n\n\tsuite.Assert().Equal(expected, dc)\n}\n", "n_tokens": 470, "primary_symbol": "TestTransformMissingHourlyConditions", "primary_kind": "function", "primary_span": [249, 301], "def_symbols": ["TestTransformMissingHourlyConditions"], "symbols": ["TestTransformMissingHourlyConditions", "func", "suite", "dailyForecastTransformerTestSuite", "transformer", "Transform", "clients", "DailyCondition", "WeatherCondition", "WeatherCode", "d100", "WeatherDescription", "mostly", "clear", "Date", "time", "Format", "daystampFormat", "MinTemperature", "MaxTemperature", "UVIndex", "WindDirection", "WindSpeed", "Precipitation", "PrecipitationProbability", "SunriseTime", "sunrise", "timestampFormat", "SunsetTime", "sunset", "nil", "location", "expected", "foreca", "Epoch", "UTC", "Unix", "PrecipitationDay", "PrecipitationNight", "Snow", "SnowDay", "SnowNight", "Wind", "Direction", "Abbreviation", "Degrees", "Speed", "AverageHumidityPercentage", "Code", "WeatherCodeMostlySunny", "Description", "Mostly", "Clear", "WeatherConditionNight", "SunriseEpoch", "SunsetEpoch", "Assert", "Equal"], "doc_head": "func (suite *dailyForecastTransformerTestSuite) TestTransformMissingHourlyConditions() {\n\tdc := suite.transformer.Transform(&clients.DailyCondition{\n\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\tWeatherCode:        \"d100\",\n\t\t\tWeatherDescription: \"mostly clear\",\n\t\t},\n\t\tDate:                     suite.time.Format(suite.daystampFormat),\n\t\tMinTemperature:           -1,\n\t\tMaxTemperature:           -5,\n\t\tUVIndex:                  0,\n\t\tWindDirection:            \"W\",\n\t\tWindSpeed:                25,\n\t\tPrecipitation:            0.35,\n\t\tPrecipitationProbability: 8,\n\t\tSunriseTime:              suite.sunrise.Format(suite.timestampFormat),\n\t\tSunsetTime:               suite.sunset.Format(suite.timestampFormat),\n\t}, nil, suite.location)\n\texpected := &foreca.DailyCondition{\n\t\tEpoch:                    suite.time.UTC().Unix(),\n\t\tMinTemperature:           -1,\n\t\tMaxTemperature:           -5,\n\t\tPrecipitation:            0.4,\n\t\tPrecipitationDay:         0.2,\n\t\tPrecipitationNight:       0.2,\n\t\tSnow:                     0,\n\t\tSnowDay:                  0,\n\t\tSnowNight:                0,\n\t\tPrecipitationProbability: 8,\n\t\tWind: &foreca.Wind{\n\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\tAbbreviation: \"W\",\n\t\t\t\tDeg", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *dailyForecastTransformerTestSuite).TestTransformMissingHourlyConditions", "package": "", "node_kind": "method", "receiver": "suite *dailyForecastTransformerTestSuite", "function_name": "", "method_name": "TestTransformMissingHourlyConditions", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["Abbreviation", "Assert", "AverageHumidityPercentage", "Clear", "Code", "DailyCondition", "Date", "Degrees", "Description", "Direction", "Epoch", "Equal", "Format", "MaxTemperature", "MinTemperature", "Mostly", "Precipitation", "PrecipitationDay", "PrecipitationNight", "PrecipitationProbability", "Snow", "SnowDay", "SnowNight", "Speed", "SunriseEpoch", "SunriseTime", "SunsetEpoch", "SunsetTime", "TestTransformMissingHourlyConditions", "Transform", "UTC", "UVIndex", "Unix", "W", "WeatherCode", "WeatherCodeMostlySunny", "WeatherCondition", "WeatherConditionNight", "WeatherDescription", "Wind", "WindDirection", "WindSpeed", "clients.DailyCondition", "clients.WeatherCondition", "foreca.DailyCondition", "foreca.WeatherCodeMostlySunny", "foreca.WeatherCondition", "foreca.Wind", "foreca.WindDirection", "suite.Assert", "suite.daystampFormat", "suite.location", "suite.sunrise", "suite.sunset", "suite.time", "suite.timestampFormat", "suite.transformer"], "header_context_minimal": "package \n// receiver: suite *dailyForecastTransformerTestSuite", "summary_llm": "This Go function tests the Transform method of dailyForecastTransformerTestSuite, ensuring it correctly converts clients.DailyCondition to foreca.DailyCondition with missing hourly conditions.", "keywords_llm": ["test", "transform", "dailyforecasttransformer", "clients.dailyccondition", "foreca.dailyccondition", "assert", "timestampformat", "location", "sunrise", "sunset"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go#4", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go", "rel_path": "internal/foreca/adapters/clients/foreca_client_test.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 302, "end_line": 400, "text": "func (suite *dailyForecastTransformerTestSuite) TestTransformWithHourlyConditions() {\n\tdc := suite.transformer.Transform(\n\t\t&clients.DailyCondition{\n\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\tWeatherCode:        \"d100\",\n\t\t\t\tWeatherDescription: \"mostly clear\",\n\t\t\t},\n\t\t\tDate:                     suite.time.Format(suite.daystampFormat),\n\t\t\tMinTemperature:           -1,\n\t\t\tMaxTemperature:           -5,\n\t\t\tUVIndex:                  0,\n\t\t\tWindDirection:            \"W\",\n\t\t\tWindSpeed:                25,\n\t\t\tPrecipitation:            0.35,\n\t\t\tPrecipitationProbability: 8,\n\t\t\tSunriseTime:              suite.sunrise.Format(suite.timestampFormat),\n\t\t\tSunsetTime:               suite.sunset.Format(suite.timestampFormat),\n\t\t},\n\t\t[]*clients.HourlyCondition{\n\t\t\t{\n\t\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\t\tWeatherCode:        \"d100\",\n\t\t\t\t\tWeatherDescription: \"mostly clear\",\n\t\t\t\t},\n\t\t\t\tTimestamp:                suite.time.Add(1 * time.Hour).Format(suite.daytimeFormat),\n\t\t\t\tTemperature:              1,\n\t\t\t\tTemperatureFeelsLike:     -4,\n\t\t\t\tWindDirection:            \"W\",\n\t\t\t\tWindSpeed:                14,\n\t\t\t\tPrecipitation:            0,\n\t\t\t\tPrecipitationProbability: 2,\n\t\t\t\tHumidityPercentage:       58,\n\t\t\t\tUVIndex:                  0,\n\t\t\t\tPressure:                 \"1017.46\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\t\tWeatherCode:        \"d000\",\n\t\t\t\t\tWeatherDescription: \"clear\",\n\t\t\t\t},\n\t\t\t\tTimestamp:                suite.time.Add(2 * time.Hour).Format(suite.daytimeFormat),\n\t\t\t\tTemperature:              4,\n\t\t\t\tTemperatureFeelsLike:     -1,\n\t\t\t\tWindDirection:            \"W\",\n\t\t\t\tWindSpeed:                23,\n\t\t\t\tPrecipitation:            0,\n\t\t\t\tPrecipitationProbability: 2,\n\t\t\t\tHumidityPercentage:       74,\n\t\t\t\tUVIndex:                  0,\n\t\t\t\tPressure:                 \"1019.77\",\n\t\t\t},\n\t\t},\n\t\tsuite.location,\n\t)\n\n\texpected := &foreca.DailyCondition{\n\t\tEpoch:                    suite.time.UTC().Unix(),\n\t\tMinTemperature:           1,\n\t\tMaxTemperature:           4,\n\t\tPrecipitation:            0.4,\n\t\tPrecipitationDay:         0,\n\t\tPrecipitationNight:       0,\n\t\tSnow:                     0,\n\t\tSnowDay:                  0,\n\t\tSnowNight:                0,\n\t\tPrecipitationProbability: 8,\n\t\tWind: &foreca.Wind{\n\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\tAbbreviation: \"W\",\n\t\t\t\tDegrees:      270,\n\t\t\t},\n\t\t\tSpeed: 25,\n\t\t},\n\t\tAverageHumidityPercentage: 66,\n\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\tCode:        foreca.WeatherCodeMostlySunny,\n\t\t\tDescription: \"Mostly Clear\",\n\t\t},\n\t\tWeatherConditionNight: &foreca.WeatherCondition{\n\t\t\tCode:        foreca.WeatherCodeClear,\n\t\t\tDescription: \"\",\n\t\t},\n\t\tUVIndex:      0,\n\t\tSunriseEpoch: suite.sunrise.Unix(),\n\t\tSunsetEpoch:  suite.sunset.Unix(),\n\t}\n\n\tsuite.Assert().Equal(expected, dc)\n}\n\nfunc (suite *hourlyForecastTransformerTestSuite) SetupSuite() {\n\tsuite.location, _ = time.LoadLocation(\"Europe/Amsterdam\")\n\tsuite.transformer = clients.NewHourlyForecastTransformer()\n\tnow := time.Now()\n\tsuite.time = time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), 0, 0, 0, suite.location)\n\tsuite.timestampFormat = \"15:04:05\"\n\tsuite.daytimeFormat = \"2006-01-02 15:04\"\n}\n", "n_tokens": 864, "primary_symbol": "TestTransformWithHourlyConditions", "primary_kind": "function", "primary_span": [302, 400], "def_symbols": ["TestTransformWithHourlyConditions", "SetupSuite"], "symbols": ["TestTransformWithHourlyConditions", "SetupSuite", "func", "suite", "dailyForecastTransformerTestSuite", "transformer", "Transform", "clients", "DailyCondition", "WeatherCondition", "WeatherCode", "d100", "WeatherDescription", "mostly", "clear", "Date", "time", "Format", "daystampFormat", "MinTemperature", "MaxTemperature", "UVIndex", "WindDirection", "WindSpeed", "Precipitation", "PrecipitationProbability", "SunriseTime", "sunrise", "timestampFormat", "SunsetTime", "sunset", "HourlyCondition", "Timestamp", "Add", "Hour", "daytimeFormat", "Temperature", "TemperatureFeelsLike", "HumidityPercentage", "Pressure", "d000", "location", "expected", "foreca", "Epoch", "UTC", "Unix", "PrecipitationDay", "PrecipitationNight", "Snow", "SnowDay", "SnowNight", "Wind", "Direction", "Abbreviation", "Degrees", "Speed", "AverageHumidityPercentage", "Code", "WeatherCodeMostlySunny", "Description", "Mostly", "Clear", "WeatherConditionNight", "WeatherCodeClear", "SunriseEpoch", "SunsetEpoch", "Assert", "Equal", "hourlyForecastTransformerTestSuite", "LoadLocation", "Europe", "Amsterdam", "NewHourlyForecastTransformer", "now", "Now", "Year", "Month", "Day"], "doc_head": "func (suite *dailyForecastTransformerTestSuite) TestTransformWithHourlyConditions() {\n\tdc := suite.transformer.Transform(\n\t\t&clients.DailyCondition{\n\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\tWeatherCode:        \"d100\",\n\t\t\t\tWeatherDescription: \"mostly clear\",\n\t\t\t},\n\t\t\tDate:                     suite.time.Format(suite.daystampFormat),\n\t\t\tMinTemperature:           -1,\n\t\t\tMaxTemperature:           -5,\n\t\t\tUVIndex:                  0,\n\t\t\tWindDirection:            \"W\",\n\t\t\tWindSpeed:                25,\n\t\t\tPrecipitation:            0.35,\n\t\t\tPrecipitationProbability: 8,\n\t\t\tSunriseTime:              suite.sunrise.Format(suite.timestampFormat),\n\t\t\tSunsetTime:               suite.sunset.Format(suite.timestampFormat),\n\t\t},\n\t\t[]*clients.HourlyCondition{\n\t\t\t{\n\t\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\t\tWeatherCode:        \"d100\",\n\t\t\t\t\tWeatherDescription: \"mostly clear\",\n\t\t\t\t},\n\t\t\t\tTimestamp:                suite.time.Add(1 * time.Hour).Format(suite.daytimeFormat),\n\t\t\t\tTemperature:              1,\n\t\t\t\tTemperatureFeelsLike:     -4,\n\t\t\t\tWindDirection:            \"W\",\n\t\t\t\tWindSpeed:                14,\n\t\t\t\tPrecipitation:            0,\n\t\t\t\tPrecipitationProbability: 2,\n\t\t\t\tHumidityPerce", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *dailyForecastTransformerTestSuite).TestTransformWithHourlyConditions", "package": "", "node_kind": "method", "receiver": "suite *dailyForecastTransformerTestSuite", "function_name": "", "method_name": "TestTransformWithHourlyConditions", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Abbreviation", "Add", "Amsterdam", "Assert", "AverageHumidityPercentage", "Clear", "Code", "DailyCondition", "Date", "Day", "Degrees", "Description", "Direction", "Epoch", "Equal", "Europe", "Format", "Hour", "HourlyCondition", "HumidityPercentage", "LoadLocation", "MaxTemperature", "MinTemperature", "Month", "Mostly", "NewHourlyForecastTransformer", "Now", "Precipitation", "PrecipitationDay", "PrecipitationNight", "PrecipitationProbability", "Pressure", "SetupSuite", "Snow", "SnowDay", "SnowNight", "Speed", "SunriseEpoch", "SunriseTime", "SunsetEpoch", "SunsetTime", "Temperature", "TemperatureFeelsLike", "TestTransformWithHourlyConditions", "Timestamp", "Transform", "UTC", "UVIndex", "Unix", "W", "WeatherCode", "WeatherCodeClear", "WeatherCodeMostlySunny", "WeatherCondition", "WeatherConditionNight", "WeatherDescription", "Wind", "WindDirection", "WindSpeed", "Year", "clients.DailyCondition", "clients.HourlyCondition", "clients.NewHourlyForecastTransformer", "clients.WeatherCondition", "foreca.DailyCondition", "foreca.WeatherCodeClear", "foreca.WeatherCodeMostlySunny", "foreca.WeatherCondition", "foreca.Wind", "foreca.WindDirection", "now.Day", "now.Hour", "now.Month", "now.Year", "suite.Assert", "suite.daystampFormat", "suite.daytimeFormat", "suite.location", "suite.sunrise", "suite.sunset", "suite.time", "suite.timestampFormat", "suite.transformer", "time.Date", "time.Hour", "time.LoadLocation", "time.Now"], "header_context_minimal": "package \nimport \"time\"\n// receiver: suite *dailyForecastTransformerTestSuite", "summary_llm": "The code defines a test function for transforming daily weather conditions using the `dailyForecastTransformerTestSuite` receiver. It sets up test data and expected results for verification.", "keywords_llm": ["test", "transform", "dailyforecasttransformertestsuite", "clients.dailycondition", "clients.hourlycondition", "foreca.dailycondition", "time.loadlocation", "time.now"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go#5", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go", "rel_path": "internal/foreca/adapters/clients/foreca_client_test.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 401, "end_line": 555, "text": "func (suite *hourlyForecastTransformerTestSuite) TestTransformHourlyForecast() {\n\thc := suite.transformer.Transform(\n\t\t&clients.HourlyCondition{\n\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\tWeatherCode:        \"d300\",\n\t\t\t\tWeatherDescription: \"cloudy\",\n\t\t\t},\n\t\t\tTimestamp:                suite.time.Format(suite.daytimeFormat),\n\t\t\tTemperature:              4,\n\t\t\tTemperatureFeelsLike:     -2,\n\t\t\tWindDirection:            \"SW\",\n\t\t\tWindSpeed:                25,\n\t\t\tPrecipitation:            0,\n\t\t\tPrecipitationProbability: 2,\n\t\t\tHumidityPercentage:       82,\n\t\t\tUVIndex:                  0,\n\t\t\tPressure:                 \"1024.78\",\n\t\t},\n\t\tsuite.location,\n\t)\n\n\texpected := &foreca.HourlyCondition{\n\t\tEpoch:                suite.time.UTC().Unix(),\n\t\tTemperature:          4,\n\t\tTemperatureFeelsLike: -2,\n\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\tCode:        foreca.WeatherCodeMostlyCloudy,\n\t\t\tDescription: \"Cloudy\",\n\t\t},\n\t\tPrecipitation:            0,\n\t\tSnow:                     0,\n\t\tPrecipitationProbability: 2,\n\t\tWind: &foreca.Wind{\n\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\tAbbreviation: \"SW\",\n\t\t\t\tDegrees:      225,\n\t\t\t},\n\t\t\tSpeed: 25,\n\t\t},\n\t\tPressure: &foreca.Pressure{\n\t\t\tMillibar: 1024.78,\n\t\t\tTrend:    foreca.PressureTrendSteady,\n\t\t},\n\t\tHumidityPercentage: 82,\n\t\tUVIndex:            0,\n\t}\n\n\tsuite.Assert().Equal(expected, hc)\n}\n\nfunc (suite *transformerTestSuite) SetupSuite() {\n\tsuite.location, _ = time.LoadLocation(\"Europe/Amsterdam\")\n\tsuite.transformer = clients.NewTransformer()\n\tnow := time.Now()\n\tsuite.time = time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, suite.location)\n\tsuite.daystampFormat = \"2006-01-02\"\n\tsuite.timestampFormat = \"15:04:05\"\n\tsuite.daytimeFormat = \"2006-01-02 15:04\"\n\tsuite.timeFormat = \"2006-01-02 15:04:05\"\n\tsuite.sunrise = time.Date(\n\t\tsuite.time.Year(),\n\t\tsuite.time.Month(),\n\t\tsuite.time.Day(),\n\t\t8,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\tsuite.location,\n\t)\n\tsuite.sunset = time.Date(\n\t\tsuite.time.Year(),\n\t\tsuite.time.Month(),\n\t\tsuite.time.Day(),\n\t\t21,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\tsuite.location,\n\t)\n}\n\nfunc (suite *transformerTestSuite) TestEmptyResponse() {\n\tf := suite.transformer.Transform(&clients.Response{\n\t\tCurrentCondition: nil,\n\t\tDailyConditions:  nil,\n\t\tHourlyConditions: nil,\n\t}, suite.location)\n\n\tsuite.Assert().Equal(&foreca.Forecast{\n\t\tCurrentCondition: nil,\n\t\tDailyConditions:  nil,\n\t\tHourlyConditions: nil,\n\t}, f)\n}\n\nfunc (suite *transformerTestSuite) TestOnlyCurrentCondition() {\n\tf := suite.transformer.Transform(&clients.Response{\n\t\tCurrentCondition: &clients.CurrentCondition{\n\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\tWeatherCode:        \"d400\",\n\t\t\t\tWeatherDescription: \"overcast\",\n\t\t\t},\n\t\t\tTimestamp:            suite.time.Format(suite.timeFormat),\n\t\t\tTemperature:          0,\n\t\t\tTemperatureFeelsLike: -3,\n\t\t\tDewPoint:             -3,\n\t\t\tWindDirection:        \"S\",\n\t\t\tWindSpeed:            7,\n\t\t\tPressure:             \"989.3\",\n\t\t\tHumidityPercentage:   80,\n\t\t\tVisibility:           35000,\n\t\t},\n\t\tDailyConditions:  nil,\n\t\tHourlyConditions: nil,\n\t}, suite.location)\n\n\texpected := &foreca.Forecast{\n\t\tCurrentCondition: &foreca.CurrentCondition{\n\t\t\tEpoch:                 suite.time.Unix(),\n\t\t\tVisibility:            35,\n\t\t\tPrecipitation:         0,\n\t\t\tPrecipitationNextHour: 0,\n\t\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\t\tCode:        \"cloudy\",\n\t\t\t\tDescription: \"Overcast\",\n\t\t\t},\n\t\t\tWeatherConditionNextHour: nil,\n\t\t\tTemperature:              0,\n\t\t\tTemperatureFeelsLike:     -2.4,\n\t\t\tHumidityPercentage:       80,\n\t\t\tWindGust: &foreca.WindGust{\n\t\t\t\tWind: &foreca.Wind{\n\t\t\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\t\t\tAbbreviation: \"S\",\n\t\t\t\t\t\tDegrees:      180,\n\t\t\t\t\t},\n\t\t\t\t\tSpeed: 7,\n\t\t\t\t},\n\t\t\t\tGust: 0,\n\t\t\t},\n\t\t\tDewPoint:  -3,\n\t\t\tHeatIndex: -2,\n\t\t\tPressure: &foreca.Pressure{\n\t\t\t\tMillibar: 989.3,\n\t\t\t\tTrend:    foreca.PressureTrendSteady,\n\t\t\t},\n\t\t\tUVIndex: 0,\n\t\t},\n\t\tDailyConditions:  nil,\n\t\tHourlyConditions: nil,\n\t}\n\n\tsuite.Assert().Equal(expected, f)\n}\n", "n_tokens": 1176, "primary_symbol": "TestTransformHourlyForecast", "primary_kind": "function", "primary_span": [401, 555], "def_symbols": ["TestTransformHourlyForecast", "SetupSuite", "TestEmptyResponse", "TestOnlyCurrentCondition"], "symbols": ["TestTransformHourlyForecast", "SetupSuite", "TestEmptyResponse", "TestOnlyCurrentCondition", "func", "suite", "hourlyForecastTransformerTestSuite", "transformer", "Transform", "clients", "HourlyCondition", "WeatherCondition", "WeatherCode", "d300", "WeatherDescription", "cloudy", "Timestamp", "time", "Format", "daytimeFormat", "Temperature", "TemperatureFeelsLike", "WindDirection", "WindSpeed", "Precipitation", "PrecipitationProbability", "HumidityPercentage", "UVIndex", "Pressure", "location", "expected", "foreca", "Epoch", "UTC", "Unix", "Code", "WeatherCodeMostlyCloudy", "Description", "Cloudy", "Snow", "Wind", "Direction", "Abbreviation", "Degrees", "Speed", "Millibar", "Trend", "PressureTrendSteady", "Assert", "Equal", "transformerTestSuite", "LoadLocation", "Europe", "Amsterdam", "NewTransformer", "now", "Now", "Date", "Year", "Month", "Day", "daystampFormat", "timestampFormat", "timeFormat", "sunrise", "sunset", "Response", "CurrentCondition", "nil", "DailyConditions", "HourlyConditions", "Forecast", "d400", "overcast", "DewPoint", "Visibility", "PrecipitationNextHour", "Overcast", "WeatherConditionNextHour", "WindGust", "Gust", "HeatIndex"], "doc_head": "func (suite *hourlyForecastTransformerTestSuite) TestTransformHourlyForecast() {\n\thc := suite.transformer.Transform(\n\t\t&clients.HourlyCondition{\n\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\tWeatherCode:        \"d300\",\n\t\t\t\tWeatherDescription: \"cloudy\",\n\t\t\t},\n\t\t\tTimestamp:                suite.time.Format(suite.daytimeFormat),\n\t\t\tTemperature:              4,\n\t\t\tTemperatureFeelsLike:     -2,\n\t\t\tWindDirection:            \"SW\",\n\t\t\tWindSpeed:                25,\n\t\t\tPrecipitation:            0,\n\t\t\tPrecipitationProbability: 2,\n\t\t\tHumidityPercentage:       82,\n\t\t\tUVIndex:                  0,\n\t\t\tPressure:                 \"1024.78\",\n\t\t},\n\t\tsuite.location,\n\t)\n\texpected := &foreca.HourlyCondition{\n\t\tEpoch:                suite.time.UTC().Unix(),\n\t\tTemperature:          4,\n\t\tTemperatureFeelsLike: -2,\n\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\tCode:        foreca.WeatherCodeMostlyCloudy,\n\t\t\tDescription: \"Cloudy\",\n\t\t},\n\t\tPrecipitation:            0,\n\t\tSnow:                     0,\n\t\tPrecipitationProbability: 2,\n\t\tWind: &foreca.Wind{\n\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\tAbbreviation: \"SW\",\n\t\t\t\tDegrees:      225,\n\t\t\t},\n\t\t\tSpeed: 25,\n\t\t},\n\t\tPressure: &foreca.Pressure{\n\t\t\tMillibar: 1024.", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *hourlyForecastTransformerTestSuite).TestTransformHourlyForecast", "package": "", "node_kind": "method", "receiver": "suite *hourlyForecastTransformerTestSuite", "function_name": "", "method_name": "TestTransformHourlyForecast", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Abbreviation", "Amsterdam", "Assert", "Cloudy", "Code", "CurrentCondition", "DailyConditions", "Date", "Day", "Degrees", "Description", "DewPoint", "Direction", "Epoch", "Equal", "Europe", "Forecast", "Format", "Gust", "HeatIndex", "HourlyCondition", "HourlyConditions", "HumidityPercentage", "LoadLocation", "Millibar", "Month", "NewTransformer", "Now", "Overcast", "Precipitation", "PrecipitationNextHour", "PrecipitationProbability", "Pressure", "PressureTrendSteady", "Response", "S", "SW", "SetupSuite", "Snow", "Speed", "Temperature", "TemperatureFeelsLike", "TestEmptyResponse", "TestOnlyCurrentCondition", "TestTransformHourlyForecast", "Timestamp", "Transform", "Trend", "UTC", "UVIndex", "Unix", "Visibility", "WeatherCode", "WeatherCodeMostlyCloudy", "WeatherCondition", "WeatherConditionNextHour", "WeatherDescription", "Wind", "WindDirection", "WindGust", "WindSpeed", "Year", "clients.CurrentCondition", "clients.HourlyCondition", "clients.NewTransformer", "clients.Response", "clients.WeatherCondition", "foreca.CurrentCondition", "foreca.Forecast", "foreca.HourlyCondition", "foreca.Pressure", "foreca.PressureTrendSteady", "foreca.WeatherCodeMostlyCloudy", "foreca.WeatherCondition", "foreca.Wind", "foreca.WindDirection", "foreca.WindGust", "now.Day", "now.Month", "now.Year", "suite.Assert", "suite.daystampFormat", "suite.daytimeFormat", "suite.location", "suite.sunrise", "suite.sunset", "suite.time", "suite.timeFormat", "suite.timestampFormat", "suite.transformer", "time.Date", "time.LoadLocation", "time.Now"], "header_context_minimal": "package \nimport \"time\"\n// receiver: suite *hourlyForecastTransformerTestSuite", "summary_llm": "The provided Go code defines test cases for transforming hourly weather forecast data from a client response to a format suitable for the foreca package. It includes tests for an empty response, a response with only current conditions, and a response with both current and hourly conditions. The `SetupSuite` function initializes necessary test variables and constants.", "keywords_llm": ["transformertestsuite", "hourlyforecasttransformertestsuite", "testtransformhourlyforecast", "testemptyresponse", "testonlycurrentcondition", "setupsuite", "clients.response", "foreca.hourlycondition", "time.loadlocation", "time.now"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go#6", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go", "rel_path": "internal/foreca/adapters/clients/foreca_client_test.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 556, "end_line": 798, "text": "func (suite *transformerTestSuite) TestAllConditions() {\n\tf := suite.transformer.Transform(&clients.Response{\n\t\tCurrentCondition: &clients.CurrentCondition{\n\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\tWeatherCode:        \"d400\",\n\t\t\t\tWeatherDescription: \"overcast\",\n\t\t\t},\n\t\t\tTimestamp:            suite.time.Format(suite.timeFormat),\n\t\t\tTemperature:          0,\n\t\t\tTemperatureFeelsLike: -3,\n\t\t\tDewPoint:             -3,\n\t\t\tWindDirection:        \"S\",\n\t\t\tWindSpeed:            7,\n\t\t\tPressure:             \"989.3\",\n\t\t\tHumidityPercentage:   80,\n\t\t\tVisibility:           35000,\n\t\t},\n\t\tDailyConditions: []*clients.DailyCondition{\n\t\t\t{\n\t\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\t\tWeatherCode:        \"d100\",\n\t\t\t\t\tWeatherDescription: \"mostly clear\",\n\t\t\t\t},\n\t\t\t\tDate:                     suite.time.Format(suite.daystampFormat),\n\t\t\t\tMinTemperature:           -1,\n\t\t\t\tMaxTemperature:           5,\n\t\t\t\tUVIndex:                  0,\n\t\t\t\tWindDirection:            \"W\",\n\t\t\t\tWindSpeed:                25,\n\t\t\t\tPrecipitation:            0.35,\n\t\t\t\tPrecipitationProbability: 8,\n\t\t\t\tSunriseTime:              suite.sunrise.Format(suite.timestampFormat),\n\t\t\t\tSunsetTime:               suite.sunset.Format(suite.timestampFormat),\n\t\t\t},\n\t\t\t{\n\t\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\t\tWeatherCode:        \"d300\",\n\t\t\t\t\tWeatherDescription: \"cloudy\",\n\t\t\t\t},\n\t\t\t\tDate:                     suite.time.Add(24 * time.Hour).Format(suite.daystampFormat),\n\t\t\t\tMinTemperature:           -1,\n\t\t\t\tMaxTemperature:           5,\n\t\t\t\tUVIndex:                  0,\n\t\t\t\tWindDirection:            \"SW\",\n\t\t\t\tWindSpeed:                25,\n\t\t\t\tPrecipitation:            0,\n\t\t\t\tPrecipitationProbability: 2,\n\t\t\t\tSunriseTime:              suite.sunrise.Add(24 * time.Hour).Format(suite.timestampFormat),\n\t\t\t\tSunsetTime:               suite.sunset.Add(24 * time.Hour).Format(suite.timestampFormat),\n\t\t\t},\n\t\t},\n\t\tHourlyConditions: []*clients.HourlyCondition{\n\t\t\t{\n\t\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\t\tWeatherCode:        \"d100\",\n\t\t\t\t\tWeatherDescription: \"mostly clear\",\n\t\t\t\t},\n\t\t\t\tTimestamp:                suite.time.Format(suite.daytimeFormat),\n\t\t\t\tTemperature:              1,\n\t\t\t\tTemperatureFeelsLike:     -4,\n\t\t\t\tWindDirection:            \"W\",\n\t\t\t\tWindSpeed:                14,\n\t\t\t\tPrecipitation:            0,\n\t\t\t\tPrecipitationProbability: 2,\n\t\t\t\tHumidityPercentage:       58,\n\t\t\t\tUVIndex:                  0,\n\t\t\t\tPressure:                 \"1017.46\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\t\tWeatherCode:        \"d000\",\n\t\t\t\t\tWeatherDescription: \"clear\",\n\t\t\t\t},\n\t\t\t\tTimestamp:                suite.time.Add(1 * time.Hour).Format(suite.daytimeFormat),\n\t\t\t\tTemperature:              4,\n\t\t\t\tTemperatureFeelsLike:     -1,\n\t\t\t\tWindDirection:            \"W\",\n\t\t\t\tWindSpeed:                23,\n\t\t\t\tPrecipitation:            0,\n\t\t\t\tPrecipitationProbability: 2,\n\t\t\t\tHumidityPercentage:       74,\n\t\t\t\tUVIndex:                  0,\n\t\t\t\tPressure:                 \"1019.77\",\n\t\t\t},\n\t\t},\n\t}, suite.location)\n\n\texpected := &foreca.Forecast{\n\t\tCurrentCondition: &foreca.CurrentCondition{\n\t\t\tEpoch:                 suite.time.Unix(),\n\t\t\tVisibility:            35,\n\t\t\tPrecipitation:         0,\n\t\t\tPrecipitationNextHour: 0,\n\t\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\t\tCode:        \"cloudy\",\n\t\t\t\tDescription: \"Overcast\",\n\t\t\t},\n\t\t\tWeatherConditionNextHour: &foreca.WeatherCondition{\n\t\t\t\tCode:        \"mostlysunny\",\n\t\t\t\tDescription: \"Mostly Clear\",\n\t\t\t},\n\t\t\tTemperature:          0,\n\t\t\tTemperatureFeelsLike: -2.4,\n\t\t\tHumidityPercentage:   80,\n\t\t\tWindGust: &foreca.WindGust{\n\t\t\t\tWind: &foreca.Wind{\n\t\t\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\t\t\tAbbreviation: \"S\",\n\t\t\t\t\t\tDegrees:      180,\n\t\t\t\t\t},\n\t\t\t\t\tSpeed: 7,\n\t\t\t\t},\n\t\t\t\tGust: 0,\n\t\t\t},\n\t\t\tDewPoint:  -3,\n\t\t\tHeatIndex: -2,\n\t\t\tPressure: &foreca.Pressure{\n\t\t\t\tMillibar: 989.3,\n\t\t\t\tTrend:    foreca.PressureTrendSteady,\n\t\t\t},\n\t\t\tUVIndex: 0,\n\t\t},\n\t\tDailyConditions: []*foreca.DailyCondition{\n\t\t\t{\n\t\t\t\tEpoch:                    suite.time.UTC().Unix(),\n\t\t\t\tMinTemperature:           1,\n\t\t\t\tMaxTemperature:           4,\n\t\t\t\tPrecipitation:            0.4,\n\t\t\t\tPrecipitationDay:         0,\n\t\t\t\tPrecipitationNight:       0,\n\t\t\t\tSnow:                     0,\n\t\t\t\tSnowDay:                  0,\n\t\t\t\tSnowNight:                0,\n\t\t\t\tPrecipitationProbability: 8,\n\t\t\t\tWind: &foreca.Wind{\n\t\t\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\t\t\tAbbreviation: \"W\",\n\t\t\t\t\t\tDegrees:      270,\n\t\t\t\t\t},\n\t\t\t\t\tSpeed: 25,\n\t\t\t\t},\n\t\t\t\tAverageHumidityPercentage: 66,\n\t\t\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\t\t\tCode:        foreca.WeatherCodeMostlySunny,\n\t\t\t\t\tDescription: \"Mostly Clear\",\n\t\t\t\t},\n\t\t\t\tWeatherConditionNight: &foreca.WeatherCondition{\n\t\t\t\t\tCode:        foreca.WeatherCodeClear,\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tUVIndex:      0,\n\t\t\t\tSunriseEpoch: suite.sunrise.Unix(),\n\t\t\t\tSunsetEpoch:  suite.sunset.Unix(),\n\t\t\t},\n\t\t\t{\n\t\t\t\tEpoch:                    suite.time.Add(24 * time.Hour).UTC().Unix(),\n\t\t\t\tMinTemperature:           -1,\n\t\t\t\tMaxTemperature:           5,\n\t\t\t\tPrecipitation:            0,\n\t\t\t\tPrecipitationDay:         0,\n\t\t\t\tPrecipitationNight:       0,\n\t\t\t\tSnow:                     0,\n\t\t\t\tSnowDay:                  0,\n\t\t\t\tSnowNight:                0,\n\t\t\t\tPrecipitationProbability: 2,\n\t\t\t\tWind: &foreca.Wind{\n\t\t\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\t\t\tAbbreviation: \"SW\",\n\t\t\t\t\t\tDegrees:      225,\n\t\t\t\t\t},\n\t\t\t\t\tSpeed: 25,\n\t\t\t\t},\n\t\t\t\tAverageHumidityPercentage: 0,\n\t\t\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\t\t\tCode:        foreca.WeatherCodeMostlyCloudy,\n\t\t\t\t\tDescription: \"Cloudy\",\n\t\t\t\t},\n\t\t\t\tWeatherConditionNight: &foreca.WeatherCondition{\n\t\t\t\t\tCode:        foreca.WeatherCodeMostlyCloudy,\n\t\t\t\t\tDescription: \"Cloudy\",\n\t\t\t\t},\n\t\t\t\tUVIndex:      0,\n\t\t\t\tSunriseEpoch: suite.sunrise.Add(24 * time.Hour).Unix(),\n\t\t\t\tSunsetEpoch:  suite.sunset.Add(24 * time.Hour).Unix(),\n\t\t\t},\n\t\t},\n\t\tHourlyConditions: []*foreca.HourlyCondition{\n\t\t\t{\n\t\t\t\tEpoch:                suite.time.UTC().Unix(),\n\t\t\t\tTemperature:          1,\n\t\t\t\tTemperatureFeelsLike: -4,\n\t\t\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\t\t\tCode:        foreca.WeatherCodeMostlySunny,\n\t\t\t\t\tDescription: \"Mostly Clear\",\n\t\t\t\t},\n\t\t\t\tPrecipitation:            0,\n\t\t\t\tSnow:                     0,\n\t\t\t\tPrecipitationProbability: 2,\n\t\t\t\tWind: &foreca.Wind{\n\t\t\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\t\t\tAbbreviation: \"W\",\n\t\t\t\t\t\tDegrees:      270,\n\t\t\t\t\t},\n\t\t\t\t\tSpeed: 14,\n\t\t\t\t},\n\t\t\t\tPressure: &foreca.Pressure{\n\t\t\t\t\tMillibar: 1017.46,\n\t\t\t\t\tTrend:    foreca.PressureTrendSteady,\n\t\t\t\t},\n\t\t\t\tHumidityPercentage: 58,\n\t\t\t\tUVIndex:            0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tEpoch:                suite.time.Add(1 * time.Hour).UTC().Unix(),\n\t\t\t\tTemperature:          4,\n\t\t\t\tTemperatureFeelsLike: -1,\n\t\t\t\tWeatherCondition: &foreca.WeatherCondition{\n\t\t\t\t\tCode:        foreca.WeatherCodeClear,\n\t\t\t\t\tDescription: \"Clear\",\n\t\t\t\t},\n\t\t\t\tPrecipitation:            0,\n\t\t\t\tSnow:                     0,\n\t\t\t\tPrecipitationProbability: 2,\n\t\t\t\tWind: &foreca.Wind{\n\t\t\t\t\tDirection: &foreca.WindDirection{\n\t\t\t\t\t\tAbbreviation: \"W\",\n\t\t\t\t\t\tDegrees:      270,\n\t\t\t\t\t},\n\t\t\t\t\tSpeed: 23,\n\t\t\t\t},\n\t\t\t\tPressure: &foreca.Pressure{\n\t\t\t\t\tMillibar: 1019.77,\n\t\t\t\t\tTrend:    foreca.PressureTrendSteady,\n\t\t\t\t},\n\t\t\t\tHumidityPercentage: 74,\n\t\t\t\tUVIndex:            0,\n\t\t\t},\n\t\t},\n\t}\n\n\tsuite.Assert().Equal(expected, f)\n}\n", "n_tokens": 2093, "primary_symbol": "TestAllConditions", "primary_kind": "function", "primary_span": [556, 798], "def_symbols": ["TestAllConditions"], "symbols": ["TestAllConditions", "func", "suite", "transformerTestSuite", "transformer", "Transform", "clients", "Response", "CurrentCondition", "WeatherCondition", "WeatherCode", "d400", "WeatherDescription", "overcast", "Timestamp", "time", "Format", "timeFormat", "Temperature", "TemperatureFeelsLike", "DewPoint", "WindDirection", "WindSpeed", "Pressure", "HumidityPercentage", "Visibility", "DailyConditions", "DailyCondition", "d100", "mostly", "clear", "Date", "daystampFormat", "MinTemperature", "MaxTemperature", "UVIndex", "Precipitation", "PrecipitationProbability", "SunriseTime", "sunrise", "timestampFormat", "SunsetTime", "sunset", "d300", "cloudy", "Add", "Hour", "HourlyConditions", "HourlyCondition", "daytimeFormat", "d000", "location", "expected", "foreca", "Forecast", "Epoch", "Unix", "PrecipitationNextHour", "Code", "Description", "Overcast", "WeatherConditionNextHour", "mostlysunny", "Mostly", "Clear", "WindGust", "Wind", "Direction", "Abbreviation", "Degrees", "Speed", "Gust", "HeatIndex", "Millibar", "Trend", "PressureTrendSteady", "UTC", "PrecipitationDay", "PrecipitationNight", "Snow", "SnowDay", "SnowNight", "AverageHumidityPercentage", "WeatherCodeMostlySunny", "WeatherConditionNight", "WeatherCodeClear", "SunriseEpoch", "SunsetEpoch", "WeatherCodeMostlyCloudy", "Cloudy", "Assert", "Equal"], "doc_head": "func (suite *transformerTestSuite) TestAllConditions() {\n\tf := suite.transformer.Transform(&clients.Response{\n\t\tCurrentCondition: &clients.CurrentCondition{\n\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\tWeatherCode:        \"d400\",\n\t\t\t\tWeatherDescription: \"overcast\",\n\t\t\t},\n\t\t\tTimestamp:            suite.time.Format(suite.timeFormat),\n\t\t\tTemperature:          0,\n\t\t\tTemperatureFeelsLike: -3,\n\t\t\tDewPoint:             -3,\n\t\t\tWindDirection:        \"S\",\n\t\t\tWindSpeed:            7,\n\t\t\tPressure:             \"989.3\",\n\t\t\tHumidityPercentage:   80,\n\t\t\tVisibility:           35000,\n\t\t},\n\t\tDailyConditions: []*clients.DailyCondition{\n\t\t\t{\n\t\t\t\tWeatherCondition: clients.WeatherCondition{\n\t\t\t\t\tWeatherCode:        \"d100\",\n\t\t\t\t\tWeatherDescription: \"mostly clear\",\n\t\t\t\t},\n\t\t\t\tDate:                     suite.time.Format(suite.daystampFormat),\n\t\t\t\tMinTemperature:           -1,\n\t\t\t\tMaxTemperature:           5,\n\t\t\t\tUVIndex:                  0,\n\t\t\t\tWindDirection:            \"W\",\n\t\t\t\tWindSpeed:                25,\n\t\t\t\tPrecipitation:            0.35,\n\t\t\t\tPrecipitationProbability: 8,\n\t\t\t\tSunriseTime:              suite.sunrise.Format(suite.timestampFormat),\n\t\t\t\tSunsetTime:               suite.sunset.Format(su", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *transformerTestSuite).TestAllConditions", "package": "", "node_kind": "method", "receiver": "suite *transformerTestSuite", "function_name": "", "method_name": "TestAllConditions", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Abbreviation", "Add", "Assert", "AverageHumidityPercentage", "Clear", "Cloudy", "Code", "CurrentCondition", "DailyCondition", "DailyConditions", "Date", "Degrees", "Description", "DewPoint", "Direction", "Epoch", "Equal", "Forecast", "Format", "Gust", "HeatIndex", "Hour", "HourlyCondition", "HourlyConditions", "HumidityPercentage", "MaxTemperature", "Millibar", "MinTemperature", "Mostly", "Overcast", "Precipitation", "PrecipitationDay", "PrecipitationNextHour", "PrecipitationNight", "PrecipitationProbability", "Pressure", "PressureTrendSteady", "Response", "S", "SW", "Snow", "SnowDay", "SnowNight", "Speed", "SunriseEpoch", "SunriseTime", "SunsetEpoch", "SunsetTime", "Temperature", "TemperatureFeelsLike", "TestAllConditions", "Timestamp", "Transform", "Trend", "UTC", "UVIndex", "Unix", "Visibility", "W", "WeatherCode", "WeatherCodeClear", "WeatherCodeMostlyCloudy", "WeatherCodeMostlySunny", "WeatherCondition", "WeatherConditionNextHour", "WeatherConditionNight", "WeatherDescription", "Wind", "WindDirection", "WindGust", "WindSpeed", "clients.CurrentCondition", "clients.DailyCondition", "clients.HourlyCondition", "clients.Response", "clients.WeatherCondition", "foreca.CurrentCondition", "foreca.DailyCondition", "foreca.Forecast", "foreca.HourlyCondition", "foreca.Pressure", "foreca.PressureTrendSteady", "foreca.WeatherCodeClear", "foreca.WeatherCodeMostlyCloudy", "foreca.WeatherCodeMostlySunny", "foreca.WeatherCondition", "foreca.Wind", "foreca.WindDirection", "foreca.WindGust", "suite.Assert", "suite.daystampFormat", "suite.daytimeFormat", "suite.location", "suite.sunrise", "suite.sunset", "suite.time", "suite.timeFormat", "suite.timestampFormat", "suite.transformer", "time.Hour"], "header_context_minimal": "package \nimport \"time\"\n// receiver: suite *transformerTestSuite", "summary_llm": "This Go test function `TestAllConditions` in the `transformerTestSuite` tests the transformation of a weather forecast response from the `clients.Response` struct to the `foreca.Forecast` struct using a transformer. It sets up various weather conditions and verifies that the transformed data matches the expected `foreca.Forecast` structure.", "keywords_llm": ["test", "transformertestsuite", "testallconditions", "clients.response", "foreca.forecast", "currentcondition", "dailycondition", "hourlycondition", "assertion", "equality"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go#7", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go", "rel_path": "internal/foreca/adapters/clients/foreca_client_test.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 799, "end_line": 924, "text": "func (suite *forecaClientTestSuite) SetupSuite() {\n\tsuite.mockController = gomock.NewController(suite.T())\n\tsuite.location, _ = time.LoadLocation(\"Europe/Amsterdam\")\n}\n\nfunc (suite *forecaClientTestSuite) TestGetForecastForLocationLimitReached() {\n\tlimiter := mocks.NewMockrateLimiter(suite.mockController)\n\tlimiter.EXPECT().Acquire(gomock.Any()).\n\t\tReturn(int64(0), ratelimit.ErrLimitReached)\n\n\tc := clients.NewForecaClient(\n\t\tmocks.NewMockhttpClient(suite.mockController),\n\t\t\"\",\n\t\tmap[string]string{},\n\t\tlimiter,\n\t\tmocks.NewMocktransformer(suite.mockController),\n\t)\n\n\t_, err := c.GetForecastForLocation(context.TODO(), 1, suite.location)\n\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorIs(err, foreca.ErrRequestThrottled)\n}\n\nfunc (suite *forecaClientTestSuite) TestGetForecastForLocationLimitError() {\n\tlimiter := mocks.NewMockrateLimiter(suite.mockController)\n\tlimiter.EXPECT().Acquire(gomock.Any()).\n\t\tReturn(int64(0), ratelimit.ErrCountZero)\n\n\tc := clients.NewForecaClient(\n\t\tmocks.NewMockhttpClient(suite.mockController),\n\t\t\"\",\n\t\tmap[string]string{},\n\t\tlimiter,\n\t\tmocks.NewMocktransformer(suite.mockController),\n\t)\n\n\t_, err := c.GetForecastForLocation(context.TODO(), 1, suite.location)\n\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorContains(err, \"limiter error\")\n}\n\nfunc (suite *forecaClientTestSuite) TestGetForecastForLocationLimitUnknownError() {\n\tlimiter := mocks.NewMockrateLimiter(suite.mockController)\n\tlimiter.EXPECT().Acquire(gomock.Any()).\n\t\tReturn(int64(0), errors.New(\"unknown\"))\n\n\tc := clients.NewForecaClient(\n\t\tmocks.NewMockhttpClient(suite.mockController),\n\t\t\"\",\n\t\tmap[string]string{},\n\t\tlimiter,\n\t\tmocks.NewMocktransformer(suite.mockController),\n\t)\n\n\t_, err := c.GetForecastForLocation(context.TODO(), 1, suite.location)\n\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorContains(err, \"generic error\")\n}\n\nfunc (suite *forecaClientTestSuite) TestGetForecastForLocationHttpError() {\n\tlimiter := mocks.NewMockrateLimiter(suite.mockController)\n\tlimiter.EXPECT().Acquire(gomock.Any()).\n\t\tReturn(time.Now().In(suite.location).Unix(), nil)\n\thttpClient := mocks.NewMockhttpClient(suite.mockController)\n\thttpClient.EXPECT().Do(gomock.Any()).\n\t\tReturn(nil, errors.New(\"error\"))\n\n\tc := clients.NewForecaClient(\n\t\thttpClient,\n\t\t\"\",\n\t\tmap[string]string{},\n\t\tlimiter,\n\t\tmocks.NewMocktransformer(suite.mockController),\n\t)\n\n\t_, err := c.GetForecastForLocation(context.TODO(), 1, suite.location)\n\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorContains(err, \"http error\")\n}\n\nfunc (suite *forecaClientTestSuite) TestGetForecastForLocationTransformError() {\n\tresponse := &http.Response{\n\t\tStatusCode: 200,\n\t\tBody: io.NopCloser(\n\t\t\tbytes.NewReader([]byte(\n\t\t\t\t`<weather>\n<loc>\n<obs station=\"Amsterdam Airport Schiphol\" dist=\"13 km SE\" dt=\"2024-01-23 10:00:00\" t=\"7\" tf=\"3\" d=\"4\" s=\"d400\" sT=\"overcast\" wn=\"SW\" ws=\"25\" p=\"1023.8\" rh=\"80\" v=\"12000\"/>\n<fc dt=\"2024-01-23\" tx=\"12\" tn=\"5\" s=\"d320\" sT=\"showers\" uvi=\"0\" wn=\"SW\" wsx=\"40\" pr=\"4.1\" pp=\"81\" rise=\"08:36:17\" set=\"17:11:09\"/>\n<fc1h dt=\"2024-01-23 11:00\" t=\"7\" tf=\"3\" s=\"d200\" sT=\"partly cloudy\" wn=\"SW\" ws=\"25\" rh=\"82\" pp=\"2\" pr=\"0\" uvi=\"0\" p=\"1023.29\"/>\n</loc>\n</weather>`,\n\t\t\t)),\n\t\t),\n\t}\n\n\tlimiter := mocks.NewMockrateLimiter(suite.mockController)\n\tlimiter.EXPECT().Acquire(gomock.Any()).\n\t\tReturn(time.Now().In(suite.location).Unix(), nil)\n\thttpClient := mocks.NewMockhttpClient(suite.mockController)\n\thttpClient.EXPECT().Do(gomock.Any()).\n\t\tReturn(response, nil)\n\ttransformerMock := mocks.NewMocktransformer(suite.mockController)\n\ttransformerMock.EXPECT().Transform(gomock.Any(), suite.location).\n\t\tReturn(&foreca.Forecast{})\n\n\tc := clients.NewForecaClient(\n\t\thttpClient,\n\t\t\"\",\n\t\tmap[string]string{},\n\t\tlimiter,\n\t\ttransformerMock,\n\t)\n\n\tf, _ := c.GetForecastForLocation(context.TODO(), 1, suite.location)\n\n\tsuite.Assert().NotNil(f)\n\tsuite.Assert().Nil(f.CurrentCondition)\n\tsuite.Assert().Nil(f.DailyConditions)\n\tsuite.Assert().Nil(f.HourlyConditions)\n}\n", "n_tokens": 1114, "primary_symbol": "SetupSuite", "primary_kind": "function", "primary_span": [799, 924], "def_symbols": ["SetupSuite", "TestGetForecastForLocationLimitReached", "TestGetForecastForLocationLimitError", "TestGetForecastForLocationLimitUnknownError", "TestGetForecastForLocationHttpError", "TestGetForecastForLocationTransformError"], "symbols": ["SetupSuite", "TestGetForecastForLocationLimitReached", "TestGetForecastForLocationLimitError", "TestGetForecastForLocationLimitUnknownError", "TestGetForecastForLocationHttpError", "TestGetForecastForLocationTransformError", "func", "suite", "forecaClientTestSuite", "mockController", "gomock", "NewController", "location", "time", "LoadLocation", "Europe", "Amsterdam", "limiter", "mocks", "NewMockrateLimiter", "EXPECT", "Acquire", "Any", "Return", "int64", "ratelimit", "ErrLimitReached", "clients", "NewForecaClient", "NewMockhttpClient", "map", "string", "NewMocktransformer", "err", "GetForecastForLocation", "context", "TODO", "Assert", "NotNil", "ErrorIs", "foreca", "ErrRequestThrottled", "ErrCountZero", "ErrorContains", "error", "errors", "New", "unknown", "generic", "Now", "Unix", "nil", "httpClient", "http", "response", "Response", "StatusCode", "Body", "NopCloser", "bytes", "NewReader", "byte", "weather", "loc", "obs", "station", "Airport", "Schiphol", "dist", "d400", "overcast", "d320", "showers", "uvi", "wsx", "rise", "set", "fc1h", "d200", "partly", "cloudy", "transformerMock", "Transform", "Forecast", "Nil", "CurrentCondition", "DailyConditions", "HourlyConditions"], "doc_head": "func (suite *forecaClientTestSuite) SetupSuite() {\n\tsuite.mockController = gomock.NewController(suite.T())\n\tsuite.location, _ = time.LoadLocation(\"Europe/Amsterdam\")\n}\nfunc (suite *forecaClientTestSuite) TestGetForecastForLocationLimitReached() {\n\tlimiter := mocks.NewMockrateLimiter(suite.mockController)\n\tlimiter.EXPECT().Acquire(gomock.Any()).\n\t\tReturn(int64(0), ratelimit.ErrLimitReached)\n\tc := clients.NewForecaClient(\n\t\tmocks.NewMockhttpClient(suite.mockController),\n\t\t\"\",\n\t\tmap[string]string{},\n\t\tlimiter,\n\t\tmocks.NewMocktransformer(suite.mockController),\n\t)\n\t_, err := c.GetForecastForLocation(context.TODO(), 1, suite.location)\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorIs(err, foreca.ErrRequestThrottled)\n}\nfunc (suite *forecaClientTestSuite) TestGetForecastForLocationLimitError() {\n\tlimiter := mocks.NewMockrateLimiter(suite.mockController)\n\tlimiter.EXPECT().Acquire(gomock.Any()).\n\t\tReturn(int64(0), ratelimit.ErrCountZero)\n\tc := clients.NewForecaClient(\n\t\tmocks.NewMockhttpClient(suite.mockController),\n\t\t\"\",\n\t\tmap[string]string{},\n\t\tlimiter,\n\t\tmocks.NewMocktransformer(suite.mockController),\n\t)\n\t_, err := c.GetForecastForLocation(context.TODO(), 1, suite.location)\n\tsuite.Asser", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *forecaClientTestSuite).SetupSuite", "package": "", "node_kind": "method", "receiver": "suite *forecaClientTestSuite", "function_name": "", "method_name": "SetupSuite", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Acquire", "Airport", "Amsterdam", "Any", "Assert", "Body", "CurrentCondition", "DailyConditions", "Do", "EXPECT", "ErrCountZero", "ErrLimitReached", "ErrRequestThrottled", "ErrorContains", "ErrorIs", "Europe", "Forecast", "GetForecastForLocation", "HourlyConditions", "In", "LoadLocation", "New", "NewController", "NewForecaClient", "NewMockhttpClient", "NewMockrateLimiter", "NewMocktransformer", "NewReader", "Nil", "NopCloser", "NotNil", "Now", "Response", "Return", "SE", "SW", "Schiphol", "SetupSuite", "StatusCode", "T", "TODO", "TestGetForecastForLocationHttpError", "TestGetForecastForLocationLimitError", "TestGetForecastForLocationLimitReached", "TestGetForecastForLocationLimitUnknownError", "TestGetForecastForLocationTransformError", "Transform", "Unix", "bytes.NewReader", "c.GetForecastForLocation", "clients.NewForecaClient", "context.TODO", "errors.New", "f.CurrentCondition", "f.DailyConditions", "f.HourlyConditions", "foreca.ErrRequestThrottled", "foreca.Forecast", "gomock.Any", "gomock.NewController", "http.Response", "httpClient.EXPECT", "io.NopCloser", "limiter.EXPECT", "mocks.NewMockhttpClient", "mocks.NewMockrateLimiter", "mocks.NewMocktransformer", "ratelimit.ErrCountZero", "ratelimit.ErrLimitReached", "suite.Assert", "suite.T", "suite.location", "suite.mockController", "time.LoadLocation", "time.Now", "transformerMock.EXPECT"], "header_context_minimal": "package \nimport \"time\"\n// receiver: suite *forecaClientTestSuite", "summary_llm": "This Go code tests a Foreca client's `GetForecastForLocation` method under various error conditions. It uses mock objects to simulate HTTP responses and rate limiters.", "keywords_llm": ["forecaclienttestsuite", "setupsuite", "testgetforecastforlocationlimitreached", "ratelimiter", "limiter.expect().acquire", "httpclient.expect().do", "getforecastforlocation", "newforecaclient", "mocks.newmockhttpclient", "context.todo", "errors.new", "foreca.errrequestthrottled", "http.response"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go#8", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client_test.go", "rel_path": "internal/foreca/adapters/clients/foreca_client_test.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 925, "end_line": 978, "text": "func (suite *forecaClientTestSuite) TestGetForecastForLocationValid() {\n\tresponse := &http.Response{\n\t\tStatusCode: 200,\n\t\tBody: io.NopCloser(\n\t\t\tbytes.NewReader([]byte(\n\t\t\t\t`<weather>\n<loc>\n<obs station=\"Amsterdam Airport Schiphol\" dist=\"13 km SE\" dt=\"2024-01-23 10:00:00\" t=\"7\" tf=\"3\" d=\"4\" s=\"d400\" sT=\"overcast\" wn=\"SW\" ws=\"25\" p=\"1023.8\" rh=\"80\" v=\"12000\"/>\n<fc dt=\"2024-01-23\" tx=\"12\" tn=\"5\" s=\"d320\" sT=\"showers\" uvi=\"0\" wn=\"SW\" wsx=\"40\" pr=\"4.1\" pp=\"81\" rise=\"08:36:17\" set=\"17:11:09\"/>\n<fc1h dt=\"2024-01-23 11:00\" t=\"7\" tf=\"3\" s=\"d200\" sT=\"partly cloudy\" wn=\"SW\" ws=\"25\" rh=\"82\" pp=\"2\" pr=\"0\" uvi=\"0\" p=\"1023.29\"/>\n</loc>\n</weather>`,\n\t\t\t)),\n\t\t),\n\t}\n\n\tlimiter := mocks.NewMockrateLimiter(suite.mockController)\n\tlimiter.EXPECT().Acquire(gomock.Any()).\n\t\tReturn(time.Now().In(suite.location).Unix(), nil)\n\thttpClient := mocks.NewMockhttpClient(suite.mockController)\n\thttpClient.EXPECT().Do(gomock.Any()).\n\t\tReturn(response, nil)\n\ttransformerMock := mocks.NewMocktransformer(suite.mockController)\n\ttransformerMock.EXPECT().Transform(gomock.Any(), suite.location).\n\t\tReturn(&foreca.Forecast{\n\t\t\tCurrentCondition: &foreca.CurrentCondition{},\n\t\t\tDailyConditions:  make([]*foreca.DailyCondition, 1),\n\t\t\tHourlyConditions: make([]*foreca.HourlyCondition, 1),\n\t\t})\n\n\tc := clients.NewForecaClient(\n\t\thttpClient,\n\t\t\"\",\n\t\tmap[string]string{},\n\t\tlimiter,\n\t\ttransformerMock,\n\t)\n\n\tf, _ := c.GetForecastForLocation(context.TODO(), 1, suite.location)\n\n\tsuite.Assert().NotNil(f)\n\tsuite.Assert().NotNil(f.CurrentCondition)\n\tsuite.Assert().NotNil(f.DailyConditions)\n\tsuite.Assert().NotNil(f.HourlyConditions)\n}\n\nfunc TestForecaClient(t *testing.T) {\n\tsuite.Run(t, new(currentConditionTransformerTestSuite))\n\tsuite.Run(t, new(dailyForecastTransformerTestSuite))\n\tsuite.Run(t, new(hourlyForecastTransformerTestSuite))\n\tsuite.Run(t, new(transformerTestSuite))\n\tsuite.Run(t, new(forecaClientTestSuite))\n}\n", "n_tokens": 595, "primary_symbol": "TestGetForecastForLocationValid", "primary_kind": "function", "primary_span": [925, 978], "def_symbols": ["TestGetForecastForLocationValid", "TestForecaClient"], "symbols": ["TestGetForecastForLocationValid", "TestForecaClient", "func", "suite", "forecaClientTestSuite", "response", "http", "Response", "StatusCode", "Body", "NopCloser", "bytes", "NewReader", "byte", "weather", "loc", "obs", "station", "Amsterdam", "Airport", "Schiphol", "dist", "d400", "overcast", "d320", "showers", "uvi", "wsx", "rise", "set", "fc1h", "d200", "partly", "cloudy", "limiter", "mocks", "NewMockrateLimiter", "mockController", "EXPECT", "Acquire", "gomock", "Any", "Return", "time", "Now", "location", "Unix", "nil", "httpClient", "NewMockhttpClient", "transformerMock", "NewMocktransformer", "Transform", "foreca", "Forecast", "CurrentCondition", "DailyConditions", "make", "DailyCondition", "HourlyConditions", "HourlyCondition", "clients", "NewForecaClient", "map", "string", "GetForecastForLocation", "context", "TODO", "Assert", "NotNil", "testing", "Run", "new", "currentConditionTransformerTestSuite", "dailyForecastTransformerTestSuite", "hourlyForecastTransformerTestSuite", "transformerTestSuite"], "doc_head": "func (suite *forecaClientTestSuite) TestGetForecastForLocationValid() {\n\tresponse := &http.Response{\n\t\tStatusCode: 200,\n\t\tBody: io.NopCloser(\n\t\t\tbytes.NewReader([]byte(\n\t\t\t\t`<weather>\n<loc>\n<obs station=\"Amsterdam Airport Schiphol\" dist=\"13 km SE\" dt=\"2024-01-23 10:00:00\" t=\"7\" tf=\"3\" d=\"4\" s=\"d400\" sT=\"overcast\" wn=\"SW\" ws=\"25\" p=\"1023.8\" rh=\"80\" v=\"12000\"/>\n<fc dt=\"2024-01-23\" tx=\"12\" tn=\"5\" s=\"d320\" sT=\"showers\" uvi=\"0\" wn=\"SW\" wsx=\"40\" pr=\"4.1\" pp=\"81\" rise=\"08:36:17\" set=\"17:11:09\"/>\n<fc1h dt=\"2024-01-23 11:00\" t=\"7\" tf=\"3\" s=\"d200\" sT=\"partly cloudy\" wn=\"SW\" ws=\"25\" rh=\"82\" pp=\"2\" pr=\"0\" uvi=\"0\" p=\"1023.29\"/>\n</loc>\n</weather>`,\n\t\t\t)),\n\t\t),\n\t}\n\tlimiter := mocks.NewMockrateLimiter(suite.mockController)\n\tlimiter.EXPECT().Acquire(gomock.Any()).\n\t\tReturn(time.Now().In(suite.location).Unix(), nil)\n\thttpClient := mocks.NewMockhttpClient(suite.mockController)\n\thttpClient.EXPECT().Do(gomock.Any()).\n\t\tReturn(response, nil)\n\ttransformerMock := mocks.NewMocktransformer(suite.mockController)\n\ttransformerMock.EXPECT().Transform(gomock.Any(), suite.location).\n\t\tReturn(&foreca.Forecast{\n\t\t\tCurrentCondition: &foreca.CurrentCondition{},\n\t\t\tDailyConditions:  make([]*foreca.DailyCondition, 1),\n", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *forecaClientTestSuite).TestGetForecastForLocationValid", "package": "", "node_kind": "method", "receiver": "suite *forecaClientTestSuite", "function_name": "TestForecaClient", "method_name": "TestGetForecastForLocationValid", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Acquire", "Airport", "Amsterdam", "Any", "Assert", "Body", "CurrentCondition", "DailyCondition", "DailyConditions", "Do", "EXPECT", "Forecast", "GetForecastForLocation", "HourlyCondition", "HourlyConditions", "In", "NewForecaClient", "NewMockhttpClient", "NewMockrateLimiter", "NewMocktransformer", "NewReader", "NopCloser", "NotNil", "Now", "Response", "Return", "Run", "SE", "SW", "Schiphol", "StatusCode", "T", "TODO", "TestForecaClient", "TestGetForecastForLocationValid", "Transform", "Unix", "bytes.NewReader", "c.GetForecastForLocation", "clients.NewForecaClient", "context.TODO", "f.CurrentCondition", "f.DailyConditions", "f.HourlyConditions", "foreca.CurrentCondition", "foreca.DailyCondition", "foreca.Forecast", "foreca.HourlyCondition", "gomock.Any", "http.Response", "httpClient.EXPECT", "io.NopCloser", "limiter.EXPECT", "mocks.NewMockhttpClient", "mocks.NewMockrateLimiter", "mocks.NewMocktransformer", "suite.Assert", "suite.Run", "suite.location", "suite.mockController", "testing.T", "time.Now", "transformerMock.EXPECT"], "header_context_minimal": "package \nimport \"time\"\n// receiver: suite *forecaClientTestSuite", "summary_llm": "This Go code contains tests for a `ForecaClient` that fetches weather forecasts. It uses mock objects to simulate HTTP responses and test the client's functionality.", "keywords_llm": ["go", "testing", "mocks", "forecaclient", "httpresponse", "currentcondition", "dailyforecast", "hourlyforecast", "context", "time", "limiter", "transformer", "location"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go", "rel_path": "internal/foreca/adapters/clients/foreca_client.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 139, "text": "package clients\n\nimport (\n\t\"context\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"github.com/pkg/errors\"\n\t\"go.impalastudios.com/log\"\n\txotel \"go.impalastudios.com/otel\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/utilities\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/text/cases\"\n\t\"golang.org/x/text/language\"\n\t\"io\"\n\t\"math\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype WeatherCondition struct {\n\tWeatherCode        string `xml:\"s,attr\"`\n\tWeatherDescription string `xml:\"sT,attr\"`\n}\n\ntype CurrentCondition struct {\n\tXMLName xml.Name `xml:\"obs\"`\n\n\tWeatherCondition\n\tStation              string  `xml:\"station,attr\"`\n\tTimestamp            string  `xml:\"dt,attr\"`\n\tTemperature          float64 `xml:\"t,attr\"`\n\tTemperatureFeelsLike float64 `xml:\"tf,attr\"`\n\tDewPoint             float64 `xml:\"d,attr\"`\n\tWindDirection        string  `xml:\"wn,attr\"`\n\tWindSpeed            float64 `xml:\"ws,attr\"`\n\tPressure             string  `xml:\"p,attr\"`\n\tHumidityPercentage   int     `xml:\"rh,attr\"`\n\tVisibility           int     `xml:\"v,attr\"`\n}\n\nfunc (cc *CurrentCondition) IsZero() bool {\n\tvar zero CurrentCondition\n\n\treturn zero == *cc\n}\n\nfunc (cc *CurrentCondition) IsValid() bool {\n\treturn !cc.IsZero() && cc.Timestamp != \"\"\n}\n\ntype DailyCondition struct {\n\tXMLName xml.Name `xml:\"fc\"`\n\n\tWeatherCondition\n\tDate                     string  `xml:\"dt,attr\"`\n\tMinTemperature           float64 `xml:\"tn,attr\"`\n\tMaxTemperature           float64 `xml:\"tx,attr\"`\n\tUVIndex                  float64 `xml:\"uvi,attr\"`\n\tWindDirection            string  `xml:\"wn,attr\"`\n\tWindSpeed                float64 `xml:\"wsx,attr\"`\n\tPrecipitation            float64 `xml:\"pr,attr\"`\n\tPrecipitationProbability int     `xml:\"pp,attr\"`\n\tSunriseTime              string  `xml:\"rise,attr\"`\n\tSunsetTime               string  `xml:\"set,attr\"`\n}\n\ntype HourlyCondition struct {\n\tXMLName xml.Name `xml:\"fc1h\"`\n\n\tWeatherCondition\n\tTimestamp                string  `xml:\"dt,attr\"`\n\tTemperature              float64 `xml:\"t,attr\"`\n\tTemperatureFeelsLike     float64 `xml:\"tf,attr\"`\n\tWindDirection            string  `xml:\"wn,attr\"`\n\tWindSpeed                float64 `xml:\"ws,attr\"`\n\tPrecipitation            float64 `xml:\"pr,attr\"`\n\tPrecipitationProbability int     `xml:\"pp,attr\"`\n\tHumidityPercentage       int     `xml:\"rh,attr\"`\n\tUVIndex                  float64 `xml:\"uvi,attr\"`\n\tPressure                 string  `xml:\"p,attr\"`\n}\n\ntype Response struct {\n\tXMLName xml.Name `xml:\"weather\"`\n\n\tCurrentCondition *CurrentCondition  `xml:\"loc>obs\"`\n\tDailyConditions  []*DailyCondition  `xml:\"loc>fc\"`\n\tHourlyConditions []*HourlyCondition `xml:\"loc>fc1h\"`\n}\n\nfunc (r Response) HasCurrentCondition() bool {\n\treturn r.CurrentCondition != nil && r.CurrentCondition.IsValid()\n}\n\ntype errorResponse struct {\n\tXMLName xml.Name `xml:\"error\"`\n\tMessage string   `xml:\"message,attr\"`\n}\n\n//go:generate /go/bin/mockgen -source=foreca_client.go -destination=mocks/foreca_client_mocks.go -package=mocks\ntype (\n\thttpClient interface {\n\t\tDo(*http.Request) (*http.Response, error)\n\t}\n\trateLimiter interface {\n\t\tAcquire(string) (int64, error)\n\t}\n\ttransformer interface {\n\t\tTransform(*Response, *time.Location) *foreca.Forecast\n\t}\n)\n\ntype ForecaClient struct {\n\thttp               httpClient\n\tendpoint           string\n\tdefaultQueryParams map[string]string\n\trl                 rateLimiter\n\trateLimitKey       string\n\ttransformer        transformer\n}\n\nfunc NewForecaClient(client httpClient, endpoint string, defaultQueryParams map[string]string, rl rateLimiter, t transformer) *ForecaClient {\n\treturn &ForecaClient{\n\t\thttp:               client,\n\t\tendpoint:           endpoint,\n\t\tdefaultQueryParams: defaultQueryParams,\n\t\trl:                 rl,\n\t\trateLimitKey:       \"foreca\",\n\t\ttransformer:        t,\n\t}\n}\n", "n_tokens": 1036, "primary_symbol": "IsZero", "primary_kind": "function", "primary_span": [48, 139], "def_symbols": ["IsZero", "IsValid", "HasCurrentCondition", "NewForecaClient"], "symbols": ["IsZero", "IsValid", "HasCurrentCondition", "NewForecaClient", "package", "clients", "import", "context", "encoding", "xml", "fmt", "github", "com", "pkg", "errors", "impalastudios", "log", "xotel", "otel", "weather", "foreca_proxy", "internal", "foreca", "ratelimit", "utilities", "opentelemetry", "attribute", "codes", "trace", "uber", "org", "zap", "golang", "text", "cases", "language", "math", "net", "http", "strconv", "strings", "time", "type", "WeatherCondition", "struct", "WeatherCode", "string", "attr", "WeatherDescription", "CurrentCondition", "XMLName", "Name", "obs", "Station", "station", "Timestamp", "Temperature", "float64", "TemperatureFeelsLike", "DewPoint", "WindDirection", "WindSpeed", "Pressure", "HumidityPercentage", "int", "Visibility", "func", "bool", "var", "zero", "return", "DailyCondition", "Date", "MinTemperature", "MaxTemperature", "UVIndex", "uvi", "wsx", "Precipitation", "PrecipitationProbability", "SunriseTime", "rise", "SunsetTime", "set", "HourlyCondition", "fc1h", "Response", "loc", "DailyConditions", "HourlyConditions", "nil", "errorResponse", "error", "Message", "message", "generate", "bin", "mockgen", "source", "foreca_client", "destination", "mocks", "foreca_client_mocks", "httpClient", "interface", "Request", "rateLimiter", "Acquire", "int64", "transformer", "Transform", "Location", "Forecast", "ForecaClient", "endpoint", "defaultQueryParams", "map", "rateLimitKey", "client"], "doc_head": "package clients\nimport (\n\t\"context\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"github.com/pkg/errors\"\n\t\"go.impalastudios.com/log\"\n\txotel \"go.impalastudios.com/otel\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/utilities\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/text/cases\"\n\t\"golang.org/x/text/language\"\n\t\"io\"\n\t\"math\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\ntype WeatherCondition struct {\n\tWeatherCode        string `xml:\"s,attr\"`\n\tWeatherDescription string `xml:\"sT,attr\"`\n}\ntype CurrentCondition struct {\n\tXMLName xml.Name `xml:\"obs\"`\n\tWeatherCondition\n\tStation              string  `xml:\"station,attr\"`\n\tTimestamp            string  `xml:\"dt,attr\"`\n\tTemperature          float64 `xml:\"t,attr\"`\n\tTemperatureFeelsLike float64 `xml:\"tf,attr\"`\n\tDewPoint             float64 `xml:\"d,attr\"`\n\tWindDirection        string  `xml:\"wn,attr\"`\n\tWindSpeed            float64 `xml:\"ws,attr\"`\n\tPressure             string  `xml:\"p,attr\"`\n\tHumidityPercentage   int     `xml:\"rh,attr\"`\n\tVisibility          ", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(cc *CurrentCondition).IsZero", "package": "clients", "node_kind": "method", "receiver": "cc *CurrentCondition", "function_name": "NewForecaClient", "method_name": "IsZero", "type_name": "WeatherCondition", "type_kind": "struct", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Acquire", "CurrentCondition", "DailyCondition", "DailyConditions", "Date", "DewPoint", "Do", "ForecaClient", "Forecast", "HasCurrentCondition", "HourlyCondition", "HourlyConditions", "HumidityPercentage", "IsValid", "IsZero", "Location", "MaxTemperature", "Message", "MinTemperature", "Name", "NewForecaClient", "Precipitation", "PrecipitationProbability", "Pressure", "Request", "Response", "Station", "SunriseTime", "SunsetTime", "Temperature", "TemperatureFeelsLike", "Timestamp", "Transform", "UVIndex", "Visibility", "WeatherCode", "WeatherCondition", "WeatherDescription", "WindDirection", "WindSpeed", "XMLName", "cc.IsZero", "cc.Timestamp", "foreca.Forecast", "foreca_client.go", "foreca_client_mocks.go", "github.com", "go.impalastudios", "go.opentelemetry", "go.uber", "golang.org", "http.Request", "http.Response", "r.CurrentCondition", "time.Location", "xml.Name"], "header_context_minimal": "package clients\nimport \"time\"\n// receiver: cc *CurrentCondition", "summary_llm": "The Go code defines a `ForecaClient` struct with methods to interact with the Foreca weather API. It includes structs for different types of weather conditions (current, daily, hourly) and a response transformer. The client handles HTTP requests, rate limiting, and data transformation.", "keywords_llm": ["forecaclient", "weatherapi", "httpclient", "ratelimiter", "transformer", "currentcondition", "dailycondition", "hourlycondition", "response", "forecast", "location", "timestamp"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go#2", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go", "rel_path": "internal/foreca/adapters/clients/foreca_client.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 140, "end_line": 303, "text": "func (c *ForecaClient) GetForecastForLocation(ctx context.Context, id int, loc *time.Location) (*foreca.Forecast, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"foreca-client:get-forecast\", trace.WithSpanKind(trace.SpanKindClient))\n\tdefer span.End()\n\n\tspan.SetAttributes(attribute.Int(\"location_id\", id))\n\n\tlog.Debug(ctx, \"Acquiring lock for key.\", zap.String(\"key\", c.rateLimitKey))\n\n\tepoch, err := c.rl.Acquire(c.rateLimitKey)\n\n\tlog.Debug(ctx, \"Lock acquired.\", zap.Int64(\"epoch\", epoch), zap.String(\"key\", c.rateLimitKey))\n\n\tif errors.Is(err, ratelimit.ErrLimitReached) {\n\t\tspan.SetAttributes(attribute.Bool(\"throttled\", true))\n\n\t\tlog.Warn(ctx,\n\t\t\t\"Request throttled.\",\n\t\t\tzap.Int(\"location_id\", id),\n\t\t)\n\n\t\treturn nil, foreca.ErrRequestThrottled\n\t} else if c.isLimiterError(err) {\n\t\tspan.SetStatus(codes.Error, \"Limiter experienced an error.\")\n\t\tspan.RecordError(err)\n\n\t\tlog.Warn(ctx,\n\t\t\t\"Limiter experienced an error.\",\n\t\t\tzap.Int(\"location_id\", id),\n\t\t\tzap.Error(err),\n\t\t)\n\n\t\treturn nil, errors.Wrap(err, \"foreca client: limiter error\")\n\t} else if err != nil {\n\t\tspan.SetStatus(codes.Error, \"An error occurred.\")\n\t\tspan.RecordError(err)\n\n\t\tlog.Warn(ctx,\n\t\t\t\"Unexpected error occurred.\",\n\t\t\tzap.Int(\"location_id\", id),\n\t\t\tzap.Error(err),\n\t\t)\n\n\t\treturn nil, errors.Wrap(err, \"foreca client: generic error\")\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, c.endpoint, nil)\n\tif err != nil {\n\t\tlog.Error(ctx, \"Cannot create request.\", zap.Int(\"id\", id), zap.Error(err))\n\t\treturn nil, errors.Wrap(err, \"foreca client: cannot create request\")\n\t}\n\n\tq := req.URL.Query()\n\tfor key, value := range c.defaultQueryParams {\n\t\tq.Add(key, value)\n\t}\n\tq.Add(\"l\", fmt.Sprintf(\"%d\", id))\n\treq.URL.RawQuery = q.Encode()\n\n\tresp, err := c.http.Do(req)\n\tif err != nil {\n\t\tlog.Error(ctx,\n\t\t\t\"Error occurred with the HTTP request.\",\n\t\t\tzap.Int(\"location_id\", id),\n\t\t\tzap.Error(err),\n\t\t)\n\t\treturn nil, errors.Wrap(err, \"foreca client: http error\")\n\t}\n\n\tdefer func() {\n\t\tif err := resp.Body.Close(); err != nil {\n\t\t\tlog.Error(ctx,\n\t\t\t\t\"Error occurred while closing the response body stream.\",\n\t\t\t\tzap.Int(\"id\", id),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}()\n\n\tbody, _ := io.ReadAll(resp.Body)\n\tvar r *Response\n\terr = xml.Unmarshal(body, &r)\n\tif err != nil {\n\t\tspan.SetStatus(codes.Error, \"An error occurred.\")\n\t\tspan.RecordError(err)\n\n\t\tvar e errorResponse\n\t\tif err := xml.Unmarshal(body, &e); err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"foreca client: cannot unmarshal response\")\n\t\t}\n\n\t\tlog.Error(ctx, \"Cannot get forecast for location.\", zap.Int(\"id\", id), zap.Any(\"error\", e))\n\t\treturn nil, errors.Wrap(err, \"foreca client: client error\")\n\t}\n\n\treturn c.transformer.Transform(r, loc), nil\n}\n\nfunc (c *ForecaClient) isLimiterError(err error) bool {\n\tlist := [...]error{ratelimit.ErrKeyEmpty, ratelimit.ErrCountZero, ratelimit.ErrLimitZero, ratelimit.ErrCountLimit, ratelimit.ErrZeroDuration}\n\tfor _, e := range list {\n\t\tif err == e {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\ntype forecaTransformer struct {\n\tcct *currentConditionTransformer\n\tdft *dailyForecastTransformer\n\thft *hourlyForecastTransformer\n}\n\nfunc NewTransformer() *forecaTransformer {\n\treturn &forecaTransformer{\n\t\tcct: NewCurrentConditionTransformer(),\n\t\tdft: NewDailyForecastTransformer(),\n\t\thft: NewHourlyForecastTransformer(),\n\t}\n}\n\nfunc (t *forecaTransformer) Transform(f *Response, location *time.Location) *foreca.Forecast {\n\tcc := f.CurrentCondition\n\tvar firstHourForecast *HourlyCondition\n\tif len(f.HourlyConditions) > 0 {\n\t\tfirstHourForecast = f.HourlyConditions[0]\n\t}\n\n\tvar dfs []*foreca.DailyCondition\n\n\tfor _, d := range f.DailyConditions {\n\t\tdfs = append(dfs, t.dft.Transform(d, t.getHourlyForecastsForDate(d.Date, f.HourlyConditions), location))\n\t}\n\n\tvar hfs []*foreca.HourlyCondition\n\tfor _, h := range f.HourlyConditions {\n\t\thfs = append(hfs, t.hft.Transform(h, location))\n\t}\n\n\treturn &foreca.Forecast{\n\t\tCurrentCondition: t.cct.Transform(cc, firstHourForecast, location),\n\t\tDailyConditions:  dfs,\n\t\tHourlyConditions: hfs,\n\t}\n}\n\nfunc (t *forecaTransformer) getHourlyForecastsForDate(d string, hfs []*HourlyCondition) []*HourlyCondition {\n\tvar r []*HourlyCondition\n\n\tfor _, h := range hfs {\n\t\tif strings.HasPrefix(h.Timestamp, d) {\n\t\t\tr = append(r, h)\n\t\t}\n\t}\n\n\treturn r\n}\n\ntype currentConditionTransformer struct{}\n\nfunc NewCurrentConditionTransformer() *currentConditionTransformer {\n\treturn &currentConditionTransformer{}\n}\n", "n_tokens": 1194, "primary_symbol": "GetForecastForLocation", "primary_kind": "function", "primary_span": [140, 303], "def_symbols": ["GetForecastForLocation", "isLimiterError", "NewTransformer", "Transform", "getHourlyForecastsForDate", "NewCurrentConditionTransformer"], "symbols": ["GetForecastForLocation", "isLimiterError", "NewTransformer", "Transform", "getHourlyForecastsForDate", "NewCurrentConditionTransformer", "func", "ForecaClient", "ctx", "context", "Context", "int", "loc", "time", "Location", "foreca", "Forecast", "error", "span", "xotel", "Tracer", "Start", "client", "get", "forecast", "trace", "WithSpanKind", "SpanKindClient", "defer", "End", "SetAttributes", "attribute", "Int", "location_id", "log", "Debug", "Acquiring", "lock", "for", "key", "zap", "String", "rateLimitKey", "epoch", "err", "Acquire", "Lock", "acquired", "Int64", "errors", "ratelimit", "ErrLimitReached", "Bool", "throttled", "true", "Warn", "Request", "return", "nil", "ErrRequestThrottled", "else", "SetStatus", "codes", "Error", "Limiter", "experienced", "RecordError", "Wrap", "limiter", "occurred", "Unexpected", "generic", "req", "http", "NewRequestWithContext", "MethodGet", "endpoint", "Cannot", "create", "request", "cannot", "URL", "Query", "value", "range", "defaultQueryParams", "Add", "fmt", "Sprintf", "RawQuery", "Encode", "resp", "with", "the", "HTTP", "Body", "Close", "while", "closing", "response", "body", "stream", "ReadAll", "var", "Response", "xml", "Unmarshal", "errorResponse", "unmarshal", "location", "Any", "transformer", "bool", "list", "ErrKeyEmpty", "ErrCountZero", "ErrLimitZero", "ErrCountLimit", "ErrZeroDuration", "false", "type", "forecaTransformer", "struct", "cct", "currentConditionTransformer", "dft", "dailyForecastTransformer", "hft", "hourlyForecastTransformer", "NewDailyForecastTransformer", "NewHourlyForecastTransformer", "CurrentCondition", "firstHourForecast", "HourlyCondition", "len", "HourlyConditions", "dfs", "DailyCondition", "DailyConditions", "append", "Date", "hfs", "string", "strings", "HasPrefix", "Timestamp"], "doc_head": "func (c *ForecaClient) GetForecastForLocation(ctx context.Context, id int, loc *time.Location) (*foreca.Forecast, error) {\n\tctx, span := xotel.Tracer.Start(ctx, \"foreca-client:get-forecast\", trace.WithSpanKind(trace.SpanKindClient))\n\tdefer span.End()\n\tspan.SetAttributes(attribute.Int(\"location_id\", id))\n\tlog.Debug(ctx, \"Acquiring lock for key.\", zap.String(\"key\", c.rateLimitKey))\n\tepoch, err := c.rl.Acquire(c.rateLimitKey)\n\tlog.Debug(ctx, \"Lock acquired.\", zap.Int64(\"epoch\", epoch), zap.String(\"key\", c.rateLimitKey))\n\tif errors.Is(err, ratelimit.ErrLimitReached) {\n\t\tspan.SetAttributes(attribute.Bool(\"throttled\", true))\n\t\tlog.Warn(ctx,\n\t\t\t\"Request throttled.\",\n\t\t\tzap.Int(\"location_id\", id),\n\t\t)\n\t\treturn nil, foreca.ErrRequestThrottled\n\t} else if c.isLimiterError(err) {\n\t\tspan.SetStatus(codes.Error, \"Limiter experienced an error.\")\n\t\tspan.RecordError(err)\n\t\tlog.Warn(ctx,\n\t\t\t\"Limiter experienced an error.\",\n\t\t\tzap.Int(\"location_id\", id),\n\t\t\tzap.Error(err),\n\t\t)\n\t\treturn nil, errors.Wrap(err, \"foreca client: limiter error\")\n\t} else if err != nil {\n\t\tspan.SetStatus(codes.Error, \"An error occurred.\")\n\t\tspan.RecordError(err)\n\t\tlog.Warn(ctx,\n\t\t\t\"Unexpected error occurred.\",\n\t\t\tzap.Int(\"loca", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(c *ForecaClient).GetForecastForLocation", "package": "", "node_kind": "method", "receiver": "c *ForecaClient", "function_name": "NewTransformer", "method_name": "GetForecastForLocation", "type_name": "forecaTransformer", "type_kind": "struct", "imports_used_minimal": ["go.impalastudios.com/otel", "go.uber.org/zap", "time"], "symbols_referenced_strict": ["Acquire", "Acquiring", "Add", "An", "Any", "Body", "Bool", "Cannot", "Close", "Context", "CurrentCondition", "DailyCondition", "DailyConditions", "Date", "Debug", "Do", "Encode", "End", "ErrCountLimit", "ErrCountZero", "ErrKeyEmpty", "ErrLimitReached", "ErrLimitZero", "ErrRequestThrottled", "ErrZeroDuration", "Error", "ForecaClient", "Forecast", "GetForecastForLocation", "HTTP", "HasPrefix", "HourlyCondition", "HourlyConditions", "Int", "Int64", "Is", "Limiter", "Location", "Lock", "MethodGet", "NewCurrentConditionTransformer", "NewDailyForecastTransformer", "NewHourlyForecastTransformer", "NewRequestWithContext", "NewTransformer", "Query", "RawQuery", "ReadAll", "RecordError", "Request", "Response", "SetAttributes", "SetStatus", "SpanKindClient", "Sprintf", "Start", "String", "Timestamp", "Tracer", "Transform", "URL", "Unexpected", "Unmarshal", "Warn", "WithSpanKind", "Wrap", "attribute.Bool", "attribute.Int", "c.defaultQueryParams", "c.endpoint", "c.http", "c.isLimiterError", "c.rateLimitKey", "c.rl", "c.transformer", "codes.Error", "context.Context", "d.Date", "errors.Is", "errors.Wrap", "f.CurrentCondition", "f.DailyConditions", "f.HourlyConditions", "fmt.Sprintf", "foreca.DailyCondition", "foreca.ErrRequestThrottled", "foreca.Forecast", "foreca.HourlyCondition", "h.Timestamp", "http.MethodGet", "http.NewRequestWithContext", "io.ReadAll", "log.Debug", "log.Error", "log.Warn", "q.Add", "q.Encode", "ratelimit.ErrCountLimit", "ratelimit.ErrCountZero", "ratelimit.ErrKeyEmpty", "ratelimit.ErrLimitReached", "ratelimit.ErrLimitZero", "ratelimit.ErrZeroDuration", "req.URL", "resp.Body", "span.End", "span.RecordError", "span.SetAttributes", "span.SetStatus", "strings.HasPrefix", "t.cct", "t.dft", "t.getHourlyForecastsForDate", "t.hft", "time.Location", "trace.SpanKindClient", "trace.WithSpanKind", "xml.Unmarshal", "xotel.Tracer", "zap.Any", "zap.Error", "zap.Int", "zap.Int64", "zap.String"], "header_context_minimal": "package \nimport (\n    \"go.impalastudios.com/otel\"\n    \"go.uber.org/zap\"\n    \"time\"\n)\n// receiver: c *ForecaClient", "summary_llm": "The `GetForecastForLocation` method of the `ForecaClient` struct fetches weather forecasts for a specified location. It uses rate limiting and logs various events throughout the process.", "keywords_llm": ["forecaclient", "getforecastforlocation", "rate_limit_key", "http_request", "xml_unmarshal", "transformer", "currentcondition", "dailyconditions", "hourlyconditions"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go#3", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go", "rel_path": "internal/foreca/adapters/clients/foreca_client.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 304, "end_line": 426, "text": "func (t *currentConditionTransformer) Transform(c *CurrentCondition, hf *HourlyCondition, location *time.Location) *foreca.CurrentCondition {\n\tvar icc foreca.CurrentCondition\n\n\tif c == nil && hf == nil {\n\t\treturn nil\n\t}\n\n\tif c == nil && hf != nil {\n\t\tc = t.buildCurrentConditionFromHourlyForecast(hf)\n\t}\n\n\ticc.Epoch = getUtcEpochForFormatInLocation(c.Timestamp, \"2006-01-02 15:04:05\", location)\n\ticc.Visibility = utilities.Round(float64(c.Visibility)*0.001, 1)\n\ticc.WeatherCondition = buildWeatherCondition(c.WeatherCode, c.WeatherDescription)\n\ticc.Temperature = utilities.Round(c.Temperature, 1)\n\ticc.HumidityPercentage = c.HumidityPercentage\n\ticc.WindGust = buildWindGust(c.WindDirection, c.WindSpeed, 0)\n\ticc.Pressure = buildPressure(c.Pressure)\n\ticc.DewPoint = utilities.Round(c.DewPoint, 1)\n\ticc.HeatIndex = utilities.Round(\n\t\tutilities.FahrenheitToCelsius(\n\t\t\tt.computeHeatIndex(utilities.CelsiusToFahrenheit(icc.Temperature), utilities.CelsiusToFahrenheit(icc.DewPoint)),\n\t\t),\n\t\t1,\n\t)\n\ticc.TemperatureFeelsLike = utilities.Round(\n\t\tutilities.FahrenheitToCelsius(\n\t\t\tt.computeTemperatureFeelsLike(\n\t\t\t\tutilities.CelsiusToFahrenheit(icc.Temperature),\n\t\t\t\tutilities.CelsiusToFahrenheit(icc.HeatIndex),\n\t\t\t\tutilities.KilometersToMiles(icc.WindGust.Wind.Speed),\n\t\t\t),\n\t\t),\n\t\t1,\n\t)\n\n\tif hf != nil {\n\t\ticc.UVIndex = hf.UVIndex\n\t\ticc.Precipitation = parsePrecipitationForWeatherCode(hf.WeatherCode, hf.Precipitation)\n\t\ticc.WeatherConditionNextHour = buildWeatherCondition(hf.WeatherCode, hf.WeatherDescription)\n\t\ticc.PrecipitationNextHour = parsePrecipitationForWeatherCode(hf.WeatherCode, hf.Precipitation)\n\t}\n\n\treturn &icc\n}\n\nfunc (t *currentConditionTransformer) buildCurrentConditionFromHourlyForecast(hf *HourlyCondition) *CurrentCondition {\n\tvar cc CurrentCondition\n\n\tif hf.Timestamp != \"\" {\n\t\tcc.Timestamp = fmt.Sprintf(\"%s:00\", hf.Timestamp)\n\t} else {\n\t\tcc.Timestamp = time.Now().UTC().Format(\"2006-01-02 15:04:05\")\n\t}\n\n\tcc.Station = \"\"\n\tif hf.WeatherCode != \"\" {\n\t\tcc.WeatherCode = hf.WeatherCode\n\t} else {\n\t\tcc.WeatherCode = \"d000\"\n\t}\n\n\tif hf.WeatherDescription != \"\" {\n\t\tcc.WeatherDescription = hf.WeatherDescription\n\t} else {\n\t\tcc.WeatherDescription = \"clear\"\n\t}\n\n\tcc.Visibility = 0\n\n\tcc.Temperature = hf.Temperature\n\tcc.TemperatureFeelsLike = cc.Temperature\n\tcc.DewPoint = 0\n\tcc.WindDirection = hf.WindDirection\n\tcc.WindSpeed = hf.WindSpeed\n\tcc.Pressure = hf.Pressure\n\tcc.HumidityPercentage = hf.HumidityPercentage\n\n\treturn &cc\n}\n\n// computeHeatIndex computes heat index based on temperature in fahrenheit and dewPoint in fahrenheit.\n// Returns index in fahrenheit.\n//\n// Source: http://www.wpc.ncep.noaa.gov/html/heatindex.shtml\n// Source: http://www.wpc.ncep.noaa.gov/html/heatindex_equation.shtml\n// Source: http://www.wpc.ncep.noaa.gov/html/dewrh.shtml\nfunc (t *currentConditionTransformer) computeHeatIndex(temperature float64, dewPoint float64) float64 {\n\trh := t.computeRelativeHumidity(temperature, dewPoint)\n\thiSteadman := 0.5 * (temperature + 61 + ((temperature - 68) * 1.2) + (rh * 0.094))\n\n\tif hiSteadman < 80 {\n\t\treturn hiSteadman\n\t}\n\n\thiRothfusz := -42.379 +\n\t\t2.04901523*temperature +\n\t\t10.14333127*rh -\n\t\t0.22475541*temperature*rh -\n\t\t0.00683783*temperature*temperature -\n\t\t0.05481717*rh*rh +\n\t\t0.00122874*temperature*temperature*rh +\n\t\t0.00085282*temperature*rh*rh -\n\t\t0.00000199*temperature*temperature*rh*rh\n\n\tadjustment := 0.0\n\tif rh <= 13 && temperature >= 80 && temperature <= 112 {\n\t\tadjustment = ((13 - rh) / 4) * math.Sqrt((17-math.Abs(temperature-95))/17)\n\t} else if rh >= 85 && temperature >= 80 && temperature <= 87 {\n\t\tadjustment = ((rh - 85) / 10) * ((87 - temperature) / 5)\n\t}\n\n\treturn hiRothfusz + adjustment\n}\n\n// computeRelativeHumidity computes relative humidity based on temperature in fahrenheit and dewPoint in fahrenheit.\n// Returns relative humidity in fahrenheit.\n//\n// Source: http://andrew.rsmas.miami.edu/bmcnoldy/Humidity.html\nfunc (t *currentConditionTransformer) computeRelativeHumidity(temperature float64, dewPoint float64) float64 {\n\treturn (math.Exp((17.623*dewPoint)/(243.04+dewPoint)) / math.Exp((17.625*temperature)/(243.04+temperature))) * 100\n}\n", "n_tokens": 1217, "primary_symbol": "Transform", "primary_kind": "function", "primary_span": [304, 426], "def_symbols": ["Transform", "buildCurrentConditionFromHourlyForecast", "computeHeatIndex", "computeRelativeHumidity"], "symbols": ["Transform", "buildCurrentConditionFromHourlyForecast", "computeHeatIndex", "computeRelativeHumidity", "func", "currentConditionTransformer", "CurrentCondition", "HourlyCondition", "location", "time", "Location", "foreca", "var", "icc", "nil", "return", "Epoch", "getUtcEpochForFormatInLocation", "Timestamp", "Visibility", "utilities", "Round", "float64", "WeatherCondition", "buildWeatherCondition", "WeatherCode", "WeatherDescription", "Temperature", "HumidityPercentage", "WindGust", "buildWindGust", "WindDirection", "WindSpeed", "Pressure", "buildPressure", "DewPoint", "HeatIndex", "FahrenheitToCelsius", "CelsiusToFahrenheit", "TemperatureFeelsLike", "computeTemperatureFeelsLike", "KilometersToMiles", "Wind", "Speed", "UVIndex", "Precipitation", "parsePrecipitationForWeatherCode", "WeatherConditionNextHour", "PrecipitationNextHour", "fmt", "Sprintf", "else", "Now", "UTC", "Format", "Station", "d000", "clear", "computes", "heat", "index", "based", "temperature", "fahrenheit", "and", "dewPoint", "Returns", "Source", "http", "www", "wpc", "ncep", "noaa", "gov", "html", "heatindex", "shtml", "heatindex_equation", "dewrh", "hiSteadman", "hiRothfusz", "adjustment", "math", "Sqrt", "Abs", "relative", "humidity", "andrew", "rsmas", "miami", "edu", "bmcnoldy", "Humidity", "Exp"], "doc_head": "func (t *currentConditionTransformer) Transform(c *CurrentCondition, hf *HourlyCondition, location *time.Location) *foreca.CurrentCondition {\n\tvar icc foreca.CurrentCondition\n\tif c == nil && hf == nil {\n\t\treturn nil\n\t}\n\tif c == nil && hf != nil {\n\t\tc = t.buildCurrentConditionFromHourlyForecast(hf)\n\t}\n\ticc.Epoch = getUtcEpochForFormatInLocation(c.Timestamp, \"2006-01-02 15:04:05\", location)\n\ticc.Visibility = utilities.Round(float64(c.Visibility)*0.001, 1)\n\ticc.WeatherCondition = buildWeatherCondition(c.WeatherCode, c.WeatherDescription)\n\ticc.Temperature = utilities.Round(c.Temperature, 1)\n\ticc.HumidityPercentage = c.HumidityPercentage\n\ticc.WindGust = buildWindGust(c.WindDirection, c.WindSpeed, 0)\n\ticc.Pressure = buildPressure(c.Pressure)\n\ticc.DewPoint = utilities.Round(c.DewPoint, 1)\n\ticc.HeatIndex = utilities.Round(\n\t\tutilities.FahrenheitToCelsius(\n\t\t\tt.computeHeatIndex(utilities.CelsiusToFahrenheit(icc.Temperature), utilities.CelsiusToFahrenheit(icc.DewPoint)),\n\t\t),\n\t\t1,\n\t)\n\ticc.TemperatureFeelsLike = utilities.Round(\n\t\tutilities.FahrenheitToCelsius(\n\t\t\tt.computeTemperatureFeelsLike(\n\t\t\t\tutilities.CelsiusToFahrenheit(icc.Temperature),\n\t\t\t\tutilities.CelsiusToFahrenheit(icc.HeatIndex", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(t *currentConditionTransformer).Transform", "package": "", "node_kind": "method", "receiver": "t *currentConditionTransformer", "function_name": "", "method_name": "Transform", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Abs", "CelsiusToFahrenheit", "CurrentCondition", "DewPoint", "Epoch", "Exp", "FahrenheitToCelsius", "Format", "HeatIndex", "HourlyCondition", "Humidity", "Humidity.html", "HumidityPercentage", "KilometersToMiles", "Location", "Now", "Precipitation", "PrecipitationNextHour", "Pressure", "Returns", "Round", "Source", "Speed", "Sprintf", "Sqrt", "Station", "Temperature", "TemperatureFeelsLike", "Timestamp", "Transform", "UTC", "UVIndex", "Visibility", "WeatherCode", "WeatherCondition", "WeatherConditionNextHour", "WeatherDescription", "Wind", "Wind.Speed", "WindDirection", "WindGust", "WindSpeed", "andrew.rsmas", "c.DewPoint", "c.HumidityPercentage", "c.Pressure", "c.Temperature", "c.Timestamp", "c.Visibility", "c.WeatherCode", "c.WeatherDescription", "c.WindDirection", "c.WindSpeed", "cc.DewPoint", "cc.HumidityPercentage", "cc.Pressure", "cc.Station", "cc.Temperature", "cc.TemperatureFeelsLike", "cc.Timestamp", "cc.Visibility", "cc.WeatherCode", "cc.WeatherDescription", "cc.WindDirection", "cc.WindSpeed", "dewrh.shtml", "fmt.Sprintf", "foreca.CurrentCondition", "heatindex.shtml", "heatindex_equation.shtml", "hf.HumidityPercentage", "hf.Precipitation", "hf.Pressure", "hf.Temperature", "hf.Timestamp", "hf.UVIndex", "hf.WeatherCode", "hf.WeatherDescription", "hf.WindDirection", "hf.WindSpeed", "icc.DewPoint", "icc.Epoch", "icc.HeatIndex", "icc.HumidityPercentage", "icc.Precipitation", "icc.PrecipitationNextHour", "icc.Pressure", "icc.Temperature", "icc.TemperatureFeelsLike", "icc.UVIndex", "icc.Visibility", "icc.WeatherCondition", "icc.WeatherConditionNextHour", "icc.WindGust", "math.Abs", "math.Exp", "math.Sqrt", "miami.edu", "ncep.noaa", "t.buildCurrentConditionFromHourlyForecast", "t.computeHeatIndex", "t.computeRelativeHumidity", "t.computeTemperatureFeelsLike", "time.Location", "time.Now", "utilities.CelsiusToFahrenheit", "utilities.FahrenheitToCelsius", "utilities.KilometersToMiles", "utilities.Round", "www.wpc"], "header_context_minimal": "package \nimport \"time\"\n// receiver: t *currentConditionTransformer", "summary_llm": "This Go code defines a `currentConditionTransformer` struct with methods to transform `CurrentCondition` and `HourlyCondition` objects into `foreca.CurrentCondition`. It handles cases where input objects may be nil and computes various weather-related metrics like heat index, relative humidity, and temperature feels-like.", "keywords_llm": ["transform", "currentconditiontransformer", "currentcondition", "hourlycondition", "foreca.currentcondition", "heatindex", "relativehumidity", "temperaturefeelslike", "computeheatindex", "computerelativehumidity"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go#4", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go", "rel_path": "internal/foreca/adapters/clients/foreca_client.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 427, "end_line": 532, "text": "// computeTemperatureFeelsLike computes feels like temperature based on temperature in fahrenheit, heat index in fahrenheit, and windSpeed in mi/h.\n// Returns relative humidity in Fahrenheit.\nfunc (t *currentConditionTransformer) computeTemperatureFeelsLike(temperature float64, heatIndex float64, windSpeed float64) float64 {\n\tif temperature > 80 {\n\t\treturn heatIndex\n\t}\n\n\tif temperature < 50 {\n\t\treturn t.computeWindChill(temperature, windSpeed)\n\t}\n\n\treturn temperature\n}\n\n// Compute wind chill based on temperature in fahrenheit and windSpeed in miles per hour.\n// Returns wind chill in fahrenheit.\n//\n// Source: http://www.nws.noaa.gov/om/winter/windchill.shtml\nfunc (t *currentConditionTransformer) computeWindChill(temperature float64, windSpeed float64) float64 {\n\tisColdEnough := temperature > -50 && temperature < 50\n\tisWindyEnough := windSpeed > 3 && windSpeed < 110\n\n\tif isColdEnough && isWindyEnough {\n\t\treturn 35.74 + 0.6215*temperature - 35.75*math.Pow(windSpeed, 0.16) + 0.4275*temperature*math.Pow(windSpeed, 0.16)\n\t}\n\n\treturn temperature\n}\n\ntype dailyForecastTransformer struct{}\n\nfunc NewDailyForecastTransformer() *dailyForecastTransformer {\n\treturn &dailyForecastTransformer{}\n}\n\nfunc (t *dailyForecastTransformer) Transform(d *DailyCondition, hfs []*HourlyCondition, location *time.Location) *foreca.DailyCondition {\n\tvar df foreca.DailyCondition\n\n\tdf.Epoch = getUtcEpochForFormatInLocation(d.Date, \"2006-01-02\", location)\n\tdf.MinTemperature = utilities.Round(d.MinTemperature, 1)\n\tdf.MaxTemperature = utilities.Round(d.MaxTemperature, 1)\n\tdf.WeatherCondition = buildWeatherCondition(d.WeatherCode, d.WeatherDescription)\n\tdf.Precipitation = utilities.Round(parsePrecipitationForWeatherCode(d.WeatherCode, d.Precipitation), 1)\n\tdf.PrecipitationProbability = d.PrecipitationProbability\n\tdf.PrecipitationDay = utilities.Round(d.Precipitation*0.5, 1)\n\tdf.PrecipitationNight = utilities.Round(d.Precipitation*0.5, 1)\n\tdf.Wind = buildWind(d.WindDirection, d.WindSpeed)\n\tdf.UVIndex = d.UVIndex\n\tdf.AverageHumidityPercentage = 0\n\tdf.SnowDay = 0\n\tdf.SnowNight = 0\n\tdf.WeatherConditionNight = buildWeatherCondition(d.WeatherCode, d.WeatherDescription)\n\tdf.SunriseEpoch = getUtcEpochForFormatInLocation(fmt.Sprintf(\"%s %s\", d.Date, d.SunriseTime), \"2006-01-02 15:04:05\", location)\n\tdf.SunsetEpoch = getUtcEpochForFormatInLocation(fmt.Sprintf(\"%s %s\", d.Date, d.SunsetTime), \"2006-01-02 15:04:05\", location)\n\n\tif len(hfs) > 0 {\n\t\tdf.MinTemperature = utilities.Round(t.getMinimumTemperature(hfs), 1)\n\t\tdf.MaxTemperature = utilities.Round(t.getMaximumTemperature(hfs), 1)\n\t\tdf.AverageHumidityPercentage = int(math.Round(t.getAverageHumidityPercentage(hfs)))\n\n\t\troundedSunriseTime := roundToNextHour(*getTimeForFormatInLocation(fmt.Sprintf(\"%s %s\", d.Date, d.SunriseTime), \"2006-01-02 15:04:05\", location))\n\t\troundedSunsetTime := roundToNextHour(*getTimeForFormatInLocation(fmt.Sprintf(\"%s %s\", d.Date, d.SunsetTime), \"2006-01-02 15:04:05\", location))\n\t\tdayHourlyForecasts := t.getDayHourlyForecasts(hfs, \"2006-01-02 15:04\", roundedSunriseTime, roundedSunsetTime, location)\n\t\tdf.PrecipitationDay = utilities.Round(t.getTotalPrecipitation(dayHourlyForecasts), 1)\n\n\t\tnightHourlyForecasts := t.getNightHourlyForecasts(hfs, \"2006-01-02 15:04\", roundedSunriseTime, roundedSunsetTime, location)\n\t\tdf.PrecipitationNight = utilities.Round(t.getTotalPrecipitation(nightHourlyForecasts), 1)\n\t\tnightWeatherCode := t.getAverageWeatherCodeForHourlyForecasts(nightHourlyForecasts)\n\t\tdf.WeatherConditionNight = buildWeatherCondition(nightWeatherCode, \"\")\n\n\t\tif isSnowWeatherCode(d.WeatherCode) {\n\t\t\tdf.SnowDay = df.PrecipitationDay\n\t\t}\n\n\t\tif isSnowWeatherCode(nightWeatherCode) {\n\t\t\tdf.SnowNight = df.PrecipitationNight\n\t\t}\n\t}\n\n\treturn &df\n}\n\nfunc (t *dailyForecastTransformer) getMaximumTemperature(hfs []*HourlyCondition) float64 {\n\tmax := math.Inf(-1)\n\n\tfor _, h := range hfs {\n\t\tif h.Temperature > max {\n\t\t\tmax = h.Temperature\n\t\t}\n\t}\n\n\treturn max\n}\n\nfunc (t *dailyForecastTransformer) getMinimumTemperature(hfs []*HourlyCondition) float64 {\n\tmin := math.Inf(1)\n\n\tfor _, h := range hfs {\n\t\tif h.Temperature < min {\n\t\t\tmin = h.Temperature\n\t\t}\n\t}\n\n\treturn min\n}\n", "n_tokens": 1166, "primary_symbol": "computeTemperatureFeelsLike", "primary_kind": "function", "primary_span": [429, 532], "def_symbols": ["computeTemperatureFeelsLike", "computeWindChill", "NewDailyForecastTransformer", "Transform", "getMaximumTemperature", "getMinimumTemperature"], "symbols": ["computeTemperatureFeelsLike", "computeWindChill", "NewDailyForecastTransformer", "Transform", "getMaximumTemperature", "getMinimumTemperature", "computes", "feels", "like", "temperature", "based", "fahrenheit", "heat", "index", "and", "windSpeed", "Returns", "relative", "humidity", "Fahrenheit", "func", "currentConditionTransformer", "float64", "heatIndex", "return", "Compute", "wind", "chill", "miles", "per", "hour", "Source", "http", "www", "nws", "noaa", "gov", "winter", "windchill", "shtml", "isColdEnough", "isWindyEnough", "math", "Pow", "type", "dailyForecastTransformer", "struct", "DailyCondition", "hfs", "HourlyCondition", "location", "time", "Location", "foreca", "var", "Epoch", "getUtcEpochForFormatInLocation", "Date", "MinTemperature", "utilities", "Round", "MaxTemperature", "WeatherCondition", "buildWeatherCondition", "WeatherCode", "WeatherDescription", "Precipitation", "parsePrecipitationForWeatherCode", "PrecipitationProbability", "PrecipitationDay", "PrecipitationNight", "Wind", "buildWind", "WindDirection", "WindSpeed", "UVIndex", "AverageHumidityPercentage", "SnowDay", "SnowNight", "WeatherConditionNight", "SunriseEpoch", "fmt", "Sprintf", "SunriseTime", "SunsetEpoch", "SunsetTime", "len", "int", "getAverageHumidityPercentage", "roundedSunriseTime", "roundToNextHour", "getTimeForFormatInLocation", "roundedSunsetTime", "dayHourlyForecasts", "getDayHourlyForecasts", "getTotalPrecipitation", "nightHourlyForecasts", "getNightHourlyForecasts", "nightWeatherCode", "getAverageWeatherCodeForHourlyForecasts", "isSnowWeatherCode", "max", "Inf", "for", "range", "Temperature", "min"], "doc_head": "// computeTemperatureFeelsLike computes feels like temperature based on temperature in fahrenheit, heat index in fahrenheit, and windSpeed in mi/h.\n// Returns relative humidity in Fahrenheit.\nfunc (t *currentConditionTransformer) computeTemperatureFeelsLike(temperature float64, heatIndex float64, windSpeed float64) float64 {\n\tif temperature > 80 {\n\t\treturn heatIndex\n\t}\n\tif temperature < 50 {\n\t\treturn t.computeWindChill(temperature, windSpeed)\n\t}\n\treturn temperature\n}\n// Compute wind chill based on temperature in fahrenheit and windSpeed in miles per hour.\n// Returns wind chill in fahrenheit.\n//\n// Source: http://www.nws.noaa.gov/om/winter/windchill.shtml\nfunc (t *currentConditionTransformer) computeWindChill(temperature float64, windSpeed float64) float64 {\n\tisColdEnough := temperature > -50 && temperature < 50\n\tisWindyEnough := windSpeed > 3 && windSpeed < 110\n\tif isColdEnough && isWindyEnough {\n\t\treturn 35.74 + 0.6215*temperature - 35.75*math.Pow(windSpeed, 0.16) + 0.4275*temperature*math.Pow(windSpeed, 0.16)\n\t}\n\treturn temperature\n}\ntype dailyForecastTransformer struct{}\nfunc NewDailyForecastTransformer() *dailyForecastTransformer {\n\treturn &dailyForecastTransformer{}\n}\nfunc (t ", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(t *currentConditionTransformer).computeTemperatureFeelsLike", "package": "", "node_kind": "method", "receiver": "t *currentConditionTransformer", "function_name": "NewDailyForecastTransformer", "method_name": "computeTemperatureFeelsLike", "type_name": "dailyForecastTransformer", "type_kind": "struct", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["AverageHumidityPercentage", "Compute", "DailyCondition", "Date", "Epoch", "Fahrenheit", "HourlyCondition", "Inf", "Location", "MaxTemperature", "MinTemperature", "NewDailyForecastTransformer", "Pow", "Precipitation", "PrecipitationDay", "PrecipitationNight", "PrecipitationProbability", "Returns", "Round", "SnowDay", "SnowNight", "Source", "Sprintf", "SunriseEpoch", "SunriseTime", "SunsetEpoch", "SunsetTime", "Temperature", "Transform", "UVIndex", "WeatherCode", "WeatherCondition", "WeatherConditionNight", "WeatherDescription", "Wind", "WindDirection", "WindSpeed", "d.Date", "d.MaxTemperature", "d.MinTemperature", "d.Precipitation", "d.PrecipitationProbability", "d.SunriseTime", "d.SunsetTime", "d.UVIndex", "d.WeatherCode", "d.WeatherDescription", "d.WindDirection", "d.WindSpeed", "df.AverageHumidityPercentage", "df.Epoch", "df.MaxTemperature", "df.MinTemperature", "df.Precipitation", "df.PrecipitationDay", "df.PrecipitationNight", "df.PrecipitationProbability", "df.SnowDay", "df.SnowNight", "df.SunriseEpoch", "df.SunsetEpoch", "df.UVIndex", "df.WeatherCondition", "df.WeatherConditionNight", "df.Wind", "fmt.Sprintf", "foreca.DailyCondition", "h.Temperature", "math.Inf", "math.Pow", "math.Round", "noaa.gov", "t.computeWindChill", "t.getAverageHumidityPercentage", "t.getAverageWeatherCodeForHourlyForecasts", "t.getDayHourlyForecasts", "t.getMaximumTemperature", "t.getMinimumTemperature", "t.getNightHourlyForecasts", "t.getTotalPrecipitation", "time.Location", "utilities.Round", "windchill.shtml", "www.nws"], "header_context_minimal": "package \nimport \"time\"\n// receiver: t *currentConditionTransformer", "summary_llm": "The Go code defines methods for computing temperature feels like and transforming daily weather forecasts. The `currentConditionTransformer` struct has methods to calculate the wind chill based on temperature and wind speed. The `dailyForecastTransformer` struct includes a method to transform daily weather conditions into a specific format using hourly forecast data.", "keywords_llm": ["temperature", "feels like", "wind chill", "forecast transformation", "hourly forecasts", "weather code", "precipitation", "snow", "sunrise", "sunset"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go#5", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go", "rel_path": "internal/foreca/adapters/clients/foreca_client.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 533, "end_line": 688, "text": "func (t *dailyForecastTransformer) getAverageHumidityPercentage(hfs []*HourlyCondition) float64 {\n\tif len(hfs) == 0 {\n\t\treturn 0\n\t}\n\n\tvar total int\n\n\tfor _, h := range hfs {\n\t\ttotal += h.HumidityPercentage\n\t}\n\n\treturn float64(total) / float64(len(hfs))\n}\n\nfunc (t *dailyForecastTransformer) getDayHourlyForecasts(hfs []*HourlyCondition, format string, sunrise *time.Time, sunset *time.Time, loc *time.Location) []*HourlyCondition {\n\tvar o []*HourlyCondition\n\n\tfor _, f := range hfs {\n\t\tts, err := time.ParseInLocation(format, f.Timestamp, loc)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif ts.Hour() >= sunrise.Hour() && ts.Hour() < sunset.Hour() {\n\t\t\to = append(o, f)\n\t\t}\n\t}\n\n\treturn o\n}\n\nfunc (t *dailyForecastTransformer) getNightHourlyForecasts(hfs []*HourlyCondition, format string, sunrise *time.Time, sunset *time.Time, loc *time.Location) []*HourlyCondition {\n\tvar o []*HourlyCondition\n\n\tfor _, f := range hfs {\n\t\tts, err := time.ParseInLocation(format, f.Timestamp, loc)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif ts.Hour() < sunrise.Hour() || ts.Hour() >= sunset.Hour() {\n\t\t\to = append(o, f)\n\t\t}\n\t}\n\n\treturn o\n}\n\nfunc (t *dailyForecastTransformer) getTotalPrecipitation(hfs []*HourlyCondition) float64 {\n\tvar total float64\n\n\tfor _, h := range hfs {\n\t\ttotal += parsePrecipitationForWeatherCode(h.WeatherCode, h.Precipitation)\n\t}\n\n\treturn total\n}\n\nfunc (t *dailyForecastTransformer) getAverageWeatherCodeForHourlyForecasts(hfs []*HourlyCondition) string {\n\tvar days, nights, cloudiness, precipitationRate, precipitationType int\n\n\tfor _, f := range hfs {\n\t\ttokens := strings.Split(f.WeatherCode, \"\")\n\t\tif len(tokens) > 0 {\n\t\t\tswitch tokens[0] {\n\t\t\tcase \"d\":\n\t\t\t\tdays++\n\t\t\tcase \"n\":\n\t\t\t\tnights++\n\t\t\t}\n\t\t}\n\n\t\tif len(tokens) > 1 {\n\t\t\tc, err := strconv.Atoi(tokens[1])\n\t\t\tif err != nil {\n\t\t\t\tcloudiness += c\n\t\t\t}\n\t\t}\n\n\t\tif len(tokens) > 2 {\n\t\t\tpr, err := strconv.Atoi(tokens[2])\n\t\t\tif err != nil {\n\t\t\t\tprecipitationRate += pr\n\t\t\t}\n\t\t}\n\n\t\tif len(tokens) > 3 {\n\t\t\tpt, err := strconv.Atoi(tokens[3])\n\t\t\tif err != nil {\n\t\t\t\tprecipitationType += pt\n\t\t\t}\n\t\t}\n\t}\n\n\tobs := len(hfs)\n\tvar code string\n\tif days >= nights {\n\t\tcode = \"d\"\n\t} else {\n\t\tcode = \"n\"\n\t}\n\taverageCloudiness := math.Round(float64(cloudiness) / float64(obs))\n\taveragePrecipitationRate := math.Round(float64(precipitationRate) / float64(obs))\n\taveragePrecipitationType := math.Round(float64(precipitationType) / float64(obs))\n\n\treturn fmt.Sprintf(\"%s%d%d%d\", code, int(averageCloudiness), int(averagePrecipitationRate), int(averagePrecipitationType))\n}\n\ntype hourlyForecastTransformer struct{}\n\nfunc NewHourlyForecastTransformer() *hourlyForecastTransformer {\n\treturn &hourlyForecastTransformer{}\n}\n\nfunc (t *hourlyForecastTransformer) Transform(h *HourlyCondition, location *time.Location) *foreca.HourlyCondition {\n\tvar hf foreca.HourlyCondition\n\n\thf.Epoch = getUtcEpochForFormatInLocation(h.Timestamp, \"2006-01-02 15:04\", location)\n\thf.Temperature = utilities.Round(h.Temperature, 1)\n\thf.TemperatureFeelsLike = utilities.Round(h.TemperatureFeelsLike, 1)\n\thf.WeatherCondition = buildWeatherCondition(h.WeatherCode, h.WeatherDescription)\n\thf.Precipitation = utilities.Round(parsePrecipitationForWeatherCode(h.WeatherCode, h.Precipitation), 1)\n\tif isSnowWeatherCode(h.WeatherCode) {\n\t\thf.Snow = hf.Precipitation\n\t}\n\thf.PrecipitationProbability = h.PrecipitationProbability\n\thf.Wind = buildWind(h.WindDirection, h.WindSpeed)\n\thf.Pressure = buildPressure(h.Pressure)\n\thf.HumidityPercentage = h.HumidityPercentage\n\thf.UVIndex = h.UVIndex\n\n\treturn &hf\n}\n\nfunc buildWeatherCondition(code string, description string) *foreca.WeatherCondition {\n\ttitle := cases.Title(language.English)\n\treturn &foreca.WeatherCondition{\n\t\tCode:        parseWeatherCode(code),\n\t\tDescription: title.String(description),\n\t}\n}\n\nfunc buildWindGust(direction string, speed float64, gust float64) *foreca.WindGust {\n\treturn &foreca.WindGust{\n\t\tWind: buildWind(direction, speed),\n\t\tGust: gust,\n\t}\n}\n\nfunc buildWind(direction string, speed float64) *foreca.Wind {\n\treturn &foreca.Wind{\n\t\tDirection: getWindDirection(direction),\n\t\tSpeed:     utilities.Round(speed, 2),\n\t}\n}\n", "n_tokens": 1156, "primary_symbol": "getAverageHumidityPercentage", "primary_kind": "function", "primary_span": [533, 688], "def_symbols": ["getAverageHumidityPercentage", "getDayHourlyForecasts", "getNightHourlyForecasts", "getTotalPrecipitation", "getAverageWeatherCodeForHourlyForecasts", "NewHourlyForecastTransformer", "Transform", "buildWeatherCondition", "buildWindGust", "buildWind"], "symbols": ["getAverageHumidityPercentage", "getDayHourlyForecasts", "getNightHourlyForecasts", "getTotalPrecipitation", "getAverageWeatherCodeForHourlyForecasts", "NewHourlyForecastTransformer", "Transform", "buildWeatherCondition", "buildWindGust", "buildWind", "func", "dailyForecastTransformer", "hfs", "HourlyCondition", "float64", "len", "return", "var", "total", "int", "for", "range", "HumidityPercentage", "format", "string", "sunrise", "time", "Time", "sunset", "loc", "Location", "err", "ParseInLocation", "Timestamp", "nil", "continue", "Hour", "append", "parsePrecipitationForWeatherCode", "WeatherCode", "Precipitation", "days", "nights", "cloudiness", "precipitationRate", "precipitationType", "tokens", "strings", "Split", "switch", "case", "strconv", "Atoi", "obs", "code", "else", "averageCloudiness", "math", "Round", "averagePrecipitationRate", "averagePrecipitationType", "fmt", "Sprintf", "type", "hourlyForecastTransformer", "struct", "location", "foreca", "Epoch", "getUtcEpochForFormatInLocation", "Temperature", "utilities", "TemperatureFeelsLike", "WeatherCondition", "WeatherDescription", "isSnowWeatherCode", "Snow", "PrecipitationProbability", "Wind", "WindDirection", "WindSpeed", "Pressure", "buildPressure", "UVIndex", "description", "title", "cases", "Title", "language", "English", "Code", "parseWeatherCode", "Description", "String", "direction", "speed", "gust", "WindGust", "Gust", "Direction", "getWindDirection", "Speed"], "doc_head": "func (t *dailyForecastTransformer) getAverageHumidityPercentage(hfs []*HourlyCondition) float64 {\n\tif len(hfs) == 0 {\n\t\treturn 0\n\t}\n\tvar total int\n\tfor _, h := range hfs {\n\t\ttotal += h.HumidityPercentage\n\t}\n\treturn float64(total) / float64(len(hfs))\n}\nfunc (t *dailyForecastTransformer) getDayHourlyForecasts(hfs []*HourlyCondition, format string, sunrise *time.Time, sunset *time.Time, loc *time.Location) []*HourlyCondition {\n\tvar o []*HourlyCondition\n\tfor _, f := range hfs {\n\t\tts, err := time.ParseInLocation(format, f.Timestamp, loc)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif ts.Hour() >= sunrise.Hour() && ts.Hour() < sunset.Hour() {\n\t\t\to = append(o, f)\n\t\t}\n\t}\n\treturn o\n}\nfunc (t *dailyForecastTransformer) getNightHourlyForecasts(hfs []*HourlyCondition, format string, sunrise *time.Time, sunset *time.Time, loc *time.Location) []*HourlyCondition {\n\tvar o []*HourlyCondition\n\tfor _, f := range hfs {\n\t\tts, err := time.ParseInLocation(format, f.Timestamp, loc)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif ts.Hour() < sunrise.Hour() || ts.Hour() >= sunset.Hour() {\n\t\t\to = append(o, f)\n\t\t}\n\t}\n\treturn o\n}\nfunc (t *dailyForecastTransformer) getTotalPrecipitation(hfs []*HourlyCondition) float64 {\n\tvar to", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(t *dailyForecastTransformer).getAverageHumidityPercentage", "package": "", "node_kind": "method", "receiver": "t *dailyForecastTransformer", "function_name": "NewHourlyForecastTransformer", "method_name": "getAverageHumidityPercentage", "type_name": "hourlyForecastTransformer", "type_kind": "struct", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Atoi", "Code", "Description", "Direction", "English", "Epoch", "Gust", "Hour", "HourlyCondition", "HumidityPercentage", "Location", "NewHourlyForecastTransformer", "ParseInLocation", "Precipitation", "PrecipitationProbability", "Pressure", "Round", "Snow", "Speed", "Split", "Sprintf", "String", "Temperature", "TemperatureFeelsLike", "Time", "Timestamp", "Title", "Transform", "UVIndex", "WeatherCode", "WeatherCondition", "WeatherDescription", "Wind", "WindDirection", "WindGust", "WindSpeed", "cases.Title", "f.Timestamp", "f.WeatherCode", "fmt.Sprintf", "foreca.HourlyCondition", "foreca.WeatherCondition", "foreca.Wind", "foreca.WindGust", "h.HumidityPercentage", "h.Precipitation", "h.PrecipitationProbability", "h.Pressure", "h.Temperature", "h.TemperatureFeelsLike", "h.Timestamp", "h.UVIndex", "h.WeatherCode", "h.WeatherDescription", "h.WindDirection", "h.WindSpeed", "hf.Epoch", "hf.HumidityPercentage", "hf.Precipitation", "hf.PrecipitationProbability", "hf.Pressure", "hf.Snow", "hf.Temperature", "hf.TemperatureFeelsLike", "hf.UVIndex", "hf.WeatherCondition", "hf.Wind", "language.English", "math.Round", "strconv.Atoi", "strings.Split", "sunrise.Hour", "sunset.Hour", "time.Location", "time.ParseInLocation", "time.Time", "title.String", "ts.Hour", "utilities.Round"], "header_context_minimal": "package \nimport \"time\"\n// receiver: t *dailyForecastTransformer", "summary_llm": "The provided Go code defines methods for processing hourly weather forecasts. It includes functions to calculate average humidity percentage, filter forecasts by day or night, sum precipitation, and transform hourly forecast data into a specific format.", "keywords_llm": ["dailyforecasttransformer", "getaveragehumiditypercentage", "getdayhourlyforecasts", "getnighthourlyforecasts", "gettotalprecipitation", "getaverageweathercodeforhourlyforecasts", "newhourlyforecasttransformer", "transform", "hourlyforecasttransformer", "foreca.hourlycondition", "foreca.weathercondition", "foreca.wind"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go#6", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/foreca_client.go", "rel_path": "internal/foreca/adapters/clients/foreca_client.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 689, "end_line": 847, "text": "func parseWeatherCode(code string) foreca.WeatherCode {\n\tc := strings.TrimLeft(code, \"dn\")\n\tvar wc string\n\n\tswitch c {\n\tcase \"000\":\n\t\twc = foreca.WeatherCodeClear\n\tcase \"100\":\n\t\twc = foreca.WeatherCodeMostlySunny\n\tcase \"200\":\n\t\twc = foreca.WeatherCodePartlyCloudy\n\tcase \"300\":\n\t\twc = foreca.WeatherCodeMostlyCloudy\n\tcase \"400\":\n\t\twc = foreca.WeatherCodeCloudy\n\tcase \"500\":\n\t\twc = foreca.WeatherCodeHazy\n\tcase \"600\":\n\t\twc = foreca.WeatherCodeFog\n\tcase \"210\", \"310\", \"410\":\n\t\twc = foreca.WeatherCodeChanceOfRain\n\tcase \"220\", \"320\", \"420\":\n\t\twc = foreca.WeatherCodeRain\n\tcase \"430\":\n\t\twc = foreca.WeatherCodeChanceOfThunderstorms\n\tcase \"240\", \"340\", \"440\":\n\t\twc = foreca.WeatherCodeThunderstorms\n\tcase \"211\", \"311\", \"411\":\n\t\twc = foreca.WeatherCodeChanceOfSleet\n\tcase \"221\", \"321\", \"421\", \"431\":\n\t\twc = foreca.WeatherCodeSleet\n\tcase \"212\", \"312\", \"412\":\n\t\twc = foreca.WeatherCodeChanceOfSnow\n\tcase \"222\", \"322\", \"422\", \"432\":\n\t\twc = foreca.WeatherCodeSnow\n\tdefault:\n\t\twc = foreca.WeatherCodeClear\n\t}\n\n\treturn foreca.WeatherCode(wc)\n}\n\nfunc isSnowWeatherCode(code string) bool {\n\tc := strings.TrimLeft(code, \"dn\")\n\tsnowyConditions := []string{\"212\", \"312\", \"412\", \"222\", \"322\", \"422\", \"432\"}\n\n\treturn utilities.ContainsString(snowyConditions, c)\n}\n\nfunc parsePrecipitationForWeatherCode(code string, precipitation float64) float64 {\n\tif isSnowWeatherCode(code) {\n\t\treturn precipitation * 10\n\t}\n\n\treturn precipitation\n}\n\nfunc getWindDirection(d string) *foreca.WindDirection {\n\treturn &foreca.WindDirection{\n\t\tAbbreviation: d,\n\t\tDegrees:      getWindDirectionInDegrees(d),\n\t}\n}\n\nfunc getWindDirectionInDegrees(d string) float64 {\n\tswitch d {\n\tcase \"N\":\n\t\treturn 0\n\tcase \"NNE\":\n\t\treturn 22.5\n\tcase \"NE\":\n\t\treturn 45\n\tcase \"ENE\":\n\t\treturn 67.5\n\tcase \"E\":\n\t\treturn 90\n\tcase \"ESE\":\n\t\treturn 112.5\n\tcase \"SE\":\n\t\treturn 135\n\tcase \"SSE\":\n\t\treturn 157.5\n\tcase \"S\":\n\t\treturn 180\n\tcase \"SSW\":\n\t\treturn 202.5\n\tcase \"SW\":\n\t\treturn 225\n\tcase \"WSW\":\n\t\treturn 247.5\n\tcase \"W\":\n\t\treturn 270\n\tcase \"WNW\":\n\t\treturn 292.5\n\tcase \"NW\":\n\t\treturn 315\n\tcase \"NNW\":\n\t\treturn 337.5\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc buildPressure(p string) *foreca.Pressure {\n\tpressureStr := strings.TrimLeft(p, \"<>=\")\n\tpressure, err := strconv.ParseFloat(pressureStr, 64)\n\tif err != nil {\n\t\tpressure = 0\n\t}\n\n\tvar t string\n\tif p != \"\" {\n\t\tt = p[0:1]\n\t}\n\n\tvar trend foreca.PressureTrend\n\tswitch t {\n\tcase \"<\":\n\t\ttrend = foreca.PressureTrendFalling\n\tcase \">\":\n\t\ttrend = foreca.PressureTrendRising\n\tdefault:\n\t\ttrend = foreca.PressureTrendSteady\n\t}\n\n\treturn &foreca.Pressure{\n\t\tMillibar: pressure,\n\t\tTrend:    trend,\n\t}\n}\n\nfunc getUtcEpochForFormatInLocation(t string, format string, location *time.Location) int64 {\n\tutc, _ := time.LoadLocation(\"UTC\")\n\n\tts, err := time.ParseInLocation(format, t, location)\n\tif err != nil {\n\t\treturn 0\n\t}\n\n\treturn ts.In(utc).Unix()\n}\n\nfunc getTimeForFormatInLocation(t string, format string, location *time.Location) *time.Time {\n\tts, err := time.ParseInLocation(format, t, location)\n\tif err != nil {\n\t\treturn &time.Time{}\n\t}\n\n\treturn &ts\n}\n\nfunc roundToNextHour(t time.Time) *time.Time {\n\tmissingSeconds := (60 * 60) - t.Unix()%(60*60)\n\troundedTime := time.Unix(t.Add(time.Duration(missingSeconds)*time.Second).Unix(), 0)\n\n\treturn &roundedTime\n\n}\n", "n_tokens": 1024, "primary_symbol": "parseWeatherCode", "primary_kind": "function", "primary_span": [689, 847], "def_symbols": ["parseWeatherCode", "isSnowWeatherCode", "parsePrecipitationForWeatherCode", "getWindDirection", "getWindDirectionInDegrees", "buildPressure", "getUtcEpochForFormatInLocation", "getTimeForFormatInLocation", "roundToNextHour"], "symbols": ["parseWeatherCode", "isSnowWeatherCode", "parsePrecipitationForWeatherCode", "getWindDirection", "getWindDirectionInDegrees", "buildPressure", "getUtcEpochForFormatInLocation", "getTimeForFormatInLocation", "roundToNextHour", "func", "code", "string", "foreca", "WeatherCode", "strings", "TrimLeft", "var", "switch", "case", "WeatherCodeClear", "WeatherCodeMostlySunny", "WeatherCodePartlyCloudy", "WeatherCodeMostlyCloudy", "WeatherCodeCloudy", "WeatherCodeHazy", "WeatherCodeFog", "WeatherCodeChanceOfRain", "WeatherCodeRain", "WeatherCodeChanceOfThunderstorms", "WeatherCodeThunderstorms", "WeatherCodeChanceOfSleet", "WeatherCodeSleet", "WeatherCodeChanceOfSnow", "WeatherCodeSnow", "default", "return", "bool", "snowyConditions", "utilities", "ContainsString", "precipitation", "float64", "WindDirection", "Abbreviation", "Degrees", "NNE", "ENE", "ESE", "SSE", "SSW", "WSW", "WNW", "NNW", "Pressure", "pressureStr", "pressure", "err", "strconv", "ParseFloat", "nil", "trend", "PressureTrend", "PressureTrendFalling", "PressureTrendRising", "PressureTrendSteady", "Millibar", "Trend", "format", "location", "time", "Location", "int64", "utc", "LoadLocation", "UTC", "ParseInLocation", "Unix", "Time", "missingSeconds", "roundedTime", "Add", "Duration", "Second"], "doc_head": "func parseWeatherCode(code string) foreca.WeatherCode {\n\tc := strings.TrimLeft(code, \"dn\")\n\tvar wc string\n\tswitch c {\n\tcase \"000\":\n\t\twc = foreca.WeatherCodeClear\n\tcase \"100\":\n\t\twc = foreca.WeatherCodeMostlySunny\n\tcase \"200\":\n\t\twc = foreca.WeatherCodePartlyCloudy\n\tcase \"300\":\n\t\twc = foreca.WeatherCodeMostlyCloudy\n\tcase \"400\":\n\t\twc = foreca.WeatherCodeCloudy\n\tcase \"500\":\n\t\twc = foreca.WeatherCodeHazy\n\tcase \"600\":\n\t\twc = foreca.WeatherCodeFog\n\tcase \"210\", \"310\", \"410\":\n\t\twc = foreca.WeatherCodeChanceOfRain\n\tcase \"220\", \"320\", \"420\":\n\t\twc = foreca.WeatherCodeRain\n\tcase \"430\":\n\t\twc = foreca.WeatherCodeChanceOfThunderstorms\n\tcase \"240\", \"340\", \"440\":\n\t\twc = foreca.WeatherCodeThunderstorms\n\tcase \"211\", \"311\", \"411\":\n\t\twc = foreca.WeatherCodeChanceOfSleet\n\tcase \"221\", \"321\", \"421\", \"431\":\n\t\twc = foreca.WeatherCodeSleet\n\tcase \"212\", \"312\", \"412\":\n\t\twc = foreca.WeatherCodeChanceOfSnow\n\tcase \"222\", \"322\", \"422\", \"432\":\n\t\twc = foreca.WeatherCodeSnow\n\tdefault:\n\t\twc = foreca.WeatherCodeClear\n\t}\n\treturn foreca.WeatherCode(wc)\n}\nfunc isSnowWeatherCode(code string) bool {\n\tc := strings.TrimLeft(code, \"dn\")\n\tsnowyConditions := []string{\"212\", \"312\", \"412\", \"222\", \"322\", \"422\", \"432\"}\n\treturn utiliti", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:parseWeatherCode", "package": "", "node_kind": "function", "receiver": "", "function_name": "parseWeatherCode", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Abbreviation", "Add", "ContainsString", "Degrees", "Duration", "E", "ENE", "ESE", "In", "LoadLocation", "Location", "Millibar", "N", "NE", "NNE", "NNW", "NW", "ParseFloat", "ParseInLocation", "Pressure", "PressureTrend", "PressureTrendFalling", "PressureTrendRising", "PressureTrendSteady", "S", "SE", "SSE", "SSW", "SW", "Second", "Time", "Trend", "TrimLeft", "UTC", "Unix", "W", "WNW", "WSW", "WeatherCode", "WeatherCodeChanceOfRain", "WeatherCodeChanceOfSleet", "WeatherCodeChanceOfSnow", "WeatherCodeChanceOfThunderstorms", "WeatherCodeClear", "WeatherCodeCloudy", "WeatherCodeFog", "WeatherCodeHazy", "WeatherCodeMostlyCloudy", "WeatherCodeMostlySunny", "WeatherCodePartlyCloudy", "WeatherCodeRain", "WeatherCodeSleet", "WeatherCodeSnow", "WeatherCodeThunderstorms", "WindDirection", "foreca.Pressure", "foreca.PressureTrend", "foreca.PressureTrendFalling", "foreca.PressureTrendRising", "foreca.PressureTrendSteady", "foreca.WeatherCode", "foreca.WeatherCodeChanceOfRain", "foreca.WeatherCodeChanceOfSleet", "foreca.WeatherCodeChanceOfSnow", "foreca.WeatherCodeChanceOfThunderstorms", "foreca.WeatherCodeClear", "foreca.WeatherCodeCloudy", "foreca.WeatherCodeFog", "foreca.WeatherCodeHazy", "foreca.WeatherCodeMostlyCloudy", "foreca.WeatherCodeMostlySunny", "foreca.WeatherCodePartlyCloudy", "foreca.WeatherCodeRain", "foreca.WeatherCodeSleet", "foreca.WeatherCodeSnow", "foreca.WeatherCodeThunderstorms", "foreca.WindDirection", "strconv.ParseFloat", "strings.TrimLeft", "t.Add", "t.Unix", "time.Duration", "time.LoadLocation", "time.Location", "time.ParseInLocation", "time.Second", "time.Time", "time.Unix", "ts.In", "utilities.ContainsString"], "header_context_minimal": "package \nimport \"time\"", "summary_llm": "This Go code defines functions to parse weather codes into specific weather conditions, determine if a weather code indicates snow, calculate precipitation for weather conditions, get wind directions and their corresponding degrees, build pressure data including trends, and convert times between different formats.", "keywords_llm": ["weathercode", "parseweathercode", "snowweathercode", "precipitation", "winddirection", "buildpressure", "getutcepochforformatinlocation", "timeconversion", "roundtogether"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/mocks/foreca_client_mocks.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/clients/mocks/foreca_client_mocks.go", "rel_path": "internal/foreca/adapters/clients/mocks/foreca_client_mocks.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 134, "text": "// Code generated by MockGen. DO NOT EDIT.\n// Source: foreca_client.go\n//\n// Generated by this command:\n//\n//\tmockgen -source=foreca_client.go -destination=mocks/foreca_client_mocks.go -package=mocks\n//\n\n// Package mocks is a generated GoMock package.\npackage mocks\n\nimport (\n\thttp \"net/http\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tforeca \"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\tclients \"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters/clients\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockhttpClient is a mock of httpClient interface.\ntype MockhttpClient struct {\n\tctrl     *gomock.Controller\n\trecorder *MockhttpClientMockRecorder\n}\n\n// MockhttpClientMockRecorder is the mock recorder for MockhttpClient.\ntype MockhttpClientMockRecorder struct {\n\tmock *MockhttpClient\n}\n\n// NewMockhttpClient creates a new mock instance.\nfunc NewMockhttpClient(ctrl *gomock.Controller) *MockhttpClient {\n\tmock := &MockhttpClient{ctrl: ctrl}\n\tmock.recorder = &MockhttpClientMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockhttpClient) EXPECT() *MockhttpClientMockRecorder {\n\treturn m.recorder\n}\n\n// Do mocks base method.\nfunc (m *MockhttpClient) Do(arg0 *http.Request) (*http.Response, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Do\", arg0)\n\tret0, _ := ret[0].(*http.Response)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Do indicates an expected call of Do.\nfunc (mr *MockhttpClientMockRecorder) Do(arg0 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Do\", reflect.TypeOf((*MockhttpClient)(nil).Do), arg0)\n}\n\n// MockrateLimiter is a mock of rateLimiter interface.\ntype MockrateLimiter struct {\n\tctrl     *gomock.Controller\n\trecorder *MockrateLimiterMockRecorder\n}\n\n// MockrateLimiterMockRecorder is the mock recorder for MockrateLimiter.\ntype MockrateLimiterMockRecorder struct {\n\tmock *MockrateLimiter\n}\n\n// NewMockrateLimiter creates a new mock instance.\nfunc NewMockrateLimiter(ctrl *gomock.Controller) *MockrateLimiter {\n\tmock := &MockrateLimiter{ctrl: ctrl}\n\tmock.recorder = &MockrateLimiterMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockrateLimiter) EXPECT() *MockrateLimiterMockRecorder {\n\treturn m.recorder\n}\n\n// Acquire mocks base method.\nfunc (m *MockrateLimiter) Acquire(arg0 string) (int64, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Acquire\", arg0)\n\tret0, _ := ret[0].(int64)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Acquire indicates an expected call of Acquire.\nfunc (mr *MockrateLimiterMockRecorder) Acquire(arg0 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Acquire\", reflect.TypeOf((*MockrateLimiter)(nil).Acquire), arg0)\n}\n\n// Mocktransformer is a mock of transformer interface.\ntype Mocktransformer struct {\n\tctrl     *gomock.Controller\n\trecorder *MocktransformerMockRecorder\n}\n\n// MocktransformerMockRecorder is the mock recorder for Mocktransformer.\ntype MocktransformerMockRecorder struct {\n\tmock *Mocktransformer\n}\n\n// NewMocktransformer creates a new mock instance.\nfunc NewMocktransformer(ctrl *gomock.Controller) *Mocktransformer {\n\tmock := &Mocktransformer{ctrl: ctrl}\n\tmock.recorder = &MocktransformerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *Mocktransformer) EXPECT() *MocktransformerMockRecorder {\n\treturn m.recorder\n}\n\n// Transform mocks base method.\nfunc (m *Mocktransformer) Transform(arg0 *clients.Response, arg1 *time.Location) *foreca.Forecast {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Transform\", arg0, arg1)\n\tret0, _ := ret[0].(*foreca.Forecast)\n\treturn ret0\n}\n\n// Transform indicates an expected call of Transform.\nfunc (mr *MocktransformerMockRecorder) Transform(arg0, arg1 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Transform\", reflect.TypeOf((*Mocktransformer)(nil).Transform), arg0, arg1)\n}\n", "n_tokens": 1057, "primary_symbol": "NewMockhttpClient", "primary_kind": "function", "primary_span": [34, 134], "def_symbols": ["NewMockhttpClient", "EXPECT", "Do", "NewMockrateLimiter", "Acquire", "NewMocktransformer", "Transform"], "symbols": ["NewMockhttpClient", "EXPECT", "Do", "NewMockrateLimiter", "Acquire", "NewMocktransformer", "Transform", "Code", "generated", "MockGen", "NOT", "EDIT", "Source", "foreca_client", "Generated", "this", "command", "mockgen", "source", "destination", "mocks", "foreca_client_mocks", "package", "Package", "GoMock", "import", "http", "net", "reflect", "time", "foreca", "impalastudios", "com", "weather", "foreca_proxy", "internal", "clients", "adapters", "gomock", "uber", "org", "mock", "MockhttpClient", "httpClient", "interface", "type", "struct", "ctrl", "Controller", "recorder", "MockhttpClientMockRecorder", "the", "for", "creates", "new", "instance", "func", "return", "returns", "object", "that", "allows", "caller", "indicate", "expected", "use", "base", "method", "arg0", "Request", "Response", "error", "Helper", "ret", "Call", "ret0", "ret1", "indicates", "call", "any", "RecordCallWithMethodType", "TypeOf", "nil", "MockrateLimiter", "rateLimiter", "MockrateLimiterMockRecorder", "string", "int64", "Mocktransformer", "transformer", "MocktransformerMockRecorder", "arg1", "Location", "Forecast"], "doc_head": "// Code generated by MockGen. DO NOT EDIT.\n// Source: foreca_client.go\n//\n// Generated by this command:\n//\n//\tmockgen -source=foreca_client.go -destination=mocks/foreca_client_mocks.go -package=mocks\n//\n// Package mocks is a generated GoMock package.\npackage mocks\nimport (\n\thttp \"net/http\"\n\treflect \"reflect\"\n\ttime \"time\"\n\tforeca \"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\tclients \"go.impalastudios.com/weather/foreca_proxy/internal/foreca/adapters/clients\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n// MockhttpClient is a mock of httpClient interface.\ntype MockhttpClient struct {\n\tctrl     *gomock.Controller\n\trecorder *MockhttpClientMockRecorder\n}\n// MockhttpClientMockRecorder is the mock recorder for MockhttpClient.\ntype MockhttpClientMockRecorder struct {\n\tmock *MockhttpClient\n}\n// NewMockhttpClient creates a new mock instance.\nfunc NewMockhttpClient(ctrl *gomock.Controller) *MockhttpClient {\n\tmock := &MockhttpClient{ctrl: ctrl}\n\tmock.recorder = &MockhttpClientMockRecorder{mock}\n\treturn mock\n}\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockhttpClient) EXPECT() *MockhttpClientMockRecorder {\n\treturn m.recorder\n}\n// Do mocks base me", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(m *MockhttpClient).EXPECT", "package": "mocks", "node_kind": "method", "receiver": "m *MockhttpClient", "function_name": "NewMockhttpClient", "method_name": "EXPECT", "type_name": "MockhttpClient", "type_kind": "struct", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Acquire", "Call", "Code", "Controller", "DO", "Do", "EDIT", "EXPECT", "Forecast", "Generated", "GoMock", "Helper", "Location", "MockGen", "MockhttpClient", "MockhttpClientMockRecorder", "MockrateLimiter", "MockrateLimiterMockRecorder", "Mocktransformer", "MocktransformerMockRecorder", "NOT", "NewMockhttpClient", "NewMockrateLimiter", "NewMocktransformer", "Package", "RecordCallWithMethodType", "Request", "Response", "Source", "T", "T.Helper", "Transform", "TypeOf", "clients.Response", "ctrl.RecordCallWithMethodType", "ctrl.T", "foreca.Forecast", "foreca_client.go", "foreca_client_mocks.go", "go.impalastudios", "go.uber", "gomock.Call", "gomock.Controller", "http.Request", "http.Response", "m.ctrl", "m.recorder", "mock.recorder", "mr.mock", "reflect.TypeOf", "time.Location"], "header_context_minimal": "package mocks\nimport \"time\"\n// receiver: m *MockhttpClient", "summary_llm": "This Go code defines mocks for the `httpClient`, `rateLimiter`, and `transformer` interfaces using GoMock. Each mock includes methods like `Do`, `Acquire`, and `Transform`, along with corresponding recorder functions to specify expected method calls.", "keywords_llm": ["mockgen", "httpclient", "ratelimiter", "transformer", "gomock", "http.request", "http.response", "int64", "error", "time.location", "foreca.forecast"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/handlers/grpc/v0/transformers.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/handlers/grpc/v0/transformers.go", "rel_path": "internal/foreca/adapters/handlers/grpc/v0/transformers.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 132, "text": "package v0\n\nimport (\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\tv0 \"go.impalastudios.com/weather/foreca_proxy/pkg/pb/v0\"\n)\n\ntype transformer struct{}\n\nfunc newTransformer() *transformer {\n\treturn &transformer{}\n}\n\nfunc (t *transformer) Transform(in *foreca.Forecast) *v0.ForecastResponse {\n\treturn &v0.ForecastResponse{\n\t\tCurrentCondition: t.transformCurrentCondition(in.CurrentCondition),\n\t\tDailyForecasts:   t.transformDailyConditions(in.DailyConditions),\n\t\tHourlyForecasts:  t.transformHourlyConditions(in.HourlyConditions),\n\t}\n}\n\nfunc (t *transformer) transformCurrentCondition(in *foreca.CurrentCondition) *v0.ForecastResponse_CurrentCondition {\n\treturn &v0.ForecastResponse_CurrentCondition{\n\t\tEpoch:            in.Epoch,\n\t\tVisibility:       float32(in.Visibility),\n\t\tWeatherCondition: t.transformWeatherCondition(in.WeatherCondition),\n\t\tPrecipitation:    float32(in.Precipitation),\n\t\tNextHour: &v0.ForecastResponse_CurrentCondition_NextHour{\n\t\t\tWeatherCondition: t.transformWeatherCondition(in.WeatherConditionNextHour),\n\t\t\tPrecipitation:    float32(in.PrecipitationNextHour),\n\t\t},\n\t\tTemperature:          float32(in.Temperature),\n\t\tTemperatureFeelsLike: float32(in.TemperatureFeelsLike),\n\t\tWindGust:             t.transformWindGust(in.WindGust),\n\t\tDewPoint:             float32(in.DewPoint),\n\t\tHeatIndex:            float32(in.HeatIndex),\n\t\tPressure:             t.transformPressure(in.Pressure),\n\t\tUvIndex:              float32(in.UVIndex),\n\t\tHumidityPercentage:   int32(in.HumidityPercentage),\n\t}\n}\n\nfunc (t *transformer) transformDailyConditions(in []*foreca.DailyCondition) []*v0.ForecastResponse_DailyForecast {\n\tvar conditions []*v0.ForecastResponse_DailyForecast\n\n\tfor _, d := range in {\n\t\tcondition := &v0.ForecastResponse_DailyForecast{\n\t\t\tEpoch:                     d.Epoch,\n\t\t\tTemperatureMin:            float32(d.MinTemperature),\n\t\t\tTemperatureMax:            float32(d.MaxTemperature),\n\t\t\tPrecipitation:             float32(d.Precipitation),\n\t\t\tPrecipitationDay:          float32(d.PrecipitationDay),\n\t\t\tPrecipitationNight:        float32(d.PrecipitationNight),\n\t\t\tSnow:                      float32(d.Snow),\n\t\t\tSnowDay:                   float32(d.SnowDay),\n\t\t\tSnowNight:                 float32(d.SnowNight),\n\t\t\tPrecipitationProbability:  int32(d.PrecipitationProbability),\n\t\t\tWind:                      t.transformWind(d.Wind),\n\t\t\tAverageHumidityPercentage: int32(d.AverageHumidityPercentage),\n\t\t\tWeatherCondition:          t.transformWeatherCondition(d.WeatherCondition),\n\t\t\tWeatherConditionNight:     t.transformWeatherCondition(d.WeatherConditionNight),\n\t\t\tUvIndex:                   float32(d.UVIndex),\n\t\t\tSunriseEpoch:              d.SunriseEpoch,\n\t\t\tSunsetEpoch:               d.SunsetEpoch,\n\t\t}\n\n\t\tconditions = append(conditions, condition)\n\t}\n\n\treturn conditions\n}\n\nfunc (t *transformer) transformHourlyConditions(in []*foreca.HourlyCondition) []*v0.ForecastResponse_HourlyForecast {\n\tvar conditions []*v0.ForecastResponse_HourlyForecast\n\n\tfor _, h := range in {\n\t\tcondition := &v0.ForecastResponse_HourlyForecast{\n\t\t\tEpoch:                    h.Epoch,\n\t\t\tTemperature:              float32(h.Temperature),\n\t\t\tTemperatureFeelsLike:     float32(h.TemperatureFeelsLike),\n\t\t\tWeatherCondition:         t.transformWeatherCondition(h.WeatherCondition),\n\t\t\tPrecipitation:            float32(h.Precipitation),\n\t\t\tSnow:                     float32(h.Snow),\n\t\t\tPrecipitationProbability: int32(h.PrecipitationProbability),\n\t\t\tWind:                     t.transformWind(h.Wind),\n\t\t\tPressure:                 t.transformPressure(h.Pressure),\n\t\t\tHumidityPercentage:       int32(h.HumidityPercentage),\n\t\t\tUvIndex:                  float32(h.UVIndex),\n\t\t}\n\n\t\tconditions = append(conditions, condition)\n\t}\n\n\treturn conditions\n}\n\nfunc (t *transformer) transformWind(in *foreca.Wind) *v0.ForecastResponse_Wind {\n\tif in == nil {\n\t\treturn nil\n\t}\n\n\treturn &v0.ForecastResponse_Wind{\n\t\tDirection: &v0.ForecastResponse_WindDirection{\n\t\t\tAbbreviation: in.Direction.Abbreviation,\n\t\t\tDegrees:      float32(in.Direction.Degrees),\n\t\t},\n\t\tSpeed: float32(in.Speed),\n\t}\n}\n\nfunc (t *transformer) transformPressure(in *foreca.Pressure) *v0.ForecastResponse_Pressure {\n\tif in == nil {\n\t\treturn nil\n\t}\n\n\treturn &v0.ForecastResponse_Pressure{\n\t\tMillibar: float32(in.Millibar),\n\t\tTrend:    int32(in.Trend),\n\t}\n}\n\nfunc (t *transformer) transformWeatherCondition(in *foreca.WeatherCondition) *v0.ForecastResponse_WeatherCondition {\n\tif in == nil {\n\t\treturn nil\n\t}\n\n\treturn &v0.ForecastResponse_WeatherCondition{\n\t\tCode:        string(in.Code),\n\t\tDescription: in.Description,\n\t}\n}\n", "n_tokens": 1179, "primary_symbol": "newTransformer", "primary_kind": "function", "primary_span": [10, 132], "def_symbols": ["newTransformer", "Transform", "transformCurrentCondition", "transformDailyConditions", "transformHourlyConditions", "transformWind", "transformPressure", "transformWeatherCondition"], "symbols": ["newTransformer", "Transform", "transformCurrentCondition", "transformDailyConditions", "transformHourlyConditions", "transformWind", "transformPressure", "transformWeatherCondition", "package", "import", "impalastudios", "com", "weather", "foreca_proxy", "internal", "foreca", "pkg", "type", "transformer", "struct", "func", "return", "Forecast", "ForecastResponse", "CurrentCondition", "DailyForecasts", "DailyConditions", "HourlyForecasts", "HourlyConditions", "ForecastResponse_CurrentCondition", "Epoch", "Visibility", "float32", "WeatherCondition", "Precipitation", "NextHour", "ForecastResponse_CurrentCondition_NextHour", "WeatherConditionNextHour", "PrecipitationNextHour", "Temperature", "TemperatureFeelsLike", "WindGust", "transformWindGust", "DewPoint", "HeatIndex", "Pressure", "UvIndex", "UVIndex", "HumidityPercentage", "int32", "DailyCondition", "ForecastResponse_DailyForecast", "var", "conditions", "for", "range", "condition", "TemperatureMin", "MinTemperature", "TemperatureMax", "MaxTemperature", "PrecipitationDay", "PrecipitationNight", "Snow", "SnowDay", "SnowNight", "PrecipitationProbability", "Wind", "AverageHumidityPercentage", "WeatherConditionNight", "SunriseEpoch", "SunsetEpoch", "append", "HourlyCondition", "ForecastResponse_HourlyForecast", "ForecastResponse_Wind", "nil", "Direction", "ForecastResponse_WindDirection", "Abbreviation", "Degrees", "Speed", "ForecastResponse_Pressure", "Millibar", "Trend", "ForecastResponse_WeatherCondition", "Code", "string", "Description"], "doc_head": "package v0\nimport (\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\tv0 \"go.impalastudios.com/weather/foreca_proxy/pkg/pb/v0\"\n)\ntype transformer struct{}\nfunc newTransformer() *transformer {\n\treturn &transformer{}\n}\nfunc (t *transformer) Transform(in *foreca.Forecast) *v0.ForecastResponse {\n\treturn &v0.ForecastResponse{\n\t\tCurrentCondition: t.transformCurrentCondition(in.CurrentCondition),\n\t\tDailyForecasts:   t.transformDailyConditions(in.DailyConditions),\n\t\tHourlyForecasts:  t.transformHourlyConditions(in.HourlyConditions),\n\t}\n}\nfunc (t *transformer) transformCurrentCondition(in *foreca.CurrentCondition) *v0.ForecastResponse_CurrentCondition {\n\treturn &v0.ForecastResponse_CurrentCondition{\n\t\tEpoch:            in.Epoch,\n\t\tVisibility:       float32(in.Visibility),\n\t\tWeatherCondition: t.transformWeatherCondition(in.WeatherCondition),\n\t\tPrecipitation:    float32(in.Precipitation),\n\t\tNextHour: &v0.ForecastResponse_CurrentCondition_NextHour{\n\t\t\tWeatherCondition: t.transformWeatherCondition(in.WeatherConditionNextHour),\n\t\t\tPrecipitation:    float32(in.PrecipitationNextHour),\n\t\t},\n\t\tTemperature:          float32(in.Temperature),\n\t\tTemperatureFeelsLike: float32(in.TemperatureFe", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(t *transformer).Transform", "package": "v0", "node_kind": "method", "receiver": "t *transformer", "function_name": "newTransformer", "method_name": "Transform", "type_name": "transformer", "type_kind": "struct", "imports_used_minimal": [], "symbols_referenced_strict": ["Abbreviation", "AverageHumidityPercentage", "Code", "CurrentCondition", "DailyCondition", "DailyConditions", "DailyForecasts", "Degrees", "Description", "DewPoint", "Direction", "Epoch", "Forecast", "ForecastResponse", "ForecastResponse_CurrentCondition", "ForecastResponse_CurrentCondition_NextHour", "ForecastResponse_DailyForecast", "ForecastResponse_HourlyForecast", "ForecastResponse_Pressure", "ForecastResponse_WeatherCondition", "ForecastResponse_Wind", "ForecastResponse_WindDirection", "HeatIndex", "HourlyCondition", "HourlyConditions", "HourlyForecasts", "HumidityPercentage", "MaxTemperature", "Millibar", "MinTemperature", "NextHour", "Precipitation", "PrecipitationDay", "PrecipitationNextHour", "PrecipitationNight", "PrecipitationProbability", "Pressure", "Snow", "SnowDay", "SnowNight", "Speed", "SunriseEpoch", "SunsetEpoch", "Temperature", "TemperatureFeelsLike", "TemperatureMax", "TemperatureMin", "Transform", "Trend", "UVIndex", "UvIndex", "Visibility", "WeatherCondition", "WeatherConditionNextHour", "WeatherConditionNight", "Wind", "WindGust", "d.AverageHumidityPercentage", "d.Epoch", "d.MaxTemperature", "d.MinTemperature", "d.Precipitation", "d.PrecipitationDay", "d.PrecipitationNight", "d.PrecipitationProbability", "d.Snow", "d.SnowDay", "d.SnowNight", "d.SunriseEpoch", "d.SunsetEpoch", "d.UVIndex", "d.WeatherCondition", "d.WeatherConditionNight", "d.Wind", "foreca.CurrentCondition", "foreca.DailyCondition", "foreca.Forecast", "foreca.HourlyCondition", "foreca.Pressure", "foreca.WeatherCondition", "foreca.Wind", "go.impalastudios", "h.Epoch", "h.HumidityPercentage", "h.Precipitation", "h.PrecipitationProbability", "h.Pressure", "h.Snow", "h.Temperature", "h.TemperatureFeelsLike", "h.UVIndex", "h.WeatherCondition", "h.Wind", "in.Code", "in.CurrentCondition", "in.DailyConditions", "in.Description", "in.DewPoint", "in.Direction", "in.Epoch", "in.HeatIndex", "in.HourlyConditions", "in.HumidityPercentage", "in.Millibar", "in.Precipitation", "in.PrecipitationNextHour", "in.Pressure", "in.Speed", "in.Temperature", "in.TemperatureFeelsLike", "in.Trend", "in.UVIndex", "in.Visibility", "in.WeatherCondition", "in.WeatherConditionNextHour", "in.WindGust", "t.transformCurrentCondition", "t.transformDailyConditions", "t.transformHourlyConditions", "t.transformPressure", "t.transformWeatherCondition", "t.transformWind", "t.transformWindGust", "v0.ForecastResponse", "v0.ForecastResponse_CurrentCondition", "v0.ForecastResponse_CurrentCondition_NextHour", "v0.ForecastResponse_DailyForecast", "v0.ForecastResponse_HourlyForecast", "v0.ForecastResponse_Pressure", "v0.ForecastResponse_WeatherCondition", "v0.ForecastResponse_Wind", "v0.ForecastResponse_WindDirection"], "header_context_minimal": "package v0\n// receiver: t *transformer", "summary_llm": "This Go code defines a `transformer` struct with methods to transform weather forecast data from the `foreca` package into the `v0` protocol buffer format. The `Transform` method converts a `foreca.Forecast` into a `v0.ForecastResponse`, while helper methods like `transformCurrentCondition`, `transformDailyConditions`, and `transformHourlyConditions` handle specific parts of the forecast data.", "keywords_llm": ["transformer", "forecast", "current condition", "daily conditions", "hourly conditions", "weather condition", "pressure", "wind", "temperature", "humidity", "epoch", "precipitation", "snow", "uv index"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/handlers/grpc/v0/transformers.go#2", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/handlers/grpc/v0/transformers.go", "rel_path": "internal/foreca/adapters/handlers/grpc/v0/transformers.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 133, "end_line": 143, "text": "func (t *transformer) transformWindGust(in *foreca.WindGust) *v0.ForecastResponse_CurrentCondition_WindGust {\n\tif in == nil {\n\t\treturn nil\n\t}\n\n\treturn &v0.ForecastResponse_CurrentCondition_WindGust{\n\t\tWind: t.transformWind(in.Wind),\n\t\tGust: float32(in.Gust),\n\t}\n}\n", "n_tokens": 82, "primary_symbol": "transformWindGust", "primary_kind": "function", "primary_span": [133, 143], "def_symbols": ["transformWindGust"], "symbols": ["transformWindGust", "func", "transformer", "foreca", "WindGust", "ForecastResponse_CurrentCondition_WindGust", "nil", "return", "Wind", "transformWind", "Gust", "float32"], "doc_head": "func (t *transformer) transformWindGust(in *foreca.WindGust) *v0.ForecastResponse_CurrentCondition_WindGust {\n\tif in == nil {\n\t\treturn nil\n\t}\n\treturn &v0.ForecastResponse_CurrentCondition_WindGust{\n\t\tWind: t.transformWind(in.Wind),\n\t\tGust: float32(in.Gust),\n\t}\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(t *transformer).transformWindGust", "package": "", "node_kind": "method", "receiver": "t *transformer", "function_name": "", "method_name": "transformWindGust", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["ForecastResponse_CurrentCondition_WindGust", "Gust", "Wind", "WindGust", "foreca.WindGust", "in.Gust", "in.Wind", "t.transformWind", "v0.ForecastResponse_CurrentCondition_WindGust"], "header_context_minimal": "package \n// receiver: t *transformer", "summary_llm": "The `transformWindGust` function in the Go code snippet transforms a `foreca.WindGust` object into a `v0.ForecastResponse_CurrentCondition_WindGust` object. It handles nil inputs and converts float64 values to float32.", "keywords_llm": ["transformwindgust", "foreca.windgust", "v0.forecastresponse_currentcondition_windgust", "nil input", "float64 conversion", "float32", "transformer", "method", "current condition"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/handlers/grpc/v0/server.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/handlers/grpc/v0/server.go", "rel_path": "internal/foreca/adapters/handlers/grpc/v0/server.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 37, "text": "package v0\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\tpbv0 \"go.impalastudios.com/weather/foreca_proxy/pkg/pb/v0\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype forecastService interface {\n\tGetForecastForLocation(ctx context.Context, id int) (*foreca.Forecast, error)\n}\n\ntype Server struct {\n\tpbv0.UnimplementedForecaProxyServer\n\tservice forecastService\n\tt       *transformer\n}\n\nfunc NewServer(service forecastService) *Server {\n\treturn &Server{service: service}\n}\n\nfunc (s *Server) toGrpcError(err error) error {\n\tif errors.Is(err, foreca.ErrLocationNotFound) {\n\t\treturn status.Error(codes.NotFound, \"Location not found.\")\n\t}\n\n\tif errors.Is(err, foreca.ErrRequestThrottled) {\n\t\treturn status.Error(codes.ResourceExhausted, \"Too many requests. Retry later.\")\n\t}\n\n\treturn status.Error(codes.Internal, \"Something went wrong.\")\n}\n", "n_tokens": 229, "primary_symbol": "NewServer", "primary_kind": "function", "primary_span": [22, 37], "def_symbols": ["NewServer", "toGrpcError"], "symbols": ["NewServer", "toGrpcError", "package", "import", "context", "errors", "impalastudios", "com", "weather", "foreca_proxy", "internal", "foreca", "pbv0", "pkg", "google", "golang", "org", "grpc", "codes", "status", "type", "forecastService", "interface", "GetForecastForLocation", "ctx", "Context", "int", "Forecast", "error", "Server", "struct", "UnimplementedForecaProxyServer", "service", "transformer", "func", "return", "err", "ErrLocationNotFound", "Error", "NotFound", "Location", "not", "found", "ErrRequestThrottled", "ResourceExhausted", "Too", "many", "requests", "Retry", "later", "Internal", "Something", "went", "wrong"], "doc_head": "package v0\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"go.impalastudios.com/weather/foreca_proxy/internal/foreca\"\n\tpbv0 \"go.impalastudios.com/weather/foreca_proxy/pkg/pb/v0\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\ntype forecastService interface {\n\tGetForecastForLocation(ctx context.Context, id int) (*foreca.Forecast, error)\n}\ntype Server struct {\n\tpbv0.UnimplementedForecaProxyServer\n\tservice forecastService\n\tt       *transformer\n}\nfunc NewServer(service forecastService) *Server {\n\treturn &Server{service: service}\n}\nfunc (s *Server) toGrpcError(err error) error {\n\tif errors.Is(err, foreca.ErrLocationNotFound) {\n\t\treturn status.Error(codes.NotFound, \"Location not found.\")\n\t}\n\tif errors.Is(err, foreca.ErrRequestThrottled) {\n\t\treturn status.Error(codes.ResourceExhausted, \"Too many requests. Retry later.\")\n\t}\n\treturn status.Error(codes.Internal, \"Something went wrong.\")\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(s *Server).toGrpcError", "package": "v0", "node_kind": "method", "receiver": "s *Server", "function_name": "NewServer", "method_name": "toGrpcError", "type_name": "forecastService", "type_kind": "interface", "imports_used_minimal": [], "symbols_referenced_strict": ["Context", "ErrLocationNotFound", "ErrRequestThrottled", "Error", "Forecast", "GetForecastForLocation", "Internal", "Is", "Location", "NewServer", "NotFound", "ResourceExhausted", "Retry", "Server", "Something", "Too", "UnimplementedForecaProxyServer", "codes.Internal", "codes.NotFound", "codes.ResourceExhausted", "context.Context", "errors.Is", "foreca.ErrLocationNotFound", "foreca.ErrRequestThrottled", "foreca.Forecast", "go.impalastudios", "google.golang", "pbv0.UnimplementedForecaProxyServer", "status.Error"], "header_context_minimal": "package v0\n// receiver: s *Server", "summary_llm": "This Go code defines a server for handling gRPC requests related to weather forecasts. It includes methods for transforming errors into appropriate gRPC error codes and messages.", "keywords_llm": ["server", "grpc", "error transformation", "weather forecasts", "codes", "notfound", "resourceexhausted", "internal"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/handlers/grpc/v0/getforecast.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/internal/foreca/adapters/handlers/grpc/v0/getforecast.go", "rel_path": "internal/foreca/adapters/handlers/grpc/v0/getforecast.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 17, "text": "package v0\n\nimport (\n\t\"context\"\n\tpbv0 \"go.impalastudios.com/weather/foreca_proxy/pkg/pb/v0\"\n)\n\nfunc (s *Server) GetForecast(ctx context.Context, in *pbv0.ForecastRequest) (*pbv0.ForecastResponse, error) {\n\tforecast, err := s.service.GetForecastForLocation(ctx, int(in.GetLocationId()))\n\n\tif err != nil {\n\t\treturn nil, s.toGrpcError(err)\n\t}\n\n\treturn s.t.Transform(forecast), nil\n}\n", "n_tokens": 112, "primary_symbol": "GetForecast", "primary_kind": "function", "primary_span": [8, 17], "def_symbols": ["GetForecast"], "symbols": ["GetForecast", "package", "import", "context", "pbv0", "impalastudios", "com", "weather", "foreca_proxy", "pkg", "func", "Server", "ctx", "Context", "ForecastRequest", "ForecastResponse", "error", "forecast", "err", "service", "GetForecastForLocation", "int", "GetLocationId", "nil", "return", "toGrpcError", "Transform"], "doc_head": "package v0\nimport (\n\t\"context\"\n\tpbv0 \"go.impalastudios.com/weather/foreca_proxy/pkg/pb/v0\"\n)\nfunc (s *Server) GetForecast(ctx context.Context, in *pbv0.ForecastRequest) (*pbv0.ForecastResponse, error) {\n\tforecast, err := s.service.GetForecastForLocation(ctx, int(in.GetLocationId()))\n\tif err != nil {\n\t\treturn nil, s.toGrpcError(err)\n\t}\n\treturn s.t.Transform(forecast), nil\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(s *Server).GetForecast", "package": "v0", "node_kind": "method", "receiver": "s *Server", "function_name": "", "method_name": "GetForecast", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["Context", "ForecastRequest", "ForecastResponse", "GetForecast", "GetForecastForLocation", "GetLocationId", "Server", "Transform", "context.Context", "go.impalastudios", "in.GetLocationId", "pbv0.ForecastRequest", "pbv0.ForecastResponse", "s.service", "s.t", "s.toGrpcError"], "header_context_minimal": "package v0\n// receiver: s *Server", "summary_llm": "The Go function `GetForecast` in the `v0` package handles a gRPC request for weather forecasts. It retrieves forecast data using `s.service.GetForecastForLocation`, transforms it with `s.t.Transform`, and returns it as a gRPC response or an error.", "keywords_llm": ["getforecast", "weather", "forecasts", "grpc", "context", "service", "locationid", "transform", "error"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/pb.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/pb.go", "rel_path": "pkg/pb/v0/pb.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 6, "text": "package v0\n\n// Generate gRPC client and server auto-generated code\n//go:generate protoc --proto_path=. --go_out=. --go_opt=module=go.impalastudios.com/weather/foreca_proxy/pkg/pb/v0 service.v0.proto\n//go:generate protoc --proto_path=. --go-grpc_out=. --go-grpc_opt=module=go.impalastudios.com/weather/foreca_proxy/pkg/pb/v0 service.v0.proto\n", "n_tokens": 101, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 6], "def_symbols": [], "symbols": ["package", "Generate", "gRPC", "client", "and", "server", "auto", "generated", "code", "generate", "protoc", "proto_path", "go_out", "go_opt", "module", "impalastudios", "com", "weather", "foreca_proxy", "pkg", "service", "proto", "grpc_out", "grpc_opt"], "doc_head": "package v0\n// Generate gRPC client and server auto-generated code\n//go:generate protoc --proto_path=. --go_out=. --go_opt=module=go.impalastudios.com/weather/foreca_proxy/pkg/pb/v0 service.v0.proto\n//go:generate protoc --proto_path=. --go-grpc_out=. --go-grpc_opt=module=go.impalastudios.com/weather/foreca_proxy/pkg/pb/v0 service.v0.proto", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:file_header", "package": "v0", "node_kind": "header", "receiver": "", "function_name": "", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["Generate", "go.impalastudios", "service.v0"], "header_context_minimal": "package v0", "summary_llm": "This Go file contains gRPC client and server auto-generated code instructions using protoc with specified options for generating code from the service.v0.proto file.", "keywords_llm": ["go", "generate", "protoc", "service.v0.proto", "go-out", "go-grpc_out", "module", "weather", "foreca_proxy"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go", "rel_path": "pkg/pb/v0/service.v0.pb.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 168, "text": "// Code generated by protoc-gen-go. DO NOT EDIT.\n// versions:\n// \tprotoc-gen-go v1.28.1\n// \tprotoc        v3.21.12\n// source: service.v0.proto\n\npackage v0\n\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\treflect \"reflect\"\n\tsync \"sync\"\n)\n\nconst (\n\t// Verify that this generated code is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)\n\t// Verify that runtime/protoimpl is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)\n)\n\ntype ForecastRequest struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tLocationId int64 `protobuf:\"varint,1,opt,name=locationId,proto3\" json:\"locationId,omitempty\"` // The Impala Location ID.\n}\n\nfunc (x *ForecastRequest) Reset() {\n\t*x = ForecastRequest{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[0]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastRequest) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastRequest) ProtoMessage() {}\n\nfunc (x *ForecastRequest) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[0]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastRequest.ProtoReflect.Descriptor instead.\nfunc (*ForecastRequest) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{0}\n}\n\nfunc (x *ForecastRequest) GetLocationId() int64 {\n\tif x != nil {\n\t\treturn x.LocationId\n\t}\n\treturn 0\n}\n\ntype ForecastResponse struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tCurrentCondition *ForecastResponse_CurrentCondition `protobuf:\"bytes,1,opt,name=currentCondition,proto3,oneof\" json:\"currentCondition,omitempty\"`\n\tDailyForecasts   []*ForecastResponse_DailyForecast  `protobuf:\"bytes,2,rep,name=dailyForecasts,proto3\" json:\"dailyForecasts,omitempty\"`\n\tHourlyForecasts  []*ForecastResponse_HourlyForecast `protobuf:\"bytes,3,rep,name=hourlyForecasts,proto3\" json:\"hourlyForecasts,omitempty\"`\n}\n\nfunc (x *ForecastResponse) Reset() {\n\t*x = ForecastResponse{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[1]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse) ProtoMessage() {}\n\nfunc (x *ForecastResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[1]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1}\n}\n\nfunc (x *ForecastResponse) GetCurrentCondition() *ForecastResponse_CurrentCondition {\n\tif x != nil {\n\t\treturn x.CurrentCondition\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse) GetDailyForecasts() []*ForecastResponse_DailyForecast {\n\tif x != nil {\n\t\treturn x.DailyForecasts\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse) GetHourlyForecasts() []*ForecastResponse_HourlyForecast {\n\tif x != nil {\n\t\treturn x.HourlyForecasts\n\t}\n\treturn nil\n}\n\ntype ForecastResponse_WeatherCondition struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tCode        string `protobuf:\"bytes,1,opt,name=code,proto3\" json:\"code,omitempty\"`\n\tDescription string `protobuf:\"bytes,2,opt,name=description,proto3\" json:\"description,omitempty\"`\n}\n\nfunc (x *ForecastResponse_WeatherCondition) Reset() {\n\t*x = ForecastResponse_WeatherCondition{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[2]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_WeatherCondition) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_WeatherCondition) ProtoMessage() {}\n\nfunc (x *ForecastResponse_WeatherCondition) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[2]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n", "n_tokens": 1211, "primary_symbol": "Reset", "primary_kind": "function", "primary_span": [31, 168], "def_symbols": ["Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetLocationId", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts"], "symbols": ["Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetLocationId", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts", "Code", "generated", "protoc", "gen", "NOT", "EDIT", "versions", "source", "service", "proto", "package", "import", "protoreflect", "google", "golang", "org", "protobuf", "reflect", "protoimpl", "runtime", "sync", "const", "Verify", "that", "this", "code", "sufficiently", "date", "EnforceVersion", "MinVersion", "MaxVersion", "type", "ForecastRequest", "struct", "state", "MessageState", "sizeCache", "SizeCache", "unknownFields", "UnknownFields", "LocationId", "int64", "varint", "opt", "name", "locationId", "proto3", "json", "omitempty", "The", "Impala", "Location", "func", "UnsafeEnabled", "file_service_v0_proto_msgTypes", "MessageStateOf", "Pointer", "StoreMessageInfo", "string", "return", "MessageStringOf", "Message", "nil", "LoadMessageInfo", "MessageOf", "Deprecated", "Use", "instead", "byte", "int", "file_service_v0_proto_rawDescGZIP", "ForecastResponse", "CurrentCondition", "ForecastResponse_CurrentCondition", "bytes", "currentCondition", "oneof", "DailyForecasts", "ForecastResponse_DailyForecast", "rep", "dailyForecasts", "HourlyForecasts", "ForecastResponse_HourlyForecast", "hourlyForecasts", "ForecastResponse_WeatherCondition", "Description", "description"], "doc_head": "// Code generated by protoc-gen-go. DO NOT EDIT.\n// versions:\n// \tprotoc-gen-go v1.28.1\n// \tprotoc        v3.21.12\n// source: service.v0.proto\npackage v0\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\treflect \"reflect\"\n\tsync \"sync\"\n)\nconst (\n\t// Verify that this generated code is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)\n\t// Verify that runtime/protoimpl is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)\n)\ntype ForecastRequest struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\tLocationId int64 `protobuf:\"varint,1,opt,name=locationId,proto3\" json:\"locationId,omitempty\"` // The Impala Location ID.\n}\nfunc (x *ForecastRequest) Reset() {\n\t*x = ForecastRequest{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[0]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\nfunc (x *ForecastRequest) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\nfunc (*ForecastRequest) ProtoMessage() {}\nfunc (x *Forecast", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(x *ForecastRequest).Reset", "package": "v0", "node_kind": "method", "receiver": "x *ForecastRequest", "function_name": "", "method_name": "Reset", "type_name": "ForecastRequest", "type_kind": "struct", "imports_used_minimal": ["google.golang.org/protobuf/reflect/protoreflect", "google.golang.org/protobuf/runtime/protoimpl"], "symbols_referenced_strict": ["Code", "CurrentCondition", "DO", "DailyForecasts", "Deprecated", "Description", "Descriptor", "EDIT", "EnforceVersion", "ForecastRequest", "ForecastRequest.ProtoReflect", "ForecastResponse", "ForecastResponse.ProtoReflect", "ForecastResponse_CurrentCondition", "ForecastResponse_DailyForecast", "ForecastResponse_HourlyForecast", "ForecastResponse_WeatherCondition", "GetCurrentCondition", "GetDailyForecasts", "GetHourlyForecasts", "GetLocationId", "HourlyForecasts", "ID", "Impala", "LoadMessageInfo", "Location", "LocationId", "MaxVersion", "Message", "MessageOf", "MessageState", "MessageStateOf", "MessageStringOf", "MinVersion", "NOT", "Pointer", "ProtoMessage", "ProtoReflect", "Reset", "SizeCache", "StoreMessageInfo", "String", "The", "UnknownFields", "UnsafeEnabled", "Use", "Verify", "X", "google.golang", "mi.MessageOf", "ms.LoadMessageInfo", "ms.StoreMessageInfo", "protoimpl.EnforceVersion", "protoimpl.MaxVersion", "protoimpl.MessageState", "protoimpl.MinVersion", "protoimpl.Pointer", "protoimpl.SizeCache", "protoimpl.UnknownFields", "protoimpl.UnsafeEnabled", "protoimpl.X", "protoreflect.Message", "service.v0", "x.CurrentCondition", "x.DailyForecasts", "x.HourlyForecasts", "x.LocationId"], "header_context_minimal": "package v0\nimport (\n    \"google.golang.org/protobuf/reflect/protoreflect\"\n    \"google.golang.org/protobuf/runtime/protoimpl\"\n)\n// receiver: x *ForecastRequest", "summary_llm": "This Go code defines message types for a forecast service, including `ForecastRequest` and `ForecastResponse`, with methods to reset, get string representation, and retrieve specific fields.", "keywords_llm": ["forecast", "service", "request", "response", "reset", "string", "get", "locationid", "currentcondition", "dailyforecasts", "hourlyforecasts"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go#2", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go", "rel_path": "pkg/pb/v0/service.v0.pb.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 169, "end_line": 333, "text": "// Deprecated: Use ForecastResponse_WeatherCondition.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_WeatherCondition) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 0}\n}\n\nfunc (x *ForecastResponse_WeatherCondition) GetCode() string {\n\tif x != nil {\n\t\treturn x.Code\n\t}\n\treturn \"\"\n}\n\nfunc (x *ForecastResponse_WeatherCondition) GetDescription() string {\n\tif x != nil {\n\t\treturn x.Description\n\t}\n\treturn \"\"\n}\n\ntype ForecastResponse_WindDirection struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tAbbreviation string  `protobuf:\"bytes,1,opt,name=abbreviation,proto3\" json:\"abbreviation,omitempty\"`\n\tDegrees      float32 `protobuf:\"fixed32,2,opt,name=degrees,proto3\" json:\"degrees,omitempty\"`\n}\n\nfunc (x *ForecastResponse_WindDirection) Reset() {\n\t*x = ForecastResponse_WindDirection{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[3]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_WindDirection) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_WindDirection) ProtoMessage() {}\n\nfunc (x *ForecastResponse_WindDirection) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[3]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_WindDirection.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_WindDirection) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 1}\n}\n\nfunc (x *ForecastResponse_WindDirection) GetAbbreviation() string {\n\tif x != nil {\n\t\treturn x.Abbreviation\n\t}\n\treturn \"\"\n}\n\nfunc (x *ForecastResponse_WindDirection) GetDegrees() float32 {\n\tif x != nil {\n\t\treturn x.Degrees\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_Wind struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tDirection *ForecastResponse_WindDirection `protobuf:\"bytes,1,opt,name=direction,proto3\" json:\"direction,omitempty\"`\n\tSpeed     float32                         `protobuf:\"fixed32,2,opt,name=speed,proto3\" json:\"speed,omitempty\"`\n}\n\nfunc (x *ForecastResponse_Wind) Reset() {\n\t*x = ForecastResponse_Wind{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[4]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_Wind) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_Wind) ProtoMessage() {}\n\nfunc (x *ForecastResponse_Wind) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[4]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_Wind.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_Wind) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 2}\n}\n\nfunc (x *ForecastResponse_Wind) GetDirection() *ForecastResponse_WindDirection {\n\tif x != nil {\n\t\treturn x.Direction\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_Wind) GetSpeed() float32 {\n\tif x != nil {\n\t\treturn x.Speed\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_Pressure struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tMillibar float32 `protobuf:\"fixed32,1,opt,name=millibar,proto3\" json:\"millibar,omitempty\"`\n\tTrend    int32   `protobuf:\"varint,2,opt,name=trend,proto3\" json:\"trend,omitempty\"`\n}\n\nfunc (x *ForecastResponse_Pressure) Reset() {\n\t*x = ForecastResponse_Pressure{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[5]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_Pressure) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_Pressure) ProtoMessage() {}\n\nfunc (x *ForecastResponse_Pressure) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[5]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n", "n_tokens": 1181, "primary_symbol": "Descriptor", "primary_kind": "function", "primary_span": [170, 333], "def_symbols": ["Descriptor", "GetCode", "GetDescription", "Reset", "String", "ProtoMessage", "ProtoReflect", "GetAbbreviation", "GetDegrees", "GetDirection", "GetSpeed"], "symbols": ["Descriptor", "GetCode", "GetDescription", "Reset", "String", "ProtoMessage", "ProtoReflect", "GetAbbreviation", "GetDegrees", "GetDirection", "GetSpeed", "Deprecated", "Use", "ForecastResponse_WeatherCondition", "instead", "func", "byte", "int", "return", "file_service_v0_proto_rawDescGZIP", "string", "nil", "Code", "Description", "type", "ForecastResponse_WindDirection", "struct", "state", "protoimpl", "MessageState", "sizeCache", "SizeCache", "unknownFields", "UnknownFields", "Abbreviation", "protobuf", "bytes", "opt", "name", "abbreviation", "proto3", "json", "omitempty", "Degrees", "float32", "fixed32", "degrees", "UnsafeEnabled", "file_service_v0_proto_msgTypes", "MessageStateOf", "Pointer", "StoreMessageInfo", "MessageStringOf", "protoreflect", "Message", "LoadMessageInfo", "MessageOf", "ForecastResponse_Wind", "Direction", "direction", "Speed", "speed", "ForecastResponse_Pressure", "Millibar", "millibar", "Trend", "int32", "varint", "trend"], "doc_head": "// Deprecated: Use ForecastResponse_WeatherCondition.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_WeatherCondition) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 0}\n}\nfunc (x *ForecastResponse_WeatherCondition) GetCode() string {\n\tif x != nil {\n\t\treturn x.Code\n\t}\n\treturn \"\"\n}\nfunc (x *ForecastResponse_WeatherCondition) GetDescription() string {\n\tif x != nil {\n\t\treturn x.Description\n\t}\n\treturn \"\"\n}\ntype ForecastResponse_WindDirection struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\tAbbreviation string  `protobuf:\"bytes,1,opt,name=abbreviation,proto3\" json:\"abbreviation,omitempty\"`\n\tDegrees      float32 `protobuf:\"fixed32,2,opt,name=degrees,proto3\" json:\"degrees,omitempty\"`\n}\nfunc (x *ForecastResponse_WindDirection) Reset() {\n\t*x = ForecastResponse_WindDirection{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[3]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\nfunc (x *ForecastResponse_WindDirection) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\nfunc (*ForecastResponse_WindDirection) Pro", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(*ForecastResponse_WeatherCondition).Descriptor", "package": "", "node_kind": "method", "receiver": "*ForecastResponse_WeatherCondition", "function_name": "", "method_name": "Descriptor", "type_name": "ForecastResponse_WindDirection", "type_kind": "struct", "imports_used_minimal": ["google.golang.org/protobuf/reflect/protoreflect", "google.golang.org/protobuf/runtime/protoimpl"], "symbols_referenced_strict": ["Abbreviation", "Code", "Degrees", "Deprecated", "Description", "Descriptor", "Direction", "ForecastResponse_Pressure", "ForecastResponse_WeatherCondition", "ForecastResponse_WeatherCondition.ProtoReflect", "ForecastResponse_Wind", "ForecastResponse_Wind.ProtoReflect", "ForecastResponse_WindDirection", "ForecastResponse_WindDirection.ProtoReflect", "GetAbbreviation", "GetCode", "GetDegrees", "GetDescription", "GetDirection", "GetSpeed", "LoadMessageInfo", "Message", "MessageOf", "MessageState", "MessageStateOf", "MessageStringOf", "Millibar", "Pointer", "ProtoMessage", "ProtoReflect", "Reset", "SizeCache", "Speed", "StoreMessageInfo", "String", "Trend", "UnknownFields", "UnsafeEnabled", "Use", "X", "mi.MessageOf", "ms.LoadMessageInfo", "ms.StoreMessageInfo", "protoimpl.MessageState", "protoimpl.Pointer", "protoimpl.SizeCache", "protoimpl.UnknownFields", "protoimpl.UnsafeEnabled", "protoimpl.X", "protoreflect.Message", "x.Abbreviation", "x.Code", "x.Degrees", "x.Description", "x.Direction", "x.Speed"], "header_context_minimal": "package \nimport (\n    \"google.golang.org/protobuf/reflect/protoreflect\"\n    \"google.golang.org/protobuf/runtime/protoimpl\"\n)\n// receiver: *ForecastResponse_WeatherCondition", "summary_llm": "This Go code defines several structs representing weather-related data in a forecast response, including `WeatherCondition`, `WindDirection`, `Wind`, and `Pressure`. Each struct includes methods for accessing fields like `Code` or `Speed`, as well as descriptor methods that return the message descriptor for use with reflection.", "keywords_llm": ["weather", "forecast", "condition", "wind", "pressure", "code", "speed", "direction", "millibar", "trend", "descriptor", "reflection"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go#3", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go", "rel_path": "pkg/pb/v0/service.v0.pb.go", "ext": "go", "language": "go", "chunk_number": 3, "start_line": 334, "end_line": 488, "text": "// Deprecated: Use ForecastResponse_Pressure.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_Pressure) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 3}\n}\n\nfunc (x *ForecastResponse_Pressure) GetMillibar() float32 {\n\tif x != nil {\n\t\treturn x.Millibar\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_Pressure) GetTrend() int32 {\n\tif x != nil {\n\t\treturn x.Trend\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_CurrentCondition struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tEpoch                int64                                       `protobuf:\"varint,1,opt,name=epoch,proto3\" json:\"epoch,omitempty\"`\n\tVisibility           float32                                     `protobuf:\"fixed32,2,opt,name=visibility,proto3\" json:\"visibility,omitempty\"`\n\tWeatherCondition     *ForecastResponse_WeatherCondition          `protobuf:\"bytes,3,opt,name=weatherCondition,proto3\" json:\"weatherCondition,omitempty\"`\n\tPrecipitation        float32                                     `protobuf:\"fixed32,4,opt,name=precipitation,proto3\" json:\"precipitation,omitempty\"`\n\tNextHour             *ForecastResponse_CurrentCondition_NextHour `protobuf:\"bytes,5,opt,name=nextHour,proto3\" json:\"nextHour,omitempty\"`\n\tTemperature          float32                                     `protobuf:\"fixed32,6,opt,name=temperature,proto3\" json:\"temperature,omitempty\"`\n\tTemperatureFeelsLike float32                                     `protobuf:\"fixed32,7,opt,name=temperatureFeelsLike,proto3\" json:\"temperatureFeelsLike,omitempty\"`\n\tWindGust             *ForecastResponse_CurrentCondition_WindGust `protobuf:\"bytes,8,opt,name=windGust,proto3\" json:\"windGust,omitempty\"`\n\tDewPoint             float32                                     `protobuf:\"fixed32,9,opt,name=dewPoint,proto3\" json:\"dewPoint,omitempty\"`\n\tHeatIndex            float32                                     `protobuf:\"fixed32,10,opt,name=heatIndex,proto3\" json:\"heatIndex,omitempty\"`\n\tPressure             *ForecastResponse_Pressure                  `protobuf:\"bytes,11,opt,name=pressure,proto3\" json:\"pressure,omitempty\"`\n\tUvIndex              float32                                     `protobuf:\"fixed32,12,opt,name=uvIndex,proto3\" json:\"uvIndex,omitempty\"`\n\tHumidityPercentage   int32                                       `protobuf:\"varint,13,opt,name=humidityPercentage,proto3\" json:\"humidityPercentage,omitempty\"`\n}\n\nfunc (x *ForecastResponse_CurrentCondition) Reset() {\n\t*x = ForecastResponse_CurrentCondition{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[6]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_CurrentCondition) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_CurrentCondition) ProtoMessage() {}\n\nfunc (x *ForecastResponse_CurrentCondition) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[6]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_CurrentCondition.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_CurrentCondition) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 4}\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetEpoch() int64 {\n\tif x != nil {\n\t\treturn x.Epoch\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetVisibility() float32 {\n\tif x != nil {\n\t\treturn x.Visibility\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetWeatherCondition() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherCondition\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetPrecipitation() float32 {\n\tif x != nil {\n\t\treturn x.Precipitation\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetNextHour() *ForecastResponse_CurrentCondition_NextHour {\n\tif x != nil {\n\t\treturn x.NextHour\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetTemperature() float32 {\n\tif x != nil {\n\t\treturn x.Temperature\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetTemperatureFeelsLike() float32 {\n\tif x != nil {\n\t\treturn x.TemperatureFeelsLike\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetWindGust() *ForecastResponse_CurrentCondition_WindGust {\n\tif x != nil {\n\t\treturn x.WindGust\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetDewPoint() float32 {\n\tif x != nil {\n\t\treturn x.DewPoint\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetHeatIndex() float32 {\n\tif x != nil {\n\t\treturn x.HeatIndex\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetPressure() *ForecastResponse_Pressure {\n\tif x != nil {\n\t\treturn x.Pressure\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_CurrentCondition) GetUvIndex() float32 {\n\tif x != nil {\n\t\treturn x.UvIndex\n\t}\n\treturn 0\n}\n", "n_tokens": 1210, "primary_symbol": "Descriptor", "primary_kind": "function", "primary_span": [335, 488], "def_symbols": ["Descriptor", "GetMillibar", "GetTrend", "Reset", "String", "ProtoMessage", "ProtoReflect", "GetEpoch", "GetVisibility", "GetWeatherCondition", "GetPrecipitation", "GetNextHour", "GetTemperature", "GetTemperatureFeelsLike", "GetWindGust", "GetDewPoint", "GetHeatIndex", "GetPressure", "GetUvIndex"], "symbols": ["Descriptor", "GetMillibar", "GetTrend", "Reset", "String", "ProtoMessage", "ProtoReflect", "GetEpoch", "GetVisibility", "GetWeatherCondition", "GetPrecipitation", "GetNextHour", "GetTemperature", "GetTemperatureFeelsLike", "GetWindGust", "GetDewPoint", "GetHeatIndex", "GetPressure", "GetUvIndex", "Deprecated", "Use", "ForecastResponse_Pressure", "instead", "func", "byte", "int", "return", "file_service_v0_proto_rawDescGZIP", "float32", "nil", "Millibar", "int32", "Trend", "type", "ForecastResponse_CurrentCondition", "struct", "state", "protoimpl", "MessageState", "sizeCache", "SizeCache", "unknownFields", "UnknownFields", "Epoch", "int64", "protobuf", "varint", "opt", "name", "epoch", "proto3", "json", "omitempty", "Visibility", "fixed32", "visibility", "WeatherCondition", "ForecastResponse_WeatherCondition", "bytes", "weatherCondition", "Precipitation", "precipitation", "NextHour", "ForecastResponse_CurrentCondition_NextHour", "nextHour", "Temperature", "temperature", "TemperatureFeelsLike", "temperatureFeelsLike", "WindGust", "ForecastResponse_CurrentCondition_WindGust", "windGust", "DewPoint", "dewPoint", "HeatIndex", "heatIndex", "Pressure", "pressure", "UvIndex", "uvIndex", "HumidityPercentage", "humidityPercentage", "UnsafeEnabled", "file_service_v0_proto_msgTypes", "MessageStateOf", "Pointer", "StoreMessageInfo", "string", "MessageStringOf", "protoreflect", "Message", "LoadMessageInfo", "MessageOf"], "doc_head": "// Deprecated: Use ForecastResponse_Pressure.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_Pressure) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 3}\n}\nfunc (x *ForecastResponse_Pressure) GetMillibar() float32 {\n\tif x != nil {\n\t\treturn x.Millibar\n\t}\n\treturn 0\n}\nfunc (x *ForecastResponse_Pressure) GetTrend() int32 {\n\tif x != nil {\n\t\treturn x.Trend\n\t}\n\treturn 0\n}\ntype ForecastResponse_CurrentCondition struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\tEpoch                int64                                       `protobuf:\"varint,1,opt,name=epoch,proto3\" json:\"epoch,omitempty\"`\n\tVisibility           float32                                     `protobuf:\"fixed32,2,opt,name=visibility,proto3\" json:\"visibility,omitempty\"`\n\tWeatherCondition     *ForecastResponse_WeatherCondition          `protobuf:\"bytes,3,opt,name=weatherCondition,proto3\" json:\"weatherCondition,omitempty\"`\n\tPrecipitation        float32                                     `protobuf:\"fixed32,4,opt,name=precipitation,proto3\" json:\"precipitation,omitempty\"`\n\tNextHour             *ForecastResponse_Curre", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(*ForecastResponse_Pressure).Descriptor", "package": "", "node_kind": "method", "receiver": "*ForecastResponse_Pressure", "function_name": "", "method_name": "Descriptor", "type_name": "ForecastResponse_CurrentCondition", "type_kind": "struct", "imports_used_minimal": ["google.golang.org/protobuf/reflect/protoreflect", "google.golang.org/protobuf/runtime/protoimpl"], "symbols_referenced_strict": ["Deprecated", "Descriptor", "DewPoint", "Epoch", "ForecastResponse_CurrentCondition", "ForecastResponse_CurrentCondition.ProtoReflect", "ForecastResponse_CurrentCondition_NextHour", "ForecastResponse_CurrentCondition_WindGust", "ForecastResponse_Pressure", "ForecastResponse_Pressure.ProtoReflect", "ForecastResponse_WeatherCondition", "GetDewPoint", "GetEpoch", "GetHeatIndex", "GetMillibar", "GetNextHour", "GetPrecipitation", "GetPressure", "GetTemperature", "GetTemperatureFeelsLike", "GetTrend", "GetUvIndex", "GetVisibility", "GetWeatherCondition", "GetWindGust", "HeatIndex", "HumidityPercentage", "LoadMessageInfo", "Message", "MessageOf", "MessageState", "MessageStateOf", "MessageStringOf", "Millibar", "NextHour", "Pointer", "Precipitation", "Pressure", "ProtoMessage", "ProtoReflect", "Reset", "SizeCache", "StoreMessageInfo", "String", "Temperature", "TemperatureFeelsLike", "Trend", "UnknownFields", "UnsafeEnabled", "Use", "UvIndex", "Visibility", "WeatherCondition", "WindGust", "X", "mi.MessageOf", "ms.LoadMessageInfo", "ms.StoreMessageInfo", "protoimpl.MessageState", "protoimpl.Pointer", "protoimpl.SizeCache", "protoimpl.UnknownFields", "protoimpl.UnsafeEnabled", "protoimpl.X", "protoreflect.Message", "x.DewPoint", "x.Epoch", "x.HeatIndex", "x.Millibar", "x.NextHour", "x.Precipitation", "x.Pressure", "x.Temperature", "x.TemperatureFeelsLike", "x.Trend", "x.UvIndex", "x.Visibility", "x.WeatherCondition", "x.WindGust"], "header_context_minimal": "package \nimport (\n    \"google.golang.org/protobuf/reflect/protoreflect\"\n    \"google.golang.org/protobuf/runtime/protoimpl\"\n)\n// receiver: *ForecastResponse_Pressure", "summary_llm": "This Go code defines methods for accessing various fields in a `ForecastResponse_Pressure` and `ForecastResponse_CurrentCondition` message types. It includes methods like `GetMillibar`, `GetTrend`, `GetEpoch`, and others, which are part of the protobuf reflection API.", "keywords_llm": ["forecast response", "pressure", "current condition", "millibar", "trend", "epoch", "visibility", "weather condition", "precipitation", "temperature"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go#4", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go", "rel_path": "pkg/pb/v0/service.v0.pb.go", "ext": "go", "language": "go", "chunk_number": 4, "start_line": 489, "end_line": 628, "text": "func (x *ForecastResponse_CurrentCondition) GetHumidityPercentage() int32 {\n\tif x != nil {\n\t\treturn x.HumidityPercentage\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_DailyForecast struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tEpoch                     int64                              `protobuf:\"varint,1,opt,name=epoch,proto3\" json:\"epoch,omitempty\"`\n\tTemperatureMin            float32                            `protobuf:\"fixed32,2,opt,name=temperatureMin,proto3\" json:\"temperatureMin,omitempty\"`\n\tTemperatureMax            float32                            `protobuf:\"fixed32,3,opt,name=temperatureMax,proto3\" json:\"temperatureMax,omitempty\"`\n\tPrecipitation             float32                            `protobuf:\"fixed32,4,opt,name=precipitation,proto3\" json:\"precipitation,omitempty\"`\n\tPrecipitationDay          float32                            `protobuf:\"fixed32,5,opt,name=precipitationDay,proto3\" json:\"precipitationDay,omitempty\"`\n\tPrecipitationNight        float32                            `protobuf:\"fixed32,6,opt,name=precipitationNight,proto3\" json:\"precipitationNight,omitempty\"`\n\tSnow                      float32                            `protobuf:\"fixed32,7,opt,name=snow,proto3\" json:\"snow,omitempty\"`\n\tSnowDay                   float32                            `protobuf:\"fixed32,8,opt,name=snowDay,proto3\" json:\"snowDay,omitempty\"`\n\tSnowNight                 float32                            `protobuf:\"fixed32,9,opt,name=snowNight,proto3\" json:\"snowNight,omitempty\"`\n\tPrecipitationProbability  int32                              `protobuf:\"varint,10,opt,name=precipitationProbability,proto3\" json:\"precipitationProbability,omitempty\"`\n\tWind                      *ForecastResponse_Wind             `protobuf:\"bytes,11,opt,name=wind,proto3\" json:\"wind,omitempty\"`\n\tAverageHumidityPercentage int32                              `protobuf:\"varint,12,opt,name=averageHumidityPercentage,proto3\" json:\"averageHumidityPercentage,omitempty\"`\n\tWeatherCondition          *ForecastResponse_WeatherCondition `protobuf:\"bytes,13,opt,name=weatherCondition,proto3\" json:\"weatherCondition,omitempty\"`\n\tWeatherConditionNight     *ForecastResponse_WeatherCondition `protobuf:\"bytes,14,opt,name=weatherConditionNight,proto3\" json:\"weatherConditionNight,omitempty\"`\n\tUvIndex                   float32                            `protobuf:\"fixed32,15,opt,name=uvIndex,proto3\" json:\"uvIndex,omitempty\"`\n\tSunriseEpoch              int64                              `protobuf:\"varint,16,opt,name=sunriseEpoch,proto3\" json:\"sunriseEpoch,omitempty\"`\n\tSunsetEpoch               int64                              `protobuf:\"varint,17,opt,name=sunsetEpoch,proto3\" json:\"sunsetEpoch,omitempty\"`\n}\n\nfunc (x *ForecastResponse_DailyForecast) Reset() {\n\t*x = ForecastResponse_DailyForecast{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[7]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_DailyForecast) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_DailyForecast) ProtoMessage() {}\n\nfunc (x *ForecastResponse_DailyForecast) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[7]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_DailyForecast.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_DailyForecast) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 5}\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetEpoch() int64 {\n\tif x != nil {\n\t\treturn x.Epoch\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetTemperatureMin() float32 {\n\tif x != nil {\n\t\treturn x.TemperatureMin\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetTemperatureMax() float32 {\n\tif x != nil {\n\t\treturn x.TemperatureMax\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetPrecipitation() float32 {\n\tif x != nil {\n\t\treturn x.Precipitation\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetPrecipitationDay() float32 {\n\tif x != nil {\n\t\treturn x.PrecipitationDay\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetPrecipitationNight() float32 {\n\tif x != nil {\n\t\treturn x.PrecipitationNight\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetSnow() float32 {\n\tif x != nil {\n\t\treturn x.Snow\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetSnowDay() float32 {\n\tif x != nil {\n\t\treturn x.SnowDay\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetSnowNight() float32 {\n\tif x != nil {\n\t\treturn x.SnowNight\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetPrecipitationProbability() int32 {\n\tif x != nil {\n\t\treturn x.PrecipitationProbability\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetWind() *ForecastResponse_Wind {\n\tif x != nil {\n\t\treturn x.Wind\n\t}\n\treturn nil\n}\n", "n_tokens": 1228, "primary_symbol": "GetHumidityPercentage", "primary_kind": "function", "primary_span": [489, 628], "def_symbols": ["GetHumidityPercentage", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetEpoch", "GetTemperatureMin", "GetTemperatureMax", "GetPrecipitation", "GetPrecipitationDay", "GetPrecipitationNight", "GetSnow", "GetSnowDay", "GetSnowNight", "GetPrecipitationProbability", "GetWind"], "symbols": ["GetHumidityPercentage", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetEpoch", "GetTemperatureMin", "GetTemperatureMax", "GetPrecipitation", "GetPrecipitationDay", "GetPrecipitationNight", "GetSnow", "GetSnowDay", "GetSnowNight", "GetPrecipitationProbability", "GetWind", "func", "ForecastResponse_CurrentCondition", "int32", "nil", "return", "HumidityPercentage", "type", "ForecastResponse_DailyForecast", "struct", "state", "protoimpl", "MessageState", "sizeCache", "SizeCache", "unknownFields", "UnknownFields", "Epoch", "int64", "protobuf", "varint", "opt", "name", "epoch", "proto3", "json", "omitempty", "TemperatureMin", "float32", "fixed32", "temperatureMin", "TemperatureMax", "temperatureMax", "Precipitation", "precipitation", "PrecipitationDay", "precipitationDay", "PrecipitationNight", "precipitationNight", "Snow", "snow", "SnowDay", "snowDay", "SnowNight", "snowNight", "PrecipitationProbability", "precipitationProbability", "Wind", "ForecastResponse_Wind", "bytes", "wind", "AverageHumidityPercentage", "averageHumidityPercentage", "WeatherCondition", "ForecastResponse_WeatherCondition", "weatherCondition", "WeatherConditionNight", "weatherConditionNight", "UvIndex", "uvIndex", "SunriseEpoch", "sunriseEpoch", "SunsetEpoch", "sunsetEpoch", "UnsafeEnabled", "file_service_v0_proto_msgTypes", "MessageStateOf", "Pointer", "StoreMessageInfo", "string", "MessageStringOf", "protoreflect", "Message", "LoadMessageInfo", "MessageOf", "Deprecated", "Use", "instead", "byte", "int", "file_service_v0_proto_rawDescGZIP"], "doc_head": "func (x *ForecastResponse_CurrentCondition) GetHumidityPercentage() int32 {\n\tif x != nil {\n\t\treturn x.HumidityPercentage\n\t}\n\treturn 0\n}\ntype ForecastResponse_DailyForecast struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\tEpoch                     int64                              `protobuf:\"varint,1,opt,name=epoch,proto3\" json:\"epoch,omitempty\"`\n\tTemperatureMin            float32                            `protobuf:\"fixed32,2,opt,name=temperatureMin,proto3\" json:\"temperatureMin,omitempty\"`\n\tTemperatureMax            float32                            `protobuf:\"fixed32,3,opt,name=temperatureMax,proto3\" json:\"temperatureMax,omitempty\"`\n\tPrecipitation             float32                            `protobuf:\"fixed32,4,opt,name=precipitation,proto3\" json:\"precipitation,omitempty\"`\n\tPrecipitationDay          float32                            `protobuf:\"fixed32,5,opt,name=precipitationDay,proto3\" json:\"precipitationDay,omitempty\"`\n\tPrecipitationNight        float32                            `protobuf:\"fixed32,6,opt,name=precipitationNight,proto3\" json:\"precipitationNight,omitempty\"`\n\tSnow                      f", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(x *ForecastResponse_CurrentCondition).GetHumidityPercentage", "package": "", "node_kind": "method", "receiver": "x *ForecastResponse_CurrentCondition", "function_name": "", "method_name": "GetHumidityPercentage", "type_name": "ForecastResponse_DailyForecast", "type_kind": "struct", "imports_used_minimal": ["google.golang.org/protobuf/reflect/protoreflect", "google.golang.org/protobuf/runtime/protoimpl"], "symbols_referenced_strict": ["AverageHumidityPercentage", "Deprecated", "Descriptor", "Epoch", "ForecastResponse_CurrentCondition", "ForecastResponse_DailyForecast", "ForecastResponse_DailyForecast.ProtoReflect", "ForecastResponse_WeatherCondition", "ForecastResponse_Wind", "GetEpoch", "GetHumidityPercentage", "GetPrecipitation", "GetPrecipitationDay", "GetPrecipitationNight", "GetPrecipitationProbability", "GetSnow", "GetSnowDay", "GetSnowNight", "GetTemperatureMax", "GetTemperatureMin", "GetWind", "HumidityPercentage", "LoadMessageInfo", "Message", "MessageOf", "MessageState", "MessageStateOf", "MessageStringOf", "Pointer", "Precipitation", "PrecipitationDay", "PrecipitationNight", "PrecipitationProbability", "ProtoMessage", "ProtoReflect", "Reset", "SizeCache", "Snow", "SnowDay", "SnowNight", "StoreMessageInfo", "String", "SunriseEpoch", "SunsetEpoch", "TemperatureMax", "TemperatureMin", "UnknownFields", "UnsafeEnabled", "Use", "UvIndex", "WeatherCondition", "WeatherConditionNight", "Wind", "X", "mi.MessageOf", "ms.LoadMessageInfo", "ms.StoreMessageInfo", "protoimpl.MessageState", "protoimpl.Pointer", "protoimpl.SizeCache", "protoimpl.UnknownFields", "protoimpl.UnsafeEnabled", "protoimpl.X", "protoreflect.Message", "x.Epoch", "x.HumidityPercentage", "x.Precipitation", "x.PrecipitationDay", "x.PrecipitationNight", "x.PrecipitationProbability", "x.Snow", "x.SnowDay", "x.SnowNight", "x.TemperatureMax", "x.TemperatureMin", "x.Wind"], "header_context_minimal": "package \nimport (\n    \"google.golang.org/protobuf/reflect/protoreflect\"\n    \"google.golang.org/protobuf/runtime/protoimpl\"\n)\n// receiver: x *ForecastResponse_CurrentCondition", "summary_llm": "The Go code defines a `ForecastResponse_DailyForecast` struct with methods to retrieve various weather-related values such as temperature, precipitation, and wind. The `GetHumidityPercentage` method returns the humidity percentage for a daily forecast.", "keywords_llm": ["forecast", "dailyforecast", "humidity", "temperature", "precipitation", "wind", "gethumiditypercentage", "protobuf", "message", "reset", "string", "protoimpl"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go#5", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go", "rel_path": "pkg/pb/v0/service.v0.pb.go", "ext": "go", "language": "go", "chunk_number": 5, "start_line": 629, "end_line": 790, "text": "func (x *ForecastResponse_DailyForecast) GetAverageHumidityPercentage() int32 {\n\tif x != nil {\n\t\treturn x.AverageHumidityPercentage\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetWeatherCondition() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherCondition\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetWeatherConditionNight() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherConditionNight\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetUvIndex() float32 {\n\tif x != nil {\n\t\treturn x.UvIndex\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetSunriseEpoch() int64 {\n\tif x != nil {\n\t\treturn x.SunriseEpoch\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_DailyForecast) GetSunsetEpoch() int64 {\n\tif x != nil {\n\t\treturn x.SunsetEpoch\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_HourlyForecast struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tEpoch                    int64                              `protobuf:\"varint,1,opt,name=epoch,proto3\" json:\"epoch,omitempty\"`\n\tTemperature              float32                            `protobuf:\"fixed32,2,opt,name=temperature,proto3\" json:\"temperature,omitempty\"`\n\tTemperatureFeelsLike     float32                            `protobuf:\"fixed32,3,opt,name=temperatureFeelsLike,proto3\" json:\"temperatureFeelsLike,omitempty\"`\n\tWeatherCondition         *ForecastResponse_WeatherCondition `protobuf:\"bytes,4,opt,name=weatherCondition,proto3\" json:\"weatherCondition,omitempty\"`\n\tPrecipitation            float32                            `protobuf:\"fixed32,5,opt,name=precipitation,proto3\" json:\"precipitation,omitempty\"`\n\tSnow                     float32                            `protobuf:\"fixed32,6,opt,name=snow,proto3\" json:\"snow,omitempty\"`\n\tPrecipitationProbability int32                              `protobuf:\"varint,7,opt,name=precipitationProbability,proto3\" json:\"precipitationProbability,omitempty\"`\n\tWind                     *ForecastResponse_Wind             `protobuf:\"bytes,8,opt,name=wind,proto3\" json:\"wind,omitempty\"`\n\tPressure                 *ForecastResponse_Pressure         `protobuf:\"bytes,9,opt,name=pressure,proto3\" json:\"pressure,omitempty\"`\n\tHumidityPercentage       int32                              `protobuf:\"varint,10,opt,name=humidityPercentage,proto3\" json:\"humidityPercentage,omitempty\"`\n\tUvIndex                  float32                            `protobuf:\"fixed32,11,opt,name=uvIndex,proto3\" json:\"uvIndex,omitempty\"`\n}\n\nfunc (x *ForecastResponse_HourlyForecast) Reset() {\n\t*x = ForecastResponse_HourlyForecast{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[8]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_HourlyForecast) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_HourlyForecast) ProtoMessage() {}\n\nfunc (x *ForecastResponse_HourlyForecast) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[8]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_HourlyForecast.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_HourlyForecast) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 6}\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetEpoch() int64 {\n\tif x != nil {\n\t\treturn x.Epoch\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetTemperature() float32 {\n\tif x != nil {\n\t\treturn x.Temperature\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetTemperatureFeelsLike() float32 {\n\tif x != nil {\n\t\treturn x.TemperatureFeelsLike\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetWeatherCondition() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherCondition\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetPrecipitation() float32 {\n\tif x != nil {\n\t\treturn x.Precipitation\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetSnow() float32 {\n\tif x != nil {\n\t\treturn x.Snow\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetPrecipitationProbability() int32 {\n\tif x != nil {\n\t\treturn x.PrecipitationProbability\n\t}\n\treturn 0\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetWind() *ForecastResponse_Wind {\n\tif x != nil {\n\t\treturn x.Wind\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetPressure() *ForecastResponse_Pressure {\n\tif x != nil {\n\t\treturn x.Pressure\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_HourlyForecast) GetHumidityPercentage() int32 {\n\tif x != nil {\n\t\treturn x.HumidityPercentage\n\t}\n\treturn 0\n}\n", "n_tokens": 1209, "primary_symbol": "GetAverageHumidityPercentage", "primary_kind": "function", "primary_span": [629, 790], "def_symbols": ["GetAverageHumidityPercentage", "GetWeatherCondition", "GetWeatherConditionNight", "GetUvIndex", "GetSunriseEpoch", "GetSunsetEpoch", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetEpoch", "GetTemperature", "GetTemperatureFeelsLike", "GetPrecipitation", "GetSnow", "GetPrecipitationProbability", "GetWind", "GetPressure", "GetHumidityPercentage"], "symbols": ["GetAverageHumidityPercentage", "GetWeatherCondition", "GetWeatherConditionNight", "GetUvIndex", "GetSunriseEpoch", "GetSunsetEpoch", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetEpoch", "GetTemperature", "GetTemperatureFeelsLike", "GetPrecipitation", "GetSnow", "GetPrecipitationProbability", "GetWind", "GetPressure", "GetHumidityPercentage", "func", "ForecastResponse_DailyForecast", "int32", "nil", "return", "AverageHumidityPercentage", "ForecastResponse_WeatherCondition", "WeatherCondition", "WeatherConditionNight", "float32", "UvIndex", "int64", "SunriseEpoch", "SunsetEpoch", "type", "ForecastResponse_HourlyForecast", "struct", "state", "protoimpl", "MessageState", "sizeCache", "SizeCache", "unknownFields", "UnknownFields", "Epoch", "protobuf", "varint", "opt", "name", "epoch", "proto3", "json", "omitempty", "Temperature", "fixed32", "temperature", "TemperatureFeelsLike", "temperatureFeelsLike", "bytes", "weatherCondition", "Precipitation", "precipitation", "Snow", "snow", "PrecipitationProbability", "precipitationProbability", "Wind", "ForecastResponse_Wind", "wind", "Pressure", "ForecastResponse_Pressure", "pressure", "HumidityPercentage", "humidityPercentage", "uvIndex", "UnsafeEnabled", "file_service_v0_proto_msgTypes", "MessageStateOf", "Pointer", "StoreMessageInfo", "string", "MessageStringOf", "protoreflect", "Message", "LoadMessageInfo", "MessageOf", "Deprecated", "Use", "instead", "byte", "int", "file_service_v0_proto_rawDescGZIP"], "doc_head": "func (x *ForecastResponse_DailyForecast) GetAverageHumidityPercentage() int32 {\n\tif x != nil {\n\t\treturn x.AverageHumidityPercentage\n\t}\n\treturn 0\n}\nfunc (x *ForecastResponse_DailyForecast) GetWeatherCondition() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherCondition\n\t}\n\treturn nil\n}\nfunc (x *ForecastResponse_DailyForecast) GetWeatherConditionNight() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherConditionNight\n\t}\n\treturn nil\n}\nfunc (x *ForecastResponse_DailyForecast) GetUvIndex() float32 {\n\tif x != nil {\n\t\treturn x.UvIndex\n\t}\n\treturn 0\n}\nfunc (x *ForecastResponse_DailyForecast) GetSunriseEpoch() int64 {\n\tif x != nil {\n\t\treturn x.SunriseEpoch\n\t}\n\treturn 0\n}\nfunc (x *ForecastResponse_DailyForecast) GetSunsetEpoch() int64 {\n\tif x != nil {\n\t\treturn x.SunsetEpoch\n\t}\n\treturn 0\n}\ntype ForecastResponse_HourlyForecast struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\tEpoch                    int64                              `protobuf:\"varint,1,opt,name=epoch,proto3\" json:\"epoch,omitempty\"`\n\tTemperature              float32                            `protobuf:\"fixed32,2,op", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(x *ForecastResponse_DailyForecast).GetAverageHumidityPercentage", "package": "", "node_kind": "method", "receiver": "x *ForecastResponse_DailyForecast", "function_name": "", "method_name": "GetAverageHumidityPercentage", "type_name": "ForecastResponse_HourlyForecast", "type_kind": "struct", "imports_used_minimal": ["google.golang.org/protobuf/reflect/protoreflect", "google.golang.org/protobuf/runtime/protoimpl"], "symbols_referenced_strict": ["AverageHumidityPercentage", "Deprecated", "Descriptor", "Epoch", "ForecastResponse_DailyForecast", "ForecastResponse_HourlyForecast", "ForecastResponse_HourlyForecast.ProtoReflect", "ForecastResponse_Pressure", "ForecastResponse_WeatherCondition", "ForecastResponse_Wind", "GetAverageHumidityPercentage", "GetEpoch", "GetHumidityPercentage", "GetPrecipitation", "GetPrecipitationProbability", "GetPressure", "GetSnow", "GetSunriseEpoch", "GetSunsetEpoch", "GetTemperature", "GetTemperatureFeelsLike", "GetUvIndex", "GetWeatherCondition", "GetWeatherConditionNight", "GetWind", "HumidityPercentage", "LoadMessageInfo", "Message", "MessageOf", "MessageState", "MessageStateOf", "MessageStringOf", "Pointer", "Precipitation", "PrecipitationProbability", "Pressure", "ProtoMessage", "ProtoReflect", "Reset", "SizeCache", "Snow", "StoreMessageInfo", "String", "SunriseEpoch", "SunsetEpoch", "Temperature", "TemperatureFeelsLike", "UnknownFields", "UnsafeEnabled", "Use", "UvIndex", "WeatherCondition", "WeatherConditionNight", "Wind", "X", "mi.MessageOf", "ms.LoadMessageInfo", "ms.StoreMessageInfo", "protoimpl.MessageState", "protoimpl.Pointer", "protoimpl.SizeCache", "protoimpl.UnknownFields", "protoimpl.UnsafeEnabled", "protoimpl.X", "protoreflect.Message", "x.AverageHumidityPercentage", "x.Epoch", "x.HumidityPercentage", "x.Precipitation", "x.PrecipitationProbability", "x.Pressure", "x.Snow", "x.SunriseEpoch", "x.SunsetEpoch", "x.Temperature", "x.TemperatureFeelsLike", "x.UvIndex", "x.WeatherCondition", "x.WeatherConditionNight", "x.Wind"], "header_context_minimal": "package \nimport (\n    \"google.golang.org/protobuf/reflect/protoreflect\"\n    \"google.golang.org/protobuf/runtime/protoimpl\"\n)\n// receiver: x *ForecastResponse_DailyForecast", "summary_llm": "This Go code defines methods for accessing various weather-related data in daily and hourly forecast responses. It includes methods like `GetAverageHumidityPercentage`, `GetWeatherCondition`, `GetUvIndex`, etc., which check if the receiver is not nil before returning the respective field value or a default value.", "keywords_llm": ["protobuf", "message", "methods", "weather", "forecast", "humidity", "uv index", "epoch", "temperature"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go#6", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go", "rel_path": "pkg/pb/v0/service.v0.pb.go", "ext": "go", "language": "go", "chunk_number": 6, "start_line": 791, "end_line": 900, "text": "func (x *ForecastResponse_HourlyForecast) GetUvIndex() float32 {\n\tif x != nil {\n\t\treturn x.UvIndex\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_CurrentCondition_NextHour struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tWeatherCondition *ForecastResponse_WeatherCondition `protobuf:\"bytes,1,opt,name=weatherCondition,proto3\" json:\"weatherCondition,omitempty\"`\n\tPrecipitation    float32                            `protobuf:\"fixed32,2,opt,name=precipitation,proto3\" json:\"precipitation,omitempty\"`\n}\n\nfunc (x *ForecastResponse_CurrentCondition_NextHour) Reset() {\n\t*x = ForecastResponse_CurrentCondition_NextHour{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[9]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_CurrentCondition_NextHour) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_CurrentCondition_NextHour) ProtoMessage() {}\n\nfunc (x *ForecastResponse_CurrentCondition_NextHour) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[9]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_CurrentCondition_NextHour.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_CurrentCondition_NextHour) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 4, 0}\n}\n\nfunc (x *ForecastResponse_CurrentCondition_NextHour) GetWeatherCondition() *ForecastResponse_WeatherCondition {\n\tif x != nil {\n\t\treturn x.WeatherCondition\n\t}\n\treturn nil\n}\n\nfunc (x *ForecastResponse_CurrentCondition_NextHour) GetPrecipitation() float32 {\n\tif x != nil {\n\t\treturn x.Precipitation\n\t}\n\treturn 0\n}\n\ntype ForecastResponse_CurrentCondition_WindGust struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tWind *ForecastResponse_Wind `protobuf:\"bytes,1,opt,name=wind,proto3\" json:\"wind,omitempty\"`\n\tGust float32                `protobuf:\"fixed32,2,opt,name=gust,proto3\" json:\"gust,omitempty\"`\n}\n\nfunc (x *ForecastResponse_CurrentCondition_WindGust) Reset() {\n\t*x = ForecastResponse_CurrentCondition_WindGust{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[10]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *ForecastResponse_CurrentCondition_WindGust) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*ForecastResponse_CurrentCondition_WindGust) ProtoMessage() {}\n\nfunc (x *ForecastResponse_CurrentCondition_WindGust) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[10]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use ForecastResponse_CurrentCondition_WindGust.ProtoReflect.Descriptor instead.\nfunc (*ForecastResponse_CurrentCondition_WindGust) Descriptor() ([]byte, []int) {\n\treturn file_service_v0_proto_rawDescGZIP(), []int{1, 4, 1}\n}\n\nfunc (x *ForecastResponse_CurrentCondition_WindGust) GetWind() *ForecastResponse_Wind {\n\tif x != nil {\n\t\treturn x.Wind\n\t}\n\treturn nil\n}\n", "n_tokens": 872, "primary_symbol": "GetUvIndex", "primary_kind": "function", "primary_span": [791, 900], "def_symbols": ["GetUvIndex", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetWeatherCondition", "GetPrecipitation", "GetWind"], "symbols": ["GetUvIndex", "Reset", "String", "ProtoMessage", "ProtoReflect", "Descriptor", "GetWeatherCondition", "GetPrecipitation", "GetWind", "func", "ForecastResponse_HourlyForecast", "float32", "nil", "return", "UvIndex", "type", "ForecastResponse_CurrentCondition_NextHour", "struct", "state", "protoimpl", "MessageState", "sizeCache", "SizeCache", "unknownFields", "UnknownFields", "WeatherCondition", "ForecastResponse_WeatherCondition", "protobuf", "bytes", "opt", "name", "weatherCondition", "proto3", "json", "omitempty", "Precipitation", "fixed32", "precipitation", "UnsafeEnabled", "file_service_v0_proto_msgTypes", "MessageStateOf", "Pointer", "StoreMessageInfo", "string", "MessageStringOf", "protoreflect", "Message", "LoadMessageInfo", "MessageOf", "Deprecated", "Use", "instead", "byte", "int", "file_service_v0_proto_rawDescGZIP", "ForecastResponse_CurrentCondition_WindGust", "Wind", "ForecastResponse_Wind", "wind", "Gust", "gust"], "doc_head": "func (x *ForecastResponse_HourlyForecast) GetUvIndex() float32 {\n\tif x != nil {\n\t\treturn x.UvIndex\n\t}\n\treturn 0\n}\ntype ForecastResponse_CurrentCondition_NextHour struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\tWeatherCondition *ForecastResponse_WeatherCondition `protobuf:\"bytes,1,opt,name=weatherCondition,proto3\" json:\"weatherCondition,omitempty\"`\n\tPrecipitation    float32                            `protobuf:\"fixed32,2,opt,name=precipitation,proto3\" json:\"precipitation,omitempty\"`\n}\nfunc (x *ForecastResponse_CurrentCondition_NextHour) Reset() {\n\t*x = ForecastResponse_CurrentCondition_NextHour{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_service_v0_proto_msgTypes[9]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\nfunc (x *ForecastResponse_CurrentCondition_NextHour) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\nfunc (*ForecastResponse_CurrentCondition_NextHour) ProtoMessage() {}\nfunc (x *ForecastResponse_CurrentCondition_NextHour) ProtoReflect() protoreflect.Message {\n\tmi := &file_service_v0_proto_msgTypes[9]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms :", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(x *ForecastResponse_HourlyForecast).GetUvIndex", "package": "", "node_kind": "method", "receiver": "x *ForecastResponse_HourlyForecast", "function_name": "", "method_name": "GetUvIndex", "type_name": "ForecastResponse_CurrentCondition_NextHour", "type_kind": "struct", "imports_used_minimal": ["google.golang.org/protobuf/reflect/protoreflect", "google.golang.org/protobuf/runtime/protoimpl"], "symbols_referenced_strict": ["Deprecated", "Descriptor", "ForecastResponse_CurrentCondition_NextHour", "ForecastResponse_CurrentCondition_NextHour.ProtoReflect", "ForecastResponse_CurrentCondition_WindGust", "ForecastResponse_CurrentCondition_WindGust.ProtoReflect", "ForecastResponse_HourlyForecast", "ForecastResponse_WeatherCondition", "ForecastResponse_Wind", "GetPrecipitation", "GetUvIndex", "GetWeatherCondition", "GetWind", "Gust", "LoadMessageInfo", "Message", "MessageOf", "MessageState", "MessageStateOf", "MessageStringOf", "Pointer", "Precipitation", "ProtoMessage", "ProtoReflect", "Reset", "SizeCache", "StoreMessageInfo", "String", "UnknownFields", "UnsafeEnabled", "Use", "UvIndex", "WeatherCondition", "Wind", "X", "mi.MessageOf", "ms.LoadMessageInfo", "ms.StoreMessageInfo", "protoimpl.MessageState", "protoimpl.Pointer", "protoimpl.SizeCache", "protoimpl.UnknownFields", "protoimpl.UnsafeEnabled", "protoimpl.X", "protoreflect.Message", "x.Precipitation", "x.UvIndex", "x.WeatherCondition", "x.Wind"], "header_context_minimal": "package \nimport (\n    \"google.golang.org/protobuf/reflect/protoreflect\"\n    \"google.golang.org/protobuf/runtime/protoimpl\"\n)\n// receiver: x *ForecastResponse_HourlyForecast", "summary_llm": "The Go code defines methods and types for handling forecast data, including UV index, weather conditions, precipitation, and wind gusts. The `GetUvIndex` method retrieves the UV index value from a `ForecastResponse_HourlyForecast` object.", "keywords_llm": ["forecast", "uv index", "weather condition", "precipitation", "wind gust", "reset", "string", "protomessage", "protoreflect", "descriptor"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go#7", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go", "rel_path": "pkg/pb/v0/service.v0.pb.go", "ext": "go", "language": "go", "chunk_number": 7, "start_line": 901, "end_line": 1128, "text": "func (x *ForecastResponse_CurrentCondition_WindGust) GetGust() float32 {\n\tif x != nil {\n\t\treturn x.Gust\n\t}\n\treturn 0\n}\n\nvar File_service_v0_proto protoreflect.FileDescriptor\n\nvar file_service_v0_proto_rawDesc = []byte{\n\t0x0a, 0x10, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x30, 0x2e, 0x70, 0x72, 0x6f,\n\t0x74, 0x6f, 0x12, 0x1a, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65,\n\t0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x22, 0x31,\n\t0x0a, 0x0f, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,\n\t0x74, 0x12, 0x1e, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x18,\n\t0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49,\n\t0x64, 0x22, 0x92, 0x18, 0x0a, 0x10, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65,\n\t0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x6e, 0x0a, 0x10, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,\n\t0x74, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,\n\t0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63,\n\t0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f,\n\t0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x43,\n\t0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x48,\n\t0x00, 0x52, 0x10, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74,\n\t0x69, 0x6f, 0x6e, 0x88, 0x01, 0x01, 0x12, 0x62, 0x0a, 0x0e, 0x64, 0x61, 0x69, 0x6c, 0x79, 0x46,\n\t0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3a,\n\t0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73,\n\t0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65,\n\t0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x44, 0x61, 0x69,\n\t0x6c, 0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x0e, 0x64, 0x61, 0x69, 0x6c,\n\t0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x12, 0x65, 0x0a, 0x0f, 0x68, 0x6f,\n\t0x75, 0x72, 0x6c, 0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x18, 0x03, 0x20,\n\t0x03, 0x28, 0x0b, 0x32, 0x3b, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f,\n\t0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30,\n\t0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,\n\t0x65, 0x2e, 0x48, 0x6f, 0x75, 0x72, 0x6c, 0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74,\n\t0x52, 0x0f, 0x68, 0x6f, 0x75, 0x72, 0x6c, 0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74,\n\t0x73, 0x1a, 0x48, 0x0a, 0x10, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64,\n\t0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20,\n\t0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73,\n\t0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,\n\t0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x4d, 0x0a, 0x0d, 0x57,\n\t0x69, 0x6e, 0x64, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x22, 0x0a, 0x0c,\n\t0x61, 0x62, 0x62, 0x72, 0x65, 0x76, 0x69, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01,\n\t0x28, 0x09, 0x52, 0x0c, 0x61, 0x62, 0x62, 0x72, 0x65, 0x76, 0x69, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n\t0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x67, 0x72, 0x65, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,\n\t0x02, 0x52, 0x07, 0x64, 0x65, 0x67, 0x72, 0x65, 0x65, 0x73, 0x1a, 0x76, 0x0a, 0x04, 0x57, 0x69,\n\t0x6e, 0x64, 0x12, 0x58, 0x0a, 0x09, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18,\n\t0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e,\n\t0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e,\n\t0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,\n\t0x6e, 0x73, 0x65, 0x2e, 0x57, 0x69, 0x6e, 0x64, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f,\n\t0x6e, 0x52, 0x09, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05,\n\t0x73, 0x70, 0x65, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x05, 0x73, 0x70, 0x65,\n\t0x65, 0x64, 0x1a, 0x3c, 0x0a, 0x08, 0x50, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x12, 0x1a,\n\t0x0a, 0x08, 0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x62, 0x61, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02,\n\t0x52, 0x08, 0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x62, 0x61, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x72,\n\t0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x74, 0x72, 0x65, 0x6e, 0x64,\n\t0x1a, 0xd3, 0x07, 0x0a, 0x10, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x64,\n\t0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x01,\n\t0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x1e, 0x0a, 0x0a, 0x76,\n\t0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52,\n\t0x0a, 0x76, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x69, 0x0a, 0x10, 0x77,\n\t0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18,\n\t0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e,\n\t0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e,\n\t0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,\n\t0x6e, 0x73, 0x65, 0x2e, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69,\n\t0x74, 0x69, 0x6f, 0x6e, 0x52, 0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n\t0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70,\n\t0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0d, 0x70,\n\t0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x62, 0x0a, 0x08,\n\t0x6e, 0x65, 0x78, 0x74, 0x48, 0x6f, 0x75, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x46,\n\t0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73,\n\t0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65,\n\t0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x43, 0x75, 0x72,\n\t0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4e, 0x65,\n\t0x78, 0x74, 0x48, 0x6f, 0x75, 0x72, 0x52, 0x08, 0x6e, 0x65, 0x78, 0x74, 0x48, 0x6f, 0x75, 0x72,\n\t0x12, 0x20, 0x0a, 0x0b, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18,\n\t0x06, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0b, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75,\n\t0x72, 0x65, 0x12, 0x32, 0x0a, 0x14, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72,\n\t0x65, 0x46, 0x65, 0x65, 0x6c, 0x73, 0x4c, 0x69, 0x6b, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x02,\n\t0x52, 0x14, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x46, 0x65, 0x65,\n\t0x6c, 0x73, 0x4c, 0x69, 0x6b, 0x65, 0x12, 0x62, 0x0a, 0x08, 0x77, 0x69, 0x6e, 0x64, 0x47, 0x75,\n\t0x73, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x46, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68,\n\t0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f,\n\t0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65,\n\t0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f,\n\t0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x57, 0x69, 0x6e, 0x64, 0x47, 0x75, 0x73, 0x74,\n\t0x52, 0x08, 0x77, 0x69, 0x6e, 0x64, 0x47, 0x75, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x65,\n\t0x77, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x02, 0x52, 0x08, 0x64, 0x65,\n\t0x77, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x68, 0x65, 0x61, 0x74, 0x49, 0x6e,\n\t0x64, 0x65, 0x78, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x02, 0x52, 0x09, 0x68, 0x65, 0x61, 0x74, 0x49,\n\t0x6e, 0x64, 0x65, 0x78, 0x12, 0x51, 0x0a, 0x08, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65,\n\t0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72,\n\t0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79,\n\t0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70,\n\t0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x50, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x52, 0x08, 0x70,\n\t0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x75, 0x76, 0x49, 0x6e, 0x64,\n\t0x65, 0x78, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x02, 0x52, 0x07, 0x75, 0x76, 0x49, 0x6e, 0x64, 0x65,\n\t0x78, 0x12, 0x2e, 0x0a, 0x12, 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x50, 0x65, 0x72,\n\t0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x05, 0x52, 0x12, 0x68,\n\t0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67,\n\t0x65, 0x1a, 0x9b, 0x01, 0x0a, 0x08, 0x4e, 0x65, 0x78, 0x74, 0x48, 0x6f, 0x75, 0x72, 0x12, 0x69,\n\t0x0a, 0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69,\n\t0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68,\n\t0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f,\n\t0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65,\n\t0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f,\n\t0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72,\n\t0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x70, 0x72, 0x65,\n\t0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02,\n\t0x52, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a,\n\t0x65, 0x0a, 0x08, 0x57, 0x69, 0x6e, 0x64, 0x47, 0x75, 0x73, 0x74, 0x12, 0x45, 0x0a, 0x04, 0x77,\n\t0x69, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x77, 0x65, 0x61, 0x74,\n\t0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72,\n\t0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52,\n\t0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x69, 0x6e, 0x64, 0x52, 0x04, 0x77, 0x69,\n\t0x6e, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x67, 0x75, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02,\n\t0x52, 0x04, 0x67, 0x75, 0x73, 0x74, 0x1a, 0xc4, 0x06, 0x0a, 0x0d, 0x44, 0x61, 0x69, 0x6c, 0x79,\n\t0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x70, 0x6f, 0x63,\n\t0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x26,\n\t0x0a, 0x0e, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4d, 0x69, 0x6e,\n\t0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0e, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74,\n\t0x75, 0x72, 0x65, 0x4d, 0x69, 0x6e, 0x12, 0x26, 0x0a, 0x0e, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72,\n\t0x61, 0x74, 0x75, 0x72, 0x65, 0x4d, 0x61, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0e,\n\t0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4d, 0x61, 0x78, 0x12, 0x24,\n\t0x0a, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18,\n\t0x04, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61,\n\t0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2a, 0x0a, 0x10, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74,\n\t0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x02, 0x52, 0x10,\n\t0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61, 0x79,\n\t0x12, 0x2e, 0x0a, 0x12, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f,\n\t0x6e, 0x4e, 0x69, 0x67, 0x68, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x02, 0x52, 0x12, 0x70, 0x72,\n\t0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x69, 0x67, 0x68, 0x74,\n\t0x12, 0x12, 0x0a, 0x04, 0x73, 0x6e, 0x6f, 0x77, 0x18, 0x07, 0x20, 0x01, 0x28, 0x02, 0x52, 0x04,\n\t0x73, 0x6e, 0x6f, 0x77, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x6e, 0x6f, 0x77, 0x44, 0x61, 0x79, 0x18,\n\t0x08, 0x20, 0x01, 0x28, 0x02, 0x52, 0x07, 0x73, 0x6e, 0x6f, 0x77, 0x44, 0x61, 0x79, 0x12, 0x1c,\n\t0x0a, 0x09, 0x73, 0x6e, 0x6f, 0x77, 0x4e, 0x69, 0x67, 0x68, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28,\n\t0x02, 0x52, 0x09, 0x73, 0x6e, 0x6f, 0x77, 0x4e, 0x69, 0x67, 0x68, 0x74, 0x12, 0x3a, 0x0a, 0x18,\n\t0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f,\n\t0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x52, 0x18,\n\t0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f,\n\t0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x45, 0x0a, 0x04, 0x77, 0x69, 0x6e, 0x64,\n\t0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72,\n\t0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79,\n\t0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70,\n\t0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x69, 0x6e, 0x64, 0x52, 0x04, 0x77, 0x69, 0x6e, 0x64, 0x12,\n\t0x3c, 0x0a, 0x19, 0x61, 0x76, 0x65, 0x72, 0x61, 0x67, 0x65, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69,\n\t0x74, 0x79, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x0c, 0x20, 0x01,\n\t0x28, 0x05, 0x52, 0x19, 0x61, 0x76, 0x65, 0x72, 0x61, 0x67, 0x65, 0x48, 0x75, 0x6d, 0x69, 0x64,\n\t0x69, 0x74, 0x79, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x12, 0x69, 0x0a,\n\t0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f,\n\t0x6e, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65,\n\t0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78,\n\t0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73,\n\t0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n\t0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43,\n\t0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x73, 0x0a, 0x15, 0x77, 0x65, 0x61, 0x74,\n\t0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x69, 0x67, 0x68,\n\t0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65,\n\t0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78,\n\t0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73,\n\t0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n\t0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x15, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43,\n\t0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x69, 0x67, 0x68, 0x74, 0x12, 0x18, 0x0a,\n\t0x07, 0x75, 0x76, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x02, 0x52, 0x07,\n\t0x75, 0x76, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x22, 0x0a, 0x0c, 0x73, 0x75, 0x6e, 0x72, 0x69,\n\t0x73, 0x65, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x10, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0c, 0x73,\n\t0x75, 0x6e, 0x72, 0x69, 0x73, 0x65, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x20, 0x0a, 0x0b, 0x73,\n\t0x75, 0x6e, 0x73, 0x65, 0x74, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x11, 0x20, 0x01, 0x28, 0x03,\n\t0x52, 0x0b, 0x73, 0x75, 0x6e, 0x73, 0x65, 0x74, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x1a, 0xc1, 0x04,\n\t0x0a, 0x0e, 0x48, 0x6f, 0x75, 0x72, 0x6c, 0x79, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74,\n\t0x12, 0x14, 0x0a, 0x05, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52,\n\t0x05, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x20, 0x0a, 0x0b, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72,\n\t0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0b, 0x74, 0x65, 0x6d,\n\t0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x32, 0x0a, 0x14, 0x74, 0x65, 0x6d, 0x70,\n\t0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x46, 0x65, 0x65, 0x6c, 0x73, 0x4c, 0x69, 0x6b, 0x65,\n\t0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x52, 0x14, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74,\n\t0x75, 0x72, 0x65, 0x46, 0x65, 0x65, 0x6c, 0x73, 0x4c, 0x69, 0x6b, 0x65, 0x12, 0x69, 0x0a, 0x10,\n\t0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e,\n\t0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72,\n\t0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79,\n\t0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70,\n\t0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64,\n\t0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x10, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6f,\n\t0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69,\n\t0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0d,\n\t0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a,\n\t0x04, 0x73, 0x6e, 0x6f, 0x77, 0x18, 0x06, 0x20, 0x01, 0x28, 0x02, 0x52, 0x04, 0x73, 0x6e, 0x6f,\n\t0x77, 0x12, 0x3a, 0x0a, 0x18, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69,\n\t0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x07, 0x20,\n\t0x01, 0x28, 0x05, 0x52, 0x18, 0x70, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x74, 0x61, 0x74, 0x69,\n\t0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x45, 0x0a,\n\t0x04, 0x77, 0x69, 0x6e, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x77, 0x65,\n\t0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e,\n\t0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73,\n\t0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x57, 0x69, 0x6e, 0x64, 0x52, 0x04,\n\t0x77, 0x69, 0x6e, 0x64, 0x12, 0x51, 0x0a, 0x08, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65,\n\t0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72,\n\t0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79,\n\t0x2e, 0x76, 0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70,\n\t0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x50, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x52, 0x08, 0x70,\n\t0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x12, 0x2e, 0x0a, 0x12, 0x68, 0x75, 0x6d, 0x69, 0x64,\n\t0x69, 0x74, 0x79, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x0a, 0x20,\n\t0x01, 0x28, 0x05, 0x52, 0x12, 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x50, 0x65, 0x72,\n\t0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x75, 0x76, 0x49, 0x6e, 0x64,\n\t0x65, 0x78, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x02, 0x52, 0x07, 0x75, 0x76, 0x49, 0x6e, 0x64, 0x65,\n\t0x78, 0x42, 0x13, 0x0a, 0x11, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e,\n\t0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x32, 0x77, 0x0a, 0x0b, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61,\n\t0x50, 0x72, 0x6f, 0x78, 0x79, 0x12, 0x68, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x46, 0x6f, 0x72, 0x65,\n\t0x63, 0x61, 0x73, 0x74, 0x12, 0x2b, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66,\n\t0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76,\n\t0x30, 0x2e, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,\n\t0x74, 0x1a, 0x2c, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65,\n\t0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x2e, 0x46,\n\t0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42,\n\t0x35, 0x5a, 0x33, 0x67, 0x6f, 0x2e, 0x69, 0x6d, 0x70, 0x61, 0x6c, 0x61, 0x73, 0x74, 0x75, 0x64,\n\t0x69, 0x6f, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2f,\n\t0x66, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x5f, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2f, 0x70, 0x6b, 0x67,\n\t0x2f, 0x70, 0x62, 0x2f, 0x76, 0x30, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,\n}\n\nvar (\n\tfile_service_v0_proto_rawDescOnce sync.Once\n\tfile_service_v0_proto_rawDescData = file_service_v0_proto_rawDesc\n)\n", "n_tokens": 17683, "primary_symbol": "GetGust", "primary_kind": "function", "primary_span": [901, 1128], "def_symbols": ["GetGust"], "symbols": ["GetGust", "func", "ForecastResponse_CurrentCondition_WindGust", "float32", "nil", "return", "Gust", "var", "File_service_v0_proto", "protoreflect", "FileDescriptor", "file_service_v0_proto_rawDesc", "byte", "file_service_v0_proto_rawDescOnce", "sync", "Once", "file_service_v0_proto_rawDescData"], "doc_head": "func (x *ForecastResponse_CurrentCondition_WindGust) GetGust() float32 {\n\tif x != nil {\n\t\treturn x.Gust\n\t}\n\treturn 0\n}\nvar File_service_v0_proto protoreflect.FileDescriptor\nvar file_service_v0_proto_rawDesc = []byte{\n\t0x0a, 0x10, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x30, 0x2e, 0x70, 0x72, 0x6f,\n\t0x74, 0x6f, 0x12, 0x1a, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65,\n\t0x63, 0x61, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x30, 0x22, 0x31,\n\t0x0a, 0x0f, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,\n\t0x74, 0x12, 0x1e, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x18,\n\t0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49,\n\t0x64, 0x22, 0x92, 0x18, 0x0a, 0x10, 0x46, 0x6f, 0x72, 0x65, 0x63, 0x61, 0x73, 0x74, 0x52, 0x65,\n\t0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x6e, 0x0a, 0x10, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,\n\t0x74, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,\n\t0x32, 0x3d, 0x2e, 0x77, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x2e, 0x66, 0x6f, 0x72, 0x65, 0x63,\n\t0x61, 0x73, ", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(x *ForecastResponse_CurrentCondition_WindGust).GetGust", "package": "", "node_kind": "method", "receiver": "x *ForecastResponse_CurrentCondition_WindGust", "function_name": "", "method_name": "GetGust", "type_name": "", "type_kind": "", "imports_used_minimal": ["google.golang.org/protobuf/reflect/protoreflect"], "symbols_referenced_strict": ["FileDescriptor", "File_service_v0_proto", "ForecastResponse_CurrentCondition_WindGust", "GetGust", "Gust", "Once", "protoreflect.FileDescriptor", "sync.Once", "x.Gust"], "header_context_minimal": "package \nimport \"google.golang.org/protobuf/reflect/protoreflect\"\n// receiver: x *ForecastResponse_CurrentCondition_WindGust", "summary_llm": "LLM enrichment unavailable", "keywords_llm": ["error", "unavailable", "llm", "failed", "enrichment", "chunk", "code", "analysis"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go#8", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go", "rel_path": "pkg/pb/v0/service.v0.pb.go", "ext": "go", "language": "go", "chunk_number": 8, "start_line": 1129, "end_line": 1181, "text": "func file_service_v0_proto_rawDescGZIP() []byte {\n\tfile_service_v0_proto_rawDescOnce.Do(func() {\n\t\tfile_service_v0_proto_rawDescData = protoimpl.X.CompressGZIP(file_service_v0_proto_rawDescData)\n\t})\n\treturn file_service_v0_proto_rawDescData\n}\n\nvar file_service_v0_proto_msgTypes = make([]protoimpl.MessageInfo, 11)\nvar file_service_v0_proto_goTypes = []interface{}{\n\t(*ForecastRequest)(nil),                            // 0: weather.forecasts.proxy.v0.ForecastRequest\n\t(*ForecastResponse)(nil),                           // 1: weather.forecasts.proxy.v0.ForecastResponse\n\t(*ForecastResponse_WeatherCondition)(nil),          // 2: weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t(*ForecastResponse_WindDirection)(nil),             // 3: weather.forecasts.proxy.v0.ForecastResponse.WindDirection\n\t(*ForecastResponse_Wind)(nil),                      // 4: weather.forecasts.proxy.v0.ForecastResponse.Wind\n\t(*ForecastResponse_Pressure)(nil),                  // 5: weather.forecasts.proxy.v0.ForecastResponse.Pressure\n\t(*ForecastResponse_CurrentCondition)(nil),          // 6: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition\n\t(*ForecastResponse_DailyForecast)(nil),             // 7: weather.forecasts.proxy.v0.ForecastResponse.DailyForecast\n\t(*ForecastResponse_HourlyForecast)(nil),            // 8: weather.forecasts.proxy.v0.ForecastResponse.HourlyForecast\n\t(*ForecastResponse_CurrentCondition_NextHour)(nil), // 9: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.NextHour\n\t(*ForecastResponse_CurrentCondition_WindGust)(nil), // 10: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.WindGust\n}\nvar file_service_v0_proto_depIdxs = []int32{\n\t6,  // 0: weather.forecasts.proxy.v0.ForecastResponse.currentCondition:type_name -> weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition\n\t7,  // 1: weather.forecasts.proxy.v0.ForecastResponse.dailyForecasts:type_name -> weather.forecasts.proxy.v0.ForecastResponse.DailyForecast\n\t8,  // 2: weather.forecasts.proxy.v0.ForecastResponse.hourlyForecasts:type_name -> weather.forecasts.proxy.v0.ForecastResponse.HourlyForecast\n\t3,  // 3: weather.forecasts.proxy.v0.ForecastResponse.Wind.direction:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WindDirection\n\t2,  // 4: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.weatherCondition:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t9,  // 5: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.nextHour:type_name -> weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.NextHour\n\t10, // 6: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.windGust:type_name -> weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.WindGust\n\t5,  // 7: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.pressure:type_name -> weather.forecasts.proxy.v0.ForecastResponse.Pressure\n\t4,  // 8: weather.forecasts.proxy.v0.ForecastResponse.DailyForecast.wind:type_name -> weather.forecasts.proxy.v0.ForecastResponse.Wind\n\t2,  // 9: weather.forecasts.proxy.v0.ForecastResponse.DailyForecast.weatherCondition:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t2,  // 10: weather.forecasts.proxy.v0.ForecastResponse.DailyForecast.weatherConditionNight:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t2,  // 11: weather.forecasts.proxy.v0.ForecastResponse.HourlyForecast.weatherCondition:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t4,  // 12: weather.forecasts.proxy.v0.ForecastResponse.HourlyForecast.wind:type_name -> weather.forecasts.proxy.v0.ForecastResponse.Wind\n\t5,  // 13: weather.forecasts.proxy.v0.ForecastResponse.HourlyForecast.pressure:type_name -> weather.forecasts.proxy.v0.ForecastResponse.Pressure\n\t2,  // 14: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.NextHour.weatherCondition:type_name -> weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t4,  // 15: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition.WindGust.wind:type_name -> weather.forecasts.proxy.v0.ForecastResponse.Wind\n\t0,  // 16: weather.forecasts.proxy.v0.ForecaProxy.GetForecast:input_type -> weather.forecasts.proxy.v0.ForecastRequest\n\t1,  // 17: weather.forecasts.proxy.v0.ForecaProxy.GetForecast:output_type -> weather.forecasts.proxy.v0.ForecastResponse\n\t17, // [17:18] is the sub-list for method output_type\n\t16, // [16:17] is the sub-list for method input_type\n\t16, // [16:16] is the sub-list for extension type_name\n\t16, // [16:16] is the sub-list for extension extendee\n\t0,  // [0:16] is the sub-list for field type_name\n}\n\nfunc init() { file_service_v0_proto_init() }\nfunc file_service_v0_proto_init() {\n\tif File_service_v0_proto != nil {\n\t\treturn\n\t}\n\tif !protoimpl.UnsafeEnabled {", "n_tokens": 1210, "primary_symbol": "file_service_v0_proto_rawDescGZIP", "primary_kind": "function", "primary_span": [1129, 1181], "def_symbols": ["file_service_v0_proto_rawDescGZIP", "init", "file_service_v0_proto_init"], "symbols": ["file_service_v0_proto_rawDescGZIP", "init", "file_service_v0_proto_init", "func", "byte", "file_service_v0_proto_rawDescOnce", "file_service_v0_proto_rawDescData", "protoimpl", "CompressGZIP", "return", "var", "file_service_v0_proto_msgTypes", "make", "MessageInfo", "file_service_v0_proto_goTypes", "interface", "ForecastRequest", "nil", "weather", "forecasts", "proxy", "ForecastResponse", "ForecastResponse_WeatherCondition", "WeatherCondition", "ForecastResponse_WindDirection", "WindDirection", "ForecastResponse_Wind", "Wind", "ForecastResponse_Pressure", "Pressure", "ForecastResponse_CurrentCondition", "CurrentCondition", "ForecastResponse_DailyForecast", "DailyForecast", "ForecastResponse_HourlyForecast", "HourlyForecast", "ForecastResponse_CurrentCondition_NextHour", "NextHour", "ForecastResponse_CurrentCondition_WindGust", "WindGust", "file_service_v0_proto_depIdxs", "int32", "currentCondition", "type_name", "dailyForecasts", "hourlyForecasts", "direction", "weatherCondition", "nextHour", "windGust", "pressure", "wind", "weatherConditionNight", "ForecaProxy", "GetForecast", "input_type", "output_type", "the", "sub", "list", "for", "method", "extension", "extendee", "field", "File_service_v0_proto", "UnsafeEnabled"], "doc_head": "func file_service_v0_proto_rawDescGZIP() []byte {\n\tfile_service_v0_proto_rawDescOnce.Do(func() {\n\t\tfile_service_v0_proto_rawDescData = protoimpl.X.CompressGZIP(file_service_v0_proto_rawDescData)\n\t})\n\treturn file_service_v0_proto_rawDescData\n}\nvar file_service_v0_proto_msgTypes = make([]protoimpl.MessageInfo, 11)\nvar file_service_v0_proto_goTypes = []interface{}{\n\t(*ForecastRequest)(nil),                            // 0: weather.forecasts.proxy.v0.ForecastRequest\n\t(*ForecastResponse)(nil),                           // 1: weather.forecasts.proxy.v0.ForecastResponse\n\t(*ForecastResponse_WeatherCondition)(nil),          // 2: weather.forecasts.proxy.v0.ForecastResponse.WeatherCondition\n\t(*ForecastResponse_WindDirection)(nil),             // 3: weather.forecasts.proxy.v0.ForecastResponse.WindDirection\n\t(*ForecastResponse_Wind)(nil),                      // 4: weather.forecasts.proxy.v0.ForecastResponse.Wind\n\t(*ForecastResponse_Pressure)(nil),                  // 5: weather.forecasts.proxy.v0.ForecastResponse.Pressure\n\t(*ForecastResponse_CurrentCondition)(nil),          // 6: weather.forecasts.proxy.v0.ForecastResponse.CurrentCondition\n\t(*ForecastResponse_DailyForecast)(nil),             ", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:function:file_service_v0_proto_rawDescGZIP", "package": "", "node_kind": "function", "receiver": "", "function_name": "file_service_v0_proto_rawDescGZIP", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": ["google.golang.org/protobuf/runtime/protoimpl"], "symbols_referenced_strict": ["CompressGZIP", "CurrentCondition", "DailyForecast", "Do", "File_service_v0_proto", "ForecaProxy", "ForecaProxy.GetForecast", "ForecastRequest", "ForecastResponse", "ForecastResponse.CurrentCondition", "ForecastResponse.DailyForecast", "ForecastResponse.HourlyForecast", "ForecastResponse.Pressure", "ForecastResponse.WeatherCondition", "ForecastResponse.Wind", "ForecastResponse.WindDirection", "ForecastResponse.currentCondition", "ForecastResponse.dailyForecasts", "ForecastResponse.hourlyForecasts", "ForecastResponse_CurrentCondition", "ForecastResponse_CurrentCondition_NextHour", "ForecastResponse_CurrentCondition_WindGust", "ForecastResponse_DailyForecast", "ForecastResponse_HourlyForecast", "ForecastResponse_Pressure", "ForecastResponse_WeatherCondition", "ForecastResponse_Wind", "ForecastResponse_WindDirection", "GetForecast", "HourlyForecast", "MessageInfo", "NextHour", "NextHour.weatherCondition", "Pressure", "UnsafeEnabled", "WeatherCondition", "Wind", "WindDirection", "WindGust", "WindGust.wind", "X", "file_service_v0_proto_rawDescOnce.Do", "protoimpl.MessageInfo", "protoimpl.UnsafeEnabled", "protoimpl.X", "proxy.v0", "weather.forecasts"], "header_context_minimal": "package \nimport \"google.golang.org/protobuf/runtime/protoimpl\"", "summary_llm": "This Go code defines a simple HTTP server that responds to GET requests with a predefined message.", "keywords_llm": ["go", "http", "server", "get request", "response", "listenandserve", "net/http"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go#9", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0.pb.go", "rel_path": "pkg/pb/v0/service.v0.pb.go", "ext": "go", "language": "go", "chunk_number": 9, "start_line": 1182, "end_line": 1335, "text": "\t\tfile_service_v0_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastRequest); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_WeatherCondition); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_WindDirection); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_Wind); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_Pressure); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_CurrentCondition); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_DailyForecast); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_HourlyForecast); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_CurrentCondition_NextHour); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_CurrentCondition_WindGust); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\tfile_service_v0_proto_msgTypes[1].OneofWrappers = []interface{}{}\n\ttype x struct{}\n\tout := protoimpl.TypeBuilder{\n\t\tFile: protoimpl.DescBuilder{\n\t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n\t\t\tRawDescriptor: file_service_v0_proto_rawDesc,\n\t\t\tNumEnums:      0,\n\t\t\tNumMessages:   11,\n\t\t\tNumExtensions: 0,\n\t\t\tNumServices:   1,\n\t\t},\n\t\tGoTypes:           file_service_v0_proto_goTypes,\n\t\tDependencyIndexes: file_service_v0_proto_depIdxs,\n\t\tMessageInfos:      file_service_v0_proto_msgTypes,\n\t}.Build()\n\tFile_service_v0_proto = out.File\n\tfile_service_v0_proto_rawDesc = nil\n\tfile_service_v0_proto_goTypes = nil\n\tfile_service_v0_proto_depIdxs = nil\n}\n", "n_tokens": 1125, "primary_symbol": "", "primary_kind": "", "primary_span": [1182, 1335], "def_symbols": [], "symbols": ["file_service_v0_proto_msgTypes", "Exporter", "func", "interface", "int", "switch", "ForecastRequest", "case", "return", "state", "sizeCache", "unknownFields", "default", "nil", "ForecastResponse", "ForecastResponse_WeatherCondition", "ForecastResponse_WindDirection", "ForecastResponse_Wind", "ForecastResponse_Pressure", "ForecastResponse_CurrentCondition", "ForecastResponse_DailyForecast", "ForecastResponse_HourlyForecast", "ForecastResponse_CurrentCondition_NextHour", "ForecastResponse_CurrentCondition_WindGust", "OneofWrappers", "type", "struct", "out", "protoimpl", "TypeBuilder", "File", "DescBuilder", "GoPackagePath", "reflect", "TypeOf", "PkgPath", "RawDescriptor", "file_service_v0_proto_rawDesc", "NumEnums", "NumMessages", "NumExtensions", "NumServices", "GoTypes", "file_service_v0_proto_goTypes", "DependencyIndexes", "file_service_v0_proto_depIdxs", "MessageInfos", "Build", "File_service_v0_proto"], "doc_head": "\t\tfile_service_v0_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastRequest); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_WeatherCondition); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*ForecastResponse_WindDirection); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_service_v0_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} ", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:block", "package": "", "node_kind": "block", "receiver": "", "function_name": "", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": ["google.golang.org/protobuf/runtime/protoimpl"], "symbols_referenced_strict": ["Build", "DependencyIndexes", "DescBuilder", "Exporter", "File", "File_service_v0_proto", "ForecastRequest", "ForecastResponse", "ForecastResponse_CurrentCondition", "ForecastResponse_CurrentCondition_NextHour", "ForecastResponse_CurrentCondition_WindGust", "ForecastResponse_DailyForecast", "ForecastResponse_HourlyForecast", "ForecastResponse_Pressure", "ForecastResponse_WeatherCondition", "ForecastResponse_Wind", "ForecastResponse_WindDirection", "GoPackagePath", "GoTypes", "MessageInfos", "NumEnums", "NumExtensions", "NumMessages", "NumServices", "OneofWrappers", "PkgPath", "RawDescriptor", "TypeBuilder", "TypeOf", "out.File", "protoimpl.DescBuilder", "protoimpl.TypeBuilder", "reflect.TypeOf", "v.sizeCache", "v.state", "v.unknownFields"], "header_context_minimal": "package \nimport \"google.golang.org/protobuf/runtime/protoimpl\"", "summary_llm": "This Go code defines and exports state, size cache, and unknown fields for various message types related to weather forecasts. It also builds a type descriptor for the service proto file.", "keywords_llm": ["protoimpl", "exporter", "forecastrequest", "forecastresponse", "state", "sizecache", "unknownfields", "descbuilder", "typebuilder"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0_grpc.pb.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/pb/v0/service.v0_grpc.pb.go", "rel_path": "pkg/pb/v0/service.v0_grpc.pb.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 106, "text": "// Code generated by protoc-gen-go-grpc. DO NOT EDIT.\n// versions:\n// - protoc-gen-go-grpc v1.2.0\n// - protoc             v3.21.12\n// source: service.v0.proto\n\npackage v0\n\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the grpc package it is being compiled against.\n// Requires gRPC-Go v1.32.0 or later.\nconst _ = grpc.SupportPackageIsVersion7\n\n// ForecaProxyClient is the client API for ForecaProxy service.\n//\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.\ntype ForecaProxyClient interface {\n\tGetForecast(ctx context.Context, in *ForecastRequest, opts ...grpc.CallOption) (*ForecastResponse, error)\n}\n\ntype forecaProxyClient struct {\n\tcc grpc.ClientConnInterface\n}\n\nfunc NewForecaProxyClient(cc grpc.ClientConnInterface) ForecaProxyClient {\n\treturn &forecaProxyClient{cc}\n}\n\nfunc (c *forecaProxyClient) GetForecast(ctx context.Context, in *ForecastRequest, opts ...grpc.CallOption) (*ForecastResponse, error) {\n\tout := new(ForecastResponse)\n\terr := c.cc.Invoke(ctx, \"/weather.forecasts.proxy.v0.ForecaProxy/GetForecast\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// ForecaProxyServer is the server API for ForecaProxy service.\n// All implementations must embed UnimplementedForecaProxyServer\n// for forward compatibility\ntype ForecaProxyServer interface {\n\tGetForecast(context.Context, *ForecastRequest) (*ForecastResponse, error)\n\tmustEmbedUnimplementedForecaProxyServer()\n}\n\n// UnimplementedForecaProxyServer must be embedded to have forward compatible implementations.\ntype UnimplementedForecaProxyServer struct {\n}\n\nfunc (UnimplementedForecaProxyServer) GetForecast(context.Context, *ForecastRequest) (*ForecastResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GetForecast not implemented\")\n}\nfunc (UnimplementedForecaProxyServer) mustEmbedUnimplementedForecaProxyServer() {}\n\n// UnsafeForecaProxyServer may be embedded to opt out of forward compatibility for this service.\n// Use of this interface is not recommended, as added methods to ForecaProxyServer will\n// result in compilation errors.\ntype UnsafeForecaProxyServer interface {\n\tmustEmbedUnimplementedForecaProxyServer()\n}\n\nfunc RegisterForecaProxyServer(s grpc.ServiceRegistrar, srv ForecaProxyServer) {\n\ts.RegisterService(&ForecaProxy_ServiceDesc, srv)\n}\n\nfunc _ForecaProxy_GetForecast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ForecastRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(ForecaProxyServer).GetForecast(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/weather.forecasts.proxy.v0.ForecaProxy/GetForecast\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(ForecaProxyServer).GetForecast(ctx, req.(*ForecastRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\n// ForecaProxy_ServiceDesc is the grpc.ServiceDesc for ForecaProxy service.\n// It's only intended for direct use with grpc.RegisterService,\n// and not to be introspected or modified (even as a copy)\nvar ForecaProxy_ServiceDesc = grpc.ServiceDesc{\n\tServiceName: \"weather.forecasts.proxy.v0.ForecaProxy\",\n\tHandlerType: (*ForecaProxyServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"GetForecast\",\n\t\t\tHandler:    _ForecaProxy_GetForecast_Handler,\n\t\t},\n\t},\n\tStreams:  []grpc.StreamDesc{},\n\tMetadata: \"service.v0.proto\",\n}\n", "n_tokens": 908, "primary_symbol": "NewForecaProxyClient", "primary_kind": "function", "primary_span": [32, 106], "def_symbols": ["NewForecaProxyClient", "GetForecast", "mustEmbedUnimplementedForecaProxyServer", "RegisterForecaProxyServer", "_ForecaProxy_GetForecast_Handler"], "symbols": ["NewForecaProxyClient", "GetForecast", "mustEmbedUnimplementedForecaProxyServer", "RegisterForecaProxyServer", "_ForecaProxy_GetForecast_Handler", "Code", "generated", "protoc", "gen", "grpc", "NOT", "EDIT", "versions", "source", "service", "proto", "package", "import", "context", "google", "golang", "org", "codes", "status", "This", "compile", "time", "assertion", "ensure", "that", "this", "file", "compatible", "with", "the", "being", "compiled", "against", "Requires", "gRPC", "later", "const", "SupportPackageIsVersion7", "ForecaProxyClient", "client", "API", "for", "ForecaProxy", "For", "semantics", "around", "ctx", "use", "and", "closing", "ending", "streaming", "RPCs", "please", "refer", "https", "pkg", "dev", "tab", "doc", "ClientConn", "NewStream", "type", "interface", "Context", "ForecastRequest", "opts", "CallOption", "ForecastResponse", "error", "forecaProxyClient", "struct", "ClientConnInterface", "func", "return", "out", "new", "err", "Invoke", "weather", "forecasts", "proxy", "nil", "ForecaProxyServer", "server", "All", "implementations", "must", "embed", "UnimplementedForecaProxyServer", "forward", "compatibility", "embedded", "have", "Errorf", "Unimplemented", "method", "not", "implemented", "UnsafeForecaProxyServer", "may", "opt", "Use", "recommended", "added", "methods", "will", "result", "compilation", "errors", "ServiceRegistrar", "srv", "RegisterService", "ForecaProxy_ServiceDesc", "dec", "interceptor", "UnaryServerInterceptor", "info", "UnaryServerInfo", "Server", "FullMethod", "handler", "req", "ServiceDesc", "only", "intended", "direct", "introspected", "modified", "even", "copy", "var", "ServiceName", "HandlerType", "Methods", "MethodDesc", "MethodName", "Handler", "Streams", "StreamDesc", "Metadata"], "doc_head": "// Code generated by protoc-gen-go-grpc. DO NOT EDIT.\n// versions:\n// - protoc-gen-go-grpc v1.2.0\n// - protoc             v3.21.12\n// source: service.v0.proto\npackage v0\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the grpc package it is being compiled against.\n// Requires gRPC-Go v1.32.0 or later.\nconst _ = grpc.SupportPackageIsVersion7\n// ForecaProxyClient is the client API for ForecaProxy service.\n//\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.\ntype ForecaProxyClient interface {\n\tGetForecast(ctx context.Context, in *ForecastRequest, opts ...grpc.CallOption) (*ForecastResponse, error)\n}\ntype forecaProxyClient struct {\n\tcc grpc.ClientConnInterface\n}\nfunc NewForecaProxyClient(cc grpc.ClientConnInterface) ForecaProxyClient {\n\treturn &forecaProxyClient{cc}\n}\nfunc (c *forecaProxyClient) GetForecast(ctx context.Context, in *ForecastRequest, opts ...grpc.CallOption) (*ForecastResponse, error) {", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(c *forecaProxyClient).GetForecast", "package": "v0", "node_kind": "method", "receiver": "c *forecaProxyClient", "function_name": "NewForecaProxyClient", "method_name": "GetForecast", "type_name": "ForecaProxyClient", "type_kind": "interface", "imports_used_minimal": [], "symbols_referenced_strict": ["API", "All", "CallOption", "ClientConn", "ClientConn.NewStream", "ClientConnInterface", "Code", "Context", "DO", "EDIT", "Errorf", "For", "ForecaProxy", "ForecaProxyClient", "ForecaProxyServer", "ForecaProxy_ServiceDesc", "ForecastRequest", "ForecastResponse", "FullMethod", "GetForecast", "Go", "Handler", "HandlerType", "Invoke", "It", "Metadata", "MethodDesc", "MethodName", "Methods", "NOT", "NewForecaProxyClient", "NewStream", "RPCs", "RegisterForecaProxyServer", "RegisterService", "Requires", "Server", "ServiceDesc", "ServiceName", "ServiceRegistrar", "StreamDesc", "Streams", "SupportPackageIsVersion7", "This", "UnaryServerInfo", "UnaryServerInterceptor", "Unimplemented", "UnimplementedForecaProxyServer", "UnsafeForecaProxyServer", "Use", "c.cc", "codes.Unimplemented", "context.Context", "google.golang", "grpc.CallOption", "grpc.ClientConnInterface", "grpc.MethodDesc", "grpc.RegisterService", "grpc.ServiceDesc", "grpc.ServiceRegistrar", "grpc.StreamDesc", "grpc.SupportPackageIsVersion7", "grpc.UnaryServerInfo", "grpc.UnaryServerInterceptor", "pkg.go", "proxy.v0", "s.RegisterService", "service.v0", "status.Errorf", "weather.forecasts"], "header_context_minimal": "package v0\n// receiver: c *forecaProxyClient", "summary_llm": "This Go code defines the client and server interfaces for a gRPC service named `ForecaProxy`. The client interface includes a method `GetForecast` to fetch weather forecasts, while the server interface requires implementing this method. The generated code also includes utility functions like `NewForecaProxyClient`, `RegisterForecaProxyServer`, and handler functions.", "keywords_llm": ["grpc", "client", "server", "interface", "method", "getforecast", "weather", "forecasts", "service", "register", "handler"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/xotel/provider.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/xotel/provider.go", "rel_path": "pkg/xotel/provider.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 126, "text": "package xotel\n\nimport (\n\t\"context\"\n\t\"go.opentelemetry.io/otel/metric\"\n\t\"time\"\n\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/spf13/viper\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc\"\n\tmetricsdk \"go.opentelemetry.io/otel/sdk/metric\"\n\t\"go.opentelemetry.io/otel/sdk/resource\"\n\ttracesdk \"go.opentelemetry.io/otel/sdk/trace\"\n\tsemconv \"go.opentelemetry.io/otel/semconv/v1.26.0\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n\n// TracerProviderConfig is the configuration for the OpenTelemetry Tracer provider\ntype TracerProviderConfig struct {\n\tEndpoint string `mapstructure:\"endpoint\"`\n}\n\n// NewTracerProvider creates a new TracerProvider provider\n// Usage:\n//\n//\ttp, err := xotel.NewTracerProvider(ctx, cfg)\n//\tif err != nil {\n//\t\treturn nil, errors.Wrap(err, \"failed to create trace provider\")\n//\t}\n//\totel.SetTracerProvider(tp)\n//\txotel.SetGlobalTracer(tp.Tracer(viper.GetString(\"app.name\")))\n//\n//\tdefer tp.Shutdown(ctx)\nfunc NewTracerProvider(ctx context.Context, cfg TracerProviderConfig) (*tracesdk.TracerProvider, error) {\n\tr, err := getResource()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"cannot get resource\")\n\t}\n\n\ttracer := otlptracegrpc.NewClient(\n\t\totlptracegrpc.WithEndpoint(cfg.Endpoint),\n\t\totlptracegrpc.WithInsecure(),\n\t)\n\texporter, err := otlptrace.New(ctx, tracer)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to initialize trace exporter\")\n\t}\n\n\ttp := tracesdk.NewTracerProvider(\n\t\t// Always be sure to batch in production.\n\t\ttracesdk.WithBatcher(exporter),\n\t\ttracesdk.WithResource(r),\n\t\ttracesdk.WithSampler(tracesdk.ParentBased(tracesdk.AlwaysSample())),\n\t)\n\n\treturn tp, nil\n}\n\n// Tracer is the global tracer\nvar Tracer trace.Tracer = nil\n\n// SetGlobalTracer sets global tracer\nfunc SetGlobalTracer(tracer trace.Tracer) {\n\tTracer = tracer\n}\n\n// MeterProviderConfig is the configuration for the OpenTelemetry providers\ntype MeterProviderConfig struct {\n\tEndpoint string        `mapstructure:\"endpoint\"`\n\tInterval time.Duration `mapstructure:\"interval\"`\n}\n\nfunc NewMeterProvider(ctx context.Context, cfg MeterProviderConfig) (*metricsdk.MeterProvider, error) {\n\tctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\tdefer cancel()\n\n\tr, err := getResource()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"cannot get resource\")\n\t}\n\n\texporter, err := otlpmetricgrpc.New(\n\t\tctx,\n\t\totlpmetricgrpc.WithEndpoint(cfg.Endpoint),\n\t\totlpmetricgrpc.WithInsecure(),\n\t)\n\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to initialize metric exporter\")\n\t}\n\n\treader := metricsdk.NewPeriodicReader(exporter, metricsdk.WithInterval(cfg.Interval))\n\n\tprovider := metricsdk.NewMeterProvider(\n\t\tmetricsdk.WithResource(r),\n\t\tmetricsdk.WithReader(reader),\n\t)\n\n\treturn provider, nil\n}\n\n// Meter is the global tracer\nvar Meter metric.Meter = nil\n\n// SetGlobalMeter sets global tracer\nfunc SetGlobalMeter(meter metric.Meter) {\n\tMeter = meter\n}\n\nfunc getResource() (*resource.Resource, error) {\n\tr, err := resource.Merge(\n\t\tresource.Default(),\n\t\tresource.NewWithAttributes(\n\t\t\tsemconv.SchemaURL,\n\t\t\tsemconv.ServiceNameKey.String(viper.GetString(\"app.name\")),\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"cannot merge resource\")\n\t}\n\n\treturn r, nil\n}\n", "n_tokens": 877, "primary_symbol": "NewTracerProvider", "primary_kind": "function", "primary_span": [36, 126], "def_symbols": ["NewTracerProvider", "SetGlobalTracer", "NewMeterProvider", "SetGlobalMeter", "getResource"], "symbols": ["NewTracerProvider", "SetGlobalTracer", "NewMeterProvider", "SetGlobalMeter", "getResource", "package", "xotel", "import", "context", "opentelemetry", "otel", "metric", "time", "github", "com", "cockroachdb", "errors", "spf13", "viper", "exporters", "otlp", "otlpmetric", "otlpmetricgrpc", "otlptrace", "otlptracegrpc", "metricsdk", "sdk", "resource", "tracesdk", "trace", "semconv", "TracerProviderConfig", "the", "configuration", "for", "OpenTelemetry", "Tracer", "provider", "type", "struct", "Endpoint", "string", "mapstructure", "endpoint", "creates", "new", "TracerProvider", "Usage", "err", "ctx", "cfg", "nil", "return", "Wrap", "failed", "create", "SetTracerProvider", "GetString", "app", "name", "defer", "Shutdown", "func", "Context", "error", "cannot", "get", "tracer", "NewClient", "WithEndpoint", "WithInsecure", "exporter", "New", "initialize", "Always", "sure", "batch", "production", "WithBatcher", "WithResource", "WithSampler", "ParentBased", "AlwaysSample", "global", "var", "sets", "MeterProviderConfig", "providers", "Interval", "Duration", "interval", "MeterProvider", "cancel", "WithTimeout", "Second", "reader", "NewPeriodicReader", "WithInterval", "WithReader", "Meter", "meter", "Resource", "Merge", "Default", "NewWithAttributes", "SchemaURL", "ServiceNameKey", "String", "merge"], "doc_head": "package xotel\nimport (\n\t\"context\"\n\t\"go.opentelemetry.io/otel/metric\"\n\t\"time\"\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/spf13/viper\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc\"\n\tmetricsdk \"go.opentelemetry.io/otel/sdk/metric\"\n\t\"go.opentelemetry.io/otel/sdk/resource\"\n\ttracesdk \"go.opentelemetry.io/otel/sdk/trace\"\n\tsemconv \"go.opentelemetry.io/otel/semconv/v1.26.0\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n// TracerProviderConfig is the configuration for the OpenTelemetry Tracer provider\ntype TracerProviderConfig struct {\n\tEndpoint string `mapstructure:\"endpoint\"`\n}\n// NewTracerProvider creates a new TracerProvider provider\n// Usage:\n//\n//\ttp, err := xotel.NewTracerProvider(ctx, cfg)\n//\tif err != nil {\n//\t\treturn nil, errors.Wrap(err, \"failed to create trace provider\")\n//\t}\n//\totel.SetTracerProvider(tp)\n//\txotel.SetGlobalTracer(tp.Tracer(viper.GetString(\"app.name\")))\n//\n//\tdefer tp.Shutdown(ctx)\nfunc NewTracerProvider(ctx context.Context, cfg TracerProviderConfig) (*tracesdk.TracerProvider, error) {\n\tr, err := getResource()\n\tif err != nil {\n\t\tr", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:NewTracerProvider", "package": "xotel", "node_kind": "function", "receiver": "", "function_name": "NewTracerProvider", "method_name": "", "type_name": "TracerProviderConfig", "type_kind": "struct", "imports_used_minimal": ["go.impalastudios.com/otel", "time"], "symbols_referenced_strict": ["Always", "AlwaysSample", "Context", "Default", "Duration", "Endpoint", "GetString", "Interval", "Merge", "Meter", "MeterProvider", "MeterProviderConfig", "New", "NewClient", "NewMeterProvider", "NewPeriodicReader", "NewTracerProvider", "NewWithAttributes", "OpenTelemetry", "ParentBased", "Resource", "SchemaURL", "Second", "ServiceNameKey", "SetGlobalMeter", "SetGlobalTracer", "SetTracerProvider", "Shutdown", "String", "Tracer", "TracerProvider", "TracerProviderConfig", "Usage", "WithBatcher", "WithEndpoint", "WithInsecure", "WithInterval", "WithReader", "WithResource", "WithSampler", "WithTimeout", "Wrap", "app.name", "cfg.Endpoint", "cfg.Interval", "context.Context", "context.WithTimeout", "errors.Wrap", "github.com", "go.opentelemetry", "metric.Meter", "metricsdk.MeterProvider", "metricsdk.NewMeterProvider", "metricsdk.NewPeriodicReader", "metricsdk.WithInterval", "metricsdk.WithReader", "metricsdk.WithResource", "otel.SetTracerProvider", "otlpmetricgrpc.New", "otlpmetricgrpc.WithEndpoint", "otlpmetricgrpc.WithInsecure", "otlptrace.New", "otlptracegrpc.NewClient", "otlptracegrpc.WithEndpoint", "otlptracegrpc.WithInsecure", "resource.Default", "resource.Merge", "resource.NewWithAttributes", "resource.Resource", "semconv.SchemaURL", "semconv.ServiceNameKey", "time.Duration", "time.Second", "tp.Shutdown", "tp.Tracer", "trace.Tracer", "tracesdk.AlwaysSample", "tracesdk.NewTracerProvider", "tracesdk.ParentBased", "tracesdk.TracerProvider", "tracesdk.WithBatcher", "tracesdk.WithResource", "tracesdk.WithSampler", "viper.GetString", "xotel.NewTracerProvider", "xotel.SetGlobalTracer"], "header_context_minimal": "package xotel\nimport (\n    \"go.impalastudios.com/otel\"\n    \"time\"\n)", "summary_llm": "This Go code provides functions to create and configure OpenTelemetry TracerProvider and MeterProvider instances. It includes configurations for endpoints, intervals, and resource attributes.", "keywords_llm": ["opentelemetry", "tracertprovider", "meterprovider", "endpoint", "interval", "resource", "attributes", "grpc", "exporters"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/cache/models.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/cache/models.go", "rel_path": "pkg/cache/models.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 8, "text": "package cache\n\ntype Item struct {\n\tKey        string\n\tValue      []byte\n\tExpiration int32\n}\n", "n_tokens": 22, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 8], "def_symbols": [], "symbols": ["package", "cache", "type", "Item", "struct", "Key", "string", "Value", "byte", "Expiration", "int32"], "doc_head": "package cache\ntype Item struct {\n\tKey        string\n\tValue      []byte\n\tExpiration int32\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:type:Item (struct)", "package": "cache", "node_kind": "type", "receiver": "", "function_name": "", "method_name": "", "type_name": "Item", "type_kind": "struct", "imports_used_minimal": [], "symbols_referenced_strict": ["Expiration", "Item", "Key", "Value"], "header_context_minimal": "package cache", "summary_llm": "The Go code defines a `cache.Item` struct with fields for a cache item's key, value, and expiration time.", "keywords_llm": ["cache", "item", "key", "value", "expiration", "struct", "string", "byte", "int32"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/cache/memcached.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/cache/memcached.go", "rel_path": "pkg/cache/memcached.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 52, "text": "package cache\n\nimport (\n\t\"github.com/dropbox/godropbox/memcache\"\n\t\"time\"\n)\n\ntype Memcached struct {\n\tc memcache.Client\n}\n\nfunc NewMemcached(client memcache.Client) *Memcached {\n\treturn &Memcached{c: client}\n}\n\nfunc (m *Memcached) Get(key string) (*Item, error) {\n\tresponse := m.c.Get(key)\n\n\tif response.Status() != memcache.StatusNoError {\n\t\tswitch response.Status() {\n\t\tcase memcache.StatusKeyNotFound:\n\t\t\treturn nil, ErrCacheMiss\n\t\tdefault:\n\t\t\treturn nil, ErrCacheGeneric\n\t\t}\n\t}\n\n\treturn &Item{\n\t\tKey:   response.Key(),\n\t\tValue: response.Value(),\n\t}, nil\n}\n\nfunc (m *Memcached) Set(key string, value []byte) error {\n\tresponse := m.c.Set(&memcache.Item{\n\t\tKey:   key,\n\t\tValue: value,\n\t})\n\n\treturn response.Error()\n}\n\nfunc (m *Memcached) SetWithExpiration(key string, value []byte, exp *time.Time) error {\n\tresponse := m.c.Set(&memcache.Item{\n\t\tKey:        key,\n\t\tValue:      value,\n\t\tExpiration: uint32(exp.Unix()),\n\t})\n\n\treturn response.Error()\n}\n", "n_tokens": 260, "primary_symbol": "NewMemcached", "primary_kind": "function", "primary_span": [12, 52], "def_symbols": ["NewMemcached", "Get", "Set", "SetWithExpiration"], "symbols": ["NewMemcached", "Get", "Set", "SetWithExpiration", "package", "cache", "import", "github", "com", "dropbox", "godropbox", "memcache", "time", "type", "Memcached", "struct", "Client", "func", "client", "return", "key", "string", "Item", "error", "response", "Status", "StatusNoError", "switch", "case", "StatusKeyNotFound", "nil", "ErrCacheMiss", "default", "ErrCacheGeneric", "Key", "Value", "value", "byte", "Error", "exp", "Time", "Expiration", "uint32", "Unix"], "doc_head": "package cache\nimport (\n\t\"github.com/dropbox/godropbox/memcache\"\n\t\"time\"\n)\ntype Memcached struct {\n\tc memcache.Client\n}\nfunc NewMemcached(client memcache.Client) *Memcached {\n\treturn &Memcached{c: client}\n}\nfunc (m *Memcached) Get(key string) (*Item, error) {\n\tresponse := m.c.Get(key)\n\tif response.Status() != memcache.StatusNoError {\n\t\tswitch response.Status() {\n\t\tcase memcache.StatusKeyNotFound:\n\t\t\treturn nil, ErrCacheMiss\n\t\tdefault:\n\t\t\treturn nil, ErrCacheGeneric\n\t\t}\n\t}\n\treturn &Item{\n\t\tKey:   response.Key(),\n\t\tValue: response.Value(),\n\t}, nil\n}\nfunc (m *Memcached) Set(key string, value []byte) error {\n\tresponse := m.c.Set(&memcache.Item{\n\t\tKey:   key,\n\t\tValue: value,\n\t})\n\treturn response.Error()\n}\nfunc (m *Memcached) SetWithExpiration(key string, value []byte, exp *time.Time) error {\n\tresponse := m.c.Set(&memcache.Item{\n\t\tKey:        key,\n\t\tValue:      value,\n\t\tExpiration: uint32(exp.Unix()),\n\t})\n\treturn response.Error()\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(m *Memcached).Get", "package": "cache", "node_kind": "method", "receiver": "m *Memcached", "function_name": "NewMemcached", "method_name": "Get", "type_name": "Memcached", "type_kind": "struct", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Client", "ErrCacheGeneric", "ErrCacheMiss", "Error", "Expiration", "Get", "Item", "Key", "Memcached", "NewMemcached", "Set", "SetWithExpiration", "Status", "StatusKeyNotFound", "StatusNoError", "Time", "Unix", "Value", "exp.Unix", "github.com", "m.c", "memcache.Client", "memcache.Item", "memcache.StatusKeyNotFound", "memcache.StatusNoError", "response.Error", "response.Key", "response.Status", "response.Value", "time.Time"], "header_context_minimal": "package cache\nimport \"time\"\n// receiver: m *Memcached", "summary_llm": "This Go code defines a `Memcached` struct with methods to interact with a memcache server. The `Get`, `Set`, and `SetWithExpiration` methods provide functionality to retrieve, store, and store with expiration times items in the memcache.", "keywords_llm": ["memcached", "get", "set", "expiration", "client", "response", "error", "item", "key", "value"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/cache/errors.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/cache/errors.go", "rel_path": "pkg/cache/errors.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 9, "text": "package cache\n\nimport \"errors\"\n\nvar (\n\tErrCacheMiss    = errors.New(\"cache miss\")\n\tErrCacheGeneric = errors.New(\"cache generic\")\n)\n", "n_tokens": 33, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 9], "def_symbols": [], "symbols": ["package", "cache", "import", "errors", "var", "ErrCacheMiss", "New", "miss", "ErrCacheGeneric", "generic"], "doc_head": "package cache\nimport \"errors\"\nvar (\n\tErrCacheMiss    = errors.New(\"cache miss\")\n\tErrCacheGeneric = errors.New(\"cache generic\")\n)", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:file_header", "package": "cache", "node_kind": "header", "receiver": "", "function_name": "", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["ErrCacheGeneric", "ErrCacheMiss", "New", "errors.New"], "header_context_minimal": "package cache", "summary_llm": "This Go code defines two error variables within the `cache` package: `ErrCacheMiss` for indicating a cache miss and `ErrCacheGeneric` for generic cache-related errors. These errors are created using `errors.New` from the Go standard library.", "keywords_llm": ["cache", "error", "errcachemiss", "errcachegeneric", "errors.new", "package", "go", "standard library"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/utilities/units.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/utilities/units.go", "rel_path": "pkg/utilities/units.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 18, "text": "package utilities\n\nfunc CelsiusToFahrenheit(celsius float64) float64 {\n\treturn (celsius * 9 / 5) + 32\n}\n\nfunc FahrenheitToCelsius(fahrenheit float64) float64 {\n\treturn (fahrenheit - 32) * 5 / 9\n}\n\nfunc KilometersToMiles(km float64) float64 {\n\treturn km / 1.609344\n}\n\nfunc MilesToKilometers(mi float64) float64 {\n\treturn mi * 1.609344\n}\n", "n_tokens": 107, "primary_symbol": "CelsiusToFahrenheit", "primary_kind": "function", "primary_span": [3, 18], "def_symbols": ["CelsiusToFahrenheit", "FahrenheitToCelsius", "KilometersToMiles", "MilesToKilometers"], "symbols": ["CelsiusToFahrenheit", "FahrenheitToCelsius", "KilometersToMiles", "MilesToKilometers", "package", "utilities", "func", "celsius", "float64", "return", "fahrenheit"], "doc_head": "package utilities\nfunc CelsiusToFahrenheit(celsius float64) float64 {\n\treturn (celsius * 9 / 5) + 32\n}\nfunc FahrenheitToCelsius(fahrenheit float64) float64 {\n\treturn (fahrenheit - 32) * 5 / 9\n}\nfunc KilometersToMiles(km float64) float64 {\n\treturn km / 1.609344\n}\nfunc MilesToKilometers(mi float64) float64 {\n\treturn mi * 1.609344\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:CelsiusToFahrenheit", "package": "utilities", "node_kind": "function", "receiver": "", "function_name": "CelsiusToFahrenheit", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["CelsiusToFahrenheit", "FahrenheitToCelsius", "KilometersToMiles", "MilesToKilometers"], "header_context_minimal": "package utilities", "summary_llm": "This Go package contains utility functions for converting temperature between Celsius and Fahrenheit, as well as distance between kilometers and miles.", "keywords_llm": ["celsius", "fahrenheit", "kilometers", "miles", "conversion", "utility", "package", "go"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/utilities/slices.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/utilities/slices.go", "rel_path": "pkg/utilities/slices.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 12, "text": "package utilities\n\nfunc ContainsString(h []string, n string) bool {\n\tfor _, v := range h {\n\t\tif v == n {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n", "n_tokens": 41, "primary_symbol": "ContainsString", "primary_kind": "function", "primary_span": [3, 12], "def_symbols": ["ContainsString"], "symbols": ["ContainsString", "package", "utilities", "func", "string", "bool", "for", "range", "return", "true", "false"], "doc_head": "package utilities\nfunc ContainsString(h []string, n string) bool {\n\tfor _, v := range h {\n\t\tif v == n {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:ContainsString", "package": "utilities", "node_kind": "function", "receiver": "", "function_name": "ContainsString", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["ContainsString"], "header_context_minimal": "package utilities", "summary_llm": "The Go code provided is a simple HTTP server that listens on port 8080 and responds with 'Hello, World!' to any incoming requests.", "keywords_llm": ["go", "http server", "port 8080", "response", "hello world"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/utilities/math.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/utilities/math.go", "rel_path": "pkg/utilities/math.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 22, "text": "package utilities\n\nimport \"math\"\n\nfunc Floor(v float64, precision int) float64 {\n\tbase := math.Pow10(precision)\n\n\treturn math.Floor(v*base) / base\n}\n\nfunc Round(v float64, precision int) float64 {\n\tbase := math.Pow10(precision)\n\n\treturn math.Round(v*base) / base\n}\n\nfunc Ceil(v float64, precision int) float64 {\n\tbase := math.Pow10(precision)\n\n\treturn math.Ceil(v*base) / base\n}\n", "n_tokens": 102, "primary_symbol": "Floor", "primary_kind": "function", "primary_span": [5, 22], "def_symbols": ["Floor", "Round", "Ceil"], "symbols": ["Floor", "Round", "Ceil", "package", "utilities", "import", "math", "func", "float64", "precision", "int", "base", "Pow10", "return"], "doc_head": "package utilities\nimport \"math\"\nfunc Floor(v float64, precision int) float64 {\n\tbase := math.Pow10(precision)\n\treturn math.Floor(v*base) / base\n}\nfunc Round(v float64, precision int) float64 {\n\tbase := math.Pow10(precision)\n\treturn math.Round(v*base) / base\n}\nfunc Ceil(v float64, precision int) float64 {\n\tbase := math.Pow10(precision)\n\treturn math.Ceil(v*base) / base\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:Floor", "package": "utilities", "node_kind": "function", "receiver": "", "function_name": "Floor", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["Ceil", "Floor", "Pow10", "Round", "math.Ceil", "math.Floor", "math.Pow10", "math.Round"], "header_context_minimal": "package utilities", "summary_llm": "The code defines functions for rounding floating-point numbers up (Ceil), down (Floor), and to the nearest value (Round) with a specified precision.", "keywords_llm": ["floor", "ceil", "round", "precision", "math.pow10", "math.ceil", "math.floor", "math.round", "utilities"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/limiter_test.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/limiter_test.go", "rel_path": "pkg/ratelimit/limiter_test.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 144, "text": "package ratelimit_test\n\nimport (\n\t\"github.com/stretchr/testify/suite\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit/mocks\"\n\t\"go.uber.org/mock/gomock\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype singleThreadLimiterTestSuite struct {\n\tsuite.Suite\n\n\tmockController *gomock.Controller\n}\n\nfunc (suite *singleThreadLimiterTestSuite) SetupSuite() {\n\tsuite.mockController = gomock.NewController(suite.T())\n}\n\nfunc (suite *singleThreadLimiterTestSuite) TestSingleThreadLimiter_PeekEmpty() {\n\tstorage := mocks.NewMockstorage(suite.mockController)\n\tstorage.EXPECT().Get(\"test\").Return(nil, nil)\n\n\tl := ratelimit.NewSingleThreadLimiter(1, time.Second, storage)\n\tl.Start()\n\tdefer l.Stop()\n\n\tu, err := l.Peek(\"test\")\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorIs(err, ratelimit.ErrNotFound)\n\tsuite.Assert().Zero(u)\n}\n\nfunc (suite *singleThreadLimiterTestSuite) TestSingleThreadLimiter_PeekNotEmpty() {\n\tstorage := mocks.NewMockstorage(suite.mockController)\n\tstorage.EXPECT().Get(\"test\").Return(&ratelimit.TokenBucket{\n\t\tUsed:           0,\n\t\tLastAccessTime: time.Now(),\n\t\tLimit:          1,\n\t\tDuration:       time.Second,\n\t}, nil)\n\n\tl := ratelimit.NewSingleThreadLimiter(1, time.Second, storage)\n\tl.Start()\n\tdefer l.Stop()\n\n\tu, err := l.Peek(\"test\")\n\tsuite.Assert().Nil(err)\n\tsuite.Assert().NotNil(u)\n\tsuite.Assert().EqualValues(0, u)\n}\n\nfunc (suite *singleThreadLimiterTestSuite) TestSingleThreadLimiter_AcquireNewBucket() {\n\tstorage := mocks.NewMockstorage(suite.mockController)\n\tstorage.EXPECT().Get(\"test\").Return(nil, nil)\n\tstorage.EXPECT().Set(\"test\", gomock.Any(), time.Second).\n\t\tDoAndReturn(func(arg0 string, arg1 *ratelimit.TokenBucket, arg2 time.Duration) error {\n\t\t\tsuite.Assert().Equal(float64(1), arg1.Used)\n\n\t\t\treturn nil\n\t\t})\n\n\tl := ratelimit.NewSingleThreadLimiter(1, time.Second, storage)\n\tl.Start()\n\tdefer l.Stop()\n\n\tu, err := l.Acquire(\"test\")\n\tsuite.Assert().Nil(err)\n\tsuite.Assert().NotNil(u)\n\tsuite.Assert().EqualValues(1, u)\n}\n\nfunc (suite *singleThreadLimiterTestSuite) TestSingleThreadLimiter_AcquireExistingBucket() {\n\tstorage := mocks.NewMockstorage(suite.mockController)\n\tstorage.EXPECT().Get(\"test\").Return(&ratelimit.TokenBucket{\n\t\tUsed:           2,\n\t\tLastAccessTime: time.Now(),\n\t\tLimit:          3,\n\t\tDuration:       time.Second,\n\t}, nil)\n\tstorage.EXPECT().Set(\"test\", gomock.Any(), time.Second).\n\t\tDoAndReturn(func(arg0 string, arg1 *ratelimit.TokenBucket, arg2 time.Duration) error {\n\t\t\tsuite.Assert().GreaterOrEqual(arg1.Used, 2.9)\n\n\t\t\treturn nil\n\t\t})\n\n\tl := ratelimit.NewSingleThreadLimiter(3, time.Second, storage)\n\tl.Start()\n\tdefer l.Stop()\n\n\tu, err := l.Acquire(\"test\")\n\tsuite.Assert().Nil(err)\n\tsuite.Assert().NotNil(u)\n\tsuite.Assert().Equal(int64(3), u)\n}\n\nfunc (suite *singleThreadLimiterTestSuite) TestSingleThreadLimiter_AcquireNNewBucket() {\n\tstorage := mocks.NewMockstorage(suite.mockController)\n\tstorage.EXPECT().Get(\"test\").Return(nil, nil)\n\tstorage.EXPECT().Set(\"test\", gomock.Any(), time.Second).\n\t\tDoAndReturn(func(arg0 string, arg1 *ratelimit.TokenBucket, arg2 time.Duration) error {\n\t\t\tsuite.Assert().Equal(float64(2), arg1.Used)\n\n\t\t\treturn nil\n\t\t})\n\n\tl := ratelimit.NewSingleThreadLimiter(2, time.Second, storage)\n\tl.Start()\n\tdefer l.Stop()\n\n\tu, err := l.AcquireN(\"test\", 2)\n\tsuite.Assert().Nil(err)\n\tsuite.Assert().NotNil(u)\n\tsuite.Assert().EqualValues(2, u)\n}\n\nfunc (suite *singleThreadLimiterTestSuite) TestSingleThreadLimiter_AcquireNExistingBucket() {\n\tstorage := mocks.NewMockstorage(suite.mockController)\n\tstorage.EXPECT().Get(\"test\").Return(&ratelimit.TokenBucket{\n\t\tUsed:           1,\n\t\tLastAccessTime: time.Now(),\n\t\tLimit:          3,\n\t\tDuration:       time.Second,\n\t}, nil)\n\tstorage.EXPECT().Set(\"test\", gomock.Any(), time.Second).\n\t\tDoAndReturn(func(arg0 string, arg1 *ratelimit.TokenBucket, arg2 time.Duration) error {\n\t\t\tsuite.Assert().GreaterOrEqual(arg1.Used, 2.9)\n\n\t\t\treturn nil\n\t\t})\n\n\tl := ratelimit.NewSingleThreadLimiter(3, time.Second, storage)\n\tl.Start()\n\tdefer l.Stop()\n\n\tu, err := l.AcquireN(\"test\", 2)\n\tsuite.Assert().Nil(err)\n\tsuite.Assert().NotNil(u)\n\tsuite.Assert().Equal(int64(3), u)\n}\n", "n_tokens": 1149, "primary_symbol": "SetupSuite", "primary_kind": "function", "primary_span": [18, 144], "def_symbols": ["SetupSuite", "TestSingleThreadLimiter_PeekEmpty", "TestSingleThreadLimiter_PeekNotEmpty", "TestSingleThreadLimiter_AcquireNewBucket", "TestSingleThreadLimiter_AcquireExistingBucket", "TestSingleThreadLimiter_AcquireNNewBucket", "TestSingleThreadLimiter_AcquireNExistingBucket"], "symbols": ["SetupSuite", "TestSingleThreadLimiter_PeekEmpty", "TestSingleThreadLimiter_PeekNotEmpty", "TestSingleThreadLimiter_AcquireNewBucket", "TestSingleThreadLimiter_AcquireExistingBucket", "TestSingleThreadLimiter_AcquireNNewBucket", "TestSingleThreadLimiter_AcquireNExistingBucket", "package", "ratelimit_test", "import", "github", "com", "stretchr", "testify", "suite", "impalastudios", "weather", "foreca_proxy", "pkg", "ratelimit", "mocks", "uber", "org", "mock", "gomock", "testing", "time", "type", "singleThreadLimiterTestSuite", "struct", "Suite", "mockController", "Controller", "func", "NewController", "storage", "NewMockstorage", "EXPECT", "Get", "test", "Return", "nil", "NewSingleThreadLimiter", "Second", "Start", "defer", "Stop", "err", "Peek", "Assert", "NotNil", "ErrorIs", "ErrNotFound", "Zero", "TokenBucket", "Used", "LastAccessTime", "Now", "Limit", "Duration", "Nil", "EqualValues", "Set", "Any", "DoAndReturn", "arg0", "string", "arg1", "arg2", "error", "Equal", "float64", "return", "Acquire", "GreaterOrEqual", "int64", "AcquireN"], "doc_head": "package ratelimit_test\nimport (\n\t\"github.com/stretchr/testify/suite\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit\"\n\t\"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit/mocks\"\n\t\"go.uber.org/mock/gomock\"\n\t\"testing\"\n\t\"time\"\n)\ntype singleThreadLimiterTestSuite struct {\n\tsuite.Suite\n\tmockController *gomock.Controller\n}\nfunc (suite *singleThreadLimiterTestSuite) SetupSuite() {\n\tsuite.mockController = gomock.NewController(suite.T())\n}\nfunc (suite *singleThreadLimiterTestSuite) TestSingleThreadLimiter_PeekEmpty() {\n\tstorage := mocks.NewMockstorage(suite.mockController)\n\tstorage.EXPECT().Get(\"test\").Return(nil, nil)\n\tl := ratelimit.NewSingleThreadLimiter(1, time.Second, storage)\n\tl.Start()\n\tdefer l.Stop()\n\tu, err := l.Peek(\"test\")\n\tsuite.Assert().NotNil(err)\n\tsuite.Assert().ErrorIs(err, ratelimit.ErrNotFound)\n\tsuite.Assert().Zero(u)\n}\nfunc (suite *singleThreadLimiterTestSuite) TestSingleThreadLimiter_PeekNotEmpty() {\n\tstorage := mocks.NewMockstorage(suite.mockController)\n\tstorage.EXPECT().Get(\"test\").Return(&ratelimit.TokenBucket{\n\t\tUsed:           0,\n\t\tLastAccessTime: time.Now(),\n\t\tLimit:          1,\n\t\tDuration:       time.Second,\n\t}, nil)\n\tl := ratelimit.NewSingleThreadL", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *singleThreadLimiterTestSuite).SetupSuite", "package": "ratelimit_test", "node_kind": "method", "receiver": "suite *singleThreadLimiterTestSuite", "function_name": "", "method_name": "SetupSuite", "type_name": "singleThreadLimiterTestSuite", "type_kind": "struct", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Acquire", "AcquireN", "Any", "Assert", "Controller", "DoAndReturn", "Duration", "EXPECT", "Equal", "EqualValues", "ErrNotFound", "ErrorIs", "Get", "GreaterOrEqual", "LastAccessTime", "Limit", "NewController", "NewMockstorage", "NewSingleThreadLimiter", "Nil", "NotNil", "Now", "Peek", "Return", "Second", "Set", "SetupSuite", "Start", "Stop", "Suite", "T", "TestSingleThreadLimiter_AcquireExistingBucket", "TestSingleThreadLimiter_AcquireNExistingBucket", "TestSingleThreadLimiter_AcquireNNewBucket", "TestSingleThreadLimiter_AcquireNewBucket", "TestSingleThreadLimiter_PeekEmpty", "TestSingleThreadLimiter_PeekNotEmpty", "TokenBucket", "Used", "Zero", "arg1.Used", "github.com", "go.impalastudios", "go.uber", "gomock.Any", "gomock.Controller", "gomock.NewController", "l.Acquire", "l.AcquireN", "l.Peek", "l.Start", "l.Stop", "mocks.NewMockstorage", "ratelimit.ErrNotFound", "ratelimit.NewSingleThreadLimiter", "ratelimit.TokenBucket", "storage.EXPECT", "suite.Assert", "suite.Suite", "suite.T", "suite.mockController", "time.Duration", "time.Now", "time.Second"], "header_context_minimal": "package ratelimit_test\nimport \"time\"\n// receiver: suite *singleThreadLimiterTestSuite", "summary_llm": "The Go code defines a test suite for the `singleThreadLimiterTestSuite` struct, which includes tests for various operations of the `ratelimit.NewSingleThreadLimiter` function. The tests use mocks and assertions to verify the behavior of acquiring tokens from a rate limiter.", "keywords_llm": ["test suite", "singlethreadlimitertestsuite", "ratelimit.newsinglethreadlimiter", "acquire token", "mock storage", "assertions", "rate limiting", "tokenbucket", "used", "limit"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/limiter_test.go#2", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/limiter_test.go", "rel_path": "pkg/ratelimit/limiter_test.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 145, "end_line": 160, "text": "func (suite *singleThreadLimiterTestSuite) TestSingleThreadLimiter_Reset() {\n\tstorage := mocks.NewMockstorage(suite.mockController)\n\tstorage.EXPECT().Delete(\"test\").Return(nil)\n\n\tl := ratelimit.NewSingleThreadLimiter(3, time.Second, storage)\n\tl.Start()\n\tdefer l.Stop()\n\n\terr := l.Reset(\"test\")\n\tsuite.Assert().Nil(err)\n}\n\nfunc TestSingleThreadLimiter(t *testing.T) {\n\tsuite.Run(t, new(singleThreadLimiterTestSuite))\n}\n", "n_tokens": 106, "primary_symbol": "TestSingleThreadLimiter_Reset", "primary_kind": "function", "primary_span": [145, 160], "def_symbols": ["TestSingleThreadLimiter_Reset", "TestSingleThreadLimiter"], "symbols": ["TestSingleThreadLimiter_Reset", "TestSingleThreadLimiter", "func", "suite", "singleThreadLimiterTestSuite", "storage", "mocks", "NewMockstorage", "mockController", "EXPECT", "Delete", "test", "Return", "nil", "ratelimit", "NewSingleThreadLimiter", "time", "Second", "Start", "defer", "Stop", "err", "Reset", "Assert", "Nil", "testing", "Run", "new"], "doc_head": "func (suite *singleThreadLimiterTestSuite) TestSingleThreadLimiter_Reset() {\n\tstorage := mocks.NewMockstorage(suite.mockController)\n\tstorage.EXPECT().Delete(\"test\").Return(nil)\n\tl := ratelimit.NewSingleThreadLimiter(3, time.Second, storage)\n\tl.Start()\n\tdefer l.Stop()\n\terr := l.Reset(\"test\")\n\tsuite.Assert().Nil(err)\n}\nfunc TestSingleThreadLimiter(t *testing.T) {\n\tsuite.Run(t, new(singleThreadLimiterTestSuite))\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(suite *singleThreadLimiterTestSuite).TestSingleThreadLimiter_Reset", "package": "", "node_kind": "method", "receiver": "suite *singleThreadLimiterTestSuite", "function_name": "TestSingleThreadLimiter", "method_name": "TestSingleThreadLimiter_Reset", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Assert", "Delete", "EXPECT", "NewMockstorage", "NewSingleThreadLimiter", "Nil", "Reset", "Return", "Run", "Second", "Start", "Stop", "T", "TestSingleThreadLimiter", "TestSingleThreadLimiter_Reset", "l.Reset", "l.Start", "l.Stop", "mocks.NewMockstorage", "ratelimit.NewSingleThreadLimiter", "storage.EXPECT", "suite.Assert", "suite.Run", "suite.mockController", "testing.T", "time.Second"], "header_context_minimal": "package \nimport \"time\"\n// receiver: suite *singleThreadLimiterTestSuite", "summary_llm": "The provided Go code includes a test for the `Reset` method of the `singleThreadLimiterTestSuite`. It sets up a mock storage and asserts that calling `Reset` on a limiter instance does not return an error. The test also ensures that the limiter is properly started and stopped.", "keywords_llm": ["test", "mockstorage", "reset", "limiter", "singlethreadlimitertestsuite", "ratelimit", "start", "stop", "defer", "assert", "error"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/interfaces.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/interfaces.go", "rel_path": "pkg/ratelimit/interfaces.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 8, "text": "package ratelimit\n\nimport \"context\"\n\ntype IRateLimit interface {\n\tAllow(ctx context.Context, key string) bool\n}\n", "n_tokens": 27, "primary_symbol": "", "primary_kind": "", "primary_span": [1, 8], "def_symbols": [], "symbols": ["package", "ratelimit", "import", "context", "type", "IRateLimit", "interface", "Allow", "ctx", "Context", "key", "string", "bool"], "doc_head": "package ratelimit\nimport \"context\"\ntype IRateLimit interface {\n\tAllow(ctx context.Context, key string) bool\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:type:IRateLimit (interface)", "package": "ratelimit", "node_kind": "type", "receiver": "", "function_name": "", "method_name": "", "type_name": "IRateLimit", "type_kind": "interface", "imports_used_minimal": [], "symbols_referenced_strict": ["Allow", "Context", "IRateLimit", "context.Context"], "header_context_minimal": "package ratelimit", "summary_llm": "The `IRateLimit` interface defines a method `Allow` that takes a `context.Context` and a key string, returning a boolean indicating whether the action is allowed based on rate limiting criteria.", "keywords_llm": ["iratelimit", "allow", "context", "key", "bool", "rate limiting", "interface", "method"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/tokenbucket.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/tokenbucket.go", "rel_path": "pkg/ratelimit/tokenbucket.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 48, "text": "package ratelimit\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\nvar (\n\tErrLimitReached = errors.New(\"limit reached\")\n)\n\ntype TokenBucket struct {\n\tUsed           float64\n\tLastAccessTime time.Time\n\tLimit          float64\n\tDuration       time.Duration\n}\n\nfunc NewTokenBucket(limit float64, duration time.Duration) *TokenBucket {\n\treturn &TokenBucket{0, time.Now(), limit, duration}\n}\n\nfunc (bucket *TokenBucket) Consume(count float64) error {\n\tnow := time.Now()\n\tused := bucket.GetAdjustedUsage(now)\n\n\tif used+count <= bucket.Limit {\n\t\tbucket.Used = used + count\n\t\tbucket.LastAccessTime = now\n\t\treturn nil\n\t}\n\n\treturn ErrLimitReached\n}\n\nfunc (bucket *TokenBucket) GetAdjustedUsage(now time.Time) float64 {\n\tused := bucket.Used\n\tif bucket.LastAccessTime.Unix() > 0 {\n\t\telapsed := now.Sub(bucket.LastAccessTime)\n\t\tback := bucket.Limit * float64(elapsed) / float64(bucket.Duration)\n\t\tused -= back\n\t\tif used < 0 {\n\t\t\tused = 0\n\t\t}\n\t}\n\treturn used\n}\n", "n_tokens": 253, "primary_symbol": "NewTokenBucket", "primary_kind": "function", "primary_span": [19, 48], "def_symbols": ["NewTokenBucket", "Consume", "GetAdjustedUsage"], "symbols": ["NewTokenBucket", "Consume", "GetAdjustedUsage", "package", "ratelimit", "import", "errors", "time", "var", "ErrLimitReached", "New", "limit", "reached", "type", "TokenBucket", "struct", "Used", "float64", "LastAccessTime", "Time", "Limit", "Duration", "func", "duration", "return", "Now", "bucket", "count", "error", "now", "used", "nil", "Unix", "elapsed", "Sub", "back"], "doc_head": "package ratelimit\nimport (\n\t\"errors\"\n\t\"time\"\n)\nvar (\n\tErrLimitReached = errors.New(\"limit reached\")\n)\ntype TokenBucket struct {\n\tUsed           float64\n\tLastAccessTime time.Time\n\tLimit          float64\n\tDuration       time.Duration\n}\nfunc NewTokenBucket(limit float64, duration time.Duration) *TokenBucket {\n\treturn &TokenBucket{0, time.Now(), limit, duration}\n}\nfunc (bucket *TokenBucket) Consume(count float64) error {\n\tnow := time.Now()\n\tused := bucket.GetAdjustedUsage(now)\n\tif used+count <= bucket.Limit {\n\t\tbucket.Used = used + count\n\t\tbucket.LastAccessTime = now\n\t\treturn nil\n\t}\n\treturn ErrLimitReached\n}\nfunc (bucket *TokenBucket) GetAdjustedUsage(now time.Time) float64 {\n\tused := bucket.Used\n\tif bucket.LastAccessTime.Unix() > 0 {\n\t\telapsed := now.Sub(bucket.LastAccessTime)\n\t\tback := bucket.Limit * float64(elapsed) / float64(bucket.Duration)\n\t\tused -= back\n\t\tif used < 0 {\n\t\t\tused = 0\n\t\t}\n\t}\n\treturn used\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(bucket *TokenBucket).Consume", "package": "ratelimit", "node_kind": "method", "receiver": "bucket *TokenBucket", "function_name": "NewTokenBucket", "method_name": "Consume", "type_name": "TokenBucket", "type_kind": "struct", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Consume", "Duration", "ErrLimitReached", "GetAdjustedUsage", "LastAccessTime", "Limit", "New", "NewTokenBucket", "Now", "Sub", "Time", "TokenBucket", "Unix", "Used", "bucket.Duration", "bucket.GetAdjustedUsage", "bucket.LastAccessTime", "bucket.Limit", "bucket.Used", "errors.New", "now.Sub", "time.Duration", "time.Now", "time.Time"], "header_context_minimal": "package ratelimit\nimport \"time\"\n// receiver: bucket *TokenBucket", "summary_llm": "The Go code defines a `TokenBucket` struct and associated methods to manage rate limiting. The `Consume` method checks if the bucket can fulfill a request based on its limit and duration, adjusting usage accordingly.", "keywords_llm": ["tokenbucket", "rate limiting", "consume", "limit reached", "adjust usage", "last access time", "used", "duration", "new tokenbucket"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/storage_memcached.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/storage_memcached.go", "rel_path": "pkg/ratelimit/storage_memcached.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 55, "text": "package ratelimit\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"github.com/dropbox/godropbox/memcache\"\n\t\"time\"\n)\n\ntype MemcachedStorage struct {\n\tclient memcache.Client\n\tprefix string\n}\n\nfunc NewMemcachedStorage(client memcache.Client, prefix string) *MemcachedStorage {\n\treturn &MemcachedStorage{client, prefix}\n}\n\nfunc (ms *MemcachedStorage) Get(key string) (*TokenBucket, error) {\n\tvar err error\n\tresp := ms.client.Get(ms.prefix + key)\n\tif resp.Status() == memcache.StatusNoError || resp.Status() == memcache.StatusKeyNotFound {\n\t\treturn nil, nil\n\t} else if resp.Error() != nil {\n\t\treturn nil, resp.Error()\n\t}\n\n\tvar bucket = new(TokenBucket)\n\tdec := gob.NewDecoder(bytes.NewBuffer(resp.Value()))\n\terr = dec.Decode(bucket)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn bucket, nil\n}\n\nfunc (ms *MemcachedStorage) Set(key string, bucket *TokenBucket, duration time.Duration) error {\n\tvar buffer = bytes.NewBuffer(nil)\n\tenc := gob.NewEncoder(buffer)\n\t_ = enc.Encode(bucket)\n\titem := &memcache.Item{\n\t\tKey:        ms.prefix + key,\n\t\tValue:      buffer.Bytes(),\n\t\tExpiration: uint32(duration.Seconds()),\n\t}\n\n\tresp := ms.client.Set(item)\n\treturn resp.Error()\n}\n\nfunc (ms *MemcachedStorage) Delete(key string) error {\n\tresp := ms.client.Delete(ms.prefix + key)\n\treturn resp.Error()\n}\n", "n_tokens": 323, "primary_symbol": "NewMemcachedStorage", "primary_kind": "function", "primary_span": [15, 55], "def_symbols": ["NewMemcachedStorage", "Get", "Set", "Delete"], "symbols": ["NewMemcachedStorage", "Get", "Set", "Delete", "package", "ratelimit", "import", "bytes", "encoding", "gob", "github", "com", "dropbox", "godropbox", "memcache", "time", "type", "MemcachedStorage", "struct", "client", "Client", "prefix", "string", "func", "return", "key", "TokenBucket", "error", "var", "err", "resp", "Status", "StatusNoError", "StatusKeyNotFound", "nil", "else", "Error", "bucket", "new", "dec", "NewDecoder", "NewBuffer", "Value", "Decode", "duration", "Duration", "buffer", "enc", "NewEncoder", "Encode", "item", "Item", "Key", "Bytes", "Expiration", "uint32", "Seconds"], "doc_head": "package ratelimit\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"github.com/dropbox/godropbox/memcache\"\n\t\"time\"\n)\ntype MemcachedStorage struct {\n\tclient memcache.Client\n\tprefix string\n}\nfunc NewMemcachedStorage(client memcache.Client, prefix string) *MemcachedStorage {\n\treturn &MemcachedStorage{client, prefix}\n}\nfunc (ms *MemcachedStorage) Get(key string) (*TokenBucket, error) {\n\tvar err error\n\tresp := ms.client.Get(ms.prefix + key)\n\tif resp.Status() == memcache.StatusNoError || resp.Status() == memcache.StatusKeyNotFound {\n\t\treturn nil, nil\n\t} else if resp.Error() != nil {\n\t\treturn nil, resp.Error()\n\t}\n\tvar bucket = new(TokenBucket)\n\tdec := gob.NewDecoder(bytes.NewBuffer(resp.Value()))\n\terr = dec.Decode(bucket)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn bucket, nil\n}\nfunc (ms *MemcachedStorage) Set(key string, bucket *TokenBucket, duration time.Duration) error {\n\tvar buffer = bytes.NewBuffer(nil)\n\tenc := gob.NewEncoder(buffer)\n\t_ = enc.Encode(bucket)\n\titem := &memcache.Item{\n\t\tKey:        ms.prefix + key,\n\t\tValue:      buffer.Bytes(),\n\t\tExpiration: uint32(duration.Seconds()),\n\t}\n\tresp := ms.client.Set(item)\n\treturn resp.Error()\n}\nfunc (ms *MemcachedStorage) Delete(key string) error {\n\tres", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(ms *MemcachedStorage).Get", "package": "ratelimit", "node_kind": "method", "receiver": "ms *MemcachedStorage", "function_name": "NewMemcachedStorage", "method_name": "Get", "type_name": "MemcachedStorage", "type_kind": "struct", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Bytes", "Client", "Decode", "Delete", "Duration", "Encode", "Error", "Expiration", "Get", "Item", "Key", "MemcachedStorage", "NewBuffer", "NewDecoder", "NewEncoder", "NewMemcachedStorage", "Seconds", "Set", "Status", "StatusKeyNotFound", "StatusNoError", "TokenBucket", "Value", "buffer.Bytes", "bytes.NewBuffer", "dec.Decode", "duration.Seconds", "enc.Encode", "github.com", "gob.NewDecoder", "gob.NewEncoder", "memcache.Client", "memcache.Item", "memcache.StatusKeyNotFound", "memcache.StatusNoError", "ms.client", "ms.prefix", "resp.Error", "resp.Status", "resp.Value", "time.Duration"], "header_context_minimal": "package ratelimit\nimport \"time\"\n// receiver: ms *MemcachedStorage", "summary_llm": "This Go code defines a `MemcachedStorage` struct that interacts with Memcached to store and retrieve rate limit token bucket data. It includes methods for getting, setting, and deleting rate limit tokens.", "keywords_llm": ["memcached", "rate limit", "token bucket", "storage", "get", "set", "delete", "client", "prefix", "buffer", "encoder", "decoder"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/storage.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/storage.go", "rel_path": "pkg/ratelimit/storage.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 43, "text": "package ratelimit\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\nvar (\n\tErrNotFound = errors.New(\"not found\")\n)\n\ntype Storage interface {\n\tGet(key string) (*TokenBucket, error)\n\tSet(key string, bucket *TokenBucket, expire time.Duration) error\n\tDelete(key string) error\n}\n\ntype DummyStorage struct {\n\tdata map[string]*TokenBucket\n}\n\nfunc NewDummyStorage() *DummyStorage {\n\treturn &DummyStorage{make(map[string]*TokenBucket)}\n}\n\nfunc (d *DummyStorage) Get(key string) (*TokenBucket, error) {\n\tb, ok := d.data[key]\n\tif !ok {\n\t\treturn nil, nil\n\t}\n\treturn b, nil\n}\n\nfunc (d *DummyStorage) Set(key string, bucket *TokenBucket, _ time.Duration) error {\n\td.data[key] = bucket\n\treturn nil\n}\n\nfunc (d *DummyStorage) Delete(key string) error {\n\tdelete(d.data, key)\n\treturn nil\n}\n", "n_tokens": 198, "primary_symbol": "NewDummyStorage", "primary_kind": "function", "primary_span": [22, 43], "def_symbols": ["NewDummyStorage", "Get", "Set", "Delete"], "symbols": ["NewDummyStorage", "Get", "Set", "Delete", "package", "ratelimit", "import", "errors", "time", "var", "ErrNotFound", "New", "not", "found", "type", "Storage", "interface", "key", "string", "TokenBucket", "error", "bucket", "expire", "Duration", "DummyStorage", "struct", "data", "map", "func", "return", "make", "nil", "delete"], "doc_head": "package ratelimit\nimport (\n\t\"errors\"\n\t\"time\"\n)\nvar (\n\tErrNotFound = errors.New(\"not found\")\n)\ntype Storage interface {\n\tGet(key string) (*TokenBucket, error)\n\tSet(key string, bucket *TokenBucket, expire time.Duration) error\n\tDelete(key string) error\n}\ntype DummyStorage struct {\n\tdata map[string]*TokenBucket\n}\nfunc NewDummyStorage() *DummyStorage {\n\treturn &DummyStorage{make(map[string]*TokenBucket)}\n}\nfunc (d *DummyStorage) Get(key string) (*TokenBucket, error) {\n\tb, ok := d.data[key]\n\tif !ok {\n\t\treturn nil, nil\n\t}\n\treturn b, nil\n}\nfunc (d *DummyStorage) Set(key string, bucket *TokenBucket, _ time.Duration) error {\n\td.data[key] = bucket\n\treturn nil\n}\nfunc (d *DummyStorage) Delete(key string) error {\n\tdelete(d.data, key)\n\treturn nil\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(d *DummyStorage).Get", "package": "ratelimit", "node_kind": "method", "receiver": "d *DummyStorage", "function_name": "NewDummyStorage", "method_name": "Get", "type_name": "Storage", "type_kind": "interface", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Delete", "DummyStorage", "Duration", "ErrNotFound", "Get", "New", "NewDummyStorage", "Set", "Storage", "TokenBucket", "d.data", "errors.New", "time.Duration"], "header_context_minimal": "package ratelimit\nimport \"time\"\n// receiver: d *DummyStorage", "summary_llm": "This Go code defines a rate limiting storage system using a dummy in-memory map. It includes a `Storage` interface with methods for getting, setting, and deleting token buckets.", "keywords_llm": ["storage", "interface", "get", "set", "delete", "token bucket", "dummy storage", "map", "errors"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/limiter.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/limiter.go", "rel_path": "pkg/ratelimit/limiter.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 203, "text": "package ratelimit\n\nimport (\n\t\"errors\"\n\t\"math\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar (\n\tErrKeyEmpty     = errors.New(\"key cannot be empty\")\n\tErrCountZero    = errors.New(\"count should be greater than zero\")\n\tErrLimitZero    = errors.New(\"limit should be greater than zero\")\n\tErrCountLimit   = errors.New(\"limit should be greater than count\")\n\tErrZeroDuration = errors.New(\"duration cannot be zero\")\n)\n\n//go:generate /go/bin/mockgen -source=limiter.go -destination=mocks/limiter_mocks.go -package=mocks\ntype (\n\tlimiter interface {\n\t\tPeek(string) (int64, error)\n\t\tAcquireN(string, int64) (int64, error)\n\t\tAcquire(string) (int64, error)\n\t\tReset(string) error\n\t}\n\tstorage interface {\n\t\tGet(string) (*TokenBucket, error)\n\t\tSet(string, *TokenBucket, time.Duration) error\n\t\tDelete(string) error\n\t}\n)\n\ntype SingleThreadLimiter struct {\n\tstorage  storage\n\treqChan  chan request\n\tstopChan chan bool\n\tlimit    int64\n\tduration time.Duration\n}\n\nfunc NewSingleThreadLimiter(limit int64, duration time.Duration, storage storage) *SingleThreadLimiter {\n\treturn &SingleThreadLimiter{storage, make(chan request), make(chan bool), limit, duration}\n}\n\nfunc (l *SingleThreadLimiter) Start() {\n\tgo l.serve()\n}\n\nfunc (l *SingleThreadLimiter) Stop() {\n\tl.stopChan <- true\n}\n\nfunc (l *SingleThreadLimiter) AcquireN(key string, count int64) (int64, error) {\n\n\terr := checkAcquireArgs(key, count, l.limit, l.duration)\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treq := request{\n\t\tACQUIRE,\n\t\tkey,\n\t\tcount,\n\t\tl.limit,\n\t\tl.duration,\n\t\tmake(chan response),\n\t}\n\tl.reqChan <- req\n\tres := <-req.response\n\treturn res.used, res.err\n}\n\nfunc (l *SingleThreadLimiter) Acquire(key string) (int64, error) {\n\treturn l.AcquireN(key, 1)\n}\n\nfunc (l *SingleThreadLimiter) Peek(key string) (int64, error) {\n\treq := request{\n\t\tPEEK,\n\t\tkey,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\tmake(chan response),\n\t}\n\tl.reqChan <- req\n\tres := <-req.response\n\treturn res.used, res.err\n}\n\nfunc (l *SingleThreadLimiter) Reset(key string) error {\n\treq := request{\n\t\tRESET,\n\t\tkey,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\tmake(chan response),\n\t}\n\tl.reqChan <- req\n\tres := <-req.response\n\treturn res.err\n}\n\nfunc (l *SingleThreadLimiter) serve() {\n\tfor {\n\t\tselect {\n\t\tcase <-l.stopChan:\n\t\t\treturn\n\t\tcase req := <-l.reqChan:\n\t\t\tswitch req.action {\n\t\t\tcase PEEK:\n\t\t\t\tbucket, err := l.storage.Get(req.key)\n\t\t\t\tif err != nil {\n\t\t\t\t\treq.response <- response{0, err}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif bucket == nil {\n\t\t\t\t\treq.response <- response{0, ErrNotFound}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tnow := time.Now()\n\t\t\t\treq.response <- response{usage(bucket.GetAdjustedUsage(now)), nil}\n\t\t\tcase RESET:\n\t\t\t\terr := l.storage.Delete(req.key)\n\t\t\t\treq.response <- response{0, err}\n\t\t\tcase ACQUIRE:\n\t\t\t\tbucket, err := l.storage.Get(req.key)\n\t\t\t\tif err != nil {\n\t\t\t\t\treq.response <- response{0, err}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tcount, limit := float64(req.count), float64(req.limit)\n\t\t\t\tduration := req.duration\n\n\t\t\t\tif bucket == nil {\n\t\t\t\t\tbucket = NewTokenBucket(limit, duration)\n\t\t\t\t} else if bucket.Limit != limit || bucket.Duration != duration {\n\t\t\t\t\tbucket = NewTokenBucket(limit, duration)\n\t\t\t\t}\n\n\t\t\t\terr = bucket.Consume(count)\n\t\t\t\tif err != nil {\n\t\t\t\t\treq.response <- response{usage(bucket.Used), err}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\terr = l.storage.Set(req.key, bucket, duration)\n\t\t\t\tif err != nil {\n\t\t\t\t\treq.response <- response{0, err}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treq.response <- response{usage(bucket.Used), nil}\n\t\t\tdefault:\n\t\t\t\treq.response <- response{0, errors.New(\"undefined method\")}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc checkAcquireArgs(key string, count, limit int64, duration time.Duration) error {\n\tswitch true {\n\tcase len(strings.TrimSpace(key)) == 0:\n\t\treturn ErrKeyEmpty\n\tcase count <= 0:\n\t\treturn ErrCountZero\n\tcase limit <= 0:\n\t\treturn ErrLimitZero\n\tcase count > limit:\n\t\treturn ErrCountLimit\n\tcase duration == 0:\n\t\treturn ErrZeroDuration\n\t}\n\treturn nil\n}\n\ntype response struct {\n\tused int64\n\terr  error\n}\n\nconst (\n\tPEEK = iota\n\tACQUIRE\n\tRESET\n)\n\ntype request struct {\n\taction   int\n\tkey      string\n\tcount    int64\n\tlimit    int64\n\tduration time.Duration\n\tresponse chan response\n}\n\nfunc usage(f float64) int64 {\n\treturn int64(math.Ceil(f))\n}\n", "n_tokens": 1145, "primary_symbol": "NewSingleThreadLimiter", "primary_kind": "function", "primary_span": [41, 203], "def_symbols": ["NewSingleThreadLimiter", "Start", "Stop", "AcquireN", "Acquire", "Peek", "Reset", "serve", "checkAcquireArgs", "usage"], "symbols": ["NewSingleThreadLimiter", "Start", "Stop", "AcquireN", "Acquire", "Peek", "Reset", "serve", "checkAcquireArgs", "usage", "package", "ratelimit", "import", "errors", "math", "strings", "time", "var", "ErrKeyEmpty", "New", "key", "cannot", "empty", "ErrCountZero", "count", "should", "greater", "than", "zero", "ErrLimitZero", "limit", "ErrCountLimit", "ErrZeroDuration", "duration", "generate", "bin", "mockgen", "source", "limiter", "destination", "mocks", "limiter_mocks", "type", "interface", "string", "int64", "error", "storage", "Get", "TokenBucket", "Set", "Duration", "Delete", "SingleThreadLimiter", "struct", "reqChan", "chan", "request", "stopChan", "bool", "func", "return", "make", "true", "err", "nil", "req", "ACQUIRE", "response", "res", "used", "PEEK", "RESET", "for", "select", "case", "switch", "action", "bucket", "continue", "ErrNotFound", "now", "Now", "GetAdjustedUsage", "float64", "NewTokenBucket", "else", "Limit", "Consume", "Used", "default", "undefined", "method", "len", "TrimSpace", "const", "iota", "int", "Ceil"], "doc_head": "package ratelimit\nimport (\n\t\"errors\"\n\t\"math\"\n\t\"strings\"\n\t\"time\"\n)\nvar (\n\tErrKeyEmpty     = errors.New(\"key cannot be empty\")\n\tErrCountZero    = errors.New(\"count should be greater than zero\")\n\tErrLimitZero    = errors.New(\"limit should be greater than zero\")\n\tErrCountLimit   = errors.New(\"limit should be greater than count\")\n\tErrZeroDuration = errors.New(\"duration cannot be zero\")\n)\n//go:generate /go/bin/mockgen -source=limiter.go -destination=mocks/limiter_mocks.go -package=mocks\ntype (\n\tlimiter interface {\n\t\tPeek(string) (int64, error)\n\t\tAcquireN(string, int64) (int64, error)\n\t\tAcquire(string) (int64, error)\n\t\tReset(string) error\n\t}\n\tstorage interface {\n\t\tGet(string) (*TokenBucket, error)\n\t\tSet(string, *TokenBucket, time.Duration) error\n\t\tDelete(string) error\n\t}\n)\ntype SingleThreadLimiter struct {\n\tstorage  storage\n\treqChan  chan request\n\tstopChan chan bool\n\tlimit    int64\n\tduration time.Duration\n}\nfunc NewSingleThreadLimiter(limit int64, duration time.Duration, storage storage) *SingleThreadLimiter {\n\treturn &SingleThreadLimiter{storage, make(chan request), make(chan bool), limit, duration}\n}\nfunc (l *SingleThreadLimiter) Start() {\n\tgo l.serve()\n}\nfunc (l *SingleThreadLimiter) S", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:method:(l *SingleThreadLimiter).Start", "package": "ratelimit", "node_kind": "method", "receiver": "l *SingleThreadLimiter", "function_name": "NewSingleThreadLimiter", "method_name": "Start", "type_name": "SingleThreadLimiter", "type_kind": "struct", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["ACQUIRE", "Acquire", "AcquireN", "Ceil", "Consume", "Delete", "Duration", "ErrCountLimit", "ErrCountZero", "ErrKeyEmpty", "ErrLimitZero", "ErrNotFound", "ErrZeroDuration", "Get", "GetAdjustedUsage", "Limit", "New", "NewSingleThreadLimiter", "NewTokenBucket", "Now", "PEEK", "Peek", "RESET", "Reset", "Set", "SingleThreadLimiter", "Start", "Stop", "TokenBucket", "TrimSpace", "Used", "bucket.Consume", "bucket.Duration", "bucket.GetAdjustedUsage", "bucket.Limit", "bucket.Used", "errors.New", "l.AcquireN", "l.duration", "l.limit", "l.reqChan", "l.serve", "l.stopChan", "l.storage", "limiter.go", "limiter_mocks.go", "math.Ceil", "req.action", "req.count", "req.duration", "req.key", "req.limit", "req.response", "res.err", "res.used", "strings.TrimSpace", "time.Duration", "time.Now"], "header_context_minimal": "package ratelimit\nimport \"time\"\n// receiver: l *SingleThreadLimiter", "summary_llm": "This Go code defines a single-threaded rate limiter that handles acquiring tokens with different actions such as peeking and resetting. It uses interfaces for storage and requests, and processes them in a goroutine.", "keywords_llm": ["ratelimit", "limiter", "storage", "request", "goroutine", "acquire", "peek", "reset", "tokenbucket", "time"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/mocks/limiter_mocks.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/mocks/limiter_mocks.go", "rel_path": "pkg/ratelimit/mocks/limiter_mocks.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 147, "text": "// Code generated by MockGen. DO NOT EDIT.\n// Source: limiter.go\n//\n// Generated by this command:\n//\n//\tmockgen -source=limiter.go -destination=mocks/limiter_mocks.go -package=mocks\n//\n\n// Package mocks is a generated GoMock package.\npackage mocks\n\nimport (\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tratelimit \"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// Mocklimiter is a mock of limiter interface.\ntype Mocklimiter struct {\n\tctrl     *gomock.Controller\n\trecorder *MocklimiterMockRecorder\n}\n\n// MocklimiterMockRecorder is the mock recorder for Mocklimiter.\ntype MocklimiterMockRecorder struct {\n\tmock *Mocklimiter\n}\n\n// NewMocklimiter creates a new mock instance.\nfunc NewMocklimiter(ctrl *gomock.Controller) *Mocklimiter {\n\tmock := &Mocklimiter{ctrl: ctrl}\n\tmock.recorder = &MocklimiterMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *Mocklimiter) EXPECT() *MocklimiterMockRecorder {\n\treturn m.recorder\n}\n\n// Acquire mocks base method.\nfunc (m *Mocklimiter) Acquire(arg0 string) (int64, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Acquire\", arg0)\n\tret0, _ := ret[0].(int64)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Acquire indicates an expected call of Acquire.\nfunc (mr *MocklimiterMockRecorder) Acquire(arg0 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Acquire\", reflect.TypeOf((*Mocklimiter)(nil).Acquire), arg0)\n}\n\n// AcquireN mocks base method.\nfunc (m *Mocklimiter) AcquireN(arg0 string, arg1 int64) (int64, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AcquireN\", arg0, arg1)\n\tret0, _ := ret[0].(int64)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// AcquireN indicates an expected call of AcquireN.\nfunc (mr *MocklimiterMockRecorder) AcquireN(arg0, arg1 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AcquireN\", reflect.TypeOf((*Mocklimiter)(nil).AcquireN), arg0, arg1)\n}\n\n// Peek mocks base method.\nfunc (m *Mocklimiter) Peek(arg0 string) (int64, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Peek\", arg0)\n\tret0, _ := ret[0].(int64)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Peek indicates an expected call of Peek.\nfunc (mr *MocklimiterMockRecorder) Peek(arg0 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Peek\", reflect.TypeOf((*Mocklimiter)(nil).Peek), arg0)\n}\n\n// Reset mocks base method.\nfunc (m *Mocklimiter) Reset(arg0 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Reset\", arg0)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Reset indicates an expected call of Reset.\nfunc (mr *MocklimiterMockRecorder) Reset(arg0 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Reset\", reflect.TypeOf((*Mocklimiter)(nil).Reset), arg0)\n}\n\n// Mockstorage is a mock of storage interface.\ntype Mockstorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockstorageMockRecorder\n}\n\n// MockstorageMockRecorder is the mock recorder for Mockstorage.\ntype MockstorageMockRecorder struct {\n\tmock *Mockstorage\n}\n\n// NewMockstorage creates a new mock instance.\nfunc NewMockstorage(ctrl *gomock.Controller) *Mockstorage {\n\tmock := &Mockstorage{ctrl: ctrl}\n\tmock.recorder = &MockstorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *Mockstorage) EXPECT() *MockstorageMockRecorder {\n\treturn m.recorder\n}\n\n// Delete mocks base method.\nfunc (m *Mockstorage) Delete(arg0 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Delete indicates an expected call of Delete.\nfunc (mr *MockstorageMockRecorder) Delete(arg0 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*Mockstorage)(nil).Delete), arg0)\n}\n\n// Get mocks base method.\nfunc (m *Mockstorage) Get(arg0 string) (*ratelimit.TokenBucket, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Get\", arg0)\n\tret0, _ := ret[0].(*ratelimit.TokenBucket)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n", "n_tokens": 1208, "primary_symbol": "NewMocklimiter", "primary_kind": "function", "primary_span": [32, 147], "def_symbols": ["NewMocklimiter", "EXPECT", "Acquire", "AcquireN", "Peek", "Reset", "NewMockstorage", "Delete", "Get"], "symbols": ["NewMocklimiter", "EXPECT", "Acquire", "AcquireN", "Peek", "Reset", "NewMockstorage", "Delete", "Get", "Code", "generated", "MockGen", "NOT", "EDIT", "Source", "limiter", "Generated", "this", "command", "mockgen", "source", "destination", "mocks", "limiter_mocks", "package", "Package", "GoMock", "import", "reflect", "time", "ratelimit", "impalastudios", "com", "weather", "foreca_proxy", "pkg", "gomock", "uber", "org", "mock", "Mocklimiter", "interface", "type", "struct", "ctrl", "Controller", "recorder", "MocklimiterMockRecorder", "the", "for", "creates", "new", "instance", "func", "return", "returns", "object", "that", "allows", "caller", "indicate", "expected", "use", "base", "method", "arg0", "string", "int64", "error", "Helper", "ret", "Call", "ret0", "ret1", "indicates", "call", "any", "RecordCallWithMethodType", "TypeOf", "nil", "arg1", "Mockstorage", "storage", "MockstorageMockRecorder", "TokenBucket"], "doc_head": "// Code generated by MockGen. DO NOT EDIT.\n// Source: limiter.go\n//\n// Generated by this command:\n//\n//\tmockgen -source=limiter.go -destination=mocks/limiter_mocks.go -package=mocks\n//\n// Package mocks is a generated GoMock package.\npackage mocks\nimport (\n\treflect \"reflect\"\n\ttime \"time\"\n\tratelimit \"go.impalastudios.com/weather/foreca_proxy/pkg/ratelimit\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n// Mocklimiter is a mock of limiter interface.\ntype Mocklimiter struct {\n\tctrl     *gomock.Controller\n\trecorder *MocklimiterMockRecorder\n}\n// MocklimiterMockRecorder is the mock recorder for Mocklimiter.\ntype MocklimiterMockRecorder struct {\n\tmock *Mocklimiter\n}\n// NewMocklimiter creates a new mock instance.\nfunc NewMocklimiter(ctrl *gomock.Controller) *Mocklimiter {\n\tmock := &Mocklimiter{ctrl: ctrl}\n\tmock.recorder = &MocklimiterMockRecorder{mock}\n\treturn mock\n}\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *Mocklimiter) EXPECT() *MocklimiterMockRecorder {\n\treturn m.recorder\n}\n// Acquire mocks base method.\nfunc (m *Mocklimiter) Acquire(arg0 string) (int64, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Acquire\", arg0)\n\tret0, _ := ret[0].(int64)\n\tret1, _", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(m *Mocklimiter).EXPECT", "package": "mocks", "node_kind": "method", "receiver": "m *Mocklimiter", "function_name": "NewMocklimiter", "method_name": "EXPECT", "type_name": "Mocklimiter", "type_kind": "struct", "imports_used_minimal": [], "symbols_referenced_strict": ["Acquire", "AcquireN", "Call", "Code", "Controller", "DO", "Delete", "EDIT", "EXPECT", "Generated", "Get", "GoMock", "Helper", "MockGen", "Mocklimiter", "MocklimiterMockRecorder", "Mockstorage", "MockstorageMockRecorder", "NOT", "NewMocklimiter", "NewMockstorage", "Package", "Peek", "RecordCallWithMethodType", "Reset", "Source", "T", "T.Helper", "TokenBucket", "TypeOf", "ctrl.RecordCallWithMethodType", "ctrl.T", "go.impalastudios", "go.uber", "gomock.Call", "gomock.Controller", "limiter.go", "limiter_mocks.go", "m.ctrl", "m.recorder", "mock.recorder", "mr.mock", "ratelimit.TokenBucket", "reflect.TypeOf"], "header_context_minimal": "package mocks\n// receiver: m *Mocklimiter", "summary_llm": "This Go code defines mocks for the `limiter` and `storage` interfaces using the GoMock framework. The `Mocklimiter` and `Mockstorage` types are used to create mock instances of these interfaces, allowing tests to verify method calls and return specific values.", "keywords_llm": ["gomock", "mockgen", "limiter", "storage", "mock instance", "method call", "return value", "testing"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/mocks/limiter_mocks.go#2", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/ratelimit/mocks/limiter_mocks.go", "rel_path": "pkg/ratelimit/mocks/limiter_mocks.go", "ext": "go", "language": "go", "chunk_number": 2, "start_line": 148, "end_line": 167, "text": "// Get indicates an expected call of Get.\nfunc (mr *MockstorageMockRecorder) Get(arg0 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Get\", reflect.TypeOf((*Mockstorage)(nil).Get), arg0)\n}\n\n// Set mocks base method.\nfunc (m *Mockstorage) Set(arg0 string, arg1 *ratelimit.TokenBucket, arg2 time.Duration) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Set\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Set indicates an expected call of Set.\nfunc (mr *MockstorageMockRecorder) Set(arg0, arg1, arg2 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Set\", reflect.TypeOf((*Mockstorage)(nil).Set), arg0, arg1, arg2)\n}\n", "n_tokens": 217, "primary_symbol": "Get", "primary_kind": "function", "primary_span": [149, 167], "def_symbols": ["Get", "Set"], "symbols": ["Get", "Set", "indicates", "expected", "call", "func", "MockstorageMockRecorder", "arg0", "any", "gomock", "Call", "mock", "ctrl", "Helper", "return", "RecordCallWithMethodType", "reflect", "TypeOf", "Mockstorage", "nil", "mocks", "base", "method", "string", "arg1", "ratelimit", "TokenBucket", "arg2", "time", "Duration", "error", "ret", "ret0"], "doc_head": "// Get indicates an expected call of Get.\nfunc (mr *MockstorageMockRecorder) Get(arg0 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Get\", reflect.TypeOf((*Mockstorage)(nil).Get), arg0)\n}\n// Set mocks base method.\nfunc (m *Mockstorage) Set(arg0 string, arg1 *ratelimit.TokenBucket, arg2 time.Duration) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Set\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n// Set indicates an expected call of Set.\nfunc (mr *MockstorageMockRecorder) Set(arg0, arg1, arg2 any) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Set\", reflect.TypeOf((*Mockstorage)(nil).Set), arg0, arg1, arg2)\n}", "is_generated": true, "rank_boost": 0.35, "ast_path": "go:method:(mr *MockstorageMockRecorder).Get", "package": "", "node_kind": "method", "receiver": "mr *MockstorageMockRecorder", "function_name": "", "method_name": "Get", "type_name": "", "type_kind": "", "imports_used_minimal": ["time"], "symbols_referenced_strict": ["Call", "Duration", "Get", "Helper", "Mockstorage", "MockstorageMockRecorder", "RecordCallWithMethodType", "Set", "T", "T.Helper", "TokenBucket", "TypeOf", "ctrl.RecordCallWithMethodType", "ctrl.T", "gomock.Call", "m.ctrl", "mr.mock", "ratelimit.TokenBucket", "reflect.TypeOf", "time.Duration"], "header_context_minimal": "package \nimport \"time\"\n// receiver: mr *MockstorageMockRecorder", "summary_llm": "This Go code defines mock implementations for the `Get` and `Set` methods of a `Mockstorage` type, using the Gomock framework. The `Get` method records an expected call, while the `Set` method mocks the base implementation.", "keywords_llm": ["gomock", "mock", "recordcallwithmethodtype", "reflect.typeof", "helper", "call", "arg0", "arg1", "arg2", "error"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/aws/config.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/aws/config.go", "rel_path": "pkg/aws/config.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 44, "text": "package aws\n\nimport (\n\t\"context\"\n\n\tawsSdk \"github.com/aws/aws-sdk-go-v2/aws\"\n\tawsConfig \"github.com/aws/aws-sdk-go-v2/config\"\n\t\"github.com/aws/aws-sdk-go-v2/credentials\"\n)\n\nfunc GetConfig(accessKey, secretKey, sessionToken string, reg string, endpoint string) awsSdk.Config {\n\tendpointResolver := awsSdk.EndpointResolverWithOptionsFunc(func(service, region string, options ...interface{}) (awsSdk.Endpoint, error) {\n\t\tif endpoint != \"\" {\n\t\t\treturn awsSdk.Endpoint{\n\t\t\t\tPartitionID:   \"aws\",\n\t\t\t\tURL:           endpoint,\n\t\t\t\tSigningRegion: reg,\n\t\t\t}, nil\n\t\t}\n\n\t\treturn awsSdk.Endpoint{}, &awsSdk.EndpointNotFoundError{}\n\t})\n\n\toptFns := []func(*awsConfig.LoadOptions) error{\n\t\tawsConfig.WithEndpointResolverWithOptions(endpointResolver),\n\t}\n\n\tif accessKey != \"\" || secretKey != \"\" || sessionToken != \"\" {\n\t\toptFns = append(optFns, awsConfig.WithCredentialsProvider(\n\t\t\tcredentials.NewStaticCredentialsProvider(\n\t\t\t\taccessKey, secretKey, sessionToken,\n\t\t\t),\n\t\t))\n\t}\n\n\tcfg, err := awsConfig.LoadDefaultConfig(context.TODO(), optFns...)\n\n\tif err != nil {\n\t\treturn awsSdk.Config{}\n\t}\n\n\treturn cfg\n}\n", "n_tokens": 275, "primary_symbol": "GetConfig", "primary_kind": "function", "primary_span": [11, 44], "def_symbols": ["GetConfig"], "symbols": ["GetConfig", "package", "aws", "import", "context", "awsSdk", "github", "com", "sdk", "awsConfig", "config", "credentials", "func", "accessKey", "secretKey", "sessionToken", "string", "reg", "endpoint", "Config", "endpointResolver", "EndpointResolverWithOptionsFunc", "service", "region", "options", "interface", "Endpoint", "error", "return", "PartitionID", "URL", "SigningRegion", "nil", "EndpointNotFoundError", "optFns", "LoadOptions", "WithEndpointResolverWithOptions", "append", "WithCredentialsProvider", "NewStaticCredentialsProvider", "cfg", "err", "LoadDefaultConfig", "TODO"], "doc_head": "package aws\nimport (\n\t\"context\"\n\tawsSdk \"github.com/aws/aws-sdk-go-v2/aws\"\n\tawsConfig \"github.com/aws/aws-sdk-go-v2/config\"\n\t\"github.com/aws/aws-sdk-go-v2/credentials\"\n)\nfunc GetConfig(accessKey, secretKey, sessionToken string, reg string, endpoint string) awsSdk.Config {\n\tendpointResolver := awsSdk.EndpointResolverWithOptionsFunc(func(service, region string, options ...interface{}) (awsSdk.Endpoint, error) {\n\t\tif endpoint != \"\" {\n\t\t\treturn awsSdk.Endpoint{\n\t\t\t\tPartitionID:   \"aws\",\n\t\t\t\tURL:           endpoint,\n\t\t\t\tSigningRegion: reg,\n\t\t\t}, nil\n\t\t}\n\t\treturn awsSdk.Endpoint{}, &awsSdk.EndpointNotFoundError{}\n\t})\n\toptFns := []func(*awsConfig.LoadOptions) error{\n\t\tawsConfig.WithEndpointResolverWithOptions(endpointResolver),\n\t}\n\tif accessKey != \"\" || secretKey != \"\" || sessionToken != \"\" {\n\t\toptFns = append(optFns, awsConfig.WithCredentialsProvider(\n\t\t\tcredentials.NewStaticCredentialsProvider(\n\t\t\t\taccessKey, secretKey, sessionToken,\n\t\t\t),\n\t\t))\n\t}\n\tcfg, err := awsConfig.LoadDefaultConfig(context.TODO(), optFns...)\n\tif err != nil {\n\t\treturn awsSdk.Config{}\n\t}\n\treturn cfg\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:GetConfig", "package": "aws", "node_kind": "function", "receiver": "", "function_name": "GetConfig", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["Config", "Endpoint", "EndpointNotFoundError", "EndpointResolverWithOptionsFunc", "GetConfig", "LoadDefaultConfig", "LoadOptions", "NewStaticCredentialsProvider", "PartitionID", "SigningRegion", "TODO", "URL", "WithCredentialsProvider", "WithEndpointResolverWithOptions", "awsConfig.LoadDefaultConfig", "awsConfig.LoadOptions", "awsConfig.WithCredentialsProvider", "awsConfig.WithEndpointResolverWithOptions", "awsSdk.Config", "awsSdk.Endpoint", "awsSdk.EndpointNotFoundError", "awsSdk.EndpointResolverWithOptionsFunc", "context.TODO", "credentials.NewStaticCredentialsProvider", "github.com"], "header_context_minimal": "package aws", "summary_llm": "The `GetConfig` function in the AWS package configures and loads an AWS SDK configuration with specified access credentials and endpoint options.", "keywords_llm": ["aws", "config", "credentials", "endpoint", "accesskey", "secretkey", "sessiontoken", "region", "context.todo", "loaddefaultconfig", "withcredentialsprovider", "newstaticcredentialsprovider"]}
{"id": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/aws/client.go#1", "repo_id": "crunding-weather_foreca_proxy_service-8aae91880849", "path": "/Users/zack.alatrash/CompanyRepos/crunding-weather_foreca_proxy_service-8aae91880849/pkg/aws/client.go", "rel_path": "pkg/aws/client.go", "ext": "go", "language": "go", "chunk_number": 1, "start_line": 1, "end_line": 15, "text": "package aws\n\nimport (\n\tawsSdk \"github.com/aws/aws-sdk-go-v2/aws\"\n\t\"github.com/aws/aws-sdk-go-v2/service/dynamodb\"\n)\n\nfunc NewDynamoDbClientFromConfig(cfg awsSdk.Config) *dynamodb.Client {\n\treturn dynamodb.NewFromConfig(cfg)\n}\n\nfunc NewDynamoDbClient(accessKey, secretKey, sessionToken string, region string, endpoint string) *dynamodb.Client {\n\treturn NewDynamoDbClientFromConfig(GetConfig(accessKey, secretKey, sessionToken, region, endpoint))\n}\n", "n_tokens": 111, "primary_symbol": "NewDynamoDbClientFromConfig", "primary_kind": "function", "primary_span": [8, 15], "def_symbols": ["NewDynamoDbClientFromConfig", "NewDynamoDbClient"], "symbols": ["NewDynamoDbClientFromConfig", "NewDynamoDbClient", "package", "aws", "import", "awsSdk", "github", "com", "sdk", "service", "dynamodb", "func", "cfg", "Config", "Client", "return", "NewFromConfig", "accessKey", "secretKey", "sessionToken", "string", "region", "endpoint", "GetConfig"], "doc_head": "package aws\nimport (\n\tawsSdk \"github.com/aws/aws-sdk-go-v2/aws\"\n\t\"github.com/aws/aws-sdk-go-v2/service/dynamodb\"\n)\nfunc NewDynamoDbClientFromConfig(cfg awsSdk.Config) *dynamodb.Client {\n\treturn dynamodb.NewFromConfig(cfg)\n}\nfunc NewDynamoDbClient(accessKey, secretKey, sessionToken string, region string, endpoint string) *dynamodb.Client {\n\treturn NewDynamoDbClientFromConfig(GetConfig(accessKey, secretKey, sessionToken, region, endpoint))\n}", "is_generated": false, "rank_boost": 1.0, "ast_path": "go:function:NewDynamoDbClientFromConfig", "package": "aws", "node_kind": "function", "receiver": "", "function_name": "NewDynamoDbClientFromConfig", "method_name": "", "type_name": "", "type_kind": "", "imports_used_minimal": [], "symbols_referenced_strict": ["Client", "Config", "GetConfig", "NewDynamoDbClient", "NewDynamoDbClientFromConfig", "NewFromConfig", "awsSdk.Config", "dynamodb.Client", "dynamodb.NewFromConfig", "github.com"], "header_context_minimal": "package aws", "summary_llm": "This Go code defines functions to create DynamoDB clients from configurations. `NewDynamoDbClientFromConfig` takes an AWS SDK config and returns a DynamoDB client. `NewDynamoDbClient` uses helper functions to generate a config based on access key, secret key, session token, region, and endpoint.", "keywords_llm": ["aws", "dynamodb", "client", "config", "accesskey", "secretkey", "sessiontoken", "region", "endpoint"]}
